
SQL*Plus: Release 11.2.0.1.0 Production on Fri Jan 14 23:07:53 2011

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

23:07:53 SQL> ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD hh24:mi:ss';

Session altered.

Elapsed: 00:00:00.01
23:07:53 SQL> ALTER SESSION SET NLS_TERRITORY='AMERICA';

Session altered.

Elapsed: 00:00:00.00
23:07:53 SQL> 23:07:53 SQL> --
23:07:53 SQL> -- update_di5min_stk.sql
23:07:53 SQL> --
23:07:53 SQL> 
23:07:53 SQL> -- I use this script to keep di5min_stk up to date.
23:07:53 SQL> 
23:07:53 SQL> -- The table, di5min_stk, contains data from duakas before '2010-12-27 09:00:00'
23:07:53 SQL> -- After that date, it holds data from IB.
23:07:53 SQL> 
23:07:53 SQL> -- CREATE TABLE di5min_stk0(tkrdate VARCHAR2(26),tkr VARCHAR2(7),ydate DATE,clse NUMBER);
23:07:53 SQL> -- CREATE TABLE di5min_stk (tkrdate VARCHAR2(26),tkr VARCHAR2(7),ydate DATE,clse NUMBER);
23:07:53 SQL> 
23:07:53 SQL> TRUNCATE TABLE di5min_stk0;

Table truncated.

Elapsed: 00:00:00.03
23:07:53 SQL> DROP TABLE di5min_stk;

Table dropped.

Elapsed: 00:00:00.04
23:07:53 SQL> PURGE RECYCLEBIN;

Recyclebin purged.

Elapsed: 00:00:00.29
23:07:54 SQL> 
23:07:54 SQL> 
23:07:54 SQL> -- I need to shave a second off of some of the dates:
23:07:54 SQL> 
23:07:54 SQL> UPDATE ibs5min SET ydate = ydate - 1/24/3600
23:07:54   2  WHERE TO_CHAR(ydate,'SS')='01'
23:07:54   3  /

0 rows updated.

Elapsed: 00:00:00.04
23:07:54 SQL> 
23:07:54 SQL> SELECT COUNT(*)FROM ibs5min;

  COUNT(*)
----------
     82434

Elapsed: 00:00:00.00
23:07:54 SQL> SELECT COUNT(*)FROM ibs5min WHERE TO_CHAR(ydate,'SS')='00';

  COUNT(*)
----------
     82434

Elapsed: 00:00:00.03
23:07:54 SQL> SELECT COUNT(*)FROM ibs5min WHERE TO_CHAR(ydate,'SS')='01';

  COUNT(*)
----------
	 0

Elapsed: 00:00:00.02
23:07:54 SQL> 
23:07:54 SQL> -- Copy in data from ibs5min:
23:07:54 SQL> 
23:07:54 SQL> INSERT INTO di5min_stk0(tkrdate,tkr,ydate,clse)
23:07:54   2  SELECT	     tkr||ydate,tkr,ydate,clse
23:07:54   3  FROM ibs5min
23:07:54   4  WHERE ydate >= '2010-12-27 09:00:00'
23:07:54   5  /
WHERE ydate >= '2010-12-27 09:00:00'
               *
ERROR at line 4:
ORA-01861: literal does not match format string


Elapsed: 00:00:00.00
23:07:54 SQL> 
23:07:54 SQL> 
23:07:54 SQL> 
23:07:54 SQL> -- rpt
23:07:54 SQL> SELECT
23:07:54   2  tkr
23:07:54   3  ,MIN(ydate)
23:07:54   4  ,COUNT(tkr)
23:07:54   5  ,MAX(ydate)
23:07:54   6  FROM di5min_stk0
23:07:54   7  GROUP BY tkr
23:07:54   8  ORDER BY tkr
23:07:54   9  /

no rows selected

Elapsed: 00:00:00.01
23:07:54 SQL> 
23:07:54 SQL> -- Next, copy in data from dukas.
23:07:54 SQL> -- dukas5min_stk depends on:
23:07:54 SQL> -- - dukas10min_stk
23:07:54 SQL> -- - svmspy/dukas/fake5.sql
23:07:54 SQL> 
23:07:54 SQL> 
23:07:54 SQL> -- I need to shave a second off of some of the dates:
23:07:54 SQL> 
23:07:54 SQL> UPDATE dukas5min_stk SET ydate = ydate - 1/24/3600
23:07:54   2  WHERE TO_CHAR(ydate,'SS')='01'
23:07:54   3  /

0 rows updated.

Elapsed: 00:00:00.07
23:07:54 SQL> 
23:07:54 SQL> SELECT COUNT(*)FROM dukas5min_stk;

  COUNT(*)
----------
    234282

Elapsed: 00:00:00.00
23:07:54 SQL> SELECT COUNT(*)FROM dukas5min_stk WHERE TO_CHAR(ydate,'SS')='00';

  COUNT(*)
----------
    234282

Elapsed: 00:00:00.07
23:07:54 SQL> SELECT COUNT(*)FROM dukas5min_stk WHERE TO_CHAR(ydate,'SS')='01';

  COUNT(*)
----------
	 0

Elapsed: 00:00:00.06
23:07:54 SQL> 
23:07:54 SQL> INSERT INTO di5min_stk0(tkrdate,tkr,ydate,clse)
23:07:54   2  SELECT	     tkr||ydate,tkr,ydate,clse
23:07:54   3  FROM dukas5min_stk
23:07:54   4  WHERE ydate < '2010-12-27 09:00:00'
23:07:54   5  /
WHERE ydate < '2010-12-27 09:00:00'
              *
ERROR at line 4:
ORA-01861: literal does not match format string


Elapsed: 00:00:00.00
23:07:54 SQL> 
23:07:54 SQL> -- rpt
23:07:54 SQL> SELECT
23:07:54   2  tkr
23:07:54   3  ,MIN(ydate)
23:07:54   4  ,COUNT(tkr)
23:07:54   5  ,MAX(ydate)
23:07:54   6  FROM dukas5min_stk
23:07:54   7  WHERE ydate < '2010-12-27 09:00:00'
23:07:54   8  GROUP BY tkr
23:07:54   9  ORDER BY tkr
23:07:54  10  /
WHERE ydate < '2010-12-27 09:00:00'
              *
ERROR at line 7:
ORA-01861: literal does not match format string


Elapsed: 00:00:00.00
23:07:54 SQL> 
23:07:54 SQL> -- rpt
23:07:54 SQL> SELECT
23:07:54   2  tkr
23:07:54   3  ,MIN(ydate)
23:07:54   4  ,COUNT(tkr)
23:07:54   5  ,MAX(ydate)
23:07:54   6  FROM di5min_stk0
23:07:54   7  GROUP BY tkr
23:07:54   8  ORDER BY tkr
23:07:54   9  /

no rows selected

Elapsed: 00:00:00.00
23:07:54 SQL> 
23:07:54 SQL> CREATE TABLE di5min_stk COMPRESS AS
23:07:54   2  SELECT
23:07:54   3  tkrdate
23:07:54   4  ,tkr
23:07:54   5  ,ydate
23:07:54   6  ,AVG(clse)clse
23:07:54   7  FROM di5min_stk0
23:07:54   8  -- I want weekdays:
23:07:54   9  WHERE 0+TO_CHAR(ydate,'D')IN(1,2,3,4,5)
23:07:54  10  GROUP BY
23:07:54  11  tkrdate
23:07:54  12  ,tkr
23:07:54  13  ,ydate
23:07:54  14  /

Table created.

Elapsed: 00:00:00.03
23:07:54 SQL> 
23:07:54 SQL> -- I need to shave a second off of some of the dates:
23:07:54 SQL> --
23:07:54 SQL> -- UPDATE di5min_stk SET ydate = ydate - 1/24/3600
23:07:54 SQL> -- WHERE TO_CHAR(ydate,'SS')='01'
23:07:54 SQL> -- /
23:07:54 SQL> --
23:07:54 SQL> -- SELECT COUNT(*)FROM di5min_stk;
23:07:54 SQL> -- SELECT COUNT(*)FROM di5min_stk WHERE TO_CHAR(ydate,'SS')='00';
23:07:54 SQL> -- SELECT COUNT(*)FROM di5min_stk WHERE TO_CHAR(ydate,'SS')='01';
23:07:54 SQL> --
23:07:54 SQL> -- UPDATE di5min_stk SET tkrdate = tkr||ydate;
23:07:54 SQL> 
23:07:54 SQL> -- Add a column to help join with future dates
23:07:54 SQL> -- and then calculate 1 day gain:
23:07:54 SQL> DROP TABLE   di5min_stk_fd;

Table dropped.

Elapsed: 00:00:00.04
23:07:54 SQL> CREATE TABLE di5min_stk_fd COMPRESS AS
23:07:54   2  SELECT
23:07:54   3  tkrdate
23:07:54   4  ,tkr
23:07:54   5  ,ydate
23:07:54   6  ,clse
23:07:54   7  ,CASE WHEN TO_CHAR(ydate,'dy')IN('mon','tue','wed','thu')THEN ydate+1
23:07:54   8  	    WHEN TO_CHAR(ydate,'dy')IN('fri')THEN ydate+3
23:07:54   9  	    ELSE NULL END selldate
23:07:54  10  FROM di5min_stk
23:07:54  11  /

Table created.

Elapsed: 00:00:00.02
23:07:54 SQL> 
23:07:54 SQL> -- Join with the future
23:07:54 SQL> 
23:07:54 SQL> DROP   TABLE di5min_stk_c2;

Table dropped.

Elapsed: 00:00:00.05
23:07:54 SQL> 
23:07:54 SQL> CREATE TABLE di5min_stk_c2 COMPRESS AS
23:07:54   2  SELECT
23:07:54   3  p.tkrdate
23:07:54   4  ,p.tkr
23:07:54   5  ,p.ydate
23:07:54   6  ,p.clse
23:07:54   7  ,p.selldate
23:07:54   8  ,f.clse clse2
23:07:54   9  ,f.clse - p.clse gain1day
23:07:54  10  FROM di5min_stk_fd p, di5min_stk f
23:07:54  11  -- Use a left-outer-join so I get recent rows in di5min_stk_fd:
23:07:54  12  WHERE p.tkr || p.selldate = f.tkrdate(+)
23:07:54  13  /

Table created.

Elapsed: 00:00:00.04
23:07:54 SQL> 
23:07:54 SQL> -- rpt
23:07:54 SQL> SELECT TO_CHAR(ydate,'dy')dday,COUNT(tkr) FROM di5min_stk_fd group by TO_CHAR(ydate,'dy');

no rows selected

Elapsed: 00:00:00.00
23:07:54 SQL> SELECT TO_CHAR(ydate,'dy')dday,COUNT(tkr) FROM di5min_stk_c2 group by TO_CHAR(ydate,'dy');

no rows selected

Elapsed: 00:00:00.00
23:07:54 SQL> SELECT MAX(ydate)FROM di5min_stk;

MAX(YDATE
---------


Elapsed: 00:00:00.01
23:07:54 SQL> SELECT MAX(ydate)FROM di5min_stk_c2;

MAX(YDATE
---------


Elapsed: 00:00:00.00
23:07:54 SQL> 
23:07:54 SQL> -- rpt
23:07:54 SQL> SELECT
23:07:54   2  tkr
23:07:54   3  ,MIN(ydate)
23:07:54   4  ,COUNT(ydate)
23:07:54   5  ,MAX(ydate)
23:07:54   6  ,MIN(clse)
23:07:54   7  ,AVG(clse)
23:07:54   8  ,MAX(clse)
23:07:54   9  ,MAX(gain1day)
23:07:54  10  FROM di5min_stk_c2
23:07:54  11  GROUP BY tkr
23:07:54  12  ORDER BY tkr
23:07:54  13  /

no rows selected

Elapsed: 00:00:00.00
23:07:54 SQL> 
23:07:54 SQL> COLUMN clse FORMAT 999.9999
23:07:54 SQL> SELECT
23:07:54   2  tkr
23:07:54   3  ,ROUND(clse,4)clse
23:07:54   4  -- Should be NULL:
23:07:54   5  ,ROUND(clse2,4)clse2
23:07:54   6  ,ydate
23:07:54   7  FROM di5min_stk_c2
23:07:54   8  WHERE ydate > sysdate - 0.5/24
23:07:54   9  ORDER BY tkr,ydate
23:07:54  10  /

no rows selected

Elapsed: 00:00:00.01
23:07:54 SQL> Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
