
SQL*Plus: Release 11.2.0.1.0 Production on Thu Jan 6 21:17:12 2011

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

21:17:12 SQL> ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD hh24:mi:ss';

Session altered.

Elapsed: 00:00:00.00
21:17:12 SQL> 21:17:12 SQL> --
21:17:12 SQL> -- qry_ibf5min.sql
21:17:12 SQL> --
21:17:12 SQL> 
21:17:12 SQL> -- I use this script to look for dups and bad data in ibf5min
21:17:12 SQL> 
21:17:12 SQL> SET LINES 66
21:17:12 SQL> DESC ibf5min
 Name				  Null?    Type
 -------------------------------- -------- -----------------------
 PAIR					   VARCHAR2(8)
 YDATE					   DATE
 CLSE					   NUMBER

21:17:12 SQL> SET LINES 166
21:17:12 SQL> 
21:17:12 SQL> SELECT
21:17:12   2  pair
21:17:12   3  ,COUNT(pair)
21:17:12   4  FROM ibf5min
21:17:12   5  GROUP BY pair
21:17:12   6  ORDER BY pair
21:17:12   7  /

PAIR	 COUNT(PAIR)
-------- -----------
aud_usd 	7885
eur_usd 	7889
gbp_usd 	7888
usd_cad 	7887
usd_chf 	7890
usd_jpy 	7887

6 rows selected.

Elapsed: 00:00:00.02
21:17:12 SQL> 
21:17:12 SQL> -- Look for dups
21:17:12 SQL> SELECT COUNT(pair)FROM
21:17:12   2  (
21:17:12   3  SELECT
21:17:12   4  pair
21:17:12   5  ,ydate
21:17:12   6  ,COUNT(pair)
21:17:12   7  FROM ibf5min
21:17:12   8  GROUP BY pair,ydate
21:17:12   9  HAVING COUNT(pair)>1
21:17:12  10  )
21:17:12  11  /

COUNT(PAIR)
-----------
	  0

Elapsed: 00:00:00.02
21:17:12 SQL> 
21:17:12 SQL> -- Use LAG() to look for big jumps.
21:17:12 SQL> 
21:17:12 SQL> CREATE OR REPLACE VIEW ibf5min10 AS
21:17:12   2  SELECT
21:17:12   3  pair
21:17:12   4  -- ydate is granular down to 5 min:
21:17:12   5  ,ydate
21:17:12   6  ,clse
21:17:12   7  -- Use analytic function to get LAG()
21:17:12   8  ,LAG(ydate,1,NULL)OVER(PARTITION BY pair ORDER BY ydate)		    lag_ydate
21:17:12   9  ,(ydate - LAG(ydate,1,NULL)OVER(PARTITION BY pair ORDER BY ydate))*24*60 minutes_diff
21:17:12  10  ,LAG(clse,1,NULL)OVER(PARTITION BY pair ORDER BY ydate)		    lag_clse
21:17:12  11  ,(clse - LAG(clse,1,NULL)OVER(PARTITION BY pair ORDER BY ydate))/clse lag_diff
21:17:12  12  FROM ibf5min
21:17:12  13  WHERE clse>0
21:17:12  14  ORDER BY pair, ydate
21:17:12  15  /

View created.

Elapsed: 00:00:00.09
21:17:12 SQL> 
21:17:12 SQL> CREATE OR REPLACE VIEW ibf5min_ld AS
21:17:12   2  SELECT
21:17:12   3  pair
21:17:12   4  ,MIN(lag_diff)	min_lag_diff
21:17:12   5  ,AVG(lag_diff)	avg_lag_diff
21:17:12   6  ,STDDEV(lag_diff) stddev_lag_diff
21:17:12   7  ,MAX(lag_diff)	max_lag_diff
21:17:12   8  ,COUNT(lag_diff)	cnt_lag_diff
21:17:12   9  FROM ibf5min10
21:17:12  10  GROUP BY pair
21:17:12  11  /

View created.

Elapsed: 00:00:00.05
21:17:12 SQL> 
21:17:12 SQL> SELECT * FROM ibf5min_ld;

PAIR	 MIN_LAG_DIFF AVG_LAG_DIFF STDDEV_LAG_DIFF MAX_LAG_DIFF CNT_LAG_DIFF
-------- ------------ ------------ --------------- ------------ ------------
aud_usd    -.00378738	4.2054E-06	.000401503   .004498551 	7883
eur_usd    -.00286489	-1.012E-06	.000417361   .004815837 	7887
gbp_usd     -.0023178	-7.621E-07	.000349594   .002629427 	7886
usd_cad    -.00352051	-2.893E-06	.000335058   .004222134 	7885
usd_chf    -.00675762	-4.628E-06	.000464675   .003827372 	7888
usd_jpy    -.00797352	-1.414E-06	.000345243   .005257751 	7885

6 rows selected.

Elapsed: 00:00:00.19
21:17:12 SQL> 
21:17:12 SQL> SELECT * FROM ibf5min10 WHERE lag_diff = (SELECT MIN(min_lag_diff)FROM ibf5min_ld);
