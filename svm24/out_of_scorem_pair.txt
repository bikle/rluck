
SQL*Plus: Release 11.2.0.1.0 Production on Sun Jan 30 03:51:52 2011

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

03:51:52 SQL> ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD hh24:mi:ss';

Session altered.

Elapsed: 00:00:00.00
03:51:52 SQL> 03:51:52 SQL> @score1_5min.sql	      2011-01-27 18:40:00 eur_usd
03:51:52 SQL> --
03:51:52 SQL> -- score1_5min.sql
03:51:52 SQL> --
03:51:52 SQL> 
03:51:52 SQL> -- Demo:
03:51:52 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:51:52 SQL> 
03:51:52 SQL> CREATE OR REPLACE VIEW sme AS
03:51:52   2  SELECT
03:51:52   3  prdate
03:51:52   4  ,NULL gatt
03:51:52   5  ,g00
03:51:52   6  ,g01
03:51:52   7  ,g02
03:51:52   8  ,g03
03:51:52   9  ,g04
03:51:52  10  ,g05
03:51:52  11  ,g06
03:51:52  12  ,g07
03:51:52  13  ,g08
03:51:52  14  ,g09
03:51:52  15  ,g10
03:51:52  16  ,g11
03:51:52  17  ,g12
03:51:52  18  ,g13
03:51:52  19  ,g14
03:51:52  20  ,g15
03:51:52  21  ,g16
03:51:52  22  ,g17
03:51:52  23  ,g18
03:51:52  24  ,g19
03:51:52  25  ,g20
03:51:52  26  ,g21
03:51:52  27  ,g22
03:51:52  28  ,g23
03:51:52  29  ,g24
03:51:52  30  ,g25
03:51:52  31  ,g26
03:51:52  32  ,g27
03:51:52  33  ,g28
03:51:52  34  ,g29
03:51:52  35  ,g30
03:51:52  36  ,g31
03:51:52  37  ,g32
03:51:52  38  ,g33
03:51:52  39  ,g34
03:51:52  40  ,g35
03:51:52  41  ,g36
03:51:52  42  ,g37
03:51:52  43  ,g38
03:51:52  44  ,g39
03:51:52  45  ,g40
03:51:52  46  ,g41
03:51:52  47  ,s.sc_corr
03:51:52  48  FROM modsrc24
03:51:52  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:51:52  50  WHERE ydate = '&1'||' '||'&2'
03:51:52  51  AND pair = '&3'
03:51:52  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'18:40:00'AND ydate<'2011-01-27'||' '||'18:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'18:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:51:52 SQL> 
03:51:52 SQL> -- rpt
03:51:52 SQL> -- We should see just 1 row:
03:51:52 SQL> 
03:51:52 SQL> SELECT COUNT(prdate) FROM sme
03:51:52   2  
03:51:52 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:51:52   2  
03:51:52 SQL> 
03:51:52 SQL> -- Build the model:
03:51:52 SQL> CREATE OR REPLACE VIEW bme AS
03:51:52   2  SELECT
03:51:52   3  prdate
03:51:52   4  ,gatt
03:51:52   5  ,g00
03:51:52   6  ,g01
03:51:52   7  ,g02
03:51:52   8  ,g03
03:51:52   9  ,g04
03:51:52  10  ,g05
03:51:52  11  ,g06
03:51:52  12  ,g07
03:51:52  13  ,g08
03:51:52  14  ,g09
03:51:52  15  ,g10
03:51:52  16  ,g11
03:51:52  17  ,g12
03:51:52  18  ,g13
03:51:52  19  ,g14
03:51:52  20  ,g15
03:51:52  21  ,g16
03:51:52  22  ,g17
03:51:52  23  ,g18
03:51:52  24  ,g19
03:51:52  25  ,g20
03:51:52  26  ,g21
03:51:52  27  ,g22
03:51:52  28  ,g23
03:51:52  29  ,g24
03:51:52  30  ,g25
03:51:52  31  ,g26
03:51:52  32  ,g27
03:51:52  33  ,g28
03:51:52  34  ,g29
03:51:52  35  ,g30
03:51:52  36  ,g31
03:51:52  37  ,g32
03:51:52  38  ,g33
03:51:52  39  ,g34
03:51:52  40  ,g35
03:51:52  41  ,g36
03:51:52  42  ,g37
03:51:52  43  ,g38
03:51:52  44  ,g39
03:51:52  45  ,g40
03:51:52  46  ,g41
03:51:52  47  ,sc_corr
03:51:52  48  FROM modsrc24
03:51:52  49  WHERE gatt IN('nup','up')
03:51:52  50  -- Use only rows which are older than 1 day:
03:51:52  51  AND 1+ydate < '&1'||' '||'&2'
03:51:52  52  AND pair = '&3'
03:51:52  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'18:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:51:53 SQL> 
03:51:53 SQL> -- rpt
03:51:53 SQL> 
03:51:53 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:51:53   2  
03:51:53 SQL> SELECT MAX(prdate) FROM bme
03:51:53   2  
03:51:53 SQL> -- Now build model from bme and score sme
03:51:53 SQL> @score1.sql gatt
03:51:53 SQL> --
03:51:53 SQL> -- score1.sql
03:51:53 SQL> --
03:51:53 SQL> 
03:51:53 SQL> -- I use this script to send 5 params to score.sql
03:51:53 SQL> -- which does the heavy lifting of creating an SVM model.
03:51:53 SQL> -- Then at the very end of this script I use the model
03:51:53 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:51:53 SQL> 
03:51:53 SQL> -- I call this script from 2 other scripts:
03:51:53 SQL> -- score1_5min.sql
03:51:53 SQL> -- score1_5min_gattn.sql
03:51:53 SQL> 
03:51:53 SQL> -- The 1st param is the name of the target attribute.
03:51:53 SQL> -- I like to call my target attributes either gatt or gattn.
03:51:53 SQL> 
03:51:53 SQL> -- Demo:
03:51:53 SQL> -- @score1.sql 'gatt'
03:51:53 SQL> -- @score1.sql 'gattn'
03:51:53 SQL> 
03:51:53 SQL> -- Now, I fill up svmc_apply_prep.
03:51:53 SQL> -- I use same model_name used in score.sql
03:51:53 SQL> DEFINE model_name = 'svmfx101'
03:51:53 SQL> DEFINE bldtable	= 'bme'
03:51:53 SQL> DEFINE scoretable = 'sme'
03:51:53 SQL> DEFINE case_id	= 'prdate'
03:51:53 SQL> -- Demo:
03:51:53 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:51:53 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:51:53 SQL> --
03:51:53 SQL> -- score.sql
03:51:53 SQL> --
03:51:53 SQL> 
03:51:53 SQL> -- usage: score.sql
03:51:53 SQL> 
03:51:53 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:51:53 SQL> 
03:51:53 SQL> -- DEFINE target	   = 'gatt'
03:51:53 SQL> -- DEFINE model_name = 'svmfx101'
03:51:53 SQL> -- DEFINE bldtable   = 'bme'
03:51:53 SQL> -- DEFINE scoretable = 'sme'
03:51:53 SQL> -- DEFINE case_id    = 'prdate'
03:51:53 SQL> 
03:51:53 SQL> DEFINE target	= '&1'
03:51:53 SQL> DEFINE model_name = '&2'
03:51:53 SQL> DEFINE bldtable	= '&3'
03:51:53 SQL> DEFINE scoretable = '&4'
03:51:53 SQL> DEFINE case_id	= '&5'
03:51:53 SQL> 
03:51:53 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:51:53 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:51:53 SQL> 
03:51:53 SQL> -- Builds an SVM model using pl/sql.
03:51:53 SQL> 
03:51:53 SQL> -----------------------------------------------------------------------
03:51:53 SQL> --			    BUILD THE MODEL
03:51:53 SQL> -----------------------------------------------------------------------
03:51:53 SQL> 
03:51:53 SQL> -- Cleanup old build data preparation objects for repeat runs
03:51:53 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:51:53 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:51:53 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:51:53 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:51:53 SQL> 
03:51:53 SQL> 
03:51:53 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:51:53 SQL> --
03:51:53 SQL> -- DROP	TABLE svmc_settings ;
03:51:53 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:51:53 SQL> -- DELETE svmc_settings;
03:51:53 SQL> 
03:51:53 SQL> -- The default classification algorithm is Naive Bayes. So override
03:51:53 SQL> -- this choice to SVM using a settings table.
03:51:53 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:51:53 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:51:53 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:51:53 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:51:53 SQL> -- models.
03:51:53 SQL> --
03:51:53 SQL> 
03:51:53 SQL> -- Do this once and then comment it out.
03:51:53 SQL> -- That makes script go faster.
03:51:53 SQL> -- BEGIN
03:51:53 SQL> -- -- Populate settings table
03:51:53 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:51:53 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:51:53 SQL> --
03:51:53 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:51:53 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:51:53 SQL> --
03:51:53 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:51:53 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:51:53 SQL> --   COMMIT;
03:51:53 SQL> -- END;
03:51:53 SQL> -- /
03:51:53 SQL> 
03:51:53 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:51:53 SQL> 
03:51:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:51:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:51:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:51:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:51:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:51:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:51:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:51:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:51:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:51:53 SQL> 
03:51:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:51:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:51:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:51:53 SQL> 
03:51:53 SQL> --------------------------------
03:51:53 SQL> -- PREPARE BUILD (TRAINING) DATA
03:51:53 SQL> --
03:51:53 SQL> 
03:51:53 SQL> -- 1. Missing Value treatment for all Predictors and
03:51:53 SQL> -- 2. Outlier Treatment and
03:51:53 SQL> -- 3. Normalization are performed below.
03:51:53 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:51:53 SQL> --    normalized here.
03:51:53 SQL> 
03:51:53 SQL> BEGIN
03:51:53   2  	-- Perform missing value treatment for all predictors
03:51:53   3  	-- create miss tables
03:51:53   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:51:53   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:51:53   6  
03:51:53   7  	-- populate miss tables
03:51:53   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:51:53   9  	  miss_table_name => 'svmc_miss_num',
03:51:53  10  	  data_table_name => '&bldtable',
03:51:53  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:51:53  12  
03:51:53  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:51:53  14  	  miss_table_name => 'svmc_miss_cat',
03:51:53  15  	  data_table_name => '&bldtable',
03:51:53  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:51:53  17  
03:51:53  18  	-- xform input data to replace missing values
03:51:53  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:51:53  20  	  miss_table_name => 'svmc_miss_num',
03:51:53  21  	  data_table_name => '&bldtable',
03:51:53  22  	  xform_view_name => 'xformed_build_miss_num');
03:51:53  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:51:53  24  	  miss_table_name => 'svmc_miss_cat',
03:51:53  25  	  data_table_name => '&bldtable',
03:51:53  26  	  xform_view_name => 'xformed_build_miss_cat');
03:51:53  27  
03:51:53  28  	-- Perform outlier treatment.
03:51:53  29  	-- create clip table
03:51:53  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:51:53  31  
03:51:53  32  	-- populate clip table
03:51:53  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:51:53  34  	  clip_table_name => 'svmc_clip',
03:51:53  35  	  data_table_name => '&bldtable',
03:51:53  36  	  tail_frac	  => 0.025,
03:51:53  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:51:53  38  
03:51:53  39  	-- xform input data to winsorized data
03:51:53  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:51:53  41  	  clip_table_name => 'svmc_clip',
03:51:53  42  	  data_table_name => '&bldtable',
03:51:53  43  	  xform_view_name => 'svmc_winsor');
03:51:53  44  
03:51:53  45  	-- create normalization table
03:51:53  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:51:53  47  
03:51:53  48  	-- populate normalization table based on winsorized data
03:51:53  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:51:53  50  	  norm_table_name => 'svmc_norm',
03:51:53  51  	  data_table_name => 'svmc_winsor',
03:51:53  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:51:53  53  
03:51:53  54  	-- normalize the original data
03:51:53  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:51:53  56  	  norm_table_name => 'svmc_norm',
03:51:53  57  	  data_table_name => '&bldtable',
03:51:53  58  	  xform_view_name => 'svmc_build_prep');
03:51:53  59  END;
03:51:53  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.76
03:51:55 SQL> 
03:51:55 SQL> ---------------------
03:51:55 SQL> -- CREATE A NEW MODEL
03:51:55 SQL> --
03:51:55 SQL> -- Cleanup old model with the same name for repeat runs
03:51:55 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:51:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:51:55   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.61
03:51:57 SQL> 
03:51:57 SQL> -- Build a new SVM Model
03:51:57 SQL> BEGIN
03:51:57   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:51:57   3  	  model_name	      => '&model_name',
03:51:57   4  	  mining_function     => dbms_data_mining.classification,
03:51:57   5  	  data_table_name     => 'svmc_build_prep',
03:51:57   6  	  case_id_column_name => '&case_id',
03:51:57   7  	  target_column_name  => '&target',
03:51:57   8  	  settings_table_name => 'svmc_settings');
03:51:57   9  END;
03:51:57  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.88
03:52:03 SQL> 
03:52:03 SQL> -----------------------------------------------------------------------
03:52:03 SQL> --			       APPLY/score THE MODEL
03:52:03 SQL> -----------------------------------------------------------------------
03:52:03 SQL> 
03:52:03 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:52:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:52:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:52:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
03:52:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:52:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:03 SQL> -----------------------
03:52:03 SQL> -- PREPARE SCORING DATA
03:52:03 SQL> --
03:52:03 SQL> -- If the data for model creation has been prepared, then the data
03:52:03 SQL> -- to be scored using the model must be prepared in the same manner
03:52:03 SQL> -- in order to obtain meaningful results.
03:52:03 SQL> --
03:52:03 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:03 SQL> -- 2. Normalization
03:52:03 SQL> -- No outlier treatment will be performed during test and apply. The
03:52:03 SQL> -- normalization step is sufficient, since the normalization parameters
03:52:03 SQL> -- already capture the effects of outlier treatment done with build data.
03:52:03 SQL> --
03:52:03 SQL> BEGIN
03:52:03   2  	-- Xform Test data to replace missing values
03:52:03   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:03   4  	  miss_table_name => 'svmc_miss_num',
03:52:03   5  	  data_table_name => '&scoretable',
03:52:03   6  	  xform_view_name => 'xformed_apply_miss_num');
03:52:03   7  
03:52:03   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:03   9  	  miss_table_name => 'svmc_miss_cat',
03:52:03  10  	  data_table_name => '&scoretable',
03:52:03  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:52:03  12  
03:52:03  13  	-- Normalize the data to be scored
03:52:03  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:03  15  	  norm_table_name => 'svmc_norm',
03:52:03  16  	  data_table_name => '&scoretable',
03:52:03  17  	  xform_view_name => 'svmc_apply_prep');
03:52:03  18  END;
03:52:03  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:52:03 SQL> 
03:52:03 SQL> -- Maybe I already collected a score for this prdate.
03:52:03 SQL> -- DELETE it if I did:
03:52:03 SQL> DELETE svm24scores
03:52:03   2  WHERE score > 0
03:52:03   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:52:03   4  -- I need to supply the target attribute name:
03:52:03   5  AND targ = '&1'
03:52:03   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:52:03 SQL> 
03:52:03 SQL> -- We do a drumroll here:
03:52:03 SQL> 
03:52:03 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:52:03   2  SELECT
03:52:03   3  prdate
03:52:03   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:52:03   5  ,sysdate
03:52:03   6  ,SUBSTR(prdate,1,7)pair
03:52:03   7  ,SUBSTR(prdate,-19)ydate
03:52:03   8  ,'&1'
03:52:03   9  FROM svmc_apply_prep
03:52:03  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:52:03 SQL> @score1_5min_gattn.sql	2011-01-20 10:45:00 eur_usd
03:52:03 SQL> --
03:52:03 SQL> -- score1_5min_gattn.sql
03:52:03 SQL> --
03:52:03 SQL> 
03:52:03 SQL> -- Demo:
03:52:03 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:52:03 SQL> 
03:52:03 SQL> CREATE OR REPLACE VIEW sme AS
03:52:03   2  SELECT
03:52:03   3  prdate
03:52:03   4  ,NULL gattn
03:52:03   5  ,g00
03:52:03   6  ,g01
03:52:03   7  ,g02
03:52:03   8  ,g03
03:52:03   9  ,g04
03:52:03  10  ,g05
03:52:03  11  ,g06
03:52:03  12  ,g07
03:52:03  13  ,g08
03:52:03  14  ,g09
03:52:03  15  ,g10
03:52:03  16  ,g11
03:52:03  17  ,g12
03:52:03  18  ,g13
03:52:03  19  ,g14
03:52:03  20  ,g15
03:52:03  21  ,g16
03:52:03  22  ,g17
03:52:03  23  ,g18
03:52:03  24  ,g19
03:52:03  25  ,g20
03:52:03  26  ,g21
03:52:03  27  ,g22
03:52:03  28  ,g23
03:52:03  29  ,g24
03:52:03  30  ,g25
03:52:03  31  ,g26
03:52:03  32  ,g27
03:52:03  33  ,g28
03:52:03  34  ,g29
03:52:03  35  ,g30
03:52:03  36  ,g31
03:52:03  37  ,g32
03:52:03  38  ,g33
03:52:03  39  ,g34
03:52:03  40  ,g35
03:52:03  41  ,g36
03:52:03  42  ,g37
03:52:03  43  ,g38
03:52:03  44  ,g39
03:52:03  45  ,g40
03:52:03  46  ,g41
03:52:03  47  ,s.sc_corr
03:52:03  48  FROM modsrc24
03:52:03  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:52:03  50  WHERE ydate = '&1'||' '||'&2'
03:52:03  51  AND pair = '&3'
03:52:03  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'10:45:00'AND ydate<'2011-01-20'||' '||'10:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'10:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:52:03 SQL> 
03:52:03 SQL> -- rpt
03:52:03 SQL> -- We should see just 1 row:
03:52:03 SQL> 
03:52:03 SQL> SELECT COUNT(prdate) FROM sme
03:52:03   2  
03:52:03 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:52:03   2  
03:52:03 SQL> 
03:52:03 SQL> -- Build the model:
03:52:03 SQL> CREATE OR REPLACE VIEW bme AS
03:52:03   2  SELECT
03:52:03   3  prdate
03:52:03   4  ,gattn
03:52:03   5  ,g00
03:52:03   6  ,g01
03:52:03   7  ,g02
03:52:03   8  ,g03
03:52:03   9  ,g04
03:52:03  10  ,g05
03:52:03  11  ,g06
03:52:03  12  ,g07
03:52:03  13  ,g08
03:52:03  14  ,g09
03:52:03  15  ,g10
03:52:03  16  ,g11
03:52:03  17  ,g12
03:52:03  18  ,g13
03:52:03  19  ,g14
03:52:03  20  ,g15
03:52:03  21  ,g16
03:52:03  22  ,g17
03:52:03  23  ,g18
03:52:03  24  ,g19
03:52:03  25  ,g20
03:52:03  26  ,g21
03:52:03  27  ,g22
03:52:03  28  ,g23
03:52:03  29  ,g24
03:52:03  30  ,g25
03:52:03  31  ,g26
03:52:03  32  ,g27
03:52:03  33  ,g28
03:52:03  34  ,g29
03:52:03  35  ,g30
03:52:03  36  ,g31
03:52:03  37  ,g32
03:52:03  38  ,g33
03:52:03  39  ,g34
03:52:03  40  ,g35
03:52:03  41  ,g36
03:52:03  42  ,g37
03:52:03  43  ,g38
03:52:03  44  ,g39
03:52:03  45  ,g40
03:52:03  46  ,g41
03:52:03  47  ,sc_corr
03:52:03  48  FROM modsrc24
03:52:03  49  WHERE gattn IN('nup','up')
03:52:03  50  -- Use only rows which are older than 1 day:
03:52:03  51  AND 1+ydate < '&1'||' '||'&2'
03:52:03  52  AND pair = '&3'
03:52:03  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'10:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:52:03 SQL> 
03:52:03 SQL> -- rpt
03:52:03 SQL> 
03:52:03 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:52:03   2  
03:52:03 SQL> SELECT MAX(prdate) FROM bme
03:52:03   2  
03:52:03 SQL> -- Now build model from bme and score sme
03:52:03 SQL> @score1.sql gattn
03:52:03 SQL> --
03:52:03 SQL> -- score1.sql
03:52:03 SQL> --
03:52:03 SQL> 
03:52:03 SQL> -- I use this script to send 5 params to score.sql
03:52:03 SQL> -- which does the heavy lifting of creating an SVM model.
03:52:03 SQL> -- Then at the very end of this script I use the model
03:52:03 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:52:03 SQL> 
03:52:03 SQL> -- I call this script from 2 other scripts:
03:52:03 SQL> -- score1_5min.sql
03:52:03 SQL> -- score1_5min_gattn.sql
03:52:03 SQL> 
03:52:03 SQL> -- The 1st param is the name of the target attribute.
03:52:03 SQL> -- I like to call my target attributes either gatt or gattn.
03:52:03 SQL> 
03:52:03 SQL> -- Demo:
03:52:03 SQL> -- @score1.sql 'gatt'
03:52:03 SQL> -- @score1.sql 'gattn'
03:52:03 SQL> 
03:52:03 SQL> -- Now, I fill up svmc_apply_prep.
03:52:03 SQL> -- I use same model_name used in score.sql
03:52:03 SQL> DEFINE model_name = 'svmfx101'
03:52:03 SQL> DEFINE bldtable	= 'bme'
03:52:03 SQL> DEFINE scoretable = 'sme'
03:52:03 SQL> DEFINE case_id	= 'prdate'
03:52:03 SQL> -- Demo:
03:52:03 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:52:03 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:52:03 SQL> --
03:52:03 SQL> -- score.sql
03:52:03 SQL> --
03:52:03 SQL> 
03:52:03 SQL> -- usage: score.sql
03:52:03 SQL> 
03:52:03 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:52:03 SQL> 
03:52:03 SQL> -- DEFINE target	   = 'gatt'
03:52:03 SQL> -- DEFINE model_name = 'svmfx101'
03:52:03 SQL> -- DEFINE bldtable   = 'bme'
03:52:03 SQL> -- DEFINE scoretable = 'sme'
03:52:03 SQL> -- DEFINE case_id    = 'prdate'
03:52:03 SQL> 
03:52:03 SQL> DEFINE target	= '&1'
03:52:03 SQL> DEFINE model_name = '&2'
03:52:03 SQL> DEFINE bldtable	= '&3'
03:52:03 SQL> DEFINE scoretable = '&4'
03:52:03 SQL> DEFINE case_id	= '&5'
03:52:03 SQL> 
03:52:03 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:52:03 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:52:03 SQL> 
03:52:03 SQL> -- Builds an SVM model using pl/sql.
03:52:03 SQL> 
03:52:03 SQL> -----------------------------------------------------------------------
03:52:03 SQL> --			    BUILD THE MODEL
03:52:03 SQL> -----------------------------------------------------------------------
03:52:03 SQL> 
03:52:03 SQL> -- Cleanup old build data preparation objects for repeat runs
03:52:03 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:03 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:52:03 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:03 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:52:03 SQL> 
03:52:03 SQL> 
03:52:03 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:52:03 SQL> --
03:52:03 SQL> -- DROP	TABLE svmc_settings ;
03:52:03 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:52:03 SQL> -- DELETE svmc_settings;
03:52:03 SQL> 
03:52:03 SQL> -- The default classification algorithm is Naive Bayes. So override
03:52:03 SQL> -- this choice to SVM using a settings table.
03:52:03 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:52:03 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:52:03 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:52:03 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:52:03 SQL> -- models.
03:52:03 SQL> --
03:52:03 SQL> 
03:52:03 SQL> -- Do this once and then comment it out.
03:52:03 SQL> -- That makes script go faster.
03:52:03 SQL> -- BEGIN
03:52:03 SQL> -- -- Populate settings table
03:52:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:03 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:52:03 SQL> --
03:52:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:03 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:52:03 SQL> --
03:52:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:03 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:52:03 SQL> --   COMMIT;
03:52:03 SQL> -- END;
03:52:03 SQL> -- /
03:52:03 SQL> 
03:52:03 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:52:03 SQL> 
03:52:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:52:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:52:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:52:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.09
03:52:04 SQL> 
03:52:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:52:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.12
03:52:04 SQL> 
03:52:04 SQL> --------------------------------
03:52:04 SQL> -- PREPARE BUILD (TRAINING) DATA
03:52:04 SQL> --
03:52:04 SQL> 
03:52:04 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:04 SQL> -- 2. Outlier Treatment and
03:52:04 SQL> -- 3. Normalization are performed below.
03:52:04 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:52:04 SQL> --    normalized here.
03:52:04 SQL> 
03:52:04 SQL> BEGIN
03:52:04   2  	-- Perform missing value treatment for all predictors
03:52:04   3  	-- create miss tables
03:52:04   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:52:04   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:52:04   6  
03:52:04   7  	-- populate miss tables
03:52:04   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:52:04   9  	  miss_table_name => 'svmc_miss_num',
03:52:04  10  	  data_table_name => '&bldtable',
03:52:04  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:04  12  
03:52:04  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:52:04  14  	  miss_table_name => 'svmc_miss_cat',
03:52:04  15  	  data_table_name => '&bldtable',
03:52:04  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:04  17  
03:52:04  18  	-- xform input data to replace missing values
03:52:04  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:04  20  	  miss_table_name => 'svmc_miss_num',
03:52:04  21  	  data_table_name => '&bldtable',
03:52:04  22  	  xform_view_name => 'xformed_build_miss_num');
03:52:04  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:04  24  	  miss_table_name => 'svmc_miss_cat',
03:52:04  25  	  data_table_name => '&bldtable',
03:52:04  26  	  xform_view_name => 'xformed_build_miss_cat');
03:52:04  27  
03:52:04  28  	-- Perform outlier treatment.
03:52:04  29  	-- create clip table
03:52:04  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:52:04  31  
03:52:04  32  	-- populate clip table
03:52:04  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:52:04  34  	  clip_table_name => 'svmc_clip',
03:52:04  35  	  data_table_name => '&bldtable',
03:52:04  36  	  tail_frac	  => 0.025,
03:52:04  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:04  38  
03:52:04  39  	-- xform input data to winsorized data
03:52:04  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:52:04  41  	  clip_table_name => 'svmc_clip',
03:52:04  42  	  data_table_name => '&bldtable',
03:52:04  43  	  xform_view_name => 'svmc_winsor');
03:52:04  44  
03:52:04  45  	-- create normalization table
03:52:04  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:52:04  47  
03:52:04  48  	-- populate normalization table based on winsorized data
03:52:04  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:52:04  50  	  norm_table_name => 'svmc_norm',
03:52:04  51  	  data_table_name => 'svmc_winsor',
03:52:04  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:04  53  
03:52:04  54  	-- normalize the original data
03:52:04  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:04  56  	  norm_table_name => 'svmc_norm',
03:52:04  57  	  data_table_name => '&bldtable',
03:52:04  58  	  xform_view_name => 'svmc_build_prep');
03:52:04  59  END;
03:52:04  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
03:52:06 SQL> 
03:52:06 SQL> ---------------------
03:52:06 SQL> -- CREATE A NEW MODEL
03:52:06 SQL> --
03:52:06 SQL> -- Cleanup old model with the same name for repeat runs
03:52:06 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:52:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:06   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.55
03:52:08 SQL> 
03:52:08 SQL> -- Build a new SVM Model
03:52:08 SQL> BEGIN
03:52:08   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:52:08   3  	  model_name	      => '&model_name',
03:52:08   4  	  mining_function     => dbms_data_mining.classification,
03:52:08   5  	  data_table_name     => 'svmc_build_prep',
03:52:08   6  	  case_id_column_name => '&case_id',
03:52:08   7  	  target_column_name  => '&target',
03:52:08   8  	  settings_table_name => 'svmc_settings');
03:52:08   9  END;
03:52:08  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.18
03:52:13 SQL> 
03:52:13 SQL> -----------------------------------------------------------------------
03:52:13 SQL> --			       APPLY/score THE MODEL
03:52:13 SQL> -----------------------------------------------------------------------
03:52:13 SQL> 
03:52:13 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:52:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:52:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:52:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:52:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:13 SQL> -----------------------
03:52:13 SQL> -- PREPARE SCORING DATA
03:52:13 SQL> --
03:52:13 SQL> -- If the data for model creation has been prepared, then the data
03:52:13 SQL> -- to be scored using the model must be prepared in the same manner
03:52:13 SQL> -- in order to obtain meaningful results.
03:52:13 SQL> --
03:52:13 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:13 SQL> -- 2. Normalization
03:52:13 SQL> -- No outlier treatment will be performed during test and apply. The
03:52:13 SQL> -- normalization step is sufficient, since the normalization parameters
03:52:13 SQL> -- already capture the effects of outlier treatment done with build data.
03:52:13 SQL> --
03:52:13 SQL> BEGIN
03:52:13   2  	-- Xform Test data to replace missing values
03:52:13   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:13   4  	  miss_table_name => 'svmc_miss_num',
03:52:13   5  	  data_table_name => '&scoretable',
03:52:13   6  	  xform_view_name => 'xformed_apply_miss_num');
03:52:13   7  
03:52:13   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:13   9  	  miss_table_name => 'svmc_miss_cat',
03:52:13  10  	  data_table_name => '&scoretable',
03:52:13  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:52:13  12  
03:52:13  13  	-- Normalize the data to be scored
03:52:13  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:13  15  	  norm_table_name => 'svmc_norm',
03:52:13  16  	  data_table_name => '&scoretable',
03:52:13  17  	  xform_view_name => 'svmc_apply_prep');
03:52:13  18  END;
03:52:13  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:52:13 SQL> 
03:52:13 SQL> -- Maybe I already collected a score for this prdate.
03:52:13 SQL> -- DELETE it if I did:
03:52:13 SQL> DELETE svm24scores
03:52:13   2  WHERE score > 0
03:52:13   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:52:13   4  -- I need to supply the target attribute name:
03:52:13   5  AND targ = '&1'
03:52:13   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:52:13 SQL> 
03:52:13 SQL> -- We do a drumroll here:
03:52:13 SQL> 
03:52:13 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:52:13   2  SELECT
03:52:13   3  prdate
03:52:13   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:52:13   5  ,sysdate
03:52:13   6  ,SUBSTR(prdate,1,7)pair
03:52:13   7  ,SUBSTR(prdate,-19)ydate
03:52:13   8  ,'&1'
03:52:13   9  FROM svmc_apply_prep
03:52:13  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:52:13 SQL> @score1_5min.sql	      2011-01-27 04:30:00 eur_usd
03:52:13 SQL> --
03:52:13 SQL> -- score1_5min.sql
03:52:13 SQL> --
03:52:13 SQL> 
03:52:13 SQL> -- Demo:
03:52:13 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:52:13 SQL> 
03:52:13 SQL> CREATE OR REPLACE VIEW sme AS
03:52:13   2  SELECT
03:52:13   3  prdate
03:52:13   4  ,NULL gatt
03:52:13   5  ,g00
03:52:13   6  ,g01
03:52:13   7  ,g02
03:52:13   8  ,g03
03:52:13   9  ,g04
03:52:13  10  ,g05
03:52:13  11  ,g06
03:52:13  12  ,g07
03:52:13  13  ,g08
03:52:13  14  ,g09
03:52:13  15  ,g10
03:52:13  16  ,g11
03:52:13  17  ,g12
03:52:13  18  ,g13
03:52:13  19  ,g14
03:52:13  20  ,g15
03:52:13  21  ,g16
03:52:13  22  ,g17
03:52:13  23  ,g18
03:52:13  24  ,g19
03:52:13  25  ,g20
03:52:13  26  ,g21
03:52:13  27  ,g22
03:52:13  28  ,g23
03:52:13  29  ,g24
03:52:13  30  ,g25
03:52:13  31  ,g26
03:52:13  32  ,g27
03:52:13  33  ,g28
03:52:13  34  ,g29
03:52:13  35  ,g30
03:52:13  36  ,g31
03:52:13  37  ,g32
03:52:13  38  ,g33
03:52:13  39  ,g34
03:52:13  40  ,g35
03:52:13  41  ,g36
03:52:13  42  ,g37
03:52:13  43  ,g38
03:52:13  44  ,g39
03:52:13  45  ,g40
03:52:13  46  ,g41
03:52:13  47  ,s.sc_corr
03:52:13  48  FROM modsrc24
03:52:13  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:52:13  50  WHERE ydate = '&1'||' '||'&2'
03:52:13  51  AND pair = '&3'
03:52:13  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'04:30:00'AND ydate<'2011-01-27'||' '||'04:30:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'04:30:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:52:13 SQL> 
03:52:13 SQL> -- rpt
03:52:13 SQL> -- We should see just 1 row:
03:52:13 SQL> 
03:52:13 SQL> SELECT COUNT(prdate) FROM sme
03:52:13   2  
03:52:13 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:52:13   2  
03:52:13 SQL> 
03:52:13 SQL> -- Build the model:
03:52:13 SQL> CREATE OR REPLACE VIEW bme AS
03:52:13   2  SELECT
03:52:13   3  prdate
03:52:13   4  ,gatt
03:52:13   5  ,g00
03:52:13   6  ,g01
03:52:13   7  ,g02
03:52:13   8  ,g03
03:52:13   9  ,g04
03:52:13  10  ,g05
03:52:13  11  ,g06
03:52:13  12  ,g07
03:52:13  13  ,g08
03:52:13  14  ,g09
03:52:13  15  ,g10
03:52:13  16  ,g11
03:52:13  17  ,g12
03:52:13  18  ,g13
03:52:13  19  ,g14
03:52:13  20  ,g15
03:52:13  21  ,g16
03:52:13  22  ,g17
03:52:13  23  ,g18
03:52:13  24  ,g19
03:52:13  25  ,g20
03:52:13  26  ,g21
03:52:13  27  ,g22
03:52:13  28  ,g23
03:52:13  29  ,g24
03:52:13  30  ,g25
03:52:13  31  ,g26
03:52:13  32  ,g27
03:52:13  33  ,g28
03:52:13  34  ,g29
03:52:13  35  ,g30
03:52:13  36  ,g31
03:52:13  37  ,g32
03:52:13  38  ,g33
03:52:13  39  ,g34
03:52:13  40  ,g35
03:52:13  41  ,g36
03:52:13  42  ,g37
03:52:13  43  ,g38
03:52:13  44  ,g39
03:52:13  45  ,g40
03:52:13  46  ,g41
03:52:13  47  ,sc_corr
03:52:13  48  FROM modsrc24
03:52:13  49  WHERE gatt IN('nup','up')
03:52:13  50  -- Use only rows which are older than 1 day:
03:52:13  51  AND 1+ydate < '&1'||' '||'&2'
03:52:13  52  AND pair = '&3'
03:52:13  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'04:30:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:52:13 SQL> 
03:52:13 SQL> -- rpt
03:52:13 SQL> 
03:52:13 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:52:13   2  
03:52:13 SQL> SELECT MAX(prdate) FROM bme
03:52:13   2  
03:52:13 SQL> -- Now build model from bme and score sme
03:52:13 SQL> @score1.sql gatt
03:52:13 SQL> --
03:52:13 SQL> -- score1.sql
03:52:13 SQL> --
03:52:13 SQL> 
03:52:13 SQL> -- I use this script to send 5 params to score.sql
03:52:13 SQL> -- which does the heavy lifting of creating an SVM model.
03:52:13 SQL> -- Then at the very end of this script I use the model
03:52:13 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:52:13 SQL> 
03:52:13 SQL> -- I call this script from 2 other scripts:
03:52:13 SQL> -- score1_5min.sql
03:52:13 SQL> -- score1_5min_gattn.sql
03:52:13 SQL> 
03:52:13 SQL> -- The 1st param is the name of the target attribute.
03:52:13 SQL> -- I like to call my target attributes either gatt or gattn.
03:52:13 SQL> 
03:52:13 SQL> -- Demo:
03:52:13 SQL> -- @score1.sql 'gatt'
03:52:13 SQL> -- @score1.sql 'gattn'
03:52:13 SQL> 
03:52:13 SQL> -- Now, I fill up svmc_apply_prep.
03:52:13 SQL> -- I use same model_name used in score.sql
03:52:13 SQL> DEFINE model_name = 'svmfx101'
03:52:13 SQL> DEFINE bldtable	= 'bme'
03:52:13 SQL> DEFINE scoretable = 'sme'
03:52:13 SQL> DEFINE case_id	= 'prdate'
03:52:13 SQL> -- Demo:
03:52:13 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:52:13 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:52:13 SQL> --
03:52:13 SQL> -- score.sql
03:52:13 SQL> --
03:52:13 SQL> 
03:52:13 SQL> -- usage: score.sql
03:52:13 SQL> 
03:52:13 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:52:13 SQL> 
03:52:13 SQL> -- DEFINE target	   = 'gatt'
03:52:13 SQL> -- DEFINE model_name = 'svmfx101'
03:52:13 SQL> -- DEFINE bldtable   = 'bme'
03:52:13 SQL> -- DEFINE scoretable = 'sme'
03:52:13 SQL> -- DEFINE case_id    = 'prdate'
03:52:13 SQL> 
03:52:13 SQL> DEFINE target	= '&1'
03:52:13 SQL> DEFINE model_name = '&2'
03:52:13 SQL> DEFINE bldtable	= '&3'
03:52:13 SQL> DEFINE scoretable = '&4'
03:52:13 SQL> DEFINE case_id	= '&5'
03:52:13 SQL> 
03:52:13 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:52:13 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:52:13 SQL> 
03:52:13 SQL> -- Builds an SVM model using pl/sql.
03:52:13 SQL> 
03:52:13 SQL> -----------------------------------------------------------------------
03:52:13 SQL> --			    BUILD THE MODEL
03:52:13 SQL> -----------------------------------------------------------------------
03:52:13 SQL> 
03:52:13 SQL> -- Cleanup old build data preparation objects for repeat runs
03:52:13 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:52:14 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:52:14 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:14 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:52:14 SQL> 
03:52:14 SQL> 
03:52:14 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:52:14 SQL> --
03:52:14 SQL> -- DROP	TABLE svmc_settings ;
03:52:14 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:52:14 SQL> -- DELETE svmc_settings;
03:52:14 SQL> 
03:52:14 SQL> -- The default classification algorithm is Naive Bayes. So override
03:52:14 SQL> -- this choice to SVM using a settings table.
03:52:14 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:52:14 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:52:14 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:52:14 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:52:14 SQL> -- models.
03:52:14 SQL> --
03:52:14 SQL> 
03:52:14 SQL> -- Do this once and then comment it out.
03:52:14 SQL> -- That makes script go faster.
03:52:14 SQL> -- BEGIN
03:52:14 SQL> -- -- Populate settings table
03:52:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:14 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:52:14 SQL> --
03:52:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:14 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:52:14 SQL> --
03:52:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:14 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:52:14 SQL> --   COMMIT;
03:52:14 SQL> -- END;
03:52:14 SQL> -- /
03:52:14 SQL> 
03:52:14 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:52:14 SQL> 
03:52:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:52:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:52:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:52:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:14 SQL> 
03:52:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:52:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:14 SQL> 
03:52:14 SQL> --------------------------------
03:52:14 SQL> -- PREPARE BUILD (TRAINING) DATA
03:52:14 SQL> --
03:52:14 SQL> 
03:52:14 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:14 SQL> -- 2. Outlier Treatment and
03:52:14 SQL> -- 3. Normalization are performed below.
03:52:14 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:52:14 SQL> --    normalized here.
03:52:14 SQL> 
03:52:14 SQL> BEGIN
03:52:14   2  	-- Perform missing value treatment for all predictors
03:52:14   3  	-- create miss tables
03:52:14   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:52:14   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:52:14   6  
03:52:14   7  	-- populate miss tables
03:52:14   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:52:14   9  	  miss_table_name => 'svmc_miss_num',
03:52:14  10  	  data_table_name => '&bldtable',
03:52:14  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:14  12  
03:52:14  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:52:14  14  	  miss_table_name => 'svmc_miss_cat',
03:52:14  15  	  data_table_name => '&bldtable',
03:52:14  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:14  17  
03:52:14  18  	-- xform input data to replace missing values
03:52:14  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:14  20  	  miss_table_name => 'svmc_miss_num',
03:52:14  21  	  data_table_name => '&bldtable',
03:52:14  22  	  xform_view_name => 'xformed_build_miss_num');
03:52:14  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:14  24  	  miss_table_name => 'svmc_miss_cat',
03:52:14  25  	  data_table_name => '&bldtable',
03:52:14  26  	  xform_view_name => 'xformed_build_miss_cat');
03:52:14  27  
03:52:14  28  	-- Perform outlier treatment.
03:52:14  29  	-- create clip table
03:52:14  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:52:14  31  
03:52:14  32  	-- populate clip table
03:52:14  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:52:14  34  	  clip_table_name => 'svmc_clip',
03:52:14  35  	  data_table_name => '&bldtable',
03:52:14  36  	  tail_frac	  => 0.025,
03:52:14  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:14  38  
03:52:14  39  	-- xform input data to winsorized data
03:52:14  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:52:14  41  	  clip_table_name => 'svmc_clip',
03:52:14  42  	  data_table_name => '&bldtable',
03:52:14  43  	  xform_view_name => 'svmc_winsor');
03:52:14  44  
03:52:14  45  	-- create normalization table
03:52:14  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:52:14  47  
03:52:14  48  	-- populate normalization table based on winsorized data
03:52:14  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:52:14  50  	  norm_table_name => 'svmc_norm',
03:52:14  51  	  data_table_name => 'svmc_winsor',
03:52:14  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:14  53  
03:52:14  54  	-- normalize the original data
03:52:14  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:14  56  	  norm_table_name => 'svmc_norm',
03:52:14  57  	  data_table_name => '&bldtable',
03:52:14  58  	  xform_view_name => 'svmc_build_prep');
03:52:14  59  END;
03:52:14  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.72
03:52:16 SQL> 
03:52:16 SQL> ---------------------
03:52:16 SQL> -- CREATE A NEW MODEL
03:52:16 SQL> --
03:52:16 SQL> -- Cleanup old model with the same name for repeat runs
03:52:16 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:52:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:16   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.56
03:52:18 SQL> 
03:52:18 SQL> -- Build a new SVM Model
03:52:18 SQL> BEGIN
03:52:18   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:52:18   3  	  model_name	      => '&model_name',
03:52:18   4  	  mining_function     => dbms_data_mining.classification,
03:52:18   5  	  data_table_name     => 'svmc_build_prep',
03:52:18   6  	  case_id_column_name => '&case_id',
03:52:18   7  	  target_column_name  => '&target',
03:52:18   8  	  settings_table_name => 'svmc_settings');
03:52:18   9  END;
03:52:18  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.15
03:52:23 SQL> 
03:52:23 SQL> -----------------------------------------------------------------------
03:52:23 SQL> --			       APPLY/score THE MODEL
03:52:23 SQL> -----------------------------------------------------------------------
03:52:23 SQL> 
03:52:23 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:52:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:52:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:52:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:52:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:23 SQL> -----------------------
03:52:23 SQL> -- PREPARE SCORING DATA
03:52:23 SQL> --
03:52:23 SQL> -- If the data for model creation has been prepared, then the data
03:52:23 SQL> -- to be scored using the model must be prepared in the same manner
03:52:23 SQL> -- in order to obtain meaningful results.
03:52:23 SQL> --
03:52:23 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:23 SQL> -- 2. Normalization
03:52:23 SQL> -- No outlier treatment will be performed during test and apply. The
03:52:23 SQL> -- normalization step is sufficient, since the normalization parameters
03:52:23 SQL> -- already capture the effects of outlier treatment done with build data.
03:52:23 SQL> --
03:52:23 SQL> BEGIN
03:52:23   2  	-- Xform Test data to replace missing values
03:52:23   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:23   4  	  miss_table_name => 'svmc_miss_num',
03:52:23   5  	  data_table_name => '&scoretable',
03:52:23   6  	  xform_view_name => 'xformed_apply_miss_num');
03:52:23   7  
03:52:23   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:23   9  	  miss_table_name => 'svmc_miss_cat',
03:52:23  10  	  data_table_name => '&scoretable',
03:52:23  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:52:23  12  
03:52:23  13  	-- Normalize the data to be scored
03:52:23  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:23  15  	  norm_table_name => 'svmc_norm',
03:52:23  16  	  data_table_name => '&scoretable',
03:52:23  17  	  xform_view_name => 'svmc_apply_prep');
03:52:23  18  END;
03:52:23  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
03:52:23 SQL> 
03:52:23 SQL> -- Maybe I already collected a score for this prdate.
03:52:23 SQL> -- DELETE it if I did:
03:52:23 SQL> DELETE svm24scores
03:52:23   2  WHERE score > 0
03:52:23   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:52:23   4  -- I need to supply the target attribute name:
03:52:23   5  AND targ = '&1'
03:52:23   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.05
03:52:23 SQL> 
03:52:23 SQL> -- We do a drumroll here:
03:52:23 SQL> 
03:52:23 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:52:23   2  SELECT
03:52:23   3  prdate
03:52:23   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:52:23   5  ,sysdate
03:52:23   6  ,SUBSTR(prdate,1,7)pair
03:52:23   7  ,SUBSTR(prdate,-19)ydate
03:52:23   8  ,'&1'
03:52:23   9  FROM svmc_apply_prep
03:52:23  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:52:23 SQL> @score1_5min_gattn.sql	2011-01-25 09:15:00 eur_usd
03:52:23 SQL> --
03:52:23 SQL> -- score1_5min_gattn.sql
03:52:23 SQL> --
03:52:23 SQL> 
03:52:23 SQL> -- Demo:
03:52:23 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:52:23 SQL> 
03:52:23 SQL> CREATE OR REPLACE VIEW sme AS
03:52:23   2  SELECT
03:52:23   3  prdate
03:52:23   4  ,NULL gattn
03:52:23   5  ,g00
03:52:23   6  ,g01
03:52:23   7  ,g02
03:52:23   8  ,g03
03:52:23   9  ,g04
03:52:23  10  ,g05
03:52:23  11  ,g06
03:52:23  12  ,g07
03:52:23  13  ,g08
03:52:23  14  ,g09
03:52:23  15  ,g10
03:52:23  16  ,g11
03:52:23  17  ,g12
03:52:23  18  ,g13
03:52:23  19  ,g14
03:52:23  20  ,g15
03:52:23  21  ,g16
03:52:23  22  ,g17
03:52:23  23  ,g18
03:52:23  24  ,g19
03:52:23  25  ,g20
03:52:23  26  ,g21
03:52:23  27  ,g22
03:52:23  28  ,g23
03:52:23  29  ,g24
03:52:23  30  ,g25
03:52:23  31  ,g26
03:52:23  32  ,g27
03:52:23  33  ,g28
03:52:23  34  ,g29
03:52:23  35  ,g30
03:52:23  36  ,g31
03:52:23  37  ,g32
03:52:23  38  ,g33
03:52:23  39  ,g34
03:52:23  40  ,g35
03:52:23  41  ,g36
03:52:23  42  ,g37
03:52:23  43  ,g38
03:52:23  44  ,g39
03:52:23  45  ,g40
03:52:23  46  ,g41
03:52:23  47  ,s.sc_corr
03:52:23  48  FROM modsrc24
03:52:23  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:52:23  50  WHERE ydate = '&1'||' '||'&2'
03:52:23  51  AND pair = '&3'
03:52:23  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'09:15:00'AND ydate<'2011-01-25'||' '||'09:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'09:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:52:24 SQL> 
03:52:24 SQL> -- rpt
03:52:24 SQL> -- We should see just 1 row:
03:52:24 SQL> 
03:52:24 SQL> SELECT COUNT(prdate) FROM sme
03:52:24   2  
03:52:24 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:52:24   2  
03:52:24 SQL> 
03:52:24 SQL> -- Build the model:
03:52:24 SQL> CREATE OR REPLACE VIEW bme AS
03:52:24   2  SELECT
03:52:24   3  prdate
03:52:24   4  ,gattn
03:52:24   5  ,g00
03:52:24   6  ,g01
03:52:24   7  ,g02
03:52:24   8  ,g03
03:52:24   9  ,g04
03:52:24  10  ,g05
03:52:24  11  ,g06
03:52:24  12  ,g07
03:52:24  13  ,g08
03:52:24  14  ,g09
03:52:24  15  ,g10
03:52:24  16  ,g11
03:52:24  17  ,g12
03:52:24  18  ,g13
03:52:24  19  ,g14
03:52:24  20  ,g15
03:52:24  21  ,g16
03:52:24  22  ,g17
03:52:24  23  ,g18
03:52:24  24  ,g19
03:52:24  25  ,g20
03:52:24  26  ,g21
03:52:24  27  ,g22
03:52:24  28  ,g23
03:52:24  29  ,g24
03:52:24  30  ,g25
03:52:24  31  ,g26
03:52:24  32  ,g27
03:52:24  33  ,g28
03:52:24  34  ,g29
03:52:24  35  ,g30
03:52:24  36  ,g31
03:52:24  37  ,g32
03:52:24  38  ,g33
03:52:24  39  ,g34
03:52:24  40  ,g35
03:52:24  41  ,g36
03:52:24  42  ,g37
03:52:24  43  ,g38
03:52:24  44  ,g39
03:52:24  45  ,g40
03:52:24  46  ,g41
03:52:24  47  ,sc_corr
03:52:24  48  FROM modsrc24
03:52:24  49  WHERE gattn IN('nup','up')
03:52:24  50  -- Use only rows which are older than 1 day:
03:52:24  51  AND 1+ydate < '&1'||' '||'&2'
03:52:24  52  AND pair = '&3'
03:52:24  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'09:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:52:24 SQL> 
03:52:24 SQL> -- rpt
03:52:24 SQL> 
03:52:24 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:52:24   2  
03:52:24 SQL> SELECT MAX(prdate) FROM bme
03:52:24   2  
03:52:24 SQL> -- Now build model from bme and score sme
03:52:24 SQL> @score1.sql gattn
03:52:24 SQL> --
03:52:24 SQL> -- score1.sql
03:52:24 SQL> --
03:52:24 SQL> 
03:52:24 SQL> -- I use this script to send 5 params to score.sql
03:52:24 SQL> -- which does the heavy lifting of creating an SVM model.
03:52:24 SQL> -- Then at the very end of this script I use the model
03:52:24 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:52:24 SQL> 
03:52:24 SQL> -- I call this script from 2 other scripts:
03:52:24 SQL> -- score1_5min.sql
03:52:24 SQL> -- score1_5min_gattn.sql
03:52:24 SQL> 
03:52:24 SQL> -- The 1st param is the name of the target attribute.
03:52:24 SQL> -- I like to call my target attributes either gatt or gattn.
03:52:24 SQL> 
03:52:24 SQL> -- Demo:
03:52:24 SQL> -- @score1.sql 'gatt'
03:52:24 SQL> -- @score1.sql 'gattn'
03:52:24 SQL> 
03:52:24 SQL> -- Now, I fill up svmc_apply_prep.
03:52:24 SQL> -- I use same model_name used in score.sql
03:52:24 SQL> DEFINE model_name = 'svmfx101'
03:52:24 SQL> DEFINE bldtable	= 'bme'
03:52:24 SQL> DEFINE scoretable = 'sme'
03:52:24 SQL> DEFINE case_id	= 'prdate'
03:52:24 SQL> -- Demo:
03:52:24 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:52:24 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:52:24 SQL> --
03:52:24 SQL> -- score.sql
03:52:24 SQL> --
03:52:24 SQL> 
03:52:24 SQL> -- usage: score.sql
03:52:24 SQL> 
03:52:24 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:52:24 SQL> 
03:52:24 SQL> -- DEFINE target	   = 'gatt'
03:52:24 SQL> -- DEFINE model_name = 'svmfx101'
03:52:24 SQL> -- DEFINE bldtable   = 'bme'
03:52:24 SQL> -- DEFINE scoretable = 'sme'
03:52:24 SQL> -- DEFINE case_id    = 'prdate'
03:52:24 SQL> 
03:52:24 SQL> DEFINE target	= '&1'
03:52:24 SQL> DEFINE model_name = '&2'
03:52:24 SQL> DEFINE bldtable	= '&3'
03:52:24 SQL> DEFINE scoretable = '&4'
03:52:24 SQL> DEFINE case_id	= '&5'
03:52:24 SQL> 
03:52:24 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:52:24 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:52:24 SQL> 
03:52:24 SQL> -- Builds an SVM model using pl/sql.
03:52:24 SQL> 
03:52:24 SQL> -----------------------------------------------------------------------
03:52:24 SQL> --			    BUILD THE MODEL
03:52:24 SQL> -----------------------------------------------------------------------
03:52:24 SQL> 
03:52:24 SQL> -- Cleanup old build data preparation objects for repeat runs
03:52:24 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:24 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:52:24 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:24 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:52:24 SQL> 
03:52:24 SQL> 
03:52:24 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:52:24 SQL> --
03:52:24 SQL> -- DROP	TABLE svmc_settings ;
03:52:24 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:52:24 SQL> -- DELETE svmc_settings;
03:52:24 SQL> 
03:52:24 SQL> -- The default classification algorithm is Naive Bayes. So override
03:52:24 SQL> -- this choice to SVM using a settings table.
03:52:24 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:52:24 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:52:24 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:52:24 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:52:24 SQL> -- models.
03:52:24 SQL> --
03:52:24 SQL> 
03:52:24 SQL> -- Do this once and then comment it out.
03:52:24 SQL> -- That makes script go faster.
03:52:24 SQL> -- BEGIN
03:52:24 SQL> -- -- Populate settings table
03:52:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:24 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:52:24 SQL> --
03:52:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:24 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:52:24 SQL> --
03:52:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:24 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:52:24 SQL> --   COMMIT;
03:52:24 SQL> -- END;
03:52:24 SQL> -- /
03:52:24 SQL> 
03:52:24 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:52:24 SQL> 
03:52:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:52:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:52:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:52:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:24 SQL> 
03:52:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:52:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:24 SQL> 
03:52:24 SQL> --------------------------------
03:52:24 SQL> -- PREPARE BUILD (TRAINING) DATA
03:52:24 SQL> --
03:52:24 SQL> 
03:52:24 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:24 SQL> -- 2. Outlier Treatment and
03:52:24 SQL> -- 3. Normalization are performed below.
03:52:24 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:52:24 SQL> --    normalized here.
03:52:24 SQL> 
03:52:24 SQL> BEGIN
03:52:24   2  	-- Perform missing value treatment for all predictors
03:52:24   3  	-- create miss tables
03:52:24   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:52:24   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:52:24   6  
03:52:24   7  	-- populate miss tables
03:52:24   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:52:24   9  	  miss_table_name => 'svmc_miss_num',
03:52:24  10  	  data_table_name => '&bldtable',
03:52:24  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:24  12  
03:52:24  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:52:24  14  	  miss_table_name => 'svmc_miss_cat',
03:52:24  15  	  data_table_name => '&bldtable',
03:52:24  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:24  17  
03:52:24  18  	-- xform input data to replace missing values
03:52:24  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:24  20  	  miss_table_name => 'svmc_miss_num',
03:52:24  21  	  data_table_name => '&bldtable',
03:52:24  22  	  xform_view_name => 'xformed_build_miss_num');
03:52:24  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:24  24  	  miss_table_name => 'svmc_miss_cat',
03:52:24  25  	  data_table_name => '&bldtable',
03:52:24  26  	  xform_view_name => 'xformed_build_miss_cat');
03:52:24  27  
03:52:24  28  	-- Perform outlier treatment.
03:52:24  29  	-- create clip table
03:52:24  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:52:24  31  
03:52:24  32  	-- populate clip table
03:52:24  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:52:24  34  	  clip_table_name => 'svmc_clip',
03:52:24  35  	  data_table_name => '&bldtable',
03:52:24  36  	  tail_frac	  => 0.025,
03:52:24  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:24  38  
03:52:24  39  	-- xform input data to winsorized data
03:52:24  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:52:24  41  	  clip_table_name => 'svmc_clip',
03:52:24  42  	  data_table_name => '&bldtable',
03:52:24  43  	  xform_view_name => 'svmc_winsor');
03:52:24  44  
03:52:24  45  	-- create normalization table
03:52:24  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:52:24  47  
03:52:24  48  	-- populate normalization table based on winsorized data
03:52:24  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:52:24  50  	  norm_table_name => 'svmc_norm',
03:52:24  51  	  data_table_name => 'svmc_winsor',
03:52:24  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:24  53  
03:52:24  54  	-- normalize the original data
03:52:24  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:24  56  	  norm_table_name => 'svmc_norm',
03:52:24  57  	  data_table_name => '&bldtable',
03:52:24  58  	  xform_view_name => 'svmc_build_prep');
03:52:24  59  END;
03:52:24  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.67
03:52:26 SQL> 
03:52:26 SQL> ---------------------
03:52:26 SQL> -- CREATE A NEW MODEL
03:52:26 SQL> --
03:52:26 SQL> -- Cleanup old model with the same name for repeat runs
03:52:26 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:52:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:26   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.51
03:52:28 SQL> 
03:52:28 SQL> -- Build a new SVM Model
03:52:28 SQL> BEGIN
03:52:28   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:52:28   3  	  model_name	      => '&model_name',
03:52:28   4  	  mining_function     => dbms_data_mining.classification,
03:52:28   5  	  data_table_name     => 'svmc_build_prep',
03:52:28   6  	  case_id_column_name => '&case_id',
03:52:28   7  	  target_column_name  => '&target',
03:52:28   8  	  settings_table_name => 'svmc_settings');
03:52:28   9  END;
03:52:28  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.82
03:52:34 SQL> 
03:52:34 SQL> -----------------------------------------------------------------------
03:52:34 SQL> --			       APPLY/score THE MODEL
03:52:34 SQL> -----------------------------------------------------------------------
03:52:34 SQL> 
03:52:34 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:34 SQL> -----------------------
03:52:34 SQL> -- PREPARE SCORING DATA
03:52:34 SQL> --
03:52:34 SQL> -- If the data for model creation has been prepared, then the data
03:52:34 SQL> -- to be scored using the model must be prepared in the same manner
03:52:34 SQL> -- in order to obtain meaningful results.
03:52:34 SQL> --
03:52:34 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:34 SQL> -- 2. Normalization
03:52:34 SQL> -- No outlier treatment will be performed during test and apply. The
03:52:34 SQL> -- normalization step is sufficient, since the normalization parameters
03:52:34 SQL> -- already capture the effects of outlier treatment done with build data.
03:52:34 SQL> --
03:52:34 SQL> BEGIN
03:52:34   2  	-- Xform Test data to replace missing values
03:52:34   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:34   4  	  miss_table_name => 'svmc_miss_num',
03:52:34   5  	  data_table_name => '&scoretable',
03:52:34   6  	  xform_view_name => 'xformed_apply_miss_num');
03:52:34   7  
03:52:34   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:34   9  	  miss_table_name => 'svmc_miss_cat',
03:52:34  10  	  data_table_name => '&scoretable',
03:52:34  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:52:34  12  
03:52:34  13  	-- Normalize the data to be scored
03:52:34  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:34  15  	  norm_table_name => 'svmc_norm',
03:52:34  16  	  data_table_name => '&scoretable',
03:52:34  17  	  xform_view_name => 'svmc_apply_prep');
03:52:34  18  END;
03:52:34  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:52:34 SQL> 
03:52:34 SQL> -- Maybe I already collected a score for this prdate.
03:52:34 SQL> -- DELETE it if I did:
03:52:34 SQL> DELETE svm24scores
03:52:34   2  WHERE score > 0
03:52:34   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:52:34   4  -- I need to supply the target attribute name:
03:52:34   5  AND targ = '&1'
03:52:34   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:52:34 SQL> 
03:52:34 SQL> -- We do a drumroll here:
03:52:34 SQL> 
03:52:34 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:52:34   2  SELECT
03:52:34   3  prdate
03:52:34   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:52:34   5  ,sysdate
03:52:34   6  ,SUBSTR(prdate,1,7)pair
03:52:34   7  ,SUBSTR(prdate,-19)ydate
03:52:34   8  ,'&1'
03:52:34   9  FROM svmc_apply_prep
03:52:34  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:52:34 SQL> @score1_5min_gattn.sql	2011-01-21 14:40:00 eur_usd
03:52:34 SQL> --
03:52:34 SQL> -- score1_5min_gattn.sql
03:52:34 SQL> --
03:52:34 SQL> 
03:52:34 SQL> -- Demo:
03:52:34 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:52:34 SQL> 
03:52:34 SQL> CREATE OR REPLACE VIEW sme AS
03:52:34   2  SELECT
03:52:34   3  prdate
03:52:34   4  ,NULL gattn
03:52:34   5  ,g00
03:52:34   6  ,g01
03:52:34   7  ,g02
03:52:34   8  ,g03
03:52:34   9  ,g04
03:52:34  10  ,g05
03:52:34  11  ,g06
03:52:34  12  ,g07
03:52:34  13  ,g08
03:52:34  14  ,g09
03:52:34  15  ,g10
03:52:34  16  ,g11
03:52:34  17  ,g12
03:52:34  18  ,g13
03:52:34  19  ,g14
03:52:34  20  ,g15
03:52:34  21  ,g16
03:52:34  22  ,g17
03:52:34  23  ,g18
03:52:34  24  ,g19
03:52:34  25  ,g20
03:52:34  26  ,g21
03:52:34  27  ,g22
03:52:34  28  ,g23
03:52:34  29  ,g24
03:52:34  30  ,g25
03:52:34  31  ,g26
03:52:34  32  ,g27
03:52:34  33  ,g28
03:52:34  34  ,g29
03:52:34  35  ,g30
03:52:34  36  ,g31
03:52:34  37  ,g32
03:52:34  38  ,g33
03:52:34  39  ,g34
03:52:34  40  ,g35
03:52:34  41  ,g36
03:52:34  42  ,g37
03:52:34  43  ,g38
03:52:34  44  ,g39
03:52:34  45  ,g40
03:52:34  46  ,g41
03:52:34  47  ,s.sc_corr
03:52:34  48  FROM modsrc24
03:52:34  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:52:34  50  WHERE ydate = '&1'||' '||'&2'
03:52:34  51  AND pair = '&3'
03:52:34  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'14:40:00'AND ydate<'2011-01-21'||' '||'14:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'14:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:52:34 SQL> 
03:52:34 SQL> -- rpt
03:52:34 SQL> -- We should see just 1 row:
03:52:34 SQL> 
03:52:34 SQL> SELECT COUNT(prdate) FROM sme
03:52:34   2  
03:52:34 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:52:34   2  
03:52:34 SQL> 
03:52:34 SQL> -- Build the model:
03:52:34 SQL> CREATE OR REPLACE VIEW bme AS
03:52:34   2  SELECT
03:52:34   3  prdate
03:52:34   4  ,gattn
03:52:34   5  ,g00
03:52:34   6  ,g01
03:52:34   7  ,g02
03:52:34   8  ,g03
03:52:34   9  ,g04
03:52:34  10  ,g05
03:52:34  11  ,g06
03:52:34  12  ,g07
03:52:34  13  ,g08
03:52:34  14  ,g09
03:52:34  15  ,g10
03:52:34  16  ,g11
03:52:34  17  ,g12
03:52:34  18  ,g13
03:52:34  19  ,g14
03:52:34  20  ,g15
03:52:34  21  ,g16
03:52:34  22  ,g17
03:52:34  23  ,g18
03:52:34  24  ,g19
03:52:34  25  ,g20
03:52:34  26  ,g21
03:52:34  27  ,g22
03:52:34  28  ,g23
03:52:34  29  ,g24
03:52:34  30  ,g25
03:52:34  31  ,g26
03:52:34  32  ,g27
03:52:34  33  ,g28
03:52:34  34  ,g29
03:52:34  35  ,g30
03:52:34  36  ,g31
03:52:34  37  ,g32
03:52:34  38  ,g33
03:52:34  39  ,g34
03:52:34  40  ,g35
03:52:34  41  ,g36
03:52:34  42  ,g37
03:52:34  43  ,g38
03:52:34  44  ,g39
03:52:34  45  ,g40
03:52:34  46  ,g41
03:52:34  47  ,sc_corr
03:52:34  48  FROM modsrc24
03:52:34  49  WHERE gattn IN('nup','up')
03:52:34  50  -- Use only rows which are older than 1 day:
03:52:34  51  AND 1+ydate < '&1'||' '||'&2'
03:52:34  52  AND pair = '&3'
03:52:34  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'14:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:52:34 SQL> 
03:52:34 SQL> -- rpt
03:52:34 SQL> 
03:52:34 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:52:34   2  
03:52:34 SQL> SELECT MAX(prdate) FROM bme
03:52:34   2  
03:52:34 SQL> -- Now build model from bme and score sme
03:52:34 SQL> @score1.sql gattn
03:52:34 SQL> --
03:52:34 SQL> -- score1.sql
03:52:34 SQL> --
03:52:34 SQL> 
03:52:34 SQL> -- I use this script to send 5 params to score.sql
03:52:34 SQL> -- which does the heavy lifting of creating an SVM model.
03:52:34 SQL> -- Then at the very end of this script I use the model
03:52:34 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:52:34 SQL> 
03:52:34 SQL> -- I call this script from 2 other scripts:
03:52:34 SQL> -- score1_5min.sql
03:52:34 SQL> -- score1_5min_gattn.sql
03:52:34 SQL> 
03:52:34 SQL> -- The 1st param is the name of the target attribute.
03:52:34 SQL> -- I like to call my target attributes either gatt or gattn.
03:52:34 SQL> 
03:52:34 SQL> -- Demo:
03:52:34 SQL> -- @score1.sql 'gatt'
03:52:34 SQL> -- @score1.sql 'gattn'
03:52:34 SQL> 
03:52:34 SQL> -- Now, I fill up svmc_apply_prep.
03:52:34 SQL> -- I use same model_name used in score.sql
03:52:34 SQL> DEFINE model_name = 'svmfx101'
03:52:34 SQL> DEFINE bldtable	= 'bme'
03:52:34 SQL> DEFINE scoretable = 'sme'
03:52:34 SQL> DEFINE case_id	= 'prdate'
03:52:34 SQL> -- Demo:
03:52:34 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:52:34 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:52:34 SQL> --
03:52:34 SQL> -- score.sql
03:52:34 SQL> --
03:52:34 SQL> 
03:52:34 SQL> -- usage: score.sql
03:52:34 SQL> 
03:52:34 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:52:34 SQL> 
03:52:34 SQL> -- DEFINE target	   = 'gatt'
03:52:34 SQL> -- DEFINE model_name = 'svmfx101'
03:52:34 SQL> -- DEFINE bldtable   = 'bme'
03:52:34 SQL> -- DEFINE scoretable = 'sme'
03:52:34 SQL> -- DEFINE case_id    = 'prdate'
03:52:34 SQL> 
03:52:34 SQL> DEFINE target	= '&1'
03:52:34 SQL> DEFINE model_name = '&2'
03:52:34 SQL> DEFINE bldtable	= '&3'
03:52:34 SQL> DEFINE scoretable = '&4'
03:52:34 SQL> DEFINE case_id	= '&5'
03:52:34 SQL> 
03:52:34 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:52:34 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:52:34 SQL> 
03:52:34 SQL> -- Builds an SVM model using pl/sql.
03:52:34 SQL> 
03:52:34 SQL> -----------------------------------------------------------------------
03:52:34 SQL> --			    BUILD THE MODEL
03:52:34 SQL> -----------------------------------------------------------------------
03:52:34 SQL> 
03:52:34 SQL> -- Cleanup old build data preparation objects for repeat runs
03:52:34 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:34 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:52:34 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:34 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:52:34 SQL> 
03:52:34 SQL> 
03:52:34 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:52:34 SQL> --
03:52:34 SQL> -- DROP	TABLE svmc_settings ;
03:52:34 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:52:34 SQL> -- DELETE svmc_settings;
03:52:34 SQL> 
03:52:34 SQL> -- The default classification algorithm is Naive Bayes. So override
03:52:34 SQL> -- this choice to SVM using a settings table.
03:52:34 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:52:34 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:52:34 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:52:34 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:52:34 SQL> -- models.
03:52:34 SQL> --
03:52:34 SQL> 
03:52:34 SQL> -- Do this once and then comment it out.
03:52:34 SQL> -- That makes script go faster.
03:52:34 SQL> -- BEGIN
03:52:34 SQL> -- -- Populate settings table
03:52:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:34 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:52:34 SQL> --
03:52:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:34 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:52:34 SQL> --
03:52:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:34 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:52:34 SQL> --   COMMIT;
03:52:34 SQL> -- END;
03:52:34 SQL> -- /
03:52:34 SQL> 
03:52:34 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:52:34 SQL> 
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:34 SQL> 
03:52:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:52:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:34 SQL> 
03:52:34 SQL> --------------------------------
03:52:34 SQL> -- PREPARE BUILD (TRAINING) DATA
03:52:34 SQL> --
03:52:34 SQL> 
03:52:34 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:34 SQL> -- 2. Outlier Treatment and
03:52:34 SQL> -- 3. Normalization are performed below.
03:52:34 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:52:34 SQL> --    normalized here.
03:52:34 SQL> 
03:52:34 SQL> BEGIN
03:52:34   2  	-- Perform missing value treatment for all predictors
03:52:34   3  	-- create miss tables
03:52:34   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:52:34   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:52:34   6  
03:52:34   7  	-- populate miss tables
03:52:34   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:52:34   9  	  miss_table_name => 'svmc_miss_num',
03:52:34  10  	  data_table_name => '&bldtable',
03:52:34  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:34  12  
03:52:34  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:52:34  14  	  miss_table_name => 'svmc_miss_cat',
03:52:34  15  	  data_table_name => '&bldtable',
03:52:34  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:34  17  
03:52:34  18  	-- xform input data to replace missing values
03:52:34  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:34  20  	  miss_table_name => 'svmc_miss_num',
03:52:34  21  	  data_table_name => '&bldtable',
03:52:34  22  	  xform_view_name => 'xformed_build_miss_num');
03:52:34  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:34  24  	  miss_table_name => 'svmc_miss_cat',
03:52:34  25  	  data_table_name => '&bldtable',
03:52:34  26  	  xform_view_name => 'xformed_build_miss_cat');
03:52:34  27  
03:52:34  28  	-- Perform outlier treatment.
03:52:34  29  	-- create clip table
03:52:34  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:52:34  31  
03:52:34  32  	-- populate clip table
03:52:34  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:52:34  34  	  clip_table_name => 'svmc_clip',
03:52:34  35  	  data_table_name => '&bldtable',
03:52:34  36  	  tail_frac	  => 0.025,
03:52:34  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:34  38  
03:52:34  39  	-- xform input data to winsorized data
03:52:34  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:52:34  41  	  clip_table_name => 'svmc_clip',
03:52:34  42  	  data_table_name => '&bldtable',
03:52:34  43  	  xform_view_name => 'svmc_winsor');
03:52:34  44  
03:52:34  45  	-- create normalization table
03:52:34  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:52:34  47  
03:52:34  48  	-- populate normalization table based on winsorized data
03:52:34  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:52:34  50  	  norm_table_name => 'svmc_norm',
03:52:34  51  	  data_table_name => 'svmc_winsor',
03:52:34  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:34  53  
03:52:34  54  	-- normalize the original data
03:52:34  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:34  56  	  norm_table_name => 'svmc_norm',
03:52:34  57  	  data_table_name => '&bldtable',
03:52:34  58  	  xform_view_name => 'svmc_build_prep');
03:52:34  59  END;
03:52:34  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
03:52:37 SQL> 
03:52:37 SQL> ---------------------
03:52:37 SQL> -- CREATE A NEW MODEL
03:52:37 SQL> --
03:52:37 SQL> -- Cleanup old model with the same name for repeat runs
03:52:37 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:52:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:37   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.54
03:52:39 SQL> 
03:52:39 SQL> -- Build a new SVM Model
03:52:39 SQL> BEGIN
03:52:39   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:52:39   3  	  model_name	      => '&model_name',
03:52:39   4  	  mining_function     => dbms_data_mining.classification,
03:52:39   5  	  data_table_name     => 'svmc_build_prep',
03:52:39   6  	  case_id_column_name => '&case_id',
03:52:39   7  	  target_column_name  => '&target',
03:52:39   8  	  settings_table_name => 'svmc_settings');
03:52:39   9  END;
03:52:39  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.43
03:52:45 SQL> 
03:52:45 SQL> -----------------------------------------------------------------------
03:52:45 SQL> --			       APPLY/score THE MODEL
03:52:45 SQL> -----------------------------------------------------------------------
03:52:45 SQL> 
03:52:45 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:52:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:52:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:52:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:52:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:45 SQL> -----------------------
03:52:45 SQL> -- PREPARE SCORING DATA
03:52:45 SQL> --
03:52:45 SQL> -- If the data for model creation has been prepared, then the data
03:52:45 SQL> -- to be scored using the model must be prepared in the same manner
03:52:45 SQL> -- in order to obtain meaningful results.
03:52:45 SQL> --
03:52:45 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:45 SQL> -- 2. Normalization
03:52:45 SQL> -- No outlier treatment will be performed during test and apply. The
03:52:45 SQL> -- normalization step is sufficient, since the normalization parameters
03:52:45 SQL> -- already capture the effects of outlier treatment done with build data.
03:52:45 SQL> --
03:52:45 SQL> BEGIN
03:52:45   2  	-- Xform Test data to replace missing values
03:52:45   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:45   4  	  miss_table_name => 'svmc_miss_num',
03:52:45   5  	  data_table_name => '&scoretable',
03:52:45   6  	  xform_view_name => 'xformed_apply_miss_num');
03:52:45   7  
03:52:45   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:45   9  	  miss_table_name => 'svmc_miss_cat',
03:52:45  10  	  data_table_name => '&scoretable',
03:52:45  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:52:45  12  
03:52:45  13  	-- Normalize the data to be scored
03:52:45  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:45  15  	  norm_table_name => 'svmc_norm',
03:52:45  16  	  data_table_name => '&scoretable',
03:52:45  17  	  xform_view_name => 'svmc_apply_prep');
03:52:45  18  END;
03:52:45  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:52:45 SQL> 
03:52:45 SQL> -- Maybe I already collected a score for this prdate.
03:52:45 SQL> -- DELETE it if I did:
03:52:45 SQL> DELETE svm24scores
03:52:45   2  WHERE score > 0
03:52:45   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:52:45   4  -- I need to supply the target attribute name:
03:52:45   5  AND targ = '&1'
03:52:45   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:52:45 SQL> 
03:52:45 SQL> -- We do a drumroll here:
03:52:45 SQL> 
03:52:45 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:52:45   2  SELECT
03:52:45   3  prdate
03:52:45   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:52:45   5  ,sysdate
03:52:45   6  ,SUBSTR(prdate,1,7)pair
03:52:45   7  ,SUBSTR(prdate,-19)ydate
03:52:45   8  ,'&1'
03:52:45   9  FROM svmc_apply_prep
03:52:45  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:52:45 SQL> @score1_5min_gattn.sql	2011-01-24 16:40:00 eur_usd
03:52:45 SQL> --
03:52:45 SQL> -- score1_5min_gattn.sql
03:52:45 SQL> --
03:52:45 SQL> 
03:52:45 SQL> -- Demo:
03:52:45 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:52:45 SQL> 
03:52:45 SQL> CREATE OR REPLACE VIEW sme AS
03:52:45   2  SELECT
03:52:45   3  prdate
03:52:45   4  ,NULL gattn
03:52:45   5  ,g00
03:52:45   6  ,g01
03:52:45   7  ,g02
03:52:45   8  ,g03
03:52:45   9  ,g04
03:52:45  10  ,g05
03:52:45  11  ,g06
03:52:45  12  ,g07
03:52:45  13  ,g08
03:52:45  14  ,g09
03:52:45  15  ,g10
03:52:45  16  ,g11
03:52:45  17  ,g12
03:52:45  18  ,g13
03:52:45  19  ,g14
03:52:45  20  ,g15
03:52:45  21  ,g16
03:52:45  22  ,g17
03:52:45  23  ,g18
03:52:45  24  ,g19
03:52:45  25  ,g20
03:52:45  26  ,g21
03:52:45  27  ,g22
03:52:45  28  ,g23
03:52:45  29  ,g24
03:52:45  30  ,g25
03:52:45  31  ,g26
03:52:45  32  ,g27
03:52:45  33  ,g28
03:52:45  34  ,g29
03:52:45  35  ,g30
03:52:45  36  ,g31
03:52:45  37  ,g32
03:52:45  38  ,g33
03:52:45  39  ,g34
03:52:45  40  ,g35
03:52:45  41  ,g36
03:52:45  42  ,g37
03:52:45  43  ,g38
03:52:45  44  ,g39
03:52:45  45  ,g40
03:52:45  46  ,g41
03:52:45  47  ,s.sc_corr
03:52:45  48  FROM modsrc24
03:52:45  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:52:45  50  WHERE ydate = '&1'||' '||'&2'
03:52:45  51  AND pair = '&3'
03:52:45  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-24'||' '||'16:40:00'AND ydate<'2011-01-24'||' '||'16:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-24'||' '||'16:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:52:45 SQL> 
03:52:45 SQL> -- rpt
03:52:45 SQL> -- We should see just 1 row:
03:52:45 SQL> 
03:52:45 SQL> SELECT COUNT(prdate) FROM sme
03:52:45   2  
03:52:45 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:52:45   2  
03:52:45 SQL> 
03:52:45 SQL> -- Build the model:
03:52:45 SQL> CREATE OR REPLACE VIEW bme AS
03:52:45   2  SELECT
03:52:45   3  prdate
03:52:45   4  ,gattn
03:52:45   5  ,g00
03:52:45   6  ,g01
03:52:45   7  ,g02
03:52:45   8  ,g03
03:52:45   9  ,g04
03:52:45  10  ,g05
03:52:45  11  ,g06
03:52:45  12  ,g07
03:52:45  13  ,g08
03:52:45  14  ,g09
03:52:45  15  ,g10
03:52:45  16  ,g11
03:52:45  17  ,g12
03:52:45  18  ,g13
03:52:45  19  ,g14
03:52:45  20  ,g15
03:52:45  21  ,g16
03:52:45  22  ,g17
03:52:45  23  ,g18
03:52:45  24  ,g19
03:52:45  25  ,g20
03:52:45  26  ,g21
03:52:45  27  ,g22
03:52:45  28  ,g23
03:52:45  29  ,g24
03:52:45  30  ,g25
03:52:45  31  ,g26
03:52:45  32  ,g27
03:52:45  33  ,g28
03:52:45  34  ,g29
03:52:45  35  ,g30
03:52:45  36  ,g31
03:52:45  37  ,g32
03:52:45  38  ,g33
03:52:45  39  ,g34
03:52:45  40  ,g35
03:52:45  41  ,g36
03:52:45  42  ,g37
03:52:45  43  ,g38
03:52:45  44  ,g39
03:52:45  45  ,g40
03:52:45  46  ,g41
03:52:45  47  ,sc_corr
03:52:45  48  FROM modsrc24
03:52:45  49  WHERE gattn IN('nup','up')
03:52:45  50  -- Use only rows which are older than 1 day:
03:52:45  51  AND 1+ydate < '&1'||' '||'&2'
03:52:45  52  AND pair = '&3'
03:52:45  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-24'||' '||'16:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:52:45 SQL> 
03:52:45 SQL> -- rpt
03:52:45 SQL> 
03:52:45 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:52:45   2  
03:52:45 SQL> SELECT MAX(prdate) FROM bme
03:52:45   2  
03:52:45 SQL> -- Now build model from bme and score sme
03:52:45 SQL> @score1.sql gattn
03:52:45 SQL> --
03:52:45 SQL> -- score1.sql
03:52:45 SQL> --
03:52:45 SQL> 
03:52:45 SQL> -- I use this script to send 5 params to score.sql
03:52:45 SQL> -- which does the heavy lifting of creating an SVM model.
03:52:45 SQL> -- Then at the very end of this script I use the model
03:52:45 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:52:45 SQL> 
03:52:45 SQL> -- I call this script from 2 other scripts:
03:52:45 SQL> -- score1_5min.sql
03:52:45 SQL> -- score1_5min_gattn.sql
03:52:45 SQL> 
03:52:45 SQL> -- The 1st param is the name of the target attribute.
03:52:45 SQL> -- I like to call my target attributes either gatt or gattn.
03:52:45 SQL> 
03:52:45 SQL> -- Demo:
03:52:45 SQL> -- @score1.sql 'gatt'
03:52:45 SQL> -- @score1.sql 'gattn'
03:52:45 SQL> 
03:52:45 SQL> -- Now, I fill up svmc_apply_prep.
03:52:45 SQL> -- I use same model_name used in score.sql
03:52:45 SQL> DEFINE model_name = 'svmfx101'
03:52:45 SQL> DEFINE bldtable	= 'bme'
03:52:45 SQL> DEFINE scoretable = 'sme'
03:52:45 SQL> DEFINE case_id	= 'prdate'
03:52:45 SQL> -- Demo:
03:52:45 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:52:45 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:52:45 SQL> --
03:52:45 SQL> -- score.sql
03:52:45 SQL> --
03:52:45 SQL> 
03:52:45 SQL> -- usage: score.sql
03:52:45 SQL> 
03:52:45 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:52:45 SQL> 
03:52:45 SQL> -- DEFINE target	   = 'gatt'
03:52:45 SQL> -- DEFINE model_name = 'svmfx101'
03:52:45 SQL> -- DEFINE bldtable   = 'bme'
03:52:45 SQL> -- DEFINE scoretable = 'sme'
03:52:45 SQL> -- DEFINE case_id    = 'prdate'
03:52:45 SQL> 
03:52:45 SQL> DEFINE target	= '&1'
03:52:45 SQL> DEFINE model_name = '&2'
03:52:45 SQL> DEFINE bldtable	= '&3'
03:52:45 SQL> DEFINE scoretable = '&4'
03:52:45 SQL> DEFINE case_id	= '&5'
03:52:45 SQL> 
03:52:45 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:52:45 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:52:45 SQL> 
03:52:45 SQL> -- Builds an SVM model using pl/sql.
03:52:45 SQL> 
03:52:45 SQL> -----------------------------------------------------------------------
03:52:45 SQL> --			    BUILD THE MODEL
03:52:45 SQL> -----------------------------------------------------------------------
03:52:45 SQL> 
03:52:45 SQL> -- Cleanup old build data preparation objects for repeat runs
03:52:45 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:45 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:52:45 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:52:45 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:52:45 SQL> 
03:52:45 SQL> 
03:52:45 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:52:45 SQL> --
03:52:45 SQL> -- DROP	TABLE svmc_settings ;
03:52:45 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:52:45 SQL> -- DELETE svmc_settings;
03:52:45 SQL> 
03:52:45 SQL> -- The default classification algorithm is Naive Bayes. So override
03:52:45 SQL> -- this choice to SVM using a settings table.
03:52:45 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:52:45 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:52:45 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:52:45 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:52:45 SQL> -- models.
03:52:45 SQL> --
03:52:45 SQL> 
03:52:45 SQL> -- Do this once and then comment it out.
03:52:45 SQL> -- That makes script go faster.
03:52:45 SQL> -- BEGIN
03:52:45 SQL> -- -- Populate settings table
03:52:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:45 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:52:45 SQL> --
03:52:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:45 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:52:45 SQL> --
03:52:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:45 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:52:45 SQL> --   COMMIT;
03:52:45 SQL> -- END;
03:52:45 SQL> -- /
03:52:45 SQL> 
03:52:45 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:52:45 SQL> 
03:52:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:52:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:52:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:52:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:52:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:52:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:46 SQL> 
03:52:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:52:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:46 SQL> 
03:52:46 SQL> --------------------------------
03:52:46 SQL> -- PREPARE BUILD (TRAINING) DATA
03:52:46 SQL> --
03:52:46 SQL> 
03:52:46 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:46 SQL> -- 2. Outlier Treatment and
03:52:46 SQL> -- 3. Normalization are performed below.
03:52:46 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:52:46 SQL> --    normalized here.
03:52:46 SQL> 
03:52:46 SQL> BEGIN
03:52:46   2  	-- Perform missing value treatment for all predictors
03:52:46   3  	-- create miss tables
03:52:46   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:52:46   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:52:46   6  
03:52:46   7  	-- populate miss tables
03:52:46   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:52:46   9  	  miss_table_name => 'svmc_miss_num',
03:52:46  10  	  data_table_name => '&bldtable',
03:52:46  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:46  12  
03:52:46  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:52:46  14  	  miss_table_name => 'svmc_miss_cat',
03:52:46  15  	  data_table_name => '&bldtable',
03:52:46  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:46  17  
03:52:46  18  	-- xform input data to replace missing values
03:52:46  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:46  20  	  miss_table_name => 'svmc_miss_num',
03:52:46  21  	  data_table_name => '&bldtable',
03:52:46  22  	  xform_view_name => 'xformed_build_miss_num');
03:52:46  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:46  24  	  miss_table_name => 'svmc_miss_cat',
03:52:46  25  	  data_table_name => '&bldtable',
03:52:46  26  	  xform_view_name => 'xformed_build_miss_cat');
03:52:46  27  
03:52:46  28  	-- Perform outlier treatment.
03:52:46  29  	-- create clip table
03:52:46  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:52:46  31  
03:52:46  32  	-- populate clip table
03:52:46  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:52:46  34  	  clip_table_name => 'svmc_clip',
03:52:46  35  	  data_table_name => '&bldtable',
03:52:46  36  	  tail_frac	  => 0.025,
03:52:46  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:46  38  
03:52:46  39  	-- xform input data to winsorized data
03:52:46  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:52:46  41  	  clip_table_name => 'svmc_clip',
03:52:46  42  	  data_table_name => '&bldtable',
03:52:46  43  	  xform_view_name => 'svmc_winsor');
03:52:46  44  
03:52:46  45  	-- create normalization table
03:52:46  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:52:46  47  
03:52:46  48  	-- populate normalization table based on winsorized data
03:52:46  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:52:46  50  	  norm_table_name => 'svmc_norm',
03:52:46  51  	  data_table_name => 'svmc_winsor',
03:52:46  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:46  53  
03:52:46  54  	-- normalize the original data
03:52:46  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:46  56  	  norm_table_name => 'svmc_norm',
03:52:46  57  	  data_table_name => '&bldtable',
03:52:46  58  	  xform_view_name => 'svmc_build_prep');
03:52:46  59  END;
03:52:46  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.79
03:52:48 SQL> 
03:52:48 SQL> ---------------------
03:52:48 SQL> -- CREATE A NEW MODEL
03:52:48 SQL> --
03:52:48 SQL> -- Cleanup old model with the same name for repeat runs
03:52:48 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:52:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:48   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.40
03:52:50 SQL> 
03:52:50 SQL> -- Build a new SVM Model
03:52:50 SQL> BEGIN
03:52:50   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:52:50   3  	  model_name	      => '&model_name',
03:52:50   4  	  mining_function     => dbms_data_mining.classification,
03:52:50   5  	  data_table_name     => 'svmc_build_prep',
03:52:50   6  	  case_id_column_name => '&case_id',
03:52:50   7  	  target_column_name  => '&target',
03:52:50   8  	  settings_table_name => 'svmc_settings');
03:52:50   9  END;
03:52:50  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.95
03:52:56 SQL> 
03:52:56 SQL> -----------------------------------------------------------------------
03:52:56 SQL> --			       APPLY/score THE MODEL
03:52:56 SQL> -----------------------------------------------------------------------
03:52:56 SQL> 
03:52:56 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.10
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
03:52:56 SQL> -----------------------
03:52:56 SQL> -- PREPARE SCORING DATA
03:52:56 SQL> --
03:52:56 SQL> -- If the data for model creation has been prepared, then the data
03:52:56 SQL> -- to be scored using the model must be prepared in the same manner
03:52:56 SQL> -- in order to obtain meaningful results.
03:52:56 SQL> --
03:52:56 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:56 SQL> -- 2. Normalization
03:52:56 SQL> -- No outlier treatment will be performed during test and apply. The
03:52:56 SQL> -- normalization step is sufficient, since the normalization parameters
03:52:56 SQL> -- already capture the effects of outlier treatment done with build data.
03:52:56 SQL> --
03:52:56 SQL> BEGIN
03:52:56   2  	-- Xform Test data to replace missing values
03:52:56   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:56   4  	  miss_table_name => 'svmc_miss_num',
03:52:56   5  	  data_table_name => '&scoretable',
03:52:56   6  	  xform_view_name => 'xformed_apply_miss_num');
03:52:56   7  
03:52:56   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:56   9  	  miss_table_name => 'svmc_miss_cat',
03:52:56  10  	  data_table_name => '&scoretable',
03:52:56  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:52:56  12  
03:52:56  13  	-- Normalize the data to be scored
03:52:56  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:56  15  	  norm_table_name => 'svmc_norm',
03:52:56  16  	  data_table_name => '&scoretable',
03:52:56  17  	  xform_view_name => 'svmc_apply_prep');
03:52:56  18  END;
03:52:56  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:52:56 SQL> 
03:52:56 SQL> -- Maybe I already collected a score for this prdate.
03:52:56 SQL> -- DELETE it if I did:
03:52:56 SQL> DELETE svm24scores
03:52:56   2  WHERE score > 0
03:52:56   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:52:56   4  -- I need to supply the target attribute name:
03:52:56   5  AND targ = '&1'
03:52:56   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:52:56 SQL> 
03:52:56 SQL> -- We do a drumroll here:
03:52:56 SQL> 
03:52:56 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:52:56   2  SELECT
03:52:56   3  prdate
03:52:56   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:52:56   5  ,sysdate
03:52:56   6  ,SUBSTR(prdate,1,7)pair
03:52:56   7  ,SUBSTR(prdate,-19)ydate
03:52:56   8  ,'&1'
03:52:56   9  FROM svmc_apply_prep
03:52:56  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:52:56 SQL> @score1_5min.sql	      2011-01-20 03:15:00 eur_usd
03:52:56 SQL> --
03:52:56 SQL> -- score1_5min.sql
03:52:56 SQL> --
03:52:56 SQL> 
03:52:56 SQL> -- Demo:
03:52:56 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:52:56 SQL> 
03:52:56 SQL> CREATE OR REPLACE VIEW sme AS
03:52:56   2  SELECT
03:52:56   3  prdate
03:52:56   4  ,NULL gatt
03:52:56   5  ,g00
03:52:56   6  ,g01
03:52:56   7  ,g02
03:52:56   8  ,g03
03:52:56   9  ,g04
03:52:56  10  ,g05
03:52:56  11  ,g06
03:52:56  12  ,g07
03:52:56  13  ,g08
03:52:56  14  ,g09
03:52:56  15  ,g10
03:52:56  16  ,g11
03:52:56  17  ,g12
03:52:56  18  ,g13
03:52:56  19  ,g14
03:52:56  20  ,g15
03:52:56  21  ,g16
03:52:56  22  ,g17
03:52:56  23  ,g18
03:52:56  24  ,g19
03:52:56  25  ,g20
03:52:56  26  ,g21
03:52:56  27  ,g22
03:52:56  28  ,g23
03:52:56  29  ,g24
03:52:56  30  ,g25
03:52:56  31  ,g26
03:52:56  32  ,g27
03:52:56  33  ,g28
03:52:56  34  ,g29
03:52:56  35  ,g30
03:52:56  36  ,g31
03:52:56  37  ,g32
03:52:56  38  ,g33
03:52:56  39  ,g34
03:52:56  40  ,g35
03:52:56  41  ,g36
03:52:56  42  ,g37
03:52:56  43  ,g38
03:52:56  44  ,g39
03:52:56  45  ,g40
03:52:56  46  ,g41
03:52:56  47  ,s.sc_corr
03:52:56  48  FROM modsrc24
03:52:56  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:52:56  50  WHERE ydate = '&1'||' '||'&2'
03:52:56  51  AND pair = '&3'
03:52:56  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'03:15:00'AND ydate<'2011-01-20'||' '||'03:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'03:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:52:56 SQL> 
03:52:56 SQL> -- rpt
03:52:56 SQL> -- We should see just 1 row:
03:52:56 SQL> 
03:52:56 SQL> SELECT COUNT(prdate) FROM sme
03:52:56   2  
03:52:56 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:52:56   2  
03:52:56 SQL> 
03:52:56 SQL> -- Build the model:
03:52:56 SQL> CREATE OR REPLACE VIEW bme AS
03:52:56   2  SELECT
03:52:56   3  prdate
03:52:56   4  ,gatt
03:52:56   5  ,g00
03:52:56   6  ,g01
03:52:56   7  ,g02
03:52:56   8  ,g03
03:52:56   9  ,g04
03:52:56  10  ,g05
03:52:56  11  ,g06
03:52:56  12  ,g07
03:52:56  13  ,g08
03:52:56  14  ,g09
03:52:56  15  ,g10
03:52:56  16  ,g11
03:52:56  17  ,g12
03:52:56  18  ,g13
03:52:56  19  ,g14
03:52:56  20  ,g15
03:52:56  21  ,g16
03:52:56  22  ,g17
03:52:56  23  ,g18
03:52:56  24  ,g19
03:52:56  25  ,g20
03:52:56  26  ,g21
03:52:56  27  ,g22
03:52:56  28  ,g23
03:52:56  29  ,g24
03:52:56  30  ,g25
03:52:56  31  ,g26
03:52:56  32  ,g27
03:52:56  33  ,g28
03:52:56  34  ,g29
03:52:56  35  ,g30
03:52:56  36  ,g31
03:52:56  37  ,g32
03:52:56  38  ,g33
03:52:56  39  ,g34
03:52:56  40  ,g35
03:52:56  41  ,g36
03:52:56  42  ,g37
03:52:56  43  ,g38
03:52:56  44  ,g39
03:52:56  45  ,g40
03:52:56  46  ,g41
03:52:56  47  ,sc_corr
03:52:56  48  FROM modsrc24
03:52:56  49  WHERE gatt IN('nup','up')
03:52:56  50  -- Use only rows which are older than 1 day:
03:52:56  51  AND 1+ydate < '&1'||' '||'&2'
03:52:56  52  AND pair = '&3'
03:52:56  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'03:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:52:56 SQL> 
03:52:56 SQL> -- rpt
03:52:56 SQL> 
03:52:56 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:52:56   2  
03:52:56 SQL> SELECT MAX(prdate) FROM bme
03:52:56   2  
03:52:56 SQL> -- Now build model from bme and score sme
03:52:56 SQL> @score1.sql gatt
03:52:56 SQL> --
03:52:56 SQL> -- score1.sql
03:52:56 SQL> --
03:52:56 SQL> 
03:52:56 SQL> -- I use this script to send 5 params to score.sql
03:52:56 SQL> -- which does the heavy lifting of creating an SVM model.
03:52:56 SQL> -- Then at the very end of this script I use the model
03:52:56 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:52:56 SQL> 
03:52:56 SQL> -- I call this script from 2 other scripts:
03:52:56 SQL> -- score1_5min.sql
03:52:56 SQL> -- score1_5min_gattn.sql
03:52:56 SQL> 
03:52:56 SQL> -- The 1st param is the name of the target attribute.
03:52:56 SQL> -- I like to call my target attributes either gatt or gattn.
03:52:56 SQL> 
03:52:56 SQL> -- Demo:
03:52:56 SQL> -- @score1.sql 'gatt'
03:52:56 SQL> -- @score1.sql 'gattn'
03:52:56 SQL> 
03:52:56 SQL> -- Now, I fill up svmc_apply_prep.
03:52:56 SQL> -- I use same model_name used in score.sql
03:52:56 SQL> DEFINE model_name = 'svmfx101'
03:52:56 SQL> DEFINE bldtable	= 'bme'
03:52:56 SQL> DEFINE scoretable = 'sme'
03:52:56 SQL> DEFINE case_id	= 'prdate'
03:52:56 SQL> -- Demo:
03:52:56 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:52:56 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:52:56 SQL> --
03:52:56 SQL> -- score.sql
03:52:56 SQL> --
03:52:56 SQL> 
03:52:56 SQL> -- usage: score.sql
03:52:56 SQL> 
03:52:56 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:52:56 SQL> 
03:52:56 SQL> -- DEFINE target	   = 'gatt'
03:52:56 SQL> -- DEFINE model_name = 'svmfx101'
03:52:56 SQL> -- DEFINE bldtable   = 'bme'
03:52:56 SQL> -- DEFINE scoretable = 'sme'
03:52:56 SQL> -- DEFINE case_id    = 'prdate'
03:52:56 SQL> 
03:52:56 SQL> DEFINE target	= '&1'
03:52:56 SQL> DEFINE model_name = '&2'
03:52:56 SQL> DEFINE bldtable	= '&3'
03:52:56 SQL> DEFINE scoretable = '&4'
03:52:56 SQL> DEFINE case_id	= '&5'
03:52:56 SQL> 
03:52:56 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:52:56 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:52:56 SQL> 
03:52:56 SQL> -- Builds an SVM model using pl/sql.
03:52:56 SQL> 
03:52:56 SQL> -----------------------------------------------------------------------
03:52:56 SQL> --			    BUILD THE MODEL
03:52:56 SQL> -----------------------------------------------------------------------
03:52:56 SQL> 
03:52:56 SQL> -- Cleanup old build data preparation objects for repeat runs
03:52:56 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:56 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:52:56 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:52:56 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:52:56 SQL> 
03:52:56 SQL> 
03:52:56 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:52:56 SQL> --
03:52:56 SQL> -- DROP	TABLE svmc_settings ;
03:52:56 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:52:56 SQL> -- DELETE svmc_settings;
03:52:56 SQL> 
03:52:56 SQL> -- The default classification algorithm is Naive Bayes. So override
03:52:56 SQL> -- this choice to SVM using a settings table.
03:52:56 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:52:56 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:52:56 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:52:56 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:52:56 SQL> -- models.
03:52:56 SQL> --
03:52:56 SQL> 
03:52:56 SQL> -- Do this once and then comment it out.
03:52:56 SQL> -- That makes script go faster.
03:52:56 SQL> -- BEGIN
03:52:56 SQL> -- -- Populate settings table
03:52:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:56 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:52:56 SQL> --
03:52:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:56 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:52:56 SQL> --
03:52:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:52:56 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:52:56 SQL> --   COMMIT;
03:52:56 SQL> -- END;
03:52:56 SQL> -- /
03:52:56 SQL> 
03:52:56 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:52:56 SQL> 
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:52:56 SQL> 
03:52:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:52:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:52:57 SQL> 
03:52:57 SQL> --------------------------------
03:52:57 SQL> -- PREPARE BUILD (TRAINING) DATA
03:52:57 SQL> --
03:52:57 SQL> 
03:52:57 SQL> -- 1. Missing Value treatment for all Predictors and
03:52:57 SQL> -- 2. Outlier Treatment and
03:52:57 SQL> -- 3. Normalization are performed below.
03:52:57 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:52:57 SQL> --    normalized here.
03:52:57 SQL> 
03:52:57 SQL> BEGIN
03:52:57   2  	-- Perform missing value treatment for all predictors
03:52:57   3  	-- create miss tables
03:52:57   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:52:57   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:52:57   6  
03:52:57   7  	-- populate miss tables
03:52:57   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:52:57   9  	  miss_table_name => 'svmc_miss_num',
03:52:57  10  	  data_table_name => '&bldtable',
03:52:57  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:57  12  
03:52:57  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:52:57  14  	  miss_table_name => 'svmc_miss_cat',
03:52:57  15  	  data_table_name => '&bldtable',
03:52:57  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:57  17  
03:52:57  18  	-- xform input data to replace missing values
03:52:57  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:52:57  20  	  miss_table_name => 'svmc_miss_num',
03:52:57  21  	  data_table_name => '&bldtable',
03:52:57  22  	  xform_view_name => 'xformed_build_miss_num');
03:52:57  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:52:57  24  	  miss_table_name => 'svmc_miss_cat',
03:52:57  25  	  data_table_name => '&bldtable',
03:52:57  26  	  xform_view_name => 'xformed_build_miss_cat');
03:52:57  27  
03:52:57  28  	-- Perform outlier treatment.
03:52:57  29  	-- create clip table
03:52:57  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:52:57  31  
03:52:57  32  	-- populate clip table
03:52:57  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:52:57  34  	  clip_table_name => 'svmc_clip',
03:52:57  35  	  data_table_name => '&bldtable',
03:52:57  36  	  tail_frac	  => 0.025,
03:52:57  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:57  38  
03:52:57  39  	-- xform input data to winsorized data
03:52:57  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:52:57  41  	  clip_table_name => 'svmc_clip',
03:52:57  42  	  data_table_name => '&bldtable',
03:52:57  43  	  xform_view_name => 'svmc_winsor');
03:52:57  44  
03:52:57  45  	-- create normalization table
03:52:57  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:52:57  47  
03:52:57  48  	-- populate normalization table based on winsorized data
03:52:57  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:52:57  50  	  norm_table_name => 'svmc_norm',
03:52:57  51  	  data_table_name => 'svmc_winsor',
03:52:57  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:52:57  53  
03:52:57  54  	-- normalize the original data
03:52:57  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:52:57  56  	  norm_table_name => 'svmc_norm',
03:52:57  57  	  data_table_name => '&bldtable',
03:52:57  58  	  xform_view_name => 'svmc_build_prep');
03:52:57  59  END;
03:52:57  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
03:52:59 SQL> 
03:52:59 SQL> ---------------------
03:52:59 SQL> -- CREATE A NEW MODEL
03:52:59 SQL> --
03:52:59 SQL> -- Cleanup old model with the same name for repeat runs
03:52:59 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:52:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:52:59   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.44
03:53:01 SQL> 
03:53:01 SQL> -- Build a new SVM Model
03:53:01 SQL> BEGIN
03:53:01   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:53:01   3  	  model_name	      => '&model_name',
03:53:01   4  	  mining_function     => dbms_data_mining.classification,
03:53:01   5  	  data_table_name     => 'svmc_build_prep',
03:53:01   6  	  case_id_column_name => '&case_id',
03:53:01   7  	  target_column_name  => '&target',
03:53:01   8  	  settings_table_name => 'svmc_settings');
03:53:01   9  END;
03:53:01  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.19
03:53:06 SQL> 
03:53:06 SQL> -----------------------------------------------------------------------
03:53:06 SQL> --			       APPLY/score THE MODEL
03:53:06 SQL> -----------------------------------------------------------------------
03:53:06 SQL> 
03:53:06 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:06 SQL> -----------------------
03:53:06 SQL> -- PREPARE SCORING DATA
03:53:06 SQL> --
03:53:06 SQL> -- If the data for model creation has been prepared, then the data
03:53:06 SQL> -- to be scored using the model must be prepared in the same manner
03:53:06 SQL> -- in order to obtain meaningful results.
03:53:06 SQL> --
03:53:06 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:06 SQL> -- 2. Normalization
03:53:06 SQL> -- No outlier treatment will be performed during test and apply. The
03:53:06 SQL> -- normalization step is sufficient, since the normalization parameters
03:53:06 SQL> -- already capture the effects of outlier treatment done with build data.
03:53:06 SQL> --
03:53:06 SQL> BEGIN
03:53:06   2  	-- Xform Test data to replace missing values
03:53:06   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:06   4  	  miss_table_name => 'svmc_miss_num',
03:53:06   5  	  data_table_name => '&scoretable',
03:53:06   6  	  xform_view_name => 'xformed_apply_miss_num');
03:53:06   7  
03:53:06   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:06   9  	  miss_table_name => 'svmc_miss_cat',
03:53:06  10  	  data_table_name => '&scoretable',
03:53:06  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:53:06  12  
03:53:06  13  	-- Normalize the data to be scored
03:53:06  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:06  15  	  norm_table_name => 'svmc_norm',
03:53:06  16  	  data_table_name => '&scoretable',
03:53:06  17  	  xform_view_name => 'svmc_apply_prep');
03:53:06  18  END;
03:53:06  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:53:06 SQL> 
03:53:06 SQL> -- Maybe I already collected a score for this prdate.
03:53:06 SQL> -- DELETE it if I did:
03:53:06 SQL> DELETE svm24scores
03:53:06   2  WHERE score > 0
03:53:06   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:53:06   4  -- I need to supply the target attribute name:
03:53:06   5  AND targ = '&1'
03:53:06   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:53:06 SQL> 
03:53:06 SQL> -- We do a drumroll here:
03:53:06 SQL> 
03:53:06 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:53:06   2  SELECT
03:53:06   3  prdate
03:53:06   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:53:06   5  ,sysdate
03:53:06   6  ,SUBSTR(prdate,1,7)pair
03:53:06   7  ,SUBSTR(prdate,-19)ydate
03:53:06   8  ,'&1'
03:53:06   9  FROM svmc_apply_prep
03:53:06  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.07
03:53:06 SQL> @score1_5min_gattn.sql	2011-01-28 16:30:00 eur_usd
03:53:06 SQL> --
03:53:06 SQL> -- score1_5min_gattn.sql
03:53:06 SQL> --
03:53:06 SQL> 
03:53:06 SQL> -- Demo:
03:53:06 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:53:06 SQL> 
03:53:06 SQL> CREATE OR REPLACE VIEW sme AS
03:53:06   2  SELECT
03:53:06   3  prdate
03:53:06   4  ,NULL gattn
03:53:06   5  ,g00
03:53:06   6  ,g01
03:53:06   7  ,g02
03:53:06   8  ,g03
03:53:06   9  ,g04
03:53:06  10  ,g05
03:53:06  11  ,g06
03:53:06  12  ,g07
03:53:06  13  ,g08
03:53:06  14  ,g09
03:53:06  15  ,g10
03:53:06  16  ,g11
03:53:06  17  ,g12
03:53:06  18  ,g13
03:53:06  19  ,g14
03:53:06  20  ,g15
03:53:06  21  ,g16
03:53:06  22  ,g17
03:53:06  23  ,g18
03:53:06  24  ,g19
03:53:06  25  ,g20
03:53:06  26  ,g21
03:53:06  27  ,g22
03:53:06  28  ,g23
03:53:06  29  ,g24
03:53:06  30  ,g25
03:53:06  31  ,g26
03:53:06  32  ,g27
03:53:06  33  ,g28
03:53:06  34  ,g29
03:53:06  35  ,g30
03:53:06  36  ,g31
03:53:06  37  ,g32
03:53:06  38  ,g33
03:53:06  39  ,g34
03:53:06  40  ,g35
03:53:06  41  ,g36
03:53:06  42  ,g37
03:53:06  43  ,g38
03:53:06  44  ,g39
03:53:06  45  ,g40
03:53:06  46  ,g41
03:53:06  47  ,s.sc_corr
03:53:06  48  FROM modsrc24
03:53:06  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:53:06  50  WHERE ydate = '&1'||' '||'&2'
03:53:06  51  AND pair = '&3'
03:53:06  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-28'||' '||'16:30:00'AND ydate<'2011-01-28'||' '||'16:30:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-28'||' '||'16:30:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:53:06 SQL> 
03:53:06 SQL> -- rpt
03:53:06 SQL> -- We should see just 1 row:
03:53:06 SQL> 
03:53:06 SQL> SELECT COUNT(prdate) FROM sme
03:53:06   2  
03:53:06 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:53:06   2  
03:53:06 SQL> 
03:53:06 SQL> -- Build the model:
03:53:06 SQL> CREATE OR REPLACE VIEW bme AS
03:53:06   2  SELECT
03:53:06   3  prdate
03:53:06   4  ,gattn
03:53:06   5  ,g00
03:53:06   6  ,g01
03:53:06   7  ,g02
03:53:06   8  ,g03
03:53:06   9  ,g04
03:53:06  10  ,g05
03:53:06  11  ,g06
03:53:06  12  ,g07
03:53:06  13  ,g08
03:53:06  14  ,g09
03:53:06  15  ,g10
03:53:06  16  ,g11
03:53:06  17  ,g12
03:53:06  18  ,g13
03:53:06  19  ,g14
03:53:06  20  ,g15
03:53:06  21  ,g16
03:53:06  22  ,g17
03:53:06  23  ,g18
03:53:06  24  ,g19
03:53:06  25  ,g20
03:53:06  26  ,g21
03:53:06  27  ,g22
03:53:06  28  ,g23
03:53:06  29  ,g24
03:53:06  30  ,g25
03:53:06  31  ,g26
03:53:06  32  ,g27
03:53:06  33  ,g28
03:53:06  34  ,g29
03:53:06  35  ,g30
03:53:06  36  ,g31
03:53:06  37  ,g32
03:53:06  38  ,g33
03:53:06  39  ,g34
03:53:06  40  ,g35
03:53:06  41  ,g36
03:53:06  42  ,g37
03:53:06  43  ,g38
03:53:06  44  ,g39
03:53:06  45  ,g40
03:53:06  46  ,g41
03:53:06  47  ,sc_corr
03:53:06  48  FROM modsrc24
03:53:06  49  WHERE gattn IN('nup','up')
03:53:06  50  -- Use only rows which are older than 1 day:
03:53:06  51  AND 1+ydate < '&1'||' '||'&2'
03:53:06  52  AND pair = '&3'
03:53:06  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-28'||' '||'16:30:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.07
03:53:06 SQL> 
03:53:06 SQL> -- rpt
03:53:06 SQL> 
03:53:06 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:53:06   2  
03:53:06 SQL> SELECT MAX(prdate) FROM bme
03:53:06   2  
03:53:06 SQL> -- Now build model from bme and score sme
03:53:06 SQL> @score1.sql gattn
03:53:06 SQL> --
03:53:06 SQL> -- score1.sql
03:53:06 SQL> --
03:53:06 SQL> 
03:53:06 SQL> -- I use this script to send 5 params to score.sql
03:53:06 SQL> -- which does the heavy lifting of creating an SVM model.
03:53:06 SQL> -- Then at the very end of this script I use the model
03:53:06 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:53:06 SQL> 
03:53:06 SQL> -- I call this script from 2 other scripts:
03:53:06 SQL> -- score1_5min.sql
03:53:06 SQL> -- score1_5min_gattn.sql
03:53:06 SQL> 
03:53:06 SQL> -- The 1st param is the name of the target attribute.
03:53:06 SQL> -- I like to call my target attributes either gatt or gattn.
03:53:06 SQL> 
03:53:06 SQL> -- Demo:
03:53:06 SQL> -- @score1.sql 'gatt'
03:53:06 SQL> -- @score1.sql 'gattn'
03:53:06 SQL> 
03:53:06 SQL> -- Now, I fill up svmc_apply_prep.
03:53:06 SQL> -- I use same model_name used in score.sql
03:53:06 SQL> DEFINE model_name = 'svmfx101'
03:53:06 SQL> DEFINE bldtable	= 'bme'
03:53:06 SQL> DEFINE scoretable = 'sme'
03:53:06 SQL> DEFINE case_id	= 'prdate'
03:53:06 SQL> -- Demo:
03:53:06 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:53:06 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:53:06 SQL> --
03:53:06 SQL> -- score.sql
03:53:06 SQL> --
03:53:06 SQL> 
03:53:06 SQL> -- usage: score.sql
03:53:06 SQL> 
03:53:06 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:53:06 SQL> 
03:53:06 SQL> -- DEFINE target	   = 'gatt'
03:53:06 SQL> -- DEFINE model_name = 'svmfx101'
03:53:06 SQL> -- DEFINE bldtable   = 'bme'
03:53:06 SQL> -- DEFINE scoretable = 'sme'
03:53:06 SQL> -- DEFINE case_id    = 'prdate'
03:53:06 SQL> 
03:53:06 SQL> DEFINE target	= '&1'
03:53:06 SQL> DEFINE model_name = '&2'
03:53:06 SQL> DEFINE bldtable	= '&3'
03:53:06 SQL> DEFINE scoretable = '&4'
03:53:06 SQL> DEFINE case_id	= '&5'
03:53:06 SQL> 
03:53:06 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:53:06 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:53:06 SQL> 
03:53:06 SQL> -- Builds an SVM model using pl/sql.
03:53:06 SQL> 
03:53:06 SQL> -----------------------------------------------------------------------
03:53:06 SQL> --			    BUILD THE MODEL
03:53:06 SQL> -----------------------------------------------------------------------
03:53:06 SQL> 
03:53:06 SQL> -- Cleanup old build data preparation objects for repeat runs
03:53:06 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:06 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:53:06 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:06 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:53:06 SQL> 
03:53:06 SQL> 
03:53:06 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:53:06 SQL> --
03:53:06 SQL> -- DROP	TABLE svmc_settings ;
03:53:06 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:53:06 SQL> -- DELETE svmc_settings;
03:53:06 SQL> 
03:53:06 SQL> -- The default classification algorithm is Naive Bayes. So override
03:53:06 SQL> -- this choice to SVM using a settings table.
03:53:06 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:53:06 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:53:06 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:53:06 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:53:06 SQL> -- models.
03:53:06 SQL> --
03:53:06 SQL> 
03:53:06 SQL> -- Do this once and then comment it out.
03:53:06 SQL> -- That makes script go faster.
03:53:06 SQL> -- BEGIN
03:53:06 SQL> -- -- Populate settings table
03:53:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:06 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:53:06 SQL> --
03:53:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:06 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:53:06 SQL> --
03:53:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:06 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:53:06 SQL> --   COMMIT;
03:53:06 SQL> -- END;
03:53:06 SQL> -- /
03:53:06 SQL> 
03:53:06 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:53:06 SQL> 
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:06 SQL> 
03:53:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:53:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:06 SQL> 
03:53:06 SQL> --------------------------------
03:53:06 SQL> -- PREPARE BUILD (TRAINING) DATA
03:53:06 SQL> --
03:53:06 SQL> 
03:53:06 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:06 SQL> -- 2. Outlier Treatment and
03:53:06 SQL> -- 3. Normalization are performed below.
03:53:06 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:53:06 SQL> --    normalized here.
03:53:06 SQL> 
03:53:06 SQL> BEGIN
03:53:06   2  	-- Perform missing value treatment for all predictors
03:53:06   3  	-- create miss tables
03:53:06   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:53:06   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:53:06   6  
03:53:06   7  	-- populate miss tables
03:53:06   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:53:06   9  	  miss_table_name => 'svmc_miss_num',
03:53:06  10  	  data_table_name => '&bldtable',
03:53:06  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:06  12  
03:53:06  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:53:06  14  	  miss_table_name => 'svmc_miss_cat',
03:53:06  15  	  data_table_name => '&bldtable',
03:53:06  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:06  17  
03:53:06  18  	-- xform input data to replace missing values
03:53:06  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:06  20  	  miss_table_name => 'svmc_miss_num',
03:53:06  21  	  data_table_name => '&bldtable',
03:53:06  22  	  xform_view_name => 'xformed_build_miss_num');
03:53:06  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:06  24  	  miss_table_name => 'svmc_miss_cat',
03:53:06  25  	  data_table_name => '&bldtable',
03:53:06  26  	  xform_view_name => 'xformed_build_miss_cat');
03:53:06  27  
03:53:06  28  	-- Perform outlier treatment.
03:53:06  29  	-- create clip table
03:53:06  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:53:06  31  
03:53:06  32  	-- populate clip table
03:53:06  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:53:06  34  	  clip_table_name => 'svmc_clip',
03:53:06  35  	  data_table_name => '&bldtable',
03:53:06  36  	  tail_frac	  => 0.025,
03:53:06  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:06  38  
03:53:06  39  	-- xform input data to winsorized data
03:53:06  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:53:06  41  	  clip_table_name => 'svmc_clip',
03:53:06  42  	  data_table_name => '&bldtable',
03:53:06  43  	  xform_view_name => 'svmc_winsor');
03:53:06  44  
03:53:06  45  	-- create normalization table
03:53:06  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:53:06  47  
03:53:06  48  	-- populate normalization table based on winsorized data
03:53:06  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:53:06  50  	  norm_table_name => 'svmc_norm',
03:53:06  51  	  data_table_name => 'svmc_winsor',
03:53:06  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:06  53  
03:53:06  54  	-- normalize the original data
03:53:06  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:06  56  	  norm_table_name => 'svmc_norm',
03:53:06  57  	  data_table_name => '&bldtable',
03:53:06  58  	  xform_view_name => 'svmc_build_prep');
03:53:06  59  END;
03:53:06  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.73
03:53:09 SQL> 
03:53:09 SQL> ---------------------
03:53:09 SQL> -- CREATE A NEW MODEL
03:53:09 SQL> --
03:53:09 SQL> -- Cleanup old model with the same name for repeat runs
03:53:09 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:53:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:09   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.58
03:53:11 SQL> 
03:53:11 SQL> -- Build a new SVM Model
03:53:11 SQL> BEGIN
03:53:11   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:53:11   3  	  model_name	      => '&model_name',
03:53:11   4  	  mining_function     => dbms_data_mining.classification,
03:53:11   5  	  data_table_name     => 'svmc_build_prep',
03:53:11   6  	  case_id_column_name => '&case_id',
03:53:11   7  	  target_column_name  => '&target',
03:53:11   8  	  settings_table_name => 'svmc_settings');
03:53:11   9  END;
03:53:11  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.20
03:53:16 SQL> 
03:53:16 SQL> -----------------------------------------------------------------------
03:53:16 SQL> --			       APPLY/score THE MODEL
03:53:16 SQL> -----------------------------------------------------------------------
03:53:16 SQL> 
03:53:16 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:53:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:53:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:53:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:53:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:16 SQL> -----------------------
03:53:16 SQL> -- PREPARE SCORING DATA
03:53:16 SQL> --
03:53:16 SQL> -- If the data for model creation has been prepared, then the data
03:53:16 SQL> -- to be scored using the model must be prepared in the same manner
03:53:16 SQL> -- in order to obtain meaningful results.
03:53:16 SQL> --
03:53:16 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:16 SQL> -- 2. Normalization
03:53:16 SQL> -- No outlier treatment will be performed during test and apply. The
03:53:16 SQL> -- normalization step is sufficient, since the normalization parameters
03:53:16 SQL> -- already capture the effects of outlier treatment done with build data.
03:53:16 SQL> --
03:53:16 SQL> BEGIN
03:53:16   2  	-- Xform Test data to replace missing values
03:53:16   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:16   4  	  miss_table_name => 'svmc_miss_num',
03:53:16   5  	  data_table_name => '&scoretable',
03:53:16   6  	  xform_view_name => 'xformed_apply_miss_num');
03:53:16   7  
03:53:16   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:16   9  	  miss_table_name => 'svmc_miss_cat',
03:53:16  10  	  data_table_name => '&scoretable',
03:53:16  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:53:16  12  
03:53:16  13  	-- Normalize the data to be scored
03:53:16  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:16  15  	  norm_table_name => 'svmc_norm',
03:53:16  16  	  data_table_name => '&scoretable',
03:53:16  17  	  xform_view_name => 'svmc_apply_prep');
03:53:16  18  END;
03:53:16  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
03:53:16 SQL> 
03:53:16 SQL> -- Maybe I already collected a score for this prdate.
03:53:16 SQL> -- DELETE it if I did:
03:53:16 SQL> DELETE svm24scores
03:53:16   2  WHERE score > 0
03:53:16   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:53:16   4  -- I need to supply the target attribute name:
03:53:16   5  AND targ = '&1'
03:53:16   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:53:16 SQL> 
03:53:16 SQL> -- We do a drumroll here:
03:53:16 SQL> 
03:53:16 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:53:16   2  SELECT
03:53:16   3  prdate
03:53:16   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:53:16   5  ,sysdate
03:53:16   6  ,SUBSTR(prdate,1,7)pair
03:53:16   7  ,SUBSTR(prdate,-19)ydate
03:53:16   8  ,'&1'
03:53:16   9  FROM svmc_apply_prep
03:53:16  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:53:16 SQL> @score1_5min.sql	      2011-01-21 05:55:00 eur_usd
03:53:16 SQL> --
03:53:16 SQL> -- score1_5min.sql
03:53:16 SQL> --
03:53:16 SQL> 
03:53:16 SQL> -- Demo:
03:53:16 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:53:16 SQL> 
03:53:16 SQL> CREATE OR REPLACE VIEW sme AS
03:53:16   2  SELECT
03:53:16   3  prdate
03:53:16   4  ,NULL gatt
03:53:16   5  ,g00
03:53:16   6  ,g01
03:53:16   7  ,g02
03:53:16   8  ,g03
03:53:16   9  ,g04
03:53:16  10  ,g05
03:53:16  11  ,g06
03:53:16  12  ,g07
03:53:16  13  ,g08
03:53:16  14  ,g09
03:53:16  15  ,g10
03:53:16  16  ,g11
03:53:16  17  ,g12
03:53:16  18  ,g13
03:53:16  19  ,g14
03:53:16  20  ,g15
03:53:16  21  ,g16
03:53:16  22  ,g17
03:53:16  23  ,g18
03:53:16  24  ,g19
03:53:16  25  ,g20
03:53:16  26  ,g21
03:53:16  27  ,g22
03:53:16  28  ,g23
03:53:16  29  ,g24
03:53:16  30  ,g25
03:53:16  31  ,g26
03:53:16  32  ,g27
03:53:16  33  ,g28
03:53:16  34  ,g29
03:53:16  35  ,g30
03:53:16  36  ,g31
03:53:16  37  ,g32
03:53:16  38  ,g33
03:53:16  39  ,g34
03:53:16  40  ,g35
03:53:16  41  ,g36
03:53:16  42  ,g37
03:53:16  43  ,g38
03:53:16  44  ,g39
03:53:16  45  ,g40
03:53:16  46  ,g41
03:53:16  47  ,s.sc_corr
03:53:16  48  FROM modsrc24
03:53:16  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:53:16  50  WHERE ydate = '&1'||' '||'&2'
03:53:16  51  AND pair = '&3'
03:53:16  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'05:55:00'AND ydate<'2011-01-21'||' '||'05:55:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'05:55:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:53:16 SQL> 
03:53:16 SQL> -- rpt
03:53:16 SQL> -- We should see just 1 row:
03:53:16 SQL> 
03:53:16 SQL> SELECT COUNT(prdate) FROM sme
03:53:16   2  
03:53:16 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:53:16   2  
03:53:16 SQL> 
03:53:16 SQL> -- Build the model:
03:53:16 SQL> CREATE OR REPLACE VIEW bme AS
03:53:16   2  SELECT
03:53:16   3  prdate
03:53:16   4  ,gatt
03:53:16   5  ,g00
03:53:16   6  ,g01
03:53:16   7  ,g02
03:53:16   8  ,g03
03:53:16   9  ,g04
03:53:16  10  ,g05
03:53:16  11  ,g06
03:53:16  12  ,g07
03:53:16  13  ,g08
03:53:16  14  ,g09
03:53:16  15  ,g10
03:53:16  16  ,g11
03:53:16  17  ,g12
03:53:16  18  ,g13
03:53:16  19  ,g14
03:53:16  20  ,g15
03:53:16  21  ,g16
03:53:16  22  ,g17
03:53:16  23  ,g18
03:53:16  24  ,g19
03:53:16  25  ,g20
03:53:16  26  ,g21
03:53:16  27  ,g22
03:53:16  28  ,g23
03:53:16  29  ,g24
03:53:16  30  ,g25
03:53:16  31  ,g26
03:53:16  32  ,g27
03:53:16  33  ,g28
03:53:16  34  ,g29
03:53:16  35  ,g30
03:53:16  36  ,g31
03:53:16  37  ,g32
03:53:16  38  ,g33
03:53:16  39  ,g34
03:53:16  40  ,g35
03:53:16  41  ,g36
03:53:16  42  ,g37
03:53:16  43  ,g38
03:53:16  44  ,g39
03:53:16  45  ,g40
03:53:16  46  ,g41
03:53:16  47  ,sc_corr
03:53:16  48  FROM modsrc24
03:53:16  49  WHERE gatt IN('nup','up')
03:53:16  50  -- Use only rows which are older than 1 day:
03:53:16  51  AND 1+ydate < '&1'||' '||'&2'
03:53:16  52  AND pair = '&3'
03:53:16  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'05:55:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:53:16 SQL> 
03:53:16 SQL> -- rpt
03:53:16 SQL> 
03:53:16 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:53:16   2  
03:53:16 SQL> SELECT MAX(prdate) FROM bme
03:53:16   2  
03:53:16 SQL> -- Now build model from bme and score sme
03:53:16 SQL> @score1.sql gatt
03:53:16 SQL> --
03:53:16 SQL> -- score1.sql
03:53:16 SQL> --
03:53:16 SQL> 
03:53:16 SQL> -- I use this script to send 5 params to score.sql
03:53:16 SQL> -- which does the heavy lifting of creating an SVM model.
03:53:16 SQL> -- Then at the very end of this script I use the model
03:53:16 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:53:16 SQL> 
03:53:16 SQL> -- I call this script from 2 other scripts:
03:53:16 SQL> -- score1_5min.sql
03:53:16 SQL> -- score1_5min_gattn.sql
03:53:16 SQL> 
03:53:16 SQL> -- The 1st param is the name of the target attribute.
03:53:16 SQL> -- I like to call my target attributes either gatt or gattn.
03:53:16 SQL> 
03:53:16 SQL> -- Demo:
03:53:16 SQL> -- @score1.sql 'gatt'
03:53:16 SQL> -- @score1.sql 'gattn'
03:53:16 SQL> 
03:53:16 SQL> -- Now, I fill up svmc_apply_prep.
03:53:16 SQL> -- I use same model_name used in score.sql
03:53:16 SQL> DEFINE model_name = 'svmfx101'
03:53:16 SQL> DEFINE bldtable	= 'bme'
03:53:16 SQL> DEFINE scoretable = 'sme'
03:53:16 SQL> DEFINE case_id	= 'prdate'
03:53:16 SQL> -- Demo:
03:53:16 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:53:16 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:53:16 SQL> --
03:53:16 SQL> -- score.sql
03:53:16 SQL> --
03:53:16 SQL> 
03:53:16 SQL> -- usage: score.sql
03:53:16 SQL> 
03:53:16 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:53:16 SQL> 
03:53:16 SQL> -- DEFINE target	   = 'gatt'
03:53:16 SQL> -- DEFINE model_name = 'svmfx101'
03:53:16 SQL> -- DEFINE bldtable   = 'bme'
03:53:16 SQL> -- DEFINE scoretable = 'sme'
03:53:16 SQL> -- DEFINE case_id    = 'prdate'
03:53:16 SQL> 
03:53:16 SQL> DEFINE target	= '&1'
03:53:16 SQL> DEFINE model_name = '&2'
03:53:16 SQL> DEFINE bldtable	= '&3'
03:53:16 SQL> DEFINE scoretable = '&4'
03:53:16 SQL> DEFINE case_id	= '&5'
03:53:16 SQL> 
03:53:16 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:53:16 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:53:16 SQL> 
03:53:16 SQL> -- Builds an SVM model using pl/sql.
03:53:16 SQL> 
03:53:16 SQL> -----------------------------------------------------------------------
03:53:16 SQL> --			    BUILD THE MODEL
03:53:16 SQL> -----------------------------------------------------------------------
03:53:16 SQL> 
03:53:16 SQL> -- Cleanup old build data preparation objects for repeat runs
03:53:16 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:16 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:53:16 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:16 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:53:16 SQL> 
03:53:16 SQL> 
03:53:16 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:53:16 SQL> --
03:53:16 SQL> -- DROP	TABLE svmc_settings ;
03:53:16 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:53:16 SQL> -- DELETE svmc_settings;
03:53:16 SQL> 
03:53:16 SQL> -- The default classification algorithm is Naive Bayes. So override
03:53:16 SQL> -- this choice to SVM using a settings table.
03:53:16 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:53:16 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:53:16 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:53:16 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:53:16 SQL> -- models.
03:53:16 SQL> --
03:53:16 SQL> 
03:53:16 SQL> -- Do this once and then comment it out.
03:53:16 SQL> -- That makes script go faster.
03:53:16 SQL> -- BEGIN
03:53:16 SQL> -- -- Populate settings table
03:53:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:16 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:53:16 SQL> --
03:53:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:16 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:53:16 SQL> --
03:53:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:16 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:53:16 SQL> --   COMMIT;
03:53:16 SQL> -- END;
03:53:16 SQL> -- /
03:53:16 SQL> 
03:53:16 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:53:16 SQL> 
03:53:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:53:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:53:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:53:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:53:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:17 SQL> 
03:53:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:53:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:17 SQL> 
03:53:17 SQL> --------------------------------
03:53:17 SQL> -- PREPARE BUILD (TRAINING) DATA
03:53:17 SQL> --
03:53:17 SQL> 
03:53:17 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:17 SQL> -- 2. Outlier Treatment and
03:53:17 SQL> -- 3. Normalization are performed below.
03:53:17 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:53:17 SQL> --    normalized here.
03:53:17 SQL> 
03:53:17 SQL> BEGIN
03:53:17   2  	-- Perform missing value treatment for all predictors
03:53:17   3  	-- create miss tables
03:53:17   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:53:17   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:53:17   6  
03:53:17   7  	-- populate miss tables
03:53:17   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:53:17   9  	  miss_table_name => 'svmc_miss_num',
03:53:17  10  	  data_table_name => '&bldtable',
03:53:17  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:17  12  
03:53:17  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:53:17  14  	  miss_table_name => 'svmc_miss_cat',
03:53:17  15  	  data_table_name => '&bldtable',
03:53:17  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:17  17  
03:53:17  18  	-- xform input data to replace missing values
03:53:17  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:17  20  	  miss_table_name => 'svmc_miss_num',
03:53:17  21  	  data_table_name => '&bldtable',
03:53:17  22  	  xform_view_name => 'xformed_build_miss_num');
03:53:17  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:17  24  	  miss_table_name => 'svmc_miss_cat',
03:53:17  25  	  data_table_name => '&bldtable',
03:53:17  26  	  xform_view_name => 'xformed_build_miss_cat');
03:53:17  27  
03:53:17  28  	-- Perform outlier treatment.
03:53:17  29  	-- create clip table
03:53:17  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:53:17  31  
03:53:17  32  	-- populate clip table
03:53:17  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:53:17  34  	  clip_table_name => 'svmc_clip',
03:53:17  35  	  data_table_name => '&bldtable',
03:53:17  36  	  tail_frac	  => 0.025,
03:53:17  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:17  38  
03:53:17  39  	-- xform input data to winsorized data
03:53:17  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:53:17  41  	  clip_table_name => 'svmc_clip',
03:53:17  42  	  data_table_name => '&bldtable',
03:53:17  43  	  xform_view_name => 'svmc_winsor');
03:53:17  44  
03:53:17  45  	-- create normalization table
03:53:17  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:53:17  47  
03:53:17  48  	-- populate normalization table based on winsorized data
03:53:17  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:53:17  50  	  norm_table_name => 'svmc_norm',
03:53:17  51  	  data_table_name => 'svmc_winsor',
03:53:17  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:17  53  
03:53:17  54  	-- normalize the original data
03:53:17  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:17  56  	  norm_table_name => 'svmc_norm',
03:53:17  57  	  data_table_name => '&bldtable',
03:53:17  58  	  xform_view_name => 'svmc_build_prep');
03:53:17  59  END;
03:53:17  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.57
03:53:19 SQL> 
03:53:19 SQL> ---------------------
03:53:19 SQL> -- CREATE A NEW MODEL
03:53:19 SQL> --
03:53:19 SQL> -- Cleanup old model with the same name for repeat runs
03:53:19 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:53:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:19   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.46
03:53:21 SQL> 
03:53:21 SQL> -- Build a new SVM Model
03:53:21 SQL> BEGIN
03:53:21   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:53:21   3  	  model_name	      => '&model_name',
03:53:21   4  	  mining_function     => dbms_data_mining.classification,
03:53:21   5  	  data_table_name     => 'svmc_build_prep',
03:53:21   6  	  case_id_column_name => '&case_id',
03:53:21   7  	  target_column_name  => '&target',
03:53:21   8  	  settings_table_name => 'svmc_settings');
03:53:21   9  END;
03:53:21  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.10
03:53:27 SQL> 
03:53:27 SQL> -----------------------------------------------------------------------
03:53:27 SQL> --			       APPLY/score THE MODEL
03:53:27 SQL> -----------------------------------------------------------------------
03:53:27 SQL> 
03:53:27 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:27 SQL> -----------------------
03:53:27 SQL> -- PREPARE SCORING DATA
03:53:27 SQL> --
03:53:27 SQL> -- If the data for model creation has been prepared, then the data
03:53:27 SQL> -- to be scored using the model must be prepared in the same manner
03:53:27 SQL> -- in order to obtain meaningful results.
03:53:27 SQL> --
03:53:27 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:27 SQL> -- 2. Normalization
03:53:27 SQL> -- No outlier treatment will be performed during test and apply. The
03:53:27 SQL> -- normalization step is sufficient, since the normalization parameters
03:53:27 SQL> -- already capture the effects of outlier treatment done with build data.
03:53:27 SQL> --
03:53:27 SQL> BEGIN
03:53:27   2  	-- Xform Test data to replace missing values
03:53:27   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:27   4  	  miss_table_name => 'svmc_miss_num',
03:53:27   5  	  data_table_name => '&scoretable',
03:53:27   6  	  xform_view_name => 'xformed_apply_miss_num');
03:53:27   7  
03:53:27   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:27   9  	  miss_table_name => 'svmc_miss_cat',
03:53:27  10  	  data_table_name => '&scoretable',
03:53:27  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:53:27  12  
03:53:27  13  	-- Normalize the data to be scored
03:53:27  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:27  15  	  norm_table_name => 'svmc_norm',
03:53:27  16  	  data_table_name => '&scoretable',
03:53:27  17  	  xform_view_name => 'svmc_apply_prep');
03:53:27  18  END;
03:53:27  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:53:27 SQL> 
03:53:27 SQL> -- Maybe I already collected a score for this prdate.
03:53:27 SQL> -- DELETE it if I did:
03:53:27 SQL> DELETE svm24scores
03:53:27   2  WHERE score > 0
03:53:27   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:53:27   4  -- I need to supply the target attribute name:
03:53:27   5  AND targ = '&1'
03:53:27   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:53:27 SQL> 
03:53:27 SQL> -- We do a drumroll here:
03:53:27 SQL> 
03:53:27 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:53:27   2  SELECT
03:53:27   3  prdate
03:53:27   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:53:27   5  ,sysdate
03:53:27   6  ,SUBSTR(prdate,1,7)pair
03:53:27   7  ,SUBSTR(prdate,-19)ydate
03:53:27   8  ,'&1'
03:53:27   9  FROM svmc_apply_prep
03:53:27  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:53:27 SQL> @score1_5min_gattn.sql	2011-01-26 08:40:00 eur_usd
03:53:27 SQL> --
03:53:27 SQL> -- score1_5min_gattn.sql
03:53:27 SQL> --
03:53:27 SQL> 
03:53:27 SQL> -- Demo:
03:53:27 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:53:27 SQL> 
03:53:27 SQL> CREATE OR REPLACE VIEW sme AS
03:53:27   2  SELECT
03:53:27   3  prdate
03:53:27   4  ,NULL gattn
03:53:27   5  ,g00
03:53:27   6  ,g01
03:53:27   7  ,g02
03:53:27   8  ,g03
03:53:27   9  ,g04
03:53:27  10  ,g05
03:53:27  11  ,g06
03:53:27  12  ,g07
03:53:27  13  ,g08
03:53:27  14  ,g09
03:53:27  15  ,g10
03:53:27  16  ,g11
03:53:27  17  ,g12
03:53:27  18  ,g13
03:53:27  19  ,g14
03:53:27  20  ,g15
03:53:27  21  ,g16
03:53:27  22  ,g17
03:53:27  23  ,g18
03:53:27  24  ,g19
03:53:27  25  ,g20
03:53:27  26  ,g21
03:53:27  27  ,g22
03:53:27  28  ,g23
03:53:27  29  ,g24
03:53:27  30  ,g25
03:53:27  31  ,g26
03:53:27  32  ,g27
03:53:27  33  ,g28
03:53:27  34  ,g29
03:53:27  35  ,g30
03:53:27  36  ,g31
03:53:27  37  ,g32
03:53:27  38  ,g33
03:53:27  39  ,g34
03:53:27  40  ,g35
03:53:27  41  ,g36
03:53:27  42  ,g37
03:53:27  43  ,g38
03:53:27  44  ,g39
03:53:27  45  ,g40
03:53:27  46  ,g41
03:53:27  47  ,s.sc_corr
03:53:27  48  FROM modsrc24
03:53:27  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:53:27  50  WHERE ydate = '&1'||' '||'&2'
03:53:27  51  AND pair = '&3'
03:53:27  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-26'||' '||'08:40:00'AND ydate<'2011-01-26'||' '||'08:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-26'||' '||'08:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:53:27 SQL> 
03:53:27 SQL> -- rpt
03:53:27 SQL> -- We should see just 1 row:
03:53:27 SQL> 
03:53:27 SQL> SELECT COUNT(prdate) FROM sme
03:53:27   2  
03:53:27 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:53:27   2  
03:53:27 SQL> 
03:53:27 SQL> -- Build the model:
03:53:27 SQL> CREATE OR REPLACE VIEW bme AS
03:53:27   2  SELECT
03:53:27   3  prdate
03:53:27   4  ,gattn
03:53:27   5  ,g00
03:53:27   6  ,g01
03:53:27   7  ,g02
03:53:27   8  ,g03
03:53:27   9  ,g04
03:53:27  10  ,g05
03:53:27  11  ,g06
03:53:27  12  ,g07
03:53:27  13  ,g08
03:53:27  14  ,g09
03:53:27  15  ,g10
03:53:27  16  ,g11
03:53:27  17  ,g12
03:53:27  18  ,g13
03:53:27  19  ,g14
03:53:27  20  ,g15
03:53:27  21  ,g16
03:53:27  22  ,g17
03:53:27  23  ,g18
03:53:27  24  ,g19
03:53:27  25  ,g20
03:53:27  26  ,g21
03:53:27  27  ,g22
03:53:27  28  ,g23
03:53:27  29  ,g24
03:53:27  30  ,g25
03:53:27  31  ,g26
03:53:27  32  ,g27
03:53:27  33  ,g28
03:53:27  34  ,g29
03:53:27  35  ,g30
03:53:27  36  ,g31
03:53:27  37  ,g32
03:53:27  38  ,g33
03:53:27  39  ,g34
03:53:27  40  ,g35
03:53:27  41  ,g36
03:53:27  42  ,g37
03:53:27  43  ,g38
03:53:27  44  ,g39
03:53:27  45  ,g40
03:53:27  46  ,g41
03:53:27  47  ,sc_corr
03:53:27  48  FROM modsrc24
03:53:27  49  WHERE gattn IN('nup','up')
03:53:27  50  -- Use only rows which are older than 1 day:
03:53:27  51  AND 1+ydate < '&1'||' '||'&2'
03:53:27  52  AND pair = '&3'
03:53:27  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-26'||' '||'08:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:53:27 SQL> 
03:53:27 SQL> -- rpt
03:53:27 SQL> 
03:53:27 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:53:27   2  
03:53:27 SQL> SELECT MAX(prdate) FROM bme
03:53:27   2  
03:53:27 SQL> -- Now build model from bme and score sme
03:53:27 SQL> @score1.sql gattn
03:53:27 SQL> --
03:53:27 SQL> -- score1.sql
03:53:27 SQL> --
03:53:27 SQL> 
03:53:27 SQL> -- I use this script to send 5 params to score.sql
03:53:27 SQL> -- which does the heavy lifting of creating an SVM model.
03:53:27 SQL> -- Then at the very end of this script I use the model
03:53:27 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:53:27 SQL> 
03:53:27 SQL> -- I call this script from 2 other scripts:
03:53:27 SQL> -- score1_5min.sql
03:53:27 SQL> -- score1_5min_gattn.sql
03:53:27 SQL> 
03:53:27 SQL> -- The 1st param is the name of the target attribute.
03:53:27 SQL> -- I like to call my target attributes either gatt or gattn.
03:53:27 SQL> 
03:53:27 SQL> -- Demo:
03:53:27 SQL> -- @score1.sql 'gatt'
03:53:27 SQL> -- @score1.sql 'gattn'
03:53:27 SQL> 
03:53:27 SQL> -- Now, I fill up svmc_apply_prep.
03:53:27 SQL> -- I use same model_name used in score.sql
03:53:27 SQL> DEFINE model_name = 'svmfx101'
03:53:27 SQL> DEFINE bldtable	= 'bme'
03:53:27 SQL> DEFINE scoretable = 'sme'
03:53:27 SQL> DEFINE case_id	= 'prdate'
03:53:27 SQL> -- Demo:
03:53:27 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:53:27 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:53:27 SQL> --
03:53:27 SQL> -- score.sql
03:53:27 SQL> --
03:53:27 SQL> 
03:53:27 SQL> -- usage: score.sql
03:53:27 SQL> 
03:53:27 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:53:27 SQL> 
03:53:27 SQL> -- DEFINE target	   = 'gatt'
03:53:27 SQL> -- DEFINE model_name = 'svmfx101'
03:53:27 SQL> -- DEFINE bldtable   = 'bme'
03:53:27 SQL> -- DEFINE scoretable = 'sme'
03:53:27 SQL> -- DEFINE case_id    = 'prdate'
03:53:27 SQL> 
03:53:27 SQL> DEFINE target	= '&1'
03:53:27 SQL> DEFINE model_name = '&2'
03:53:27 SQL> DEFINE bldtable	= '&3'
03:53:27 SQL> DEFINE scoretable = '&4'
03:53:27 SQL> DEFINE case_id	= '&5'
03:53:27 SQL> 
03:53:27 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:53:27 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:53:27 SQL> 
03:53:27 SQL> -- Builds an SVM model using pl/sql.
03:53:27 SQL> 
03:53:27 SQL> -----------------------------------------------------------------------
03:53:27 SQL> --			    BUILD THE MODEL
03:53:27 SQL> -----------------------------------------------------------------------
03:53:27 SQL> 
03:53:27 SQL> -- Cleanup old build data preparation objects for repeat runs
03:53:27 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:27 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:53:27 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:27 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:53:27 SQL> 
03:53:27 SQL> 
03:53:27 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:53:27 SQL> --
03:53:27 SQL> -- DROP	TABLE svmc_settings ;
03:53:27 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:53:27 SQL> -- DELETE svmc_settings;
03:53:27 SQL> 
03:53:27 SQL> -- The default classification algorithm is Naive Bayes. So override
03:53:27 SQL> -- this choice to SVM using a settings table.
03:53:27 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:53:27 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:53:27 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:53:27 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:53:27 SQL> -- models.
03:53:27 SQL> --
03:53:27 SQL> 
03:53:27 SQL> -- Do this once and then comment it out.
03:53:27 SQL> -- That makes script go faster.
03:53:27 SQL> -- BEGIN
03:53:27 SQL> -- -- Populate settings table
03:53:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:27 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:53:27 SQL> --
03:53:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:27 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:53:27 SQL> --
03:53:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:27 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:53:27 SQL> --   COMMIT;
03:53:27 SQL> -- END;
03:53:27 SQL> -- /
03:53:27 SQL> 
03:53:27 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:53:27 SQL> 
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:27 SQL> 
03:53:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:53:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:27 SQL> 
03:53:27 SQL> --------------------------------
03:53:27 SQL> -- PREPARE BUILD (TRAINING) DATA
03:53:27 SQL> --
03:53:27 SQL> 
03:53:27 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:27 SQL> -- 2. Outlier Treatment and
03:53:27 SQL> -- 3. Normalization are performed below.
03:53:27 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:53:27 SQL> --    normalized here.
03:53:27 SQL> 
03:53:27 SQL> BEGIN
03:53:27   2  	-- Perform missing value treatment for all predictors
03:53:27   3  	-- create miss tables
03:53:27   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:53:27   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:53:27   6  
03:53:27   7  	-- populate miss tables
03:53:27   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:53:27   9  	  miss_table_name => 'svmc_miss_num',
03:53:27  10  	  data_table_name => '&bldtable',
03:53:27  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:27  12  
03:53:27  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:53:27  14  	  miss_table_name => 'svmc_miss_cat',
03:53:27  15  	  data_table_name => '&bldtable',
03:53:27  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:27  17  
03:53:27  18  	-- xform input data to replace missing values
03:53:27  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:27  20  	  miss_table_name => 'svmc_miss_num',
03:53:27  21  	  data_table_name => '&bldtable',
03:53:27  22  	  xform_view_name => 'xformed_build_miss_num');
03:53:27  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:27  24  	  miss_table_name => 'svmc_miss_cat',
03:53:27  25  	  data_table_name => '&bldtable',
03:53:27  26  	  xform_view_name => 'xformed_build_miss_cat');
03:53:27  27  
03:53:27  28  	-- Perform outlier treatment.
03:53:27  29  	-- create clip table
03:53:27  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:53:27  31  
03:53:27  32  	-- populate clip table
03:53:27  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:53:27  34  	  clip_table_name => 'svmc_clip',
03:53:27  35  	  data_table_name => '&bldtable',
03:53:27  36  	  tail_frac	  => 0.025,
03:53:27  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:27  38  
03:53:27  39  	-- xform input data to winsorized data
03:53:27  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:53:27  41  	  clip_table_name => 'svmc_clip',
03:53:27  42  	  data_table_name => '&bldtable',
03:53:27  43  	  xform_view_name => 'svmc_winsor');
03:53:27  44  
03:53:27  45  	-- create normalization table
03:53:27  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:53:27  47  
03:53:27  48  	-- populate normalization table based on winsorized data
03:53:27  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:53:27  50  	  norm_table_name => 'svmc_norm',
03:53:27  51  	  data_table_name => 'svmc_winsor',
03:53:27  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:27  53  
03:53:27  54  	-- normalize the original data
03:53:27  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:27  56  	  norm_table_name => 'svmc_norm',
03:53:27  57  	  data_table_name => '&bldtable',
03:53:27  58  	  xform_view_name => 'svmc_build_prep');
03:53:27  59  END;
03:53:27  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.68
03:53:30 SQL> 
03:53:30 SQL> ---------------------
03:53:30 SQL> -- CREATE A NEW MODEL
03:53:30 SQL> --
03:53:30 SQL> -- Cleanup old model with the same name for repeat runs
03:53:30 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:53:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:30   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.38
03:53:31 SQL> 
03:53:31 SQL> -- Build a new SVM Model
03:53:31 SQL> BEGIN
03:53:31   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:53:31   3  	  model_name	      => '&model_name',
03:53:31   4  	  mining_function     => dbms_data_mining.classification,
03:53:31   5  	  data_table_name     => 'svmc_build_prep',
03:53:31   6  	  case_id_column_name => '&case_id',
03:53:31   7  	  target_column_name  => '&target',
03:53:31   8  	  settings_table_name => 'svmc_settings');
03:53:31   9  END;
03:53:31  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.78
03:53:37 SQL> 
03:53:37 SQL> -----------------------------------------------------------------------
03:53:37 SQL> --			       APPLY/score THE MODEL
03:53:37 SQL> -----------------------------------------------------------------------
03:53:37 SQL> 
03:53:37 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:53:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:53:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:53:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:53:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
03:53:37 SQL> -----------------------
03:53:37 SQL> -- PREPARE SCORING DATA
03:53:37 SQL> --
03:53:37 SQL> -- If the data for model creation has been prepared, then the data
03:53:37 SQL> -- to be scored using the model must be prepared in the same manner
03:53:37 SQL> -- in order to obtain meaningful results.
03:53:37 SQL> --
03:53:37 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:37 SQL> -- 2. Normalization
03:53:37 SQL> -- No outlier treatment will be performed during test and apply. The
03:53:37 SQL> -- normalization step is sufficient, since the normalization parameters
03:53:37 SQL> -- already capture the effects of outlier treatment done with build data.
03:53:37 SQL> --
03:53:37 SQL> BEGIN
03:53:37   2  	-- Xform Test data to replace missing values
03:53:37   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:37   4  	  miss_table_name => 'svmc_miss_num',
03:53:37   5  	  data_table_name => '&scoretable',
03:53:37   6  	  xform_view_name => 'xformed_apply_miss_num');
03:53:37   7  
03:53:37   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:37   9  	  miss_table_name => 'svmc_miss_cat',
03:53:37  10  	  data_table_name => '&scoretable',
03:53:37  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:53:37  12  
03:53:37  13  	-- Normalize the data to be scored
03:53:37  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:37  15  	  norm_table_name => 'svmc_norm',
03:53:37  16  	  data_table_name => '&scoretable',
03:53:37  17  	  xform_view_name => 'svmc_apply_prep');
03:53:37  18  END;
03:53:37  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:53:38 SQL> 
03:53:38 SQL> -- Maybe I already collected a score for this prdate.
03:53:38 SQL> -- DELETE it if I did:
03:53:38 SQL> DELETE svm24scores
03:53:38   2  WHERE score > 0
03:53:38   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:53:38   4  -- I need to supply the target attribute name:
03:53:38   5  AND targ = '&1'
03:53:38   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:53:38 SQL> 
03:53:38 SQL> -- We do a drumroll here:
03:53:38 SQL> 
03:53:38 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:53:38   2  SELECT
03:53:38   3  prdate
03:53:38   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:53:38   5  ,sysdate
03:53:38   6  ,SUBSTR(prdate,1,7)pair
03:53:38   7  ,SUBSTR(prdate,-19)ydate
03:53:38   8  ,'&1'
03:53:38   9  FROM svmc_apply_prep
03:53:38  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:53:38 SQL> @score1_5min_gattn.sql	2011-01-27 18:55:00 eur_usd
03:53:38 SQL> --
03:53:38 SQL> -- score1_5min_gattn.sql
03:53:38 SQL> --
03:53:38 SQL> 
03:53:38 SQL> -- Demo:
03:53:38 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:53:38 SQL> 
03:53:38 SQL> CREATE OR REPLACE VIEW sme AS
03:53:38   2  SELECT
03:53:38   3  prdate
03:53:38   4  ,NULL gattn
03:53:38   5  ,g00
03:53:38   6  ,g01
03:53:38   7  ,g02
03:53:38   8  ,g03
03:53:38   9  ,g04
03:53:38  10  ,g05
03:53:38  11  ,g06
03:53:38  12  ,g07
03:53:38  13  ,g08
03:53:38  14  ,g09
03:53:38  15  ,g10
03:53:38  16  ,g11
03:53:38  17  ,g12
03:53:38  18  ,g13
03:53:38  19  ,g14
03:53:38  20  ,g15
03:53:38  21  ,g16
03:53:38  22  ,g17
03:53:38  23  ,g18
03:53:38  24  ,g19
03:53:38  25  ,g20
03:53:38  26  ,g21
03:53:38  27  ,g22
03:53:38  28  ,g23
03:53:38  29  ,g24
03:53:38  30  ,g25
03:53:38  31  ,g26
03:53:38  32  ,g27
03:53:38  33  ,g28
03:53:38  34  ,g29
03:53:38  35  ,g30
03:53:38  36  ,g31
03:53:38  37  ,g32
03:53:38  38  ,g33
03:53:38  39  ,g34
03:53:38  40  ,g35
03:53:38  41  ,g36
03:53:38  42  ,g37
03:53:38  43  ,g38
03:53:38  44  ,g39
03:53:38  45  ,g40
03:53:38  46  ,g41
03:53:38  47  ,s.sc_corr
03:53:38  48  FROM modsrc24
03:53:38  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:53:38  50  WHERE ydate = '&1'||' '||'&2'
03:53:38  51  AND pair = '&3'
03:53:38  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'18:55:00'AND ydate<'2011-01-27'||' '||'18:55:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'18:55:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:53:38 SQL> 
03:53:38 SQL> -- rpt
03:53:38 SQL> -- We should see just 1 row:
03:53:38 SQL> 
03:53:38 SQL> SELECT COUNT(prdate) FROM sme
03:53:38   2  
03:53:38 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:53:38   2  
03:53:38 SQL> 
03:53:38 SQL> -- Build the model:
03:53:38 SQL> CREATE OR REPLACE VIEW bme AS
03:53:38   2  SELECT
03:53:38   3  prdate
03:53:38   4  ,gattn
03:53:38   5  ,g00
03:53:38   6  ,g01
03:53:38   7  ,g02
03:53:38   8  ,g03
03:53:38   9  ,g04
03:53:38  10  ,g05
03:53:38  11  ,g06
03:53:38  12  ,g07
03:53:38  13  ,g08
03:53:38  14  ,g09
03:53:38  15  ,g10
03:53:38  16  ,g11
03:53:38  17  ,g12
03:53:38  18  ,g13
03:53:38  19  ,g14
03:53:38  20  ,g15
03:53:38  21  ,g16
03:53:38  22  ,g17
03:53:38  23  ,g18
03:53:38  24  ,g19
03:53:38  25  ,g20
03:53:38  26  ,g21
03:53:38  27  ,g22
03:53:38  28  ,g23
03:53:38  29  ,g24
03:53:38  30  ,g25
03:53:38  31  ,g26
03:53:38  32  ,g27
03:53:38  33  ,g28
03:53:38  34  ,g29
03:53:38  35  ,g30
03:53:38  36  ,g31
03:53:38  37  ,g32
03:53:38  38  ,g33
03:53:38  39  ,g34
03:53:38  40  ,g35
03:53:38  41  ,g36
03:53:38  42  ,g37
03:53:38  43  ,g38
03:53:38  44  ,g39
03:53:38  45  ,g40
03:53:38  46  ,g41
03:53:38  47  ,sc_corr
03:53:38  48  FROM modsrc24
03:53:38  49  WHERE gattn IN('nup','up')
03:53:38  50  -- Use only rows which are older than 1 day:
03:53:38  51  AND 1+ydate < '&1'||' '||'&2'
03:53:38  52  AND pair = '&3'
03:53:38  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'18:55:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:53:38 SQL> 
03:53:38 SQL> -- rpt
03:53:38 SQL> 
03:53:38 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:53:38   2  
03:53:38 SQL> SELECT MAX(prdate) FROM bme
03:53:38   2  
03:53:38 SQL> -- Now build model from bme and score sme
03:53:38 SQL> @score1.sql gattn
03:53:38 SQL> --
03:53:38 SQL> -- score1.sql
03:53:38 SQL> --
03:53:38 SQL> 
03:53:38 SQL> -- I use this script to send 5 params to score.sql
03:53:38 SQL> -- which does the heavy lifting of creating an SVM model.
03:53:38 SQL> -- Then at the very end of this script I use the model
03:53:38 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:53:38 SQL> 
03:53:38 SQL> -- I call this script from 2 other scripts:
03:53:38 SQL> -- score1_5min.sql
03:53:38 SQL> -- score1_5min_gattn.sql
03:53:38 SQL> 
03:53:38 SQL> -- The 1st param is the name of the target attribute.
03:53:38 SQL> -- I like to call my target attributes either gatt or gattn.
03:53:38 SQL> 
03:53:38 SQL> -- Demo:
03:53:38 SQL> -- @score1.sql 'gatt'
03:53:38 SQL> -- @score1.sql 'gattn'
03:53:38 SQL> 
03:53:38 SQL> -- Now, I fill up svmc_apply_prep.
03:53:38 SQL> -- I use same model_name used in score.sql
03:53:38 SQL> DEFINE model_name = 'svmfx101'
03:53:38 SQL> DEFINE bldtable	= 'bme'
03:53:38 SQL> DEFINE scoretable = 'sme'
03:53:38 SQL> DEFINE case_id	= 'prdate'
03:53:38 SQL> -- Demo:
03:53:38 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:53:38 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:53:38 SQL> --
03:53:38 SQL> -- score.sql
03:53:38 SQL> --
03:53:38 SQL> 
03:53:38 SQL> -- usage: score.sql
03:53:38 SQL> 
03:53:38 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:53:38 SQL> 
03:53:38 SQL> -- DEFINE target	   = 'gatt'
03:53:38 SQL> -- DEFINE model_name = 'svmfx101'
03:53:38 SQL> -- DEFINE bldtable   = 'bme'
03:53:38 SQL> -- DEFINE scoretable = 'sme'
03:53:38 SQL> -- DEFINE case_id    = 'prdate'
03:53:38 SQL> 
03:53:38 SQL> DEFINE target	= '&1'
03:53:38 SQL> DEFINE model_name = '&2'
03:53:38 SQL> DEFINE bldtable	= '&3'
03:53:38 SQL> DEFINE scoretable = '&4'
03:53:38 SQL> DEFINE case_id	= '&5'
03:53:38 SQL> 
03:53:38 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:53:38 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:53:38 SQL> 
03:53:38 SQL> -- Builds an SVM model using pl/sql.
03:53:38 SQL> 
03:53:38 SQL> -----------------------------------------------------------------------
03:53:38 SQL> --			    BUILD THE MODEL
03:53:38 SQL> -----------------------------------------------------------------------
03:53:38 SQL> 
03:53:38 SQL> -- Cleanup old build data preparation objects for repeat runs
03:53:38 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:38 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:53:38 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:53:38 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:53:38 SQL> 
03:53:38 SQL> 
03:53:38 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:53:38 SQL> --
03:53:38 SQL> -- DROP	TABLE svmc_settings ;
03:53:38 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:53:38 SQL> -- DELETE svmc_settings;
03:53:38 SQL> 
03:53:38 SQL> -- The default classification algorithm is Naive Bayes. So override
03:53:38 SQL> -- this choice to SVM using a settings table.
03:53:38 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:53:38 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:53:38 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:53:38 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:53:38 SQL> -- models.
03:53:38 SQL> --
03:53:38 SQL> 
03:53:38 SQL> -- Do this once and then comment it out.
03:53:38 SQL> -- That makes script go faster.
03:53:38 SQL> -- BEGIN
03:53:38 SQL> -- -- Populate settings table
03:53:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:38 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:53:38 SQL> --
03:53:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:38 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:53:38 SQL> --
03:53:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:38 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:53:38 SQL> --   COMMIT;
03:53:38 SQL> -- END;
03:53:38 SQL> -- /
03:53:38 SQL> 
03:53:38 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:53:38 SQL> 
03:53:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:53:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
03:53:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:53:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:53:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:38 SQL> 
03:53:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:53:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:38 SQL> 
03:53:38 SQL> --------------------------------
03:53:38 SQL> -- PREPARE BUILD (TRAINING) DATA
03:53:38 SQL> --
03:53:38 SQL> 
03:53:38 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:38 SQL> -- 2. Outlier Treatment and
03:53:38 SQL> -- 3. Normalization are performed below.
03:53:38 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:53:38 SQL> --    normalized here.
03:53:38 SQL> 
03:53:38 SQL> BEGIN
03:53:38   2  	-- Perform missing value treatment for all predictors
03:53:38   3  	-- create miss tables
03:53:38   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:53:38   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:53:38   6  
03:53:38   7  	-- populate miss tables
03:53:38   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:53:38   9  	  miss_table_name => 'svmc_miss_num',
03:53:38  10  	  data_table_name => '&bldtable',
03:53:38  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:38  12  
03:53:38  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:53:38  14  	  miss_table_name => 'svmc_miss_cat',
03:53:38  15  	  data_table_name => '&bldtable',
03:53:38  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:38  17  
03:53:38  18  	-- xform input data to replace missing values
03:53:38  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:38  20  	  miss_table_name => 'svmc_miss_num',
03:53:38  21  	  data_table_name => '&bldtable',
03:53:38  22  	  xform_view_name => 'xformed_build_miss_num');
03:53:38  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:38  24  	  miss_table_name => 'svmc_miss_cat',
03:53:38  25  	  data_table_name => '&bldtable',
03:53:38  26  	  xform_view_name => 'xformed_build_miss_cat');
03:53:38  27  
03:53:38  28  	-- Perform outlier treatment.
03:53:38  29  	-- create clip table
03:53:38  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:53:38  31  
03:53:38  32  	-- populate clip table
03:53:38  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:53:38  34  	  clip_table_name => 'svmc_clip',
03:53:38  35  	  data_table_name => '&bldtable',
03:53:38  36  	  tail_frac	  => 0.025,
03:53:38  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:38  38  
03:53:38  39  	-- xform input data to winsorized data
03:53:38  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:53:38  41  	  clip_table_name => 'svmc_clip',
03:53:38  42  	  data_table_name => '&bldtable',
03:53:38  43  	  xform_view_name => 'svmc_winsor');
03:53:38  44  
03:53:38  45  	-- create normalization table
03:53:38  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:53:38  47  
03:53:38  48  	-- populate normalization table based on winsorized data
03:53:38  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:53:38  50  	  norm_table_name => 'svmc_norm',
03:53:38  51  	  data_table_name => 'svmc_winsor',
03:53:38  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:38  53  
03:53:38  54  	-- normalize the original data
03:53:38  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:38  56  	  norm_table_name => 'svmc_norm',
03:53:38  57  	  data_table_name => '&bldtable',
03:53:38  58  	  xform_view_name => 'svmc_build_prep');
03:53:38  59  END;
03:53:38  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.71
03:53:41 SQL> 
03:53:41 SQL> ---------------------
03:53:41 SQL> -- CREATE A NEW MODEL
03:53:41 SQL> --
03:53:41 SQL> -- Cleanup old model with the same name for repeat runs
03:53:41 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:53:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:41   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.49
03:53:42 SQL> 
03:53:42 SQL> -- Build a new SVM Model
03:53:42 SQL> BEGIN
03:53:42   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:53:42   3  	  model_name	      => '&model_name',
03:53:42   4  	  mining_function     => dbms_data_mining.classification,
03:53:42   5  	  data_table_name     => 'svmc_build_prep',
03:53:42   6  	  case_id_column_name => '&case_id',
03:53:42   7  	  target_column_name  => '&target',
03:53:42   8  	  settings_table_name => 'svmc_settings');
03:53:42   9  END;
03:53:42  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.67
03:53:48 SQL> 
03:53:48 SQL> -----------------------------------------------------------------------
03:53:48 SQL> --			       APPLY/score THE MODEL
03:53:48 SQL> -----------------------------------------------------------------------
03:53:48 SQL> 
03:53:48 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:48 SQL> -----------------------
03:53:48 SQL> -- PREPARE SCORING DATA
03:53:48 SQL> --
03:53:48 SQL> -- If the data for model creation has been prepared, then the data
03:53:48 SQL> -- to be scored using the model must be prepared in the same manner
03:53:48 SQL> -- in order to obtain meaningful results.
03:53:48 SQL> --
03:53:48 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:48 SQL> -- 2. Normalization
03:53:48 SQL> -- No outlier treatment will be performed during test and apply. The
03:53:48 SQL> -- normalization step is sufficient, since the normalization parameters
03:53:48 SQL> -- already capture the effects of outlier treatment done with build data.
03:53:48 SQL> --
03:53:48 SQL> BEGIN
03:53:48   2  	-- Xform Test data to replace missing values
03:53:48   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:48   4  	  miss_table_name => 'svmc_miss_num',
03:53:48   5  	  data_table_name => '&scoretable',
03:53:48   6  	  xform_view_name => 'xformed_apply_miss_num');
03:53:48   7  
03:53:48   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:48   9  	  miss_table_name => 'svmc_miss_cat',
03:53:48  10  	  data_table_name => '&scoretable',
03:53:48  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:53:48  12  
03:53:48  13  	-- Normalize the data to be scored
03:53:48  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:48  15  	  norm_table_name => 'svmc_norm',
03:53:48  16  	  data_table_name => '&scoretable',
03:53:48  17  	  xform_view_name => 'svmc_apply_prep');
03:53:48  18  END;
03:53:48  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:53:48 SQL> 
03:53:48 SQL> -- Maybe I already collected a score for this prdate.
03:53:48 SQL> -- DELETE it if I did:
03:53:48 SQL> DELETE svm24scores
03:53:48   2  WHERE score > 0
03:53:48   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:53:48   4  -- I need to supply the target attribute name:
03:53:48   5  AND targ = '&1'
03:53:48   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:53:48 SQL> 
03:53:48 SQL> -- We do a drumroll here:
03:53:48 SQL> 
03:53:48 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:53:48   2  SELECT
03:53:48   3  prdate
03:53:48   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:53:48   5  ,sysdate
03:53:48   6  ,SUBSTR(prdate,1,7)pair
03:53:48   7  ,SUBSTR(prdate,-19)ydate
03:53:48   8  ,'&1'
03:53:48   9  FROM svmc_apply_prep
03:53:48  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:53:48 SQL> @score1_5min.sql	      2011-01-20 12:20:00 eur_usd
03:53:48 SQL> --
03:53:48 SQL> -- score1_5min.sql
03:53:48 SQL> --
03:53:48 SQL> 
03:53:48 SQL> -- Demo:
03:53:48 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:53:48 SQL> 
03:53:48 SQL> CREATE OR REPLACE VIEW sme AS
03:53:48   2  SELECT
03:53:48   3  prdate
03:53:48   4  ,NULL gatt
03:53:48   5  ,g00
03:53:48   6  ,g01
03:53:48   7  ,g02
03:53:48   8  ,g03
03:53:48   9  ,g04
03:53:48  10  ,g05
03:53:48  11  ,g06
03:53:48  12  ,g07
03:53:48  13  ,g08
03:53:48  14  ,g09
03:53:48  15  ,g10
03:53:48  16  ,g11
03:53:48  17  ,g12
03:53:48  18  ,g13
03:53:48  19  ,g14
03:53:48  20  ,g15
03:53:48  21  ,g16
03:53:48  22  ,g17
03:53:48  23  ,g18
03:53:48  24  ,g19
03:53:48  25  ,g20
03:53:48  26  ,g21
03:53:48  27  ,g22
03:53:48  28  ,g23
03:53:48  29  ,g24
03:53:48  30  ,g25
03:53:48  31  ,g26
03:53:48  32  ,g27
03:53:48  33  ,g28
03:53:48  34  ,g29
03:53:48  35  ,g30
03:53:48  36  ,g31
03:53:48  37  ,g32
03:53:48  38  ,g33
03:53:48  39  ,g34
03:53:48  40  ,g35
03:53:48  41  ,g36
03:53:48  42  ,g37
03:53:48  43  ,g38
03:53:48  44  ,g39
03:53:48  45  ,g40
03:53:48  46  ,g41
03:53:48  47  ,s.sc_corr
03:53:48  48  FROM modsrc24
03:53:48  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:53:48  50  WHERE ydate = '&1'||' '||'&2'
03:53:48  51  AND pair = '&3'
03:53:48  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'12:20:00'AND ydate<'2011-01-20'||' '||'12:20:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'12:20:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:53:48 SQL> 
03:53:48 SQL> -- rpt
03:53:48 SQL> -- We should see just 1 row:
03:53:48 SQL> 
03:53:48 SQL> SELECT COUNT(prdate) FROM sme
03:53:48   2  
03:53:48 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:53:48   2  
03:53:48 SQL> 
03:53:48 SQL> -- Build the model:
03:53:48 SQL> CREATE OR REPLACE VIEW bme AS
03:53:48   2  SELECT
03:53:48   3  prdate
03:53:48   4  ,gatt
03:53:48   5  ,g00
03:53:48   6  ,g01
03:53:48   7  ,g02
03:53:48   8  ,g03
03:53:48   9  ,g04
03:53:48  10  ,g05
03:53:48  11  ,g06
03:53:48  12  ,g07
03:53:48  13  ,g08
03:53:48  14  ,g09
03:53:48  15  ,g10
03:53:48  16  ,g11
03:53:48  17  ,g12
03:53:48  18  ,g13
03:53:48  19  ,g14
03:53:48  20  ,g15
03:53:48  21  ,g16
03:53:48  22  ,g17
03:53:48  23  ,g18
03:53:48  24  ,g19
03:53:48  25  ,g20
03:53:48  26  ,g21
03:53:48  27  ,g22
03:53:48  28  ,g23
03:53:48  29  ,g24
03:53:48  30  ,g25
03:53:48  31  ,g26
03:53:48  32  ,g27
03:53:48  33  ,g28
03:53:48  34  ,g29
03:53:48  35  ,g30
03:53:48  36  ,g31
03:53:48  37  ,g32
03:53:48  38  ,g33
03:53:48  39  ,g34
03:53:48  40  ,g35
03:53:48  41  ,g36
03:53:48  42  ,g37
03:53:48  43  ,g38
03:53:48  44  ,g39
03:53:48  45  ,g40
03:53:48  46  ,g41
03:53:48  47  ,sc_corr
03:53:48  48  FROM modsrc24
03:53:48  49  WHERE gatt IN('nup','up')
03:53:48  50  -- Use only rows which are older than 1 day:
03:53:48  51  AND 1+ydate < '&1'||' '||'&2'
03:53:48  52  AND pair = '&3'
03:53:48  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'12:20:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:53:48 SQL> 
03:53:48 SQL> -- rpt
03:53:48 SQL> 
03:53:48 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:53:48   2  
03:53:48 SQL> SELECT MAX(prdate) FROM bme
03:53:48   2  
03:53:48 SQL> -- Now build model from bme and score sme
03:53:48 SQL> @score1.sql gatt
03:53:48 SQL> --
03:53:48 SQL> -- score1.sql
03:53:48 SQL> --
03:53:48 SQL> 
03:53:48 SQL> -- I use this script to send 5 params to score.sql
03:53:48 SQL> -- which does the heavy lifting of creating an SVM model.
03:53:48 SQL> -- Then at the very end of this script I use the model
03:53:48 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:53:48 SQL> 
03:53:48 SQL> -- I call this script from 2 other scripts:
03:53:48 SQL> -- score1_5min.sql
03:53:48 SQL> -- score1_5min_gattn.sql
03:53:48 SQL> 
03:53:48 SQL> -- The 1st param is the name of the target attribute.
03:53:48 SQL> -- I like to call my target attributes either gatt or gattn.
03:53:48 SQL> 
03:53:48 SQL> -- Demo:
03:53:48 SQL> -- @score1.sql 'gatt'
03:53:48 SQL> -- @score1.sql 'gattn'
03:53:48 SQL> 
03:53:48 SQL> -- Now, I fill up svmc_apply_prep.
03:53:48 SQL> -- I use same model_name used in score.sql
03:53:48 SQL> DEFINE model_name = 'svmfx101'
03:53:48 SQL> DEFINE bldtable	= 'bme'
03:53:48 SQL> DEFINE scoretable = 'sme'
03:53:48 SQL> DEFINE case_id	= 'prdate'
03:53:48 SQL> -- Demo:
03:53:48 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:53:48 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:53:48 SQL> --
03:53:48 SQL> -- score.sql
03:53:48 SQL> --
03:53:48 SQL> 
03:53:48 SQL> -- usage: score.sql
03:53:48 SQL> 
03:53:48 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:53:48 SQL> 
03:53:48 SQL> -- DEFINE target	   = 'gatt'
03:53:48 SQL> -- DEFINE model_name = 'svmfx101'
03:53:48 SQL> -- DEFINE bldtable   = 'bme'
03:53:48 SQL> -- DEFINE scoretable = 'sme'
03:53:48 SQL> -- DEFINE case_id    = 'prdate'
03:53:48 SQL> 
03:53:48 SQL> DEFINE target	= '&1'
03:53:48 SQL> DEFINE model_name = '&2'
03:53:48 SQL> DEFINE bldtable	= '&3'
03:53:48 SQL> DEFINE scoretable = '&4'
03:53:48 SQL> DEFINE case_id	= '&5'
03:53:48 SQL> 
03:53:48 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:53:48 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:53:48 SQL> 
03:53:48 SQL> -- Builds an SVM model using pl/sql.
03:53:48 SQL> 
03:53:48 SQL> -----------------------------------------------------------------------
03:53:48 SQL> --			    BUILD THE MODEL
03:53:48 SQL> -----------------------------------------------------------------------
03:53:48 SQL> 
03:53:48 SQL> -- Cleanup old build data preparation objects for repeat runs
03:53:48 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:48 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:53:48 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:53:48 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:53:48 SQL> 
03:53:48 SQL> 
03:53:48 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:53:48 SQL> --
03:53:48 SQL> -- DROP	TABLE svmc_settings ;
03:53:48 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:53:48 SQL> -- DELETE svmc_settings;
03:53:48 SQL> 
03:53:48 SQL> -- The default classification algorithm is Naive Bayes. So override
03:53:48 SQL> -- this choice to SVM using a settings table.
03:53:48 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:53:48 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:53:48 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:53:48 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:53:48 SQL> -- models.
03:53:48 SQL> --
03:53:48 SQL> 
03:53:48 SQL> -- Do this once and then comment it out.
03:53:48 SQL> -- That makes script go faster.
03:53:48 SQL> -- BEGIN
03:53:48 SQL> -- -- Populate settings table
03:53:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:48 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:53:48 SQL> --
03:53:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:48 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:53:48 SQL> --
03:53:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:48 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:53:48 SQL> --   COMMIT;
03:53:48 SQL> -- END;
03:53:48 SQL> -- /
03:53:48 SQL> 
03:53:48 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:53:48 SQL> 
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:48 SQL> 
03:53:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:53:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:48 SQL> 
03:53:48 SQL> --------------------------------
03:53:48 SQL> -- PREPARE BUILD (TRAINING) DATA
03:53:48 SQL> --
03:53:48 SQL> 
03:53:48 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:48 SQL> -- 2. Outlier Treatment and
03:53:48 SQL> -- 3. Normalization are performed below.
03:53:48 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:53:48 SQL> --    normalized here.
03:53:48 SQL> 
03:53:48 SQL> BEGIN
03:53:48   2  	-- Perform missing value treatment for all predictors
03:53:48   3  	-- create miss tables
03:53:48   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:53:48   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:53:48   6  
03:53:48   7  	-- populate miss tables
03:53:48   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:53:48   9  	  miss_table_name => 'svmc_miss_num',
03:53:48  10  	  data_table_name => '&bldtable',
03:53:48  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:48  12  
03:53:48  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:53:48  14  	  miss_table_name => 'svmc_miss_cat',
03:53:48  15  	  data_table_name => '&bldtable',
03:53:48  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:48  17  
03:53:48  18  	-- xform input data to replace missing values
03:53:48  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:48  20  	  miss_table_name => 'svmc_miss_num',
03:53:48  21  	  data_table_name => '&bldtable',
03:53:48  22  	  xform_view_name => 'xformed_build_miss_num');
03:53:48  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:48  24  	  miss_table_name => 'svmc_miss_cat',
03:53:48  25  	  data_table_name => '&bldtable',
03:53:48  26  	  xform_view_name => 'xformed_build_miss_cat');
03:53:48  27  
03:53:48  28  	-- Perform outlier treatment.
03:53:48  29  	-- create clip table
03:53:48  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:53:48  31  
03:53:48  32  	-- populate clip table
03:53:48  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:53:48  34  	  clip_table_name => 'svmc_clip',
03:53:48  35  	  data_table_name => '&bldtable',
03:53:48  36  	  tail_frac	  => 0.025,
03:53:48  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:48  38  
03:53:48  39  	-- xform input data to winsorized data
03:53:48  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:53:48  41  	  clip_table_name => 'svmc_clip',
03:53:48  42  	  data_table_name => '&bldtable',
03:53:48  43  	  xform_view_name => 'svmc_winsor');
03:53:48  44  
03:53:48  45  	-- create normalization table
03:53:48  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:53:48  47  
03:53:48  48  	-- populate normalization table based on winsorized data
03:53:48  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:53:48  50  	  norm_table_name => 'svmc_norm',
03:53:48  51  	  data_table_name => 'svmc_winsor',
03:53:48  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:48  53  
03:53:48  54  	-- normalize the original data
03:53:48  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:48  56  	  norm_table_name => 'svmc_norm',
03:53:48  57  	  data_table_name => '&bldtable',
03:53:48  58  	  xform_view_name => 'svmc_build_prep');
03:53:48  59  END;
03:53:48  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.62
03:53:51 SQL> 
03:53:51 SQL> ---------------------
03:53:51 SQL> -- CREATE A NEW MODEL
03:53:51 SQL> --
03:53:51 SQL> -- Cleanup old model with the same name for repeat runs
03:53:51 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:53:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:51   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
03:53:53 SQL> 
03:53:53 SQL> -- Build a new SVM Model
03:53:53 SQL> BEGIN
03:53:53   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:53:53   3  	  model_name	      => '&model_name',
03:53:53   4  	  mining_function     => dbms_data_mining.classification,
03:53:53   5  	  data_table_name     => 'svmc_build_prep',
03:53:53   6  	  case_id_column_name => '&case_id',
03:53:53   7  	  target_column_name  => '&target',
03:53:53   8  	  settings_table_name => 'svmc_settings');
03:53:53   9  END;
03:53:53  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.15
03:53:58 SQL> 
03:53:58 SQL> -----------------------------------------------------------------------
03:53:58 SQL> --			       APPLY/score THE MODEL
03:53:58 SQL> -----------------------------------------------------------------------
03:53:58 SQL> 
03:53:58 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:58 SQL> -----------------------
03:53:58 SQL> -- PREPARE SCORING DATA
03:53:58 SQL> --
03:53:58 SQL> -- If the data for model creation has been prepared, then the data
03:53:58 SQL> -- to be scored using the model must be prepared in the same manner
03:53:58 SQL> -- in order to obtain meaningful results.
03:53:58 SQL> --
03:53:58 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:58 SQL> -- 2. Normalization
03:53:58 SQL> -- No outlier treatment will be performed during test and apply. The
03:53:58 SQL> -- normalization step is sufficient, since the normalization parameters
03:53:58 SQL> -- already capture the effects of outlier treatment done with build data.
03:53:58 SQL> --
03:53:58 SQL> BEGIN
03:53:58   2  	-- Xform Test data to replace missing values
03:53:58   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:58   4  	  miss_table_name => 'svmc_miss_num',
03:53:58   5  	  data_table_name => '&scoretable',
03:53:58   6  	  xform_view_name => 'xformed_apply_miss_num');
03:53:58   7  
03:53:58   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:58   9  	  miss_table_name => 'svmc_miss_cat',
03:53:58  10  	  data_table_name => '&scoretable',
03:53:58  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:53:58  12  
03:53:58  13  	-- Normalize the data to be scored
03:53:58  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:58  15  	  norm_table_name => 'svmc_norm',
03:53:58  16  	  data_table_name => '&scoretable',
03:53:58  17  	  xform_view_name => 'svmc_apply_prep');
03:53:58  18  END;
03:53:58  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:53:58 SQL> 
03:53:58 SQL> -- Maybe I already collected a score for this prdate.
03:53:58 SQL> -- DELETE it if I did:
03:53:58 SQL> DELETE svm24scores
03:53:58   2  WHERE score > 0
03:53:58   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:53:58   4  -- I need to supply the target attribute name:
03:53:58   5  AND targ = '&1'
03:53:58   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:53:58 SQL> 
03:53:58 SQL> -- We do a drumroll here:
03:53:58 SQL> 
03:53:58 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:53:58   2  SELECT
03:53:58   3  prdate
03:53:58   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:53:58   5  ,sysdate
03:53:58   6  ,SUBSTR(prdate,1,7)pair
03:53:58   7  ,SUBSTR(prdate,-19)ydate
03:53:58   8  ,'&1'
03:53:58   9  FROM svmc_apply_prep
03:53:58  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:53:58 SQL> @score1_5min_gattn.sql	2011-01-27 12:00:00 eur_usd
03:53:58 SQL> --
03:53:58 SQL> -- score1_5min_gattn.sql
03:53:58 SQL> --
03:53:58 SQL> 
03:53:58 SQL> -- Demo:
03:53:58 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:53:58 SQL> 
03:53:58 SQL> CREATE OR REPLACE VIEW sme AS
03:53:58   2  SELECT
03:53:58   3  prdate
03:53:58   4  ,NULL gattn
03:53:58   5  ,g00
03:53:58   6  ,g01
03:53:58   7  ,g02
03:53:58   8  ,g03
03:53:58   9  ,g04
03:53:58  10  ,g05
03:53:58  11  ,g06
03:53:58  12  ,g07
03:53:58  13  ,g08
03:53:58  14  ,g09
03:53:58  15  ,g10
03:53:58  16  ,g11
03:53:58  17  ,g12
03:53:58  18  ,g13
03:53:58  19  ,g14
03:53:58  20  ,g15
03:53:58  21  ,g16
03:53:58  22  ,g17
03:53:58  23  ,g18
03:53:58  24  ,g19
03:53:58  25  ,g20
03:53:58  26  ,g21
03:53:58  27  ,g22
03:53:58  28  ,g23
03:53:58  29  ,g24
03:53:58  30  ,g25
03:53:58  31  ,g26
03:53:58  32  ,g27
03:53:58  33  ,g28
03:53:58  34  ,g29
03:53:58  35  ,g30
03:53:58  36  ,g31
03:53:58  37  ,g32
03:53:58  38  ,g33
03:53:58  39  ,g34
03:53:58  40  ,g35
03:53:58  41  ,g36
03:53:58  42  ,g37
03:53:58  43  ,g38
03:53:58  44  ,g39
03:53:58  45  ,g40
03:53:58  46  ,g41
03:53:58  47  ,s.sc_corr
03:53:58  48  FROM modsrc24
03:53:58  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:53:58  50  WHERE ydate = '&1'||' '||'&2'
03:53:58  51  AND pair = '&3'
03:53:58  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'12:00:00'AND ydate<'2011-01-27'||' '||'12:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'12:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:53:58 SQL> 
03:53:58 SQL> -- rpt
03:53:58 SQL> -- We should see just 1 row:
03:53:58 SQL> 
03:53:58 SQL> SELECT COUNT(prdate) FROM sme
03:53:58   2  
03:53:58 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:53:58   2  
03:53:58 SQL> 
03:53:58 SQL> -- Build the model:
03:53:58 SQL> CREATE OR REPLACE VIEW bme AS
03:53:58   2  SELECT
03:53:58   3  prdate
03:53:58   4  ,gattn
03:53:58   5  ,g00
03:53:58   6  ,g01
03:53:58   7  ,g02
03:53:58   8  ,g03
03:53:58   9  ,g04
03:53:58  10  ,g05
03:53:58  11  ,g06
03:53:58  12  ,g07
03:53:58  13  ,g08
03:53:58  14  ,g09
03:53:58  15  ,g10
03:53:58  16  ,g11
03:53:58  17  ,g12
03:53:58  18  ,g13
03:53:58  19  ,g14
03:53:58  20  ,g15
03:53:58  21  ,g16
03:53:58  22  ,g17
03:53:58  23  ,g18
03:53:58  24  ,g19
03:53:58  25  ,g20
03:53:58  26  ,g21
03:53:58  27  ,g22
03:53:58  28  ,g23
03:53:58  29  ,g24
03:53:58  30  ,g25
03:53:58  31  ,g26
03:53:58  32  ,g27
03:53:58  33  ,g28
03:53:58  34  ,g29
03:53:58  35  ,g30
03:53:58  36  ,g31
03:53:58  37  ,g32
03:53:58  38  ,g33
03:53:58  39  ,g34
03:53:58  40  ,g35
03:53:58  41  ,g36
03:53:58  42  ,g37
03:53:58  43  ,g38
03:53:58  44  ,g39
03:53:58  45  ,g40
03:53:58  46  ,g41
03:53:58  47  ,sc_corr
03:53:58  48  FROM modsrc24
03:53:58  49  WHERE gattn IN('nup','up')
03:53:58  50  -- Use only rows which are older than 1 day:
03:53:58  51  AND 1+ydate < '&1'||' '||'&2'
03:53:58  52  AND pair = '&3'
03:53:58  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'12:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:53:58 SQL> 
03:53:58 SQL> -- rpt
03:53:58 SQL> 
03:53:58 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:53:58   2  
03:53:58 SQL> SELECT MAX(prdate) FROM bme
03:53:58   2  
03:53:58 SQL> -- Now build model from bme and score sme
03:53:58 SQL> @score1.sql gattn
03:53:58 SQL> --
03:53:58 SQL> -- score1.sql
03:53:58 SQL> --
03:53:58 SQL> 
03:53:58 SQL> -- I use this script to send 5 params to score.sql
03:53:58 SQL> -- which does the heavy lifting of creating an SVM model.
03:53:58 SQL> -- Then at the very end of this script I use the model
03:53:58 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:53:58 SQL> 
03:53:58 SQL> -- I call this script from 2 other scripts:
03:53:58 SQL> -- score1_5min.sql
03:53:58 SQL> -- score1_5min_gattn.sql
03:53:58 SQL> 
03:53:58 SQL> -- The 1st param is the name of the target attribute.
03:53:58 SQL> -- I like to call my target attributes either gatt or gattn.
03:53:58 SQL> 
03:53:58 SQL> -- Demo:
03:53:58 SQL> -- @score1.sql 'gatt'
03:53:58 SQL> -- @score1.sql 'gattn'
03:53:58 SQL> 
03:53:58 SQL> -- Now, I fill up svmc_apply_prep.
03:53:58 SQL> -- I use same model_name used in score.sql
03:53:58 SQL> DEFINE model_name = 'svmfx101'
03:53:58 SQL> DEFINE bldtable	= 'bme'
03:53:58 SQL> DEFINE scoretable = 'sme'
03:53:58 SQL> DEFINE case_id	= 'prdate'
03:53:58 SQL> -- Demo:
03:53:58 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:53:58 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:53:58 SQL> --
03:53:58 SQL> -- score.sql
03:53:58 SQL> --
03:53:58 SQL> 
03:53:58 SQL> -- usage: score.sql
03:53:58 SQL> 
03:53:58 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:53:58 SQL> 
03:53:58 SQL> -- DEFINE target	   = 'gatt'
03:53:58 SQL> -- DEFINE model_name = 'svmfx101'
03:53:58 SQL> -- DEFINE bldtable   = 'bme'
03:53:58 SQL> -- DEFINE scoretable = 'sme'
03:53:58 SQL> -- DEFINE case_id    = 'prdate'
03:53:58 SQL> 
03:53:58 SQL> DEFINE target	= '&1'
03:53:58 SQL> DEFINE model_name = '&2'
03:53:58 SQL> DEFINE bldtable	= '&3'
03:53:58 SQL> DEFINE scoretable = '&4'
03:53:58 SQL> DEFINE case_id	= '&5'
03:53:58 SQL> 
03:53:58 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:53:58 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:53:58 SQL> 
03:53:58 SQL> -- Builds an SVM model using pl/sql.
03:53:58 SQL> 
03:53:58 SQL> -----------------------------------------------------------------------
03:53:58 SQL> --			    BUILD THE MODEL
03:53:58 SQL> -----------------------------------------------------------------------
03:53:58 SQL> 
03:53:58 SQL> -- Cleanup old build data preparation objects for repeat runs
03:53:58 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:58 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:53:58 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:53:58 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:53:58 SQL> 
03:53:58 SQL> 
03:53:58 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:53:58 SQL> --
03:53:58 SQL> -- DROP	TABLE svmc_settings ;
03:53:58 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:53:58 SQL> -- DELETE svmc_settings;
03:53:58 SQL> 
03:53:58 SQL> -- The default classification algorithm is Naive Bayes. So override
03:53:58 SQL> -- this choice to SVM using a settings table.
03:53:58 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:53:58 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:53:58 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:53:58 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:53:58 SQL> -- models.
03:53:58 SQL> --
03:53:58 SQL> 
03:53:58 SQL> -- Do this once and then comment it out.
03:53:58 SQL> -- That makes script go faster.
03:53:58 SQL> -- BEGIN
03:53:58 SQL> -- -- Populate settings table
03:53:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:58 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:53:58 SQL> --
03:53:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:58 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:53:58 SQL> --
03:53:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:53:58 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:53:58 SQL> --   COMMIT;
03:53:58 SQL> -- END;
03:53:58 SQL> -- /
03:53:58 SQL> 
03:53:58 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:53:58 SQL> 
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:58 SQL> 
03:53:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:53:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:53:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:53:58 SQL> 
03:53:58 SQL> --------------------------------
03:53:58 SQL> -- PREPARE BUILD (TRAINING) DATA
03:53:58 SQL> --
03:53:58 SQL> 
03:53:58 SQL> -- 1. Missing Value treatment for all Predictors and
03:53:58 SQL> -- 2. Outlier Treatment and
03:53:58 SQL> -- 3. Normalization are performed below.
03:53:58 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:53:58 SQL> --    normalized here.
03:53:58 SQL> 
03:53:58 SQL> BEGIN
03:53:58   2  	-- Perform missing value treatment for all predictors
03:53:58   3  	-- create miss tables
03:53:58   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:53:58   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:53:58   6  
03:53:58   7  	-- populate miss tables
03:53:58   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:53:58   9  	  miss_table_name => 'svmc_miss_num',
03:53:58  10  	  data_table_name => '&bldtable',
03:53:58  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:58  12  
03:53:58  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:53:58  14  	  miss_table_name => 'svmc_miss_cat',
03:53:58  15  	  data_table_name => '&bldtable',
03:53:58  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:58  17  
03:53:58  18  	-- xform input data to replace missing values
03:53:58  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:53:58  20  	  miss_table_name => 'svmc_miss_num',
03:53:58  21  	  data_table_name => '&bldtable',
03:53:58  22  	  xform_view_name => 'xformed_build_miss_num');
03:53:58  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:53:58  24  	  miss_table_name => 'svmc_miss_cat',
03:53:58  25  	  data_table_name => '&bldtable',
03:53:58  26  	  xform_view_name => 'xformed_build_miss_cat');
03:53:58  27  
03:53:58  28  	-- Perform outlier treatment.
03:53:58  29  	-- create clip table
03:53:58  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:53:58  31  
03:53:58  32  	-- populate clip table
03:53:58  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:53:58  34  	  clip_table_name => 'svmc_clip',
03:53:58  35  	  data_table_name => '&bldtable',
03:53:58  36  	  tail_frac	  => 0.025,
03:53:58  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:58  38  
03:53:58  39  	-- xform input data to winsorized data
03:53:58  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:53:58  41  	  clip_table_name => 'svmc_clip',
03:53:58  42  	  data_table_name => '&bldtable',
03:53:58  43  	  xform_view_name => 'svmc_winsor');
03:53:58  44  
03:53:58  45  	-- create normalization table
03:53:58  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:53:58  47  
03:53:58  48  	-- populate normalization table based on winsorized data
03:53:58  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:53:58  50  	  norm_table_name => 'svmc_norm',
03:53:58  51  	  data_table_name => 'svmc_winsor',
03:53:58  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:53:58  53  
03:53:58  54  	-- normalize the original data
03:53:58  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:53:58  56  	  norm_table_name => 'svmc_norm',
03:53:58  57  	  data_table_name => '&bldtable',
03:53:58  58  	  xform_view_name => 'svmc_build_prep');
03:53:58  59  END;
03:53:58  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.67
03:54:01 SQL> 
03:54:01 SQL> ---------------------
03:54:01 SQL> -- CREATE A NEW MODEL
03:54:01 SQL> --
03:54:01 SQL> -- Cleanup old model with the same name for repeat runs
03:54:01 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:54:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:01   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
03:54:03 SQL> 
03:54:03 SQL> -- Build a new SVM Model
03:54:03 SQL> BEGIN
03:54:03   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:54:03   3  	  model_name	      => '&model_name',
03:54:03   4  	  mining_function     => dbms_data_mining.classification,
03:54:03   5  	  data_table_name     => 'svmc_build_prep',
03:54:03   6  	  case_id_column_name => '&case_id',
03:54:03   7  	  target_column_name  => '&target',
03:54:03   8  	  settings_table_name => 'svmc_settings');
03:54:03   9  END;
03:54:03  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.08
03:54:09 SQL> 
03:54:09 SQL> -----------------------------------------------------------------------
03:54:09 SQL> --			       APPLY/score THE MODEL
03:54:09 SQL> -----------------------------------------------------------------------
03:54:09 SQL> 
03:54:09 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:09 SQL> -----------------------
03:54:09 SQL> -- PREPARE SCORING DATA
03:54:09 SQL> --
03:54:09 SQL> -- If the data for model creation has been prepared, then the data
03:54:09 SQL> -- to be scored using the model must be prepared in the same manner
03:54:09 SQL> -- in order to obtain meaningful results.
03:54:09 SQL> --
03:54:09 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:09 SQL> -- 2. Normalization
03:54:09 SQL> -- No outlier treatment will be performed during test and apply. The
03:54:09 SQL> -- normalization step is sufficient, since the normalization parameters
03:54:09 SQL> -- already capture the effects of outlier treatment done with build data.
03:54:09 SQL> --
03:54:09 SQL> BEGIN
03:54:09   2  	-- Xform Test data to replace missing values
03:54:09   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:09   4  	  miss_table_name => 'svmc_miss_num',
03:54:09   5  	  data_table_name => '&scoretable',
03:54:09   6  	  xform_view_name => 'xformed_apply_miss_num');
03:54:09   7  
03:54:09   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:09   9  	  miss_table_name => 'svmc_miss_cat',
03:54:09  10  	  data_table_name => '&scoretable',
03:54:09  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:54:09  12  
03:54:09  13  	-- Normalize the data to be scored
03:54:09  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:09  15  	  norm_table_name => 'svmc_norm',
03:54:09  16  	  data_table_name => '&scoretable',
03:54:09  17  	  xform_view_name => 'svmc_apply_prep');
03:54:09  18  END;
03:54:09  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:54:09 SQL> 
03:54:09 SQL> -- Maybe I already collected a score for this prdate.
03:54:09 SQL> -- DELETE it if I did:
03:54:09 SQL> DELETE svm24scores
03:54:09   2  WHERE score > 0
03:54:09   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:54:09   4  -- I need to supply the target attribute name:
03:54:09   5  AND targ = '&1'
03:54:09   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:54:09 SQL> 
03:54:09 SQL> -- We do a drumroll here:
03:54:09 SQL> 
03:54:09 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:54:09   2  SELECT
03:54:09   3  prdate
03:54:09   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:54:09   5  ,sysdate
03:54:09   6  ,SUBSTR(prdate,1,7)pair
03:54:09   7  ,SUBSTR(prdate,-19)ydate
03:54:09   8  ,'&1'
03:54:09   9  FROM svmc_apply_prep
03:54:09  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:54:09 SQL> @score1_5min.sql	      2011-01-20 06:10:00 eur_usd
03:54:09 SQL> --
03:54:09 SQL> -- score1_5min.sql
03:54:09 SQL> --
03:54:09 SQL> 
03:54:09 SQL> -- Demo:
03:54:09 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:54:09 SQL> 
03:54:09 SQL> CREATE OR REPLACE VIEW sme AS
03:54:09   2  SELECT
03:54:09   3  prdate
03:54:09   4  ,NULL gatt
03:54:09   5  ,g00
03:54:09   6  ,g01
03:54:09   7  ,g02
03:54:09   8  ,g03
03:54:09   9  ,g04
03:54:09  10  ,g05
03:54:09  11  ,g06
03:54:09  12  ,g07
03:54:09  13  ,g08
03:54:09  14  ,g09
03:54:09  15  ,g10
03:54:09  16  ,g11
03:54:09  17  ,g12
03:54:09  18  ,g13
03:54:09  19  ,g14
03:54:09  20  ,g15
03:54:09  21  ,g16
03:54:09  22  ,g17
03:54:09  23  ,g18
03:54:09  24  ,g19
03:54:09  25  ,g20
03:54:09  26  ,g21
03:54:09  27  ,g22
03:54:09  28  ,g23
03:54:09  29  ,g24
03:54:09  30  ,g25
03:54:09  31  ,g26
03:54:09  32  ,g27
03:54:09  33  ,g28
03:54:09  34  ,g29
03:54:09  35  ,g30
03:54:09  36  ,g31
03:54:09  37  ,g32
03:54:09  38  ,g33
03:54:09  39  ,g34
03:54:09  40  ,g35
03:54:09  41  ,g36
03:54:09  42  ,g37
03:54:09  43  ,g38
03:54:09  44  ,g39
03:54:09  45  ,g40
03:54:09  46  ,g41
03:54:09  47  ,s.sc_corr
03:54:09  48  FROM modsrc24
03:54:09  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:54:09  50  WHERE ydate = '&1'||' '||'&2'
03:54:09  51  AND pair = '&3'
03:54:09  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'06:10:00'AND ydate<'2011-01-20'||' '||'06:10:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'06:10:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:54:09 SQL> 
03:54:09 SQL> -- rpt
03:54:09 SQL> -- We should see just 1 row:
03:54:09 SQL> 
03:54:09 SQL> SELECT COUNT(prdate) FROM sme
03:54:09   2  
03:54:09 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:54:09   2  
03:54:09 SQL> 
03:54:09 SQL> -- Build the model:
03:54:09 SQL> CREATE OR REPLACE VIEW bme AS
03:54:09   2  SELECT
03:54:09   3  prdate
03:54:09   4  ,gatt
03:54:09   5  ,g00
03:54:09   6  ,g01
03:54:09   7  ,g02
03:54:09   8  ,g03
03:54:09   9  ,g04
03:54:09  10  ,g05
03:54:09  11  ,g06
03:54:09  12  ,g07
03:54:09  13  ,g08
03:54:09  14  ,g09
03:54:09  15  ,g10
03:54:09  16  ,g11
03:54:09  17  ,g12
03:54:09  18  ,g13
03:54:09  19  ,g14
03:54:09  20  ,g15
03:54:09  21  ,g16
03:54:09  22  ,g17
03:54:09  23  ,g18
03:54:09  24  ,g19
03:54:09  25  ,g20
03:54:09  26  ,g21
03:54:09  27  ,g22
03:54:09  28  ,g23
03:54:09  29  ,g24
03:54:09  30  ,g25
03:54:09  31  ,g26
03:54:09  32  ,g27
03:54:09  33  ,g28
03:54:09  34  ,g29
03:54:09  35  ,g30
03:54:09  36  ,g31
03:54:09  37  ,g32
03:54:09  38  ,g33
03:54:09  39  ,g34
03:54:09  40  ,g35
03:54:09  41  ,g36
03:54:09  42  ,g37
03:54:09  43  ,g38
03:54:09  44  ,g39
03:54:09  45  ,g40
03:54:09  46  ,g41
03:54:09  47  ,sc_corr
03:54:09  48  FROM modsrc24
03:54:09  49  WHERE gatt IN('nup','up')
03:54:09  50  -- Use only rows which are older than 1 day:
03:54:09  51  AND 1+ydate < '&1'||' '||'&2'
03:54:09  52  AND pair = '&3'
03:54:09  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'06:10:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:54:09 SQL> 
03:54:09 SQL> -- rpt
03:54:09 SQL> 
03:54:09 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:54:09   2  
03:54:09 SQL> SELECT MAX(prdate) FROM bme
03:54:09   2  
03:54:09 SQL> -- Now build model from bme and score sme
03:54:09 SQL> @score1.sql gatt
03:54:09 SQL> --
03:54:09 SQL> -- score1.sql
03:54:09 SQL> --
03:54:09 SQL> 
03:54:09 SQL> -- I use this script to send 5 params to score.sql
03:54:09 SQL> -- which does the heavy lifting of creating an SVM model.
03:54:09 SQL> -- Then at the very end of this script I use the model
03:54:09 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:54:09 SQL> 
03:54:09 SQL> -- I call this script from 2 other scripts:
03:54:09 SQL> -- score1_5min.sql
03:54:09 SQL> -- score1_5min_gattn.sql
03:54:09 SQL> 
03:54:09 SQL> -- The 1st param is the name of the target attribute.
03:54:09 SQL> -- I like to call my target attributes either gatt or gattn.
03:54:09 SQL> 
03:54:09 SQL> -- Demo:
03:54:09 SQL> -- @score1.sql 'gatt'
03:54:09 SQL> -- @score1.sql 'gattn'
03:54:09 SQL> 
03:54:09 SQL> -- Now, I fill up svmc_apply_prep.
03:54:09 SQL> -- I use same model_name used in score.sql
03:54:09 SQL> DEFINE model_name = 'svmfx101'
03:54:09 SQL> DEFINE bldtable	= 'bme'
03:54:09 SQL> DEFINE scoretable = 'sme'
03:54:09 SQL> DEFINE case_id	= 'prdate'
03:54:09 SQL> -- Demo:
03:54:09 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:54:09 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:54:09 SQL> --
03:54:09 SQL> -- score.sql
03:54:09 SQL> --
03:54:09 SQL> 
03:54:09 SQL> -- usage: score.sql
03:54:09 SQL> 
03:54:09 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:54:09 SQL> 
03:54:09 SQL> -- DEFINE target	   = 'gatt'
03:54:09 SQL> -- DEFINE model_name = 'svmfx101'
03:54:09 SQL> -- DEFINE bldtable   = 'bme'
03:54:09 SQL> -- DEFINE scoretable = 'sme'
03:54:09 SQL> -- DEFINE case_id    = 'prdate'
03:54:09 SQL> 
03:54:09 SQL> DEFINE target	= '&1'
03:54:09 SQL> DEFINE model_name = '&2'
03:54:09 SQL> DEFINE bldtable	= '&3'
03:54:09 SQL> DEFINE scoretable = '&4'
03:54:09 SQL> DEFINE case_id	= '&5'
03:54:09 SQL> 
03:54:09 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:54:09 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:54:09 SQL> 
03:54:09 SQL> -- Builds an SVM model using pl/sql.
03:54:09 SQL> 
03:54:09 SQL> -----------------------------------------------------------------------
03:54:09 SQL> --			    BUILD THE MODEL
03:54:09 SQL> -----------------------------------------------------------------------
03:54:09 SQL> 
03:54:09 SQL> -- Cleanup old build data preparation objects for repeat runs
03:54:09 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:09 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
03:54:09 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:09 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:54:09 SQL> 
03:54:09 SQL> 
03:54:09 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:54:09 SQL> --
03:54:09 SQL> -- DROP	TABLE svmc_settings ;
03:54:09 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:54:09 SQL> -- DELETE svmc_settings;
03:54:09 SQL> 
03:54:09 SQL> -- The default classification algorithm is Naive Bayes. So override
03:54:09 SQL> -- this choice to SVM using a settings table.
03:54:09 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:54:09 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:54:09 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:54:09 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:54:09 SQL> -- models.
03:54:09 SQL> --
03:54:09 SQL> 
03:54:09 SQL> -- Do this once and then comment it out.
03:54:09 SQL> -- That makes script go faster.
03:54:09 SQL> -- BEGIN
03:54:09 SQL> -- -- Populate settings table
03:54:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:09 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:54:09 SQL> --
03:54:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:09 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:54:09 SQL> --
03:54:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:09 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:54:09 SQL> --   COMMIT;
03:54:09 SQL> -- END;
03:54:09 SQL> -- /
03:54:09 SQL> 
03:54:09 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:54:09 SQL> 
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:09 SQL> 
03:54:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:54:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
03:54:09 SQL> 
03:54:09 SQL> --------------------------------
03:54:09 SQL> -- PREPARE BUILD (TRAINING) DATA
03:54:09 SQL> --
03:54:09 SQL> 
03:54:09 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:09 SQL> -- 2. Outlier Treatment and
03:54:09 SQL> -- 3. Normalization are performed below.
03:54:09 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:54:09 SQL> --    normalized here.
03:54:09 SQL> 
03:54:09 SQL> BEGIN
03:54:09   2  	-- Perform missing value treatment for all predictors
03:54:09   3  	-- create miss tables
03:54:09   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:54:09   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:54:09   6  
03:54:09   7  	-- populate miss tables
03:54:09   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:54:09   9  	  miss_table_name => 'svmc_miss_num',
03:54:09  10  	  data_table_name => '&bldtable',
03:54:09  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:09  12  
03:54:09  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:54:09  14  	  miss_table_name => 'svmc_miss_cat',
03:54:09  15  	  data_table_name => '&bldtable',
03:54:09  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:09  17  
03:54:09  18  	-- xform input data to replace missing values
03:54:09  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:09  20  	  miss_table_name => 'svmc_miss_num',
03:54:09  21  	  data_table_name => '&bldtable',
03:54:09  22  	  xform_view_name => 'xformed_build_miss_num');
03:54:09  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:09  24  	  miss_table_name => 'svmc_miss_cat',
03:54:09  25  	  data_table_name => '&bldtable',
03:54:09  26  	  xform_view_name => 'xformed_build_miss_cat');
03:54:09  27  
03:54:09  28  	-- Perform outlier treatment.
03:54:09  29  	-- create clip table
03:54:09  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:54:09  31  
03:54:09  32  	-- populate clip table
03:54:09  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:54:09  34  	  clip_table_name => 'svmc_clip',
03:54:09  35  	  data_table_name => '&bldtable',
03:54:09  36  	  tail_frac	  => 0.025,
03:54:09  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:09  38  
03:54:09  39  	-- xform input data to winsorized data
03:54:09  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:54:09  41  	  clip_table_name => 'svmc_clip',
03:54:09  42  	  data_table_name => '&bldtable',
03:54:09  43  	  xform_view_name => 'svmc_winsor');
03:54:09  44  
03:54:09  45  	-- create normalization table
03:54:09  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:54:09  47  
03:54:09  48  	-- populate normalization table based on winsorized data
03:54:09  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:54:09  50  	  norm_table_name => 'svmc_norm',
03:54:09  51  	  data_table_name => 'svmc_winsor',
03:54:09  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:09  53  
03:54:09  54  	-- normalize the original data
03:54:09  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:09  56  	  norm_table_name => 'svmc_norm',
03:54:09  57  	  data_table_name => '&bldtable',
03:54:09  58  	  xform_view_name => 'svmc_build_prep');
03:54:09  59  END;
03:54:09  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.71
03:54:12 SQL> 
03:54:12 SQL> ---------------------
03:54:12 SQL> -- CREATE A NEW MODEL
03:54:12 SQL> --
03:54:12 SQL> -- Cleanup old model with the same name for repeat runs
03:54:12 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:54:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:12   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.36
03:54:13 SQL> 
03:54:13 SQL> -- Build a new SVM Model
03:54:13 SQL> BEGIN
03:54:13   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:54:13   3  	  model_name	      => '&model_name',
03:54:13   4  	  mining_function     => dbms_data_mining.classification,
03:54:13   5  	  data_table_name     => 'svmc_build_prep',
03:54:13   6  	  case_id_column_name => '&case_id',
03:54:13   7  	  target_column_name  => '&target',
03:54:13   8  	  settings_table_name => 'svmc_settings');
03:54:13   9  END;
03:54:13  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.89
03:54:18 SQL> 
03:54:18 SQL> -----------------------------------------------------------------------
03:54:18 SQL> --			       APPLY/score THE MODEL
03:54:18 SQL> -----------------------------------------------------------------------
03:54:18 SQL> 
03:54:18 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:54:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:54:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:54:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:54:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:18 SQL> -----------------------
03:54:18 SQL> -- PREPARE SCORING DATA
03:54:18 SQL> --
03:54:18 SQL> -- If the data for model creation has been prepared, then the data
03:54:18 SQL> -- to be scored using the model must be prepared in the same manner
03:54:18 SQL> -- in order to obtain meaningful results.
03:54:18 SQL> --
03:54:18 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:18 SQL> -- 2. Normalization
03:54:18 SQL> -- No outlier treatment will be performed during test and apply. The
03:54:18 SQL> -- normalization step is sufficient, since the normalization parameters
03:54:18 SQL> -- already capture the effects of outlier treatment done with build data.
03:54:18 SQL> --
03:54:18 SQL> BEGIN
03:54:18   2  	-- Xform Test data to replace missing values
03:54:18   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:18   4  	  miss_table_name => 'svmc_miss_num',
03:54:18   5  	  data_table_name => '&scoretable',
03:54:18   6  	  xform_view_name => 'xformed_apply_miss_num');
03:54:18   7  
03:54:18   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:18   9  	  miss_table_name => 'svmc_miss_cat',
03:54:18  10  	  data_table_name => '&scoretable',
03:54:18  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:54:18  12  
03:54:18  13  	-- Normalize the data to be scored
03:54:18  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:18  15  	  norm_table_name => 'svmc_norm',
03:54:18  16  	  data_table_name => '&scoretable',
03:54:18  17  	  xform_view_name => 'svmc_apply_prep');
03:54:18  18  END;
03:54:18  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:54:19 SQL> 
03:54:19 SQL> -- Maybe I already collected a score for this prdate.
03:54:19 SQL> -- DELETE it if I did:
03:54:19 SQL> DELETE svm24scores
03:54:19   2  WHERE score > 0
03:54:19   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:54:19   4  -- I need to supply the target attribute name:
03:54:19   5  AND targ = '&1'
03:54:19   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:54:19 SQL> 
03:54:19 SQL> -- We do a drumroll here:
03:54:19 SQL> 
03:54:19 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:54:19   2  SELECT
03:54:19   3  prdate
03:54:19   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:54:19   5  ,sysdate
03:54:19   6  ,SUBSTR(prdate,1,7)pair
03:54:19   7  ,SUBSTR(prdate,-19)ydate
03:54:19   8  ,'&1'
03:54:19   9  FROM svmc_apply_prep
03:54:19  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:54:19 SQL> @score1_5min.sql	      2011-01-27 20:50:00 eur_usd
03:54:19 SQL> --
03:54:19 SQL> -- score1_5min.sql
03:54:19 SQL> --
03:54:19 SQL> 
03:54:19 SQL> -- Demo:
03:54:19 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:54:19 SQL> 
03:54:19 SQL> CREATE OR REPLACE VIEW sme AS
03:54:19   2  SELECT
03:54:19   3  prdate
03:54:19   4  ,NULL gatt
03:54:19   5  ,g00
03:54:19   6  ,g01
03:54:19   7  ,g02
03:54:19   8  ,g03
03:54:19   9  ,g04
03:54:19  10  ,g05
03:54:19  11  ,g06
03:54:19  12  ,g07
03:54:19  13  ,g08
03:54:19  14  ,g09
03:54:19  15  ,g10
03:54:19  16  ,g11
03:54:19  17  ,g12
03:54:19  18  ,g13
03:54:19  19  ,g14
03:54:19  20  ,g15
03:54:19  21  ,g16
03:54:19  22  ,g17
03:54:19  23  ,g18
03:54:19  24  ,g19
03:54:19  25  ,g20
03:54:19  26  ,g21
03:54:19  27  ,g22
03:54:19  28  ,g23
03:54:19  29  ,g24
03:54:19  30  ,g25
03:54:19  31  ,g26
03:54:19  32  ,g27
03:54:19  33  ,g28
03:54:19  34  ,g29
03:54:19  35  ,g30
03:54:19  36  ,g31
03:54:19  37  ,g32
03:54:19  38  ,g33
03:54:19  39  ,g34
03:54:19  40  ,g35
03:54:19  41  ,g36
03:54:19  42  ,g37
03:54:19  43  ,g38
03:54:19  44  ,g39
03:54:19  45  ,g40
03:54:19  46  ,g41
03:54:19  47  ,s.sc_corr
03:54:19  48  FROM modsrc24
03:54:19  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:54:19  50  WHERE ydate = '&1'||' '||'&2'
03:54:19  51  AND pair = '&3'
03:54:19  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'20:50:00'AND ydate<'2011-01-27'||' '||'20:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'20:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:54:19 SQL> 
03:54:19 SQL> -- rpt
03:54:19 SQL> -- We should see just 1 row:
03:54:19 SQL> 
03:54:19 SQL> SELECT COUNT(prdate) FROM sme
03:54:19   2  
03:54:19 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:54:19   2  
03:54:19 SQL> 
03:54:19 SQL> -- Build the model:
03:54:19 SQL> CREATE OR REPLACE VIEW bme AS
03:54:19   2  SELECT
03:54:19   3  prdate
03:54:19   4  ,gatt
03:54:19   5  ,g00
03:54:19   6  ,g01
03:54:19   7  ,g02
03:54:19   8  ,g03
03:54:19   9  ,g04
03:54:19  10  ,g05
03:54:19  11  ,g06
03:54:19  12  ,g07
03:54:19  13  ,g08
03:54:19  14  ,g09
03:54:19  15  ,g10
03:54:19  16  ,g11
03:54:19  17  ,g12
03:54:19  18  ,g13
03:54:19  19  ,g14
03:54:19  20  ,g15
03:54:19  21  ,g16
03:54:19  22  ,g17
03:54:19  23  ,g18
03:54:19  24  ,g19
03:54:19  25  ,g20
03:54:19  26  ,g21
03:54:19  27  ,g22
03:54:19  28  ,g23
03:54:19  29  ,g24
03:54:19  30  ,g25
03:54:19  31  ,g26
03:54:19  32  ,g27
03:54:19  33  ,g28
03:54:19  34  ,g29
03:54:19  35  ,g30
03:54:19  36  ,g31
03:54:19  37  ,g32
03:54:19  38  ,g33
03:54:19  39  ,g34
03:54:19  40  ,g35
03:54:19  41  ,g36
03:54:19  42  ,g37
03:54:19  43  ,g38
03:54:19  44  ,g39
03:54:19  45  ,g40
03:54:19  46  ,g41
03:54:19  47  ,sc_corr
03:54:19  48  FROM modsrc24
03:54:19  49  WHERE gatt IN('nup','up')
03:54:19  50  -- Use only rows which are older than 1 day:
03:54:19  51  AND 1+ydate < '&1'||' '||'&2'
03:54:19  52  AND pair = '&3'
03:54:19  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'20:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:54:19 SQL> 
03:54:19 SQL> -- rpt
03:54:19 SQL> 
03:54:19 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:54:19   2  
03:54:19 SQL> SELECT MAX(prdate) FROM bme
03:54:19   2  
03:54:19 SQL> -- Now build model from bme and score sme
03:54:19 SQL> @score1.sql gatt
03:54:19 SQL> --
03:54:19 SQL> -- score1.sql
03:54:19 SQL> --
03:54:19 SQL> 
03:54:19 SQL> -- I use this script to send 5 params to score.sql
03:54:19 SQL> -- which does the heavy lifting of creating an SVM model.
03:54:19 SQL> -- Then at the very end of this script I use the model
03:54:19 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:54:19 SQL> 
03:54:19 SQL> -- I call this script from 2 other scripts:
03:54:19 SQL> -- score1_5min.sql
03:54:19 SQL> -- score1_5min_gattn.sql
03:54:19 SQL> 
03:54:19 SQL> -- The 1st param is the name of the target attribute.
03:54:19 SQL> -- I like to call my target attributes either gatt or gattn.
03:54:19 SQL> 
03:54:19 SQL> -- Demo:
03:54:19 SQL> -- @score1.sql 'gatt'
03:54:19 SQL> -- @score1.sql 'gattn'
03:54:19 SQL> 
03:54:19 SQL> -- Now, I fill up svmc_apply_prep.
03:54:19 SQL> -- I use same model_name used in score.sql
03:54:19 SQL> DEFINE model_name = 'svmfx101'
03:54:19 SQL> DEFINE bldtable	= 'bme'
03:54:19 SQL> DEFINE scoretable = 'sme'
03:54:19 SQL> DEFINE case_id	= 'prdate'
03:54:19 SQL> -- Demo:
03:54:19 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:54:19 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:54:19 SQL> --
03:54:19 SQL> -- score.sql
03:54:19 SQL> --
03:54:19 SQL> 
03:54:19 SQL> -- usage: score.sql
03:54:19 SQL> 
03:54:19 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:54:19 SQL> 
03:54:19 SQL> -- DEFINE target	   = 'gatt'
03:54:19 SQL> -- DEFINE model_name = 'svmfx101'
03:54:19 SQL> -- DEFINE bldtable   = 'bme'
03:54:19 SQL> -- DEFINE scoretable = 'sme'
03:54:19 SQL> -- DEFINE case_id    = 'prdate'
03:54:19 SQL> 
03:54:19 SQL> DEFINE target	= '&1'
03:54:19 SQL> DEFINE model_name = '&2'
03:54:19 SQL> DEFINE bldtable	= '&3'
03:54:19 SQL> DEFINE scoretable = '&4'
03:54:19 SQL> DEFINE case_id	= '&5'
03:54:19 SQL> 
03:54:19 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:54:19 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:54:19 SQL> 
03:54:19 SQL> -- Builds an SVM model using pl/sql.
03:54:19 SQL> 
03:54:19 SQL> -----------------------------------------------------------------------
03:54:19 SQL> --			    BUILD THE MODEL
03:54:19 SQL> -----------------------------------------------------------------------
03:54:19 SQL> 
03:54:19 SQL> -- Cleanup old build data preparation objects for repeat runs
03:54:19 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:19 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:54:19 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:19 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:54:19 SQL> 
03:54:19 SQL> 
03:54:19 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:54:19 SQL> --
03:54:19 SQL> -- DROP	TABLE svmc_settings ;
03:54:19 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:54:19 SQL> -- DELETE svmc_settings;
03:54:19 SQL> 
03:54:19 SQL> -- The default classification algorithm is Naive Bayes. So override
03:54:19 SQL> -- this choice to SVM using a settings table.
03:54:19 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:54:19 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:54:19 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:54:19 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:54:19 SQL> -- models.
03:54:19 SQL> --
03:54:19 SQL> 
03:54:19 SQL> -- Do this once and then comment it out.
03:54:19 SQL> -- That makes script go faster.
03:54:19 SQL> -- BEGIN
03:54:19 SQL> -- -- Populate settings table
03:54:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:19 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:54:19 SQL> --
03:54:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:19 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:54:19 SQL> --
03:54:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:19 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:54:19 SQL> --   COMMIT;
03:54:19 SQL> -- END;
03:54:19 SQL> -- /
03:54:19 SQL> 
03:54:19 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:54:19 SQL> 
03:54:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:54:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:54:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:54:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:19 SQL> 
03:54:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:54:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:19 SQL> 
03:54:19 SQL> --------------------------------
03:54:19 SQL> -- PREPARE BUILD (TRAINING) DATA
03:54:19 SQL> --
03:54:19 SQL> 
03:54:19 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:19 SQL> -- 2. Outlier Treatment and
03:54:19 SQL> -- 3. Normalization are performed below.
03:54:19 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:54:19 SQL> --    normalized here.
03:54:19 SQL> 
03:54:19 SQL> BEGIN
03:54:19   2  	-- Perform missing value treatment for all predictors
03:54:19   3  	-- create miss tables
03:54:19   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:54:19   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:54:19   6  
03:54:19   7  	-- populate miss tables
03:54:19   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:54:19   9  	  miss_table_name => 'svmc_miss_num',
03:54:19  10  	  data_table_name => '&bldtable',
03:54:19  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:19  12  
03:54:19  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:54:19  14  	  miss_table_name => 'svmc_miss_cat',
03:54:19  15  	  data_table_name => '&bldtable',
03:54:19  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:19  17  
03:54:19  18  	-- xform input data to replace missing values
03:54:19  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:19  20  	  miss_table_name => 'svmc_miss_num',
03:54:19  21  	  data_table_name => '&bldtable',
03:54:19  22  	  xform_view_name => 'xformed_build_miss_num');
03:54:19  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:19  24  	  miss_table_name => 'svmc_miss_cat',
03:54:19  25  	  data_table_name => '&bldtable',
03:54:19  26  	  xform_view_name => 'xformed_build_miss_cat');
03:54:19  27  
03:54:19  28  	-- Perform outlier treatment.
03:54:19  29  	-- create clip table
03:54:19  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:54:19  31  
03:54:19  32  	-- populate clip table
03:54:19  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:54:19  34  	  clip_table_name => 'svmc_clip',
03:54:19  35  	  data_table_name => '&bldtable',
03:54:19  36  	  tail_frac	  => 0.025,
03:54:19  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:19  38  
03:54:19  39  	-- xform input data to winsorized data
03:54:19  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:54:19  41  	  clip_table_name => 'svmc_clip',
03:54:19  42  	  data_table_name => '&bldtable',
03:54:19  43  	  xform_view_name => 'svmc_winsor');
03:54:19  44  
03:54:19  45  	-- create normalization table
03:54:19  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:54:19  47  
03:54:19  48  	-- populate normalization table based on winsorized data
03:54:19  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:54:19  50  	  norm_table_name => 'svmc_norm',
03:54:19  51  	  data_table_name => 'svmc_winsor',
03:54:19  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:19  53  
03:54:19  54  	-- normalize the original data
03:54:19  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:19  56  	  norm_table_name => 'svmc_norm',
03:54:19  57  	  data_table_name => '&bldtable',
03:54:19  58  	  xform_view_name => 'svmc_build_prep');
03:54:19  59  END;
03:54:19  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.68
03:54:22 SQL> 
03:54:22 SQL> ---------------------
03:54:22 SQL> -- CREATE A NEW MODEL
03:54:22 SQL> --
03:54:22 SQL> -- Cleanup old model with the same name for repeat runs
03:54:22 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:54:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:22   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.57
03:54:23 SQL> 
03:54:23 SQL> -- Build a new SVM Model
03:54:23 SQL> BEGIN
03:54:23   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:54:23   3  	  model_name	      => '&model_name',
03:54:23   4  	  mining_function     => dbms_data_mining.classification,
03:54:23   5  	  data_table_name     => 'svmc_build_prep',
03:54:23   6  	  case_id_column_name => '&case_id',
03:54:23   7  	  target_column_name  => '&target',
03:54:23   8  	  settings_table_name => 'svmc_settings');
03:54:23   9  END;
03:54:23  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.50
03:54:29 SQL> 
03:54:29 SQL> -----------------------------------------------------------------------
03:54:29 SQL> --			       APPLY/score THE MODEL
03:54:29 SQL> -----------------------------------------------------------------------
03:54:29 SQL> 
03:54:29 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:29 SQL> -----------------------
03:54:29 SQL> -- PREPARE SCORING DATA
03:54:29 SQL> --
03:54:29 SQL> -- If the data for model creation has been prepared, then the data
03:54:29 SQL> -- to be scored using the model must be prepared in the same manner
03:54:29 SQL> -- in order to obtain meaningful results.
03:54:29 SQL> --
03:54:29 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:29 SQL> -- 2. Normalization
03:54:29 SQL> -- No outlier treatment will be performed during test and apply. The
03:54:29 SQL> -- normalization step is sufficient, since the normalization parameters
03:54:29 SQL> -- already capture the effects of outlier treatment done with build data.
03:54:29 SQL> --
03:54:29 SQL> BEGIN
03:54:29   2  	-- Xform Test data to replace missing values
03:54:29   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:29   4  	  miss_table_name => 'svmc_miss_num',
03:54:29   5  	  data_table_name => '&scoretable',
03:54:29   6  	  xform_view_name => 'xformed_apply_miss_num');
03:54:29   7  
03:54:29   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:29   9  	  miss_table_name => 'svmc_miss_cat',
03:54:29  10  	  data_table_name => '&scoretable',
03:54:29  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:54:29  12  
03:54:29  13  	-- Normalize the data to be scored
03:54:29  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:29  15  	  norm_table_name => 'svmc_norm',
03:54:29  16  	  data_table_name => '&scoretable',
03:54:29  17  	  xform_view_name => 'svmc_apply_prep');
03:54:29  18  END;
03:54:29  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:54:29 SQL> 
03:54:29 SQL> -- Maybe I already collected a score for this prdate.
03:54:29 SQL> -- DELETE it if I did:
03:54:29 SQL> DELETE svm24scores
03:54:29   2  WHERE score > 0
03:54:29   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:54:29   4  -- I need to supply the target attribute name:
03:54:29   5  AND targ = '&1'
03:54:29   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.03
03:54:29 SQL> 
03:54:29 SQL> -- We do a drumroll here:
03:54:29 SQL> 
03:54:29 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:54:29   2  SELECT
03:54:29   3  prdate
03:54:29   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:54:29   5  ,sysdate
03:54:29   6  ,SUBSTR(prdate,1,7)pair
03:54:29   7  ,SUBSTR(prdate,-19)ydate
03:54:29   8  ,'&1'
03:54:29   9  FROM svmc_apply_prep
03:54:29  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.07
03:54:29 SQL> @score1_5min.sql	      2011-01-20 06:20:00 eur_usd
03:54:29 SQL> --
03:54:29 SQL> -- score1_5min.sql
03:54:29 SQL> --
03:54:29 SQL> 
03:54:29 SQL> -- Demo:
03:54:29 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:54:29 SQL> 
03:54:29 SQL> CREATE OR REPLACE VIEW sme AS
03:54:29   2  SELECT
03:54:29   3  prdate
03:54:29   4  ,NULL gatt
03:54:29   5  ,g00
03:54:29   6  ,g01
03:54:29   7  ,g02
03:54:29   8  ,g03
03:54:29   9  ,g04
03:54:29  10  ,g05
03:54:29  11  ,g06
03:54:29  12  ,g07
03:54:29  13  ,g08
03:54:29  14  ,g09
03:54:29  15  ,g10
03:54:29  16  ,g11
03:54:29  17  ,g12
03:54:29  18  ,g13
03:54:29  19  ,g14
03:54:29  20  ,g15
03:54:29  21  ,g16
03:54:29  22  ,g17
03:54:29  23  ,g18
03:54:29  24  ,g19
03:54:29  25  ,g20
03:54:29  26  ,g21
03:54:29  27  ,g22
03:54:29  28  ,g23
03:54:29  29  ,g24
03:54:29  30  ,g25
03:54:29  31  ,g26
03:54:29  32  ,g27
03:54:29  33  ,g28
03:54:29  34  ,g29
03:54:29  35  ,g30
03:54:29  36  ,g31
03:54:29  37  ,g32
03:54:29  38  ,g33
03:54:29  39  ,g34
03:54:29  40  ,g35
03:54:29  41  ,g36
03:54:29  42  ,g37
03:54:29  43  ,g38
03:54:29  44  ,g39
03:54:29  45  ,g40
03:54:29  46  ,g41
03:54:29  47  ,s.sc_corr
03:54:29  48  FROM modsrc24
03:54:29  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:54:29  50  WHERE ydate = '&1'||' '||'&2'
03:54:29  51  AND pair = '&3'
03:54:29  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'06:20:00'AND ydate<'2011-01-20'||' '||'06:20:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'06:20:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:54:29 SQL> 
03:54:29 SQL> -- rpt
03:54:29 SQL> -- We should see just 1 row:
03:54:29 SQL> 
03:54:29 SQL> SELECT COUNT(prdate) FROM sme
03:54:29   2  
03:54:29 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:54:29   2  
03:54:29 SQL> 
03:54:29 SQL> -- Build the model:
03:54:29 SQL> CREATE OR REPLACE VIEW bme AS
03:54:29   2  SELECT
03:54:29   3  prdate
03:54:29   4  ,gatt
03:54:29   5  ,g00
03:54:29   6  ,g01
03:54:29   7  ,g02
03:54:29   8  ,g03
03:54:29   9  ,g04
03:54:29  10  ,g05
03:54:29  11  ,g06
03:54:29  12  ,g07
03:54:29  13  ,g08
03:54:29  14  ,g09
03:54:29  15  ,g10
03:54:29  16  ,g11
03:54:29  17  ,g12
03:54:29  18  ,g13
03:54:29  19  ,g14
03:54:29  20  ,g15
03:54:29  21  ,g16
03:54:29  22  ,g17
03:54:29  23  ,g18
03:54:29  24  ,g19
03:54:29  25  ,g20
03:54:29  26  ,g21
03:54:29  27  ,g22
03:54:29  28  ,g23
03:54:29  29  ,g24
03:54:29  30  ,g25
03:54:29  31  ,g26
03:54:29  32  ,g27
03:54:29  33  ,g28
03:54:29  34  ,g29
03:54:29  35  ,g30
03:54:29  36  ,g31
03:54:29  37  ,g32
03:54:29  38  ,g33
03:54:29  39  ,g34
03:54:29  40  ,g35
03:54:29  41  ,g36
03:54:29  42  ,g37
03:54:29  43  ,g38
03:54:29  44  ,g39
03:54:29  45  ,g40
03:54:29  46  ,g41
03:54:29  47  ,sc_corr
03:54:29  48  FROM modsrc24
03:54:29  49  WHERE gatt IN('nup','up')
03:54:29  50  -- Use only rows which are older than 1 day:
03:54:29  51  AND 1+ydate < '&1'||' '||'&2'
03:54:29  52  AND pair = '&3'
03:54:29  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'06:20:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:54:29 SQL> 
03:54:29 SQL> -- rpt
03:54:29 SQL> 
03:54:29 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:54:29   2  
03:54:29 SQL> SELECT MAX(prdate) FROM bme
03:54:29   2  
03:54:29 SQL> -- Now build model from bme and score sme
03:54:29 SQL> @score1.sql gatt
03:54:29 SQL> --
03:54:29 SQL> -- score1.sql
03:54:29 SQL> --
03:54:29 SQL> 
03:54:29 SQL> -- I use this script to send 5 params to score.sql
03:54:29 SQL> -- which does the heavy lifting of creating an SVM model.
03:54:29 SQL> -- Then at the very end of this script I use the model
03:54:29 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:54:29 SQL> 
03:54:29 SQL> -- I call this script from 2 other scripts:
03:54:29 SQL> -- score1_5min.sql
03:54:29 SQL> -- score1_5min_gattn.sql
03:54:29 SQL> 
03:54:29 SQL> -- The 1st param is the name of the target attribute.
03:54:29 SQL> -- I like to call my target attributes either gatt or gattn.
03:54:29 SQL> 
03:54:29 SQL> -- Demo:
03:54:29 SQL> -- @score1.sql 'gatt'
03:54:29 SQL> -- @score1.sql 'gattn'
03:54:29 SQL> 
03:54:29 SQL> -- Now, I fill up svmc_apply_prep.
03:54:29 SQL> -- I use same model_name used in score.sql
03:54:29 SQL> DEFINE model_name = 'svmfx101'
03:54:29 SQL> DEFINE bldtable	= 'bme'
03:54:29 SQL> DEFINE scoretable = 'sme'
03:54:29 SQL> DEFINE case_id	= 'prdate'
03:54:29 SQL> -- Demo:
03:54:29 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:54:29 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:54:29 SQL> --
03:54:29 SQL> -- score.sql
03:54:29 SQL> --
03:54:29 SQL> 
03:54:29 SQL> -- usage: score.sql
03:54:29 SQL> 
03:54:29 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:54:29 SQL> 
03:54:29 SQL> -- DEFINE target	   = 'gatt'
03:54:29 SQL> -- DEFINE model_name = 'svmfx101'
03:54:29 SQL> -- DEFINE bldtable   = 'bme'
03:54:29 SQL> -- DEFINE scoretable = 'sme'
03:54:29 SQL> -- DEFINE case_id    = 'prdate'
03:54:29 SQL> 
03:54:29 SQL> DEFINE target	= '&1'
03:54:29 SQL> DEFINE model_name = '&2'
03:54:29 SQL> DEFINE bldtable	= '&3'
03:54:29 SQL> DEFINE scoretable = '&4'
03:54:29 SQL> DEFINE case_id	= '&5'
03:54:29 SQL> 
03:54:29 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:54:29 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:54:29 SQL> 
03:54:29 SQL> -- Builds an SVM model using pl/sql.
03:54:29 SQL> 
03:54:29 SQL> -----------------------------------------------------------------------
03:54:29 SQL> --			    BUILD THE MODEL
03:54:29 SQL> -----------------------------------------------------------------------
03:54:29 SQL> 
03:54:29 SQL> -- Cleanup old build data preparation objects for repeat runs
03:54:29 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:29 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:54:29 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:54:29 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:54:29 SQL> 
03:54:29 SQL> 
03:54:29 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:54:29 SQL> --
03:54:29 SQL> -- DROP	TABLE svmc_settings ;
03:54:29 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:54:29 SQL> -- DELETE svmc_settings;
03:54:29 SQL> 
03:54:29 SQL> -- The default classification algorithm is Naive Bayes. So override
03:54:29 SQL> -- this choice to SVM using a settings table.
03:54:29 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:54:29 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:54:29 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:54:29 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:54:29 SQL> -- models.
03:54:29 SQL> --
03:54:29 SQL> 
03:54:29 SQL> -- Do this once and then comment it out.
03:54:29 SQL> -- That makes script go faster.
03:54:29 SQL> -- BEGIN
03:54:29 SQL> -- -- Populate settings table
03:54:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:29 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:54:29 SQL> --
03:54:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:29 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:54:29 SQL> --
03:54:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:29 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:54:29 SQL> --   COMMIT;
03:54:29 SQL> -- END;
03:54:29 SQL> -- /
03:54:29 SQL> 
03:54:29 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:54:29 SQL> 
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:29 SQL> 
03:54:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:54:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:29 SQL> 
03:54:29 SQL> --------------------------------
03:54:29 SQL> -- PREPARE BUILD (TRAINING) DATA
03:54:29 SQL> --
03:54:29 SQL> 
03:54:29 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:29 SQL> -- 2. Outlier Treatment and
03:54:29 SQL> -- 3. Normalization are performed below.
03:54:29 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:54:29 SQL> --    normalized here.
03:54:29 SQL> 
03:54:29 SQL> BEGIN
03:54:29   2  	-- Perform missing value treatment for all predictors
03:54:29   3  	-- create miss tables
03:54:29   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:54:29   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:54:29   6  
03:54:29   7  	-- populate miss tables
03:54:29   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:54:29   9  	  miss_table_name => 'svmc_miss_num',
03:54:29  10  	  data_table_name => '&bldtable',
03:54:29  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:29  12  
03:54:29  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:54:29  14  	  miss_table_name => 'svmc_miss_cat',
03:54:29  15  	  data_table_name => '&bldtable',
03:54:29  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:29  17  
03:54:29  18  	-- xform input data to replace missing values
03:54:29  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:29  20  	  miss_table_name => 'svmc_miss_num',
03:54:29  21  	  data_table_name => '&bldtable',
03:54:29  22  	  xform_view_name => 'xformed_build_miss_num');
03:54:29  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:29  24  	  miss_table_name => 'svmc_miss_cat',
03:54:29  25  	  data_table_name => '&bldtable',
03:54:29  26  	  xform_view_name => 'xformed_build_miss_cat');
03:54:29  27  
03:54:29  28  	-- Perform outlier treatment.
03:54:29  29  	-- create clip table
03:54:29  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:54:29  31  
03:54:29  32  	-- populate clip table
03:54:29  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:54:29  34  	  clip_table_name => 'svmc_clip',
03:54:29  35  	  data_table_name => '&bldtable',
03:54:29  36  	  tail_frac	  => 0.025,
03:54:29  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:29  38  
03:54:29  39  	-- xform input data to winsorized data
03:54:29  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:54:29  41  	  clip_table_name => 'svmc_clip',
03:54:29  42  	  data_table_name => '&bldtable',
03:54:29  43  	  xform_view_name => 'svmc_winsor');
03:54:29  44  
03:54:29  45  	-- create normalization table
03:54:29  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:54:29  47  
03:54:29  48  	-- populate normalization table based on winsorized data
03:54:29  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:54:29  50  	  norm_table_name => 'svmc_norm',
03:54:29  51  	  data_table_name => 'svmc_winsor',
03:54:29  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:29  53  
03:54:29  54  	-- normalize the original data
03:54:29  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:29  56  	  norm_table_name => 'svmc_norm',
03:54:29  57  	  data_table_name => '&bldtable',
03:54:29  58  	  xform_view_name => 'svmc_build_prep');
03:54:29  59  END;
03:54:29  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.53
03:54:32 SQL> 
03:54:32 SQL> ---------------------
03:54:32 SQL> -- CREATE A NEW MODEL
03:54:32 SQL> --
03:54:32 SQL> -- Cleanup old model with the same name for repeat runs
03:54:32 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:54:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:32   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.43
03:54:33 SQL> 
03:54:33 SQL> -- Build a new SVM Model
03:54:33 SQL> BEGIN
03:54:33   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:54:33   3  	  model_name	      => '&model_name',
03:54:33   4  	  mining_function     => dbms_data_mining.classification,
03:54:33   5  	  data_table_name     => 'svmc_build_prep',
03:54:33   6  	  case_id_column_name => '&case_id',
03:54:33   7  	  target_column_name  => '&target',
03:54:33   8  	  settings_table_name => 'svmc_settings');
03:54:33   9  END;
03:54:33  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.26
03:54:37 SQL> 
03:54:37 SQL> -----------------------------------------------------------------------
03:54:37 SQL> --			       APPLY/score THE MODEL
03:54:37 SQL> -----------------------------------------------------------------------
03:54:37 SQL> 
03:54:37 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:54:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:54:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:54:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:54:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:38 SQL> -----------------------
03:54:38 SQL> -- PREPARE SCORING DATA
03:54:38 SQL> --
03:54:38 SQL> -- If the data for model creation has been prepared, then the data
03:54:38 SQL> -- to be scored using the model must be prepared in the same manner
03:54:38 SQL> -- in order to obtain meaningful results.
03:54:38 SQL> --
03:54:38 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:38 SQL> -- 2. Normalization
03:54:38 SQL> -- No outlier treatment will be performed during test and apply. The
03:54:38 SQL> -- normalization step is sufficient, since the normalization parameters
03:54:38 SQL> -- already capture the effects of outlier treatment done with build data.
03:54:38 SQL> --
03:54:38 SQL> BEGIN
03:54:38   2  	-- Xform Test data to replace missing values
03:54:38   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:38   4  	  miss_table_name => 'svmc_miss_num',
03:54:38   5  	  data_table_name => '&scoretable',
03:54:38   6  	  xform_view_name => 'xformed_apply_miss_num');
03:54:38   7  
03:54:38   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:38   9  	  miss_table_name => 'svmc_miss_cat',
03:54:38  10  	  data_table_name => '&scoretable',
03:54:38  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:54:38  12  
03:54:38  13  	-- Normalize the data to be scored
03:54:38  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:38  15  	  norm_table_name => 'svmc_norm',
03:54:38  16  	  data_table_name => '&scoretable',
03:54:38  17  	  xform_view_name => 'svmc_apply_prep');
03:54:38  18  END;
03:54:38  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:54:38 SQL> 
03:54:38 SQL> -- Maybe I already collected a score for this prdate.
03:54:38 SQL> -- DELETE it if I did:
03:54:38 SQL> DELETE svm24scores
03:54:38   2  WHERE score > 0
03:54:38   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:54:38   4  -- I need to supply the target attribute name:
03:54:38   5  AND targ = '&1'
03:54:38   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:54:38 SQL> 
03:54:38 SQL> -- We do a drumroll here:
03:54:38 SQL> 
03:54:38 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:54:38   2  SELECT
03:54:38   3  prdate
03:54:38   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:54:38   5  ,sysdate
03:54:38   6  ,SUBSTR(prdate,1,7)pair
03:54:38   7  ,SUBSTR(prdate,-19)ydate
03:54:38   8  ,'&1'
03:54:38   9  FROM svmc_apply_prep
03:54:38  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:54:38 SQL> @score1_5min_gattn.sql	2011-01-21 08:45:00 eur_usd
03:54:38 SQL> --
03:54:38 SQL> -- score1_5min_gattn.sql
03:54:38 SQL> --
03:54:38 SQL> 
03:54:38 SQL> -- Demo:
03:54:38 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:54:38 SQL> 
03:54:38 SQL> CREATE OR REPLACE VIEW sme AS
03:54:38   2  SELECT
03:54:38   3  prdate
03:54:38   4  ,NULL gattn
03:54:38   5  ,g00
03:54:38   6  ,g01
03:54:38   7  ,g02
03:54:38   8  ,g03
03:54:38   9  ,g04
03:54:38  10  ,g05
03:54:38  11  ,g06
03:54:38  12  ,g07
03:54:38  13  ,g08
03:54:38  14  ,g09
03:54:38  15  ,g10
03:54:38  16  ,g11
03:54:38  17  ,g12
03:54:38  18  ,g13
03:54:38  19  ,g14
03:54:38  20  ,g15
03:54:38  21  ,g16
03:54:38  22  ,g17
03:54:38  23  ,g18
03:54:38  24  ,g19
03:54:38  25  ,g20
03:54:38  26  ,g21
03:54:38  27  ,g22
03:54:38  28  ,g23
03:54:38  29  ,g24
03:54:38  30  ,g25
03:54:38  31  ,g26
03:54:38  32  ,g27
03:54:38  33  ,g28
03:54:38  34  ,g29
03:54:38  35  ,g30
03:54:38  36  ,g31
03:54:38  37  ,g32
03:54:38  38  ,g33
03:54:38  39  ,g34
03:54:38  40  ,g35
03:54:38  41  ,g36
03:54:38  42  ,g37
03:54:38  43  ,g38
03:54:38  44  ,g39
03:54:38  45  ,g40
03:54:38  46  ,g41
03:54:38  47  ,s.sc_corr
03:54:38  48  FROM modsrc24
03:54:38  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:54:38  50  WHERE ydate = '&1'||' '||'&2'
03:54:38  51  AND pair = '&3'
03:54:38  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'08:45:00'AND ydate<'2011-01-21'||' '||'08:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'08:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:54:38 SQL> 
03:54:38 SQL> -- rpt
03:54:38 SQL> -- We should see just 1 row:
03:54:38 SQL> 
03:54:38 SQL> SELECT COUNT(prdate) FROM sme
03:54:38   2  
03:54:38 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:54:38   2  
03:54:38 SQL> 
03:54:38 SQL> -- Build the model:
03:54:38 SQL> CREATE OR REPLACE VIEW bme AS
03:54:38   2  SELECT
03:54:38   3  prdate
03:54:38   4  ,gattn
03:54:38   5  ,g00
03:54:38   6  ,g01
03:54:38   7  ,g02
03:54:38   8  ,g03
03:54:38   9  ,g04
03:54:38  10  ,g05
03:54:38  11  ,g06
03:54:38  12  ,g07
03:54:38  13  ,g08
03:54:38  14  ,g09
03:54:38  15  ,g10
03:54:38  16  ,g11
03:54:38  17  ,g12
03:54:38  18  ,g13
03:54:38  19  ,g14
03:54:38  20  ,g15
03:54:38  21  ,g16
03:54:38  22  ,g17
03:54:38  23  ,g18
03:54:38  24  ,g19
03:54:38  25  ,g20
03:54:38  26  ,g21
03:54:38  27  ,g22
03:54:38  28  ,g23
03:54:38  29  ,g24
03:54:38  30  ,g25
03:54:38  31  ,g26
03:54:38  32  ,g27
03:54:38  33  ,g28
03:54:38  34  ,g29
03:54:38  35  ,g30
03:54:38  36  ,g31
03:54:38  37  ,g32
03:54:38  38  ,g33
03:54:38  39  ,g34
03:54:38  40  ,g35
03:54:38  41  ,g36
03:54:38  42  ,g37
03:54:38  43  ,g38
03:54:38  44  ,g39
03:54:38  45  ,g40
03:54:38  46  ,g41
03:54:38  47  ,sc_corr
03:54:38  48  FROM modsrc24
03:54:38  49  WHERE gattn IN('nup','up')
03:54:38  50  -- Use only rows which are older than 1 day:
03:54:38  51  AND 1+ydate < '&1'||' '||'&2'
03:54:38  52  AND pair = '&3'
03:54:38  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'08:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:54:38 SQL> 
03:54:38 SQL> -- rpt
03:54:38 SQL> 
03:54:38 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:54:38   2  
03:54:38 SQL> SELECT MAX(prdate) FROM bme
03:54:38   2  
03:54:38 SQL> -- Now build model from bme and score sme
03:54:38 SQL> @score1.sql gattn
03:54:38 SQL> --
03:54:38 SQL> -- score1.sql
03:54:38 SQL> --
03:54:38 SQL> 
03:54:38 SQL> -- I use this script to send 5 params to score.sql
03:54:38 SQL> -- which does the heavy lifting of creating an SVM model.
03:54:38 SQL> -- Then at the very end of this script I use the model
03:54:38 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:54:38 SQL> 
03:54:38 SQL> -- I call this script from 2 other scripts:
03:54:38 SQL> -- score1_5min.sql
03:54:38 SQL> -- score1_5min_gattn.sql
03:54:38 SQL> 
03:54:38 SQL> -- The 1st param is the name of the target attribute.
03:54:38 SQL> -- I like to call my target attributes either gatt or gattn.
03:54:38 SQL> 
03:54:38 SQL> -- Demo:
03:54:38 SQL> -- @score1.sql 'gatt'
03:54:38 SQL> -- @score1.sql 'gattn'
03:54:38 SQL> 
03:54:38 SQL> -- Now, I fill up svmc_apply_prep.
03:54:38 SQL> -- I use same model_name used in score.sql
03:54:38 SQL> DEFINE model_name = 'svmfx101'
03:54:38 SQL> DEFINE bldtable	= 'bme'
03:54:38 SQL> DEFINE scoretable = 'sme'
03:54:38 SQL> DEFINE case_id	= 'prdate'
03:54:38 SQL> -- Demo:
03:54:38 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:54:38 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:54:38 SQL> --
03:54:38 SQL> -- score.sql
03:54:38 SQL> --
03:54:38 SQL> 
03:54:38 SQL> -- usage: score.sql
03:54:38 SQL> 
03:54:38 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:54:38 SQL> 
03:54:38 SQL> -- DEFINE target	   = 'gatt'
03:54:38 SQL> -- DEFINE model_name = 'svmfx101'
03:54:38 SQL> -- DEFINE bldtable   = 'bme'
03:54:38 SQL> -- DEFINE scoretable = 'sme'
03:54:38 SQL> -- DEFINE case_id    = 'prdate'
03:54:38 SQL> 
03:54:38 SQL> DEFINE target	= '&1'
03:54:38 SQL> DEFINE model_name = '&2'
03:54:38 SQL> DEFINE bldtable	= '&3'
03:54:38 SQL> DEFINE scoretable = '&4'
03:54:38 SQL> DEFINE case_id	= '&5'
03:54:38 SQL> 
03:54:38 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:54:38 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:54:38 SQL> 
03:54:38 SQL> -- Builds an SVM model using pl/sql.
03:54:38 SQL> 
03:54:38 SQL> -----------------------------------------------------------------------
03:54:38 SQL> --			    BUILD THE MODEL
03:54:38 SQL> -----------------------------------------------------------------------
03:54:38 SQL> 
03:54:38 SQL> -- Cleanup old build data preparation objects for repeat runs
03:54:38 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:38 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:54:38 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:38 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:54:38 SQL> 
03:54:38 SQL> 
03:54:38 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:54:38 SQL> --
03:54:38 SQL> -- DROP	TABLE svmc_settings ;
03:54:38 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:54:38 SQL> -- DELETE svmc_settings;
03:54:38 SQL> 
03:54:38 SQL> -- The default classification algorithm is Naive Bayes. So override
03:54:38 SQL> -- this choice to SVM using a settings table.
03:54:38 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:54:38 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:54:38 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:54:38 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:54:38 SQL> -- models.
03:54:38 SQL> --
03:54:38 SQL> 
03:54:38 SQL> -- Do this once and then comment it out.
03:54:38 SQL> -- That makes script go faster.
03:54:38 SQL> -- BEGIN
03:54:38 SQL> -- -- Populate settings table
03:54:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:38 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:54:38 SQL> --
03:54:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:38 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:54:38 SQL> --
03:54:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:38 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:54:38 SQL> --   COMMIT;
03:54:38 SQL> -- END;
03:54:38 SQL> -- /
03:54:38 SQL> 
03:54:38 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:54:38 SQL> 
03:54:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:54:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:54:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:54:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:38 SQL> 
03:54:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:54:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:38 SQL> 
03:54:38 SQL> --------------------------------
03:54:38 SQL> -- PREPARE BUILD (TRAINING) DATA
03:54:38 SQL> --
03:54:38 SQL> 
03:54:38 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:38 SQL> -- 2. Outlier Treatment and
03:54:38 SQL> -- 3. Normalization are performed below.
03:54:38 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:54:38 SQL> --    normalized here.
03:54:38 SQL> 
03:54:38 SQL> BEGIN
03:54:38   2  	-- Perform missing value treatment for all predictors
03:54:38   3  	-- create miss tables
03:54:38   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:54:38   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:54:38   6  
03:54:38   7  	-- populate miss tables
03:54:38   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:54:38   9  	  miss_table_name => 'svmc_miss_num',
03:54:38  10  	  data_table_name => '&bldtable',
03:54:38  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:38  12  
03:54:38  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:54:38  14  	  miss_table_name => 'svmc_miss_cat',
03:54:38  15  	  data_table_name => '&bldtable',
03:54:38  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:38  17  
03:54:38  18  	-- xform input data to replace missing values
03:54:38  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:38  20  	  miss_table_name => 'svmc_miss_num',
03:54:38  21  	  data_table_name => '&bldtable',
03:54:38  22  	  xform_view_name => 'xformed_build_miss_num');
03:54:38  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:38  24  	  miss_table_name => 'svmc_miss_cat',
03:54:38  25  	  data_table_name => '&bldtable',
03:54:38  26  	  xform_view_name => 'xformed_build_miss_cat');
03:54:38  27  
03:54:38  28  	-- Perform outlier treatment.
03:54:38  29  	-- create clip table
03:54:38  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:54:38  31  
03:54:38  32  	-- populate clip table
03:54:38  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:54:38  34  	  clip_table_name => 'svmc_clip',
03:54:38  35  	  data_table_name => '&bldtable',
03:54:38  36  	  tail_frac	  => 0.025,
03:54:38  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:38  38  
03:54:38  39  	-- xform input data to winsorized data
03:54:38  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:54:38  41  	  clip_table_name => 'svmc_clip',
03:54:38  42  	  data_table_name => '&bldtable',
03:54:38  43  	  xform_view_name => 'svmc_winsor');
03:54:38  44  
03:54:38  45  	-- create normalization table
03:54:38  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:54:38  47  
03:54:38  48  	-- populate normalization table based on winsorized data
03:54:38  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:54:38  50  	  norm_table_name => 'svmc_norm',
03:54:38  51  	  data_table_name => 'svmc_winsor',
03:54:38  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:38  53  
03:54:38  54  	-- normalize the original data
03:54:38  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:38  56  	  norm_table_name => 'svmc_norm',
03:54:38  57  	  data_table_name => '&bldtable',
03:54:38  58  	  xform_view_name => 'svmc_build_prep');
03:54:38  59  END;
03:54:38  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.60
03:54:41 SQL> 
03:54:41 SQL> ---------------------
03:54:41 SQL> -- CREATE A NEW MODEL
03:54:41 SQL> --
03:54:41 SQL> -- Cleanup old model with the same name for repeat runs
03:54:41 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:54:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:41   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.41
03:54:42 SQL> 
03:54:42 SQL> -- Build a new SVM Model
03:54:42 SQL> BEGIN
03:54:42   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:54:42   3  	  model_name	      => '&model_name',
03:54:42   4  	  mining_function     => dbms_data_mining.classification,
03:54:42   5  	  data_table_name     => 'svmc_build_prep',
03:54:42   6  	  case_id_column_name => '&case_id',
03:54:42   7  	  target_column_name  => '&target',
03:54:42   8  	  settings_table_name => 'svmc_settings');
03:54:42   9  END;
03:54:42  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.57
03:54:49 SQL> 
03:54:49 SQL> -----------------------------------------------------------------------
03:54:49 SQL> --			       APPLY/score THE MODEL
03:54:49 SQL> -----------------------------------------------------------------------
03:54:49 SQL> 
03:54:49 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:49 SQL> -----------------------
03:54:49 SQL> -- PREPARE SCORING DATA
03:54:49 SQL> --
03:54:49 SQL> -- If the data for model creation has been prepared, then the data
03:54:49 SQL> -- to be scored using the model must be prepared in the same manner
03:54:49 SQL> -- in order to obtain meaningful results.
03:54:49 SQL> --
03:54:49 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:49 SQL> -- 2. Normalization
03:54:49 SQL> -- No outlier treatment will be performed during test and apply. The
03:54:49 SQL> -- normalization step is sufficient, since the normalization parameters
03:54:49 SQL> -- already capture the effects of outlier treatment done with build data.
03:54:49 SQL> --
03:54:49 SQL> BEGIN
03:54:49   2  	-- Xform Test data to replace missing values
03:54:49   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:49   4  	  miss_table_name => 'svmc_miss_num',
03:54:49   5  	  data_table_name => '&scoretable',
03:54:49   6  	  xform_view_name => 'xformed_apply_miss_num');
03:54:49   7  
03:54:49   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:49   9  	  miss_table_name => 'svmc_miss_cat',
03:54:49  10  	  data_table_name => '&scoretable',
03:54:49  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:54:49  12  
03:54:49  13  	-- Normalize the data to be scored
03:54:49  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:49  15  	  norm_table_name => 'svmc_norm',
03:54:49  16  	  data_table_name => '&scoretable',
03:54:49  17  	  xform_view_name => 'svmc_apply_prep');
03:54:49  18  END;
03:54:49  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:54:49 SQL> 
03:54:49 SQL> -- Maybe I already collected a score for this prdate.
03:54:49 SQL> -- DELETE it if I did:
03:54:49 SQL> DELETE svm24scores
03:54:49   2  WHERE score > 0
03:54:49   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:54:49   4  -- I need to supply the target attribute name:
03:54:49   5  AND targ = '&1'
03:54:49   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:54:49 SQL> 
03:54:49 SQL> -- We do a drumroll here:
03:54:49 SQL> 
03:54:49 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:54:49   2  SELECT
03:54:49   3  prdate
03:54:49   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:54:49   5  ,sysdate
03:54:49   6  ,SUBSTR(prdate,1,7)pair
03:54:49   7  ,SUBSTR(prdate,-19)ydate
03:54:49   8  ,'&1'
03:54:49   9  FROM svmc_apply_prep
03:54:49  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:54:49 SQL> @score1_5min_gattn.sql	2011-01-19 15:00:00 eur_usd
03:54:49 SQL> --
03:54:49 SQL> -- score1_5min_gattn.sql
03:54:49 SQL> --
03:54:49 SQL> 
03:54:49 SQL> -- Demo:
03:54:49 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:54:49 SQL> 
03:54:49 SQL> CREATE OR REPLACE VIEW sme AS
03:54:49   2  SELECT
03:54:49   3  prdate
03:54:49   4  ,NULL gattn
03:54:49   5  ,g00
03:54:49   6  ,g01
03:54:49   7  ,g02
03:54:49   8  ,g03
03:54:49   9  ,g04
03:54:49  10  ,g05
03:54:49  11  ,g06
03:54:49  12  ,g07
03:54:49  13  ,g08
03:54:49  14  ,g09
03:54:49  15  ,g10
03:54:49  16  ,g11
03:54:49  17  ,g12
03:54:49  18  ,g13
03:54:49  19  ,g14
03:54:49  20  ,g15
03:54:49  21  ,g16
03:54:49  22  ,g17
03:54:49  23  ,g18
03:54:49  24  ,g19
03:54:49  25  ,g20
03:54:49  26  ,g21
03:54:49  27  ,g22
03:54:49  28  ,g23
03:54:49  29  ,g24
03:54:49  30  ,g25
03:54:49  31  ,g26
03:54:49  32  ,g27
03:54:49  33  ,g28
03:54:49  34  ,g29
03:54:49  35  ,g30
03:54:49  36  ,g31
03:54:49  37  ,g32
03:54:49  38  ,g33
03:54:49  39  ,g34
03:54:49  40  ,g35
03:54:49  41  ,g36
03:54:49  42  ,g37
03:54:49  43  ,g38
03:54:49  44  ,g39
03:54:49  45  ,g40
03:54:49  46  ,g41
03:54:49  47  ,s.sc_corr
03:54:49  48  FROM modsrc24
03:54:49  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:54:49  50  WHERE ydate = '&1'||' '||'&2'
03:54:49  51  AND pair = '&3'
03:54:49  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'15:00:00'AND ydate<'2011-01-19'||' '||'15:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'15:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:54:49 SQL> 
03:54:49 SQL> -- rpt
03:54:49 SQL> -- We should see just 1 row:
03:54:49 SQL> 
03:54:49 SQL> SELECT COUNT(prdate) FROM sme
03:54:49   2  
03:54:49 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:54:49   2  
03:54:49 SQL> 
03:54:49 SQL> -- Build the model:
03:54:49 SQL> CREATE OR REPLACE VIEW bme AS
03:54:49   2  SELECT
03:54:49   3  prdate
03:54:49   4  ,gattn
03:54:49   5  ,g00
03:54:49   6  ,g01
03:54:49   7  ,g02
03:54:49   8  ,g03
03:54:49   9  ,g04
03:54:49  10  ,g05
03:54:49  11  ,g06
03:54:49  12  ,g07
03:54:49  13  ,g08
03:54:49  14  ,g09
03:54:49  15  ,g10
03:54:49  16  ,g11
03:54:49  17  ,g12
03:54:49  18  ,g13
03:54:49  19  ,g14
03:54:49  20  ,g15
03:54:49  21  ,g16
03:54:49  22  ,g17
03:54:49  23  ,g18
03:54:49  24  ,g19
03:54:49  25  ,g20
03:54:49  26  ,g21
03:54:49  27  ,g22
03:54:49  28  ,g23
03:54:49  29  ,g24
03:54:49  30  ,g25
03:54:49  31  ,g26
03:54:49  32  ,g27
03:54:49  33  ,g28
03:54:49  34  ,g29
03:54:49  35  ,g30
03:54:49  36  ,g31
03:54:49  37  ,g32
03:54:49  38  ,g33
03:54:49  39  ,g34
03:54:49  40  ,g35
03:54:49  41  ,g36
03:54:49  42  ,g37
03:54:49  43  ,g38
03:54:49  44  ,g39
03:54:49  45  ,g40
03:54:49  46  ,g41
03:54:49  47  ,sc_corr
03:54:49  48  FROM modsrc24
03:54:49  49  WHERE gattn IN('nup','up')
03:54:49  50  -- Use only rows which are older than 1 day:
03:54:49  51  AND 1+ydate < '&1'||' '||'&2'
03:54:49  52  AND pair = '&3'
03:54:49  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'15:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:54:49 SQL> 
03:54:49 SQL> -- rpt
03:54:49 SQL> 
03:54:49 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:54:49   2  
03:54:49 SQL> SELECT MAX(prdate) FROM bme
03:54:49   2  
03:54:49 SQL> -- Now build model from bme and score sme
03:54:49 SQL> @score1.sql gattn
03:54:49 SQL> --
03:54:49 SQL> -- score1.sql
03:54:49 SQL> --
03:54:49 SQL> 
03:54:49 SQL> -- I use this script to send 5 params to score.sql
03:54:49 SQL> -- which does the heavy lifting of creating an SVM model.
03:54:49 SQL> -- Then at the very end of this script I use the model
03:54:49 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:54:49 SQL> 
03:54:49 SQL> -- I call this script from 2 other scripts:
03:54:49 SQL> -- score1_5min.sql
03:54:49 SQL> -- score1_5min_gattn.sql
03:54:49 SQL> 
03:54:49 SQL> -- The 1st param is the name of the target attribute.
03:54:49 SQL> -- I like to call my target attributes either gatt or gattn.
03:54:49 SQL> 
03:54:49 SQL> -- Demo:
03:54:49 SQL> -- @score1.sql 'gatt'
03:54:49 SQL> -- @score1.sql 'gattn'
03:54:49 SQL> 
03:54:49 SQL> -- Now, I fill up svmc_apply_prep.
03:54:49 SQL> -- I use same model_name used in score.sql
03:54:49 SQL> DEFINE model_name = 'svmfx101'
03:54:49 SQL> DEFINE bldtable	= 'bme'
03:54:49 SQL> DEFINE scoretable = 'sme'
03:54:49 SQL> DEFINE case_id	= 'prdate'
03:54:49 SQL> -- Demo:
03:54:49 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:54:49 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:54:49 SQL> --
03:54:49 SQL> -- score.sql
03:54:49 SQL> --
03:54:49 SQL> 
03:54:49 SQL> -- usage: score.sql
03:54:49 SQL> 
03:54:49 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:54:49 SQL> 
03:54:49 SQL> -- DEFINE target	   = 'gatt'
03:54:49 SQL> -- DEFINE model_name = 'svmfx101'
03:54:49 SQL> -- DEFINE bldtable   = 'bme'
03:54:49 SQL> -- DEFINE scoretable = 'sme'
03:54:49 SQL> -- DEFINE case_id    = 'prdate'
03:54:49 SQL> 
03:54:49 SQL> DEFINE target	= '&1'
03:54:49 SQL> DEFINE model_name = '&2'
03:54:49 SQL> DEFINE bldtable	= '&3'
03:54:49 SQL> DEFINE scoretable = '&4'
03:54:49 SQL> DEFINE case_id	= '&5'
03:54:49 SQL> 
03:54:49 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:54:49 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:54:49 SQL> 
03:54:49 SQL> -- Builds an SVM model using pl/sql.
03:54:49 SQL> 
03:54:49 SQL> -----------------------------------------------------------------------
03:54:49 SQL> --			    BUILD THE MODEL
03:54:49 SQL> -----------------------------------------------------------------------
03:54:49 SQL> 
03:54:49 SQL> -- Cleanup old build data preparation objects for repeat runs
03:54:49 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:49 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:54:49 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:49 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:54:49 SQL> 
03:54:49 SQL> 
03:54:49 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:54:49 SQL> --
03:54:49 SQL> -- DROP	TABLE svmc_settings ;
03:54:49 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:54:49 SQL> -- DELETE svmc_settings;
03:54:49 SQL> 
03:54:49 SQL> -- The default classification algorithm is Naive Bayes. So override
03:54:49 SQL> -- this choice to SVM using a settings table.
03:54:49 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:54:49 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:54:49 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:54:49 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:54:49 SQL> -- models.
03:54:49 SQL> --
03:54:49 SQL> 
03:54:49 SQL> -- Do this once and then comment it out.
03:54:49 SQL> -- That makes script go faster.
03:54:49 SQL> -- BEGIN
03:54:49 SQL> -- -- Populate settings table
03:54:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:49 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:54:49 SQL> --
03:54:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:49 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:54:49 SQL> --
03:54:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:49 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:54:49 SQL> --   COMMIT;
03:54:49 SQL> -- END;
03:54:49 SQL> -- /
03:54:49 SQL> 
03:54:49 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:54:49 SQL> 
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:49 SQL> 
03:54:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:54:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:49 SQL> 
03:54:49 SQL> --------------------------------
03:54:49 SQL> -- PREPARE BUILD (TRAINING) DATA
03:54:49 SQL> --
03:54:49 SQL> 
03:54:49 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:49 SQL> -- 2. Outlier Treatment and
03:54:49 SQL> -- 3. Normalization are performed below.
03:54:49 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:54:49 SQL> --    normalized here.
03:54:49 SQL> 
03:54:49 SQL> BEGIN
03:54:49   2  	-- Perform missing value treatment for all predictors
03:54:49   3  	-- create miss tables
03:54:49   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:54:49   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:54:49   6  
03:54:49   7  	-- populate miss tables
03:54:49   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:54:49   9  	  miss_table_name => 'svmc_miss_num',
03:54:49  10  	  data_table_name => '&bldtable',
03:54:49  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:49  12  
03:54:49  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:54:49  14  	  miss_table_name => 'svmc_miss_cat',
03:54:49  15  	  data_table_name => '&bldtable',
03:54:49  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:49  17  
03:54:49  18  	-- xform input data to replace missing values
03:54:49  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:49  20  	  miss_table_name => 'svmc_miss_num',
03:54:49  21  	  data_table_name => '&bldtable',
03:54:49  22  	  xform_view_name => 'xformed_build_miss_num');
03:54:49  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:49  24  	  miss_table_name => 'svmc_miss_cat',
03:54:49  25  	  data_table_name => '&bldtable',
03:54:49  26  	  xform_view_name => 'xformed_build_miss_cat');
03:54:49  27  
03:54:49  28  	-- Perform outlier treatment.
03:54:49  29  	-- create clip table
03:54:49  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:54:49  31  
03:54:49  32  	-- populate clip table
03:54:49  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:54:49  34  	  clip_table_name => 'svmc_clip',
03:54:49  35  	  data_table_name => '&bldtable',
03:54:49  36  	  tail_frac	  => 0.025,
03:54:49  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:49  38  
03:54:49  39  	-- xform input data to winsorized data
03:54:49  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:54:49  41  	  clip_table_name => 'svmc_clip',
03:54:49  42  	  data_table_name => '&bldtable',
03:54:49  43  	  xform_view_name => 'svmc_winsor');
03:54:49  44  
03:54:49  45  	-- create normalization table
03:54:49  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:54:49  47  
03:54:49  48  	-- populate normalization table based on winsorized data
03:54:49  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:54:49  50  	  norm_table_name => 'svmc_norm',
03:54:49  51  	  data_table_name => 'svmc_winsor',
03:54:49  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:49  53  
03:54:49  54  	-- normalize the original data
03:54:49  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:49  56  	  norm_table_name => 'svmc_norm',
03:54:49  57  	  data_table_name => '&bldtable',
03:54:49  58  	  xform_view_name => 'svmc_build_prep');
03:54:49  59  END;
03:54:49  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.57
03:54:52 SQL> 
03:54:52 SQL> ---------------------
03:54:52 SQL> -- CREATE A NEW MODEL
03:54:52 SQL> --
03:54:52 SQL> -- Cleanup old model with the same name for repeat runs
03:54:52 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:54:52   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:52   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.43
03:54:53 SQL> 
03:54:53 SQL> -- Build a new SVM Model
03:54:53 SQL> BEGIN
03:54:53   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:54:53   3  	  model_name	      => '&model_name',
03:54:53   4  	  mining_function     => dbms_data_mining.classification,
03:54:53   5  	  data_table_name     => 'svmc_build_prep',
03:54:53   6  	  case_id_column_name => '&case_id',
03:54:53   7  	  target_column_name  => '&target',
03:54:53   8  	  settings_table_name => 'svmc_settings');
03:54:53   9  END;
03:54:53  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.84
03:54:58 SQL> 
03:54:58 SQL> -----------------------------------------------------------------------
03:54:58 SQL> --			       APPLY/score THE MODEL
03:54:58 SQL> -----------------------------------------------------------------------
03:54:58 SQL> 
03:54:58 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:54:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:54:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:54:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:54:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:58 SQL> -----------------------
03:54:58 SQL> -- PREPARE SCORING DATA
03:54:58 SQL> --
03:54:58 SQL> -- If the data for model creation has been prepared, then the data
03:54:58 SQL> -- to be scored using the model must be prepared in the same manner
03:54:58 SQL> -- in order to obtain meaningful results.
03:54:58 SQL> --
03:54:58 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:58 SQL> -- 2. Normalization
03:54:58 SQL> -- No outlier treatment will be performed during test and apply. The
03:54:58 SQL> -- normalization step is sufficient, since the normalization parameters
03:54:58 SQL> -- already capture the effects of outlier treatment done with build data.
03:54:58 SQL> --
03:54:58 SQL> BEGIN
03:54:58   2  	-- Xform Test data to replace missing values
03:54:58   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:58   4  	  miss_table_name => 'svmc_miss_num',
03:54:58   5  	  data_table_name => '&scoretable',
03:54:58   6  	  xform_view_name => 'xformed_apply_miss_num');
03:54:58   7  
03:54:58   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:58   9  	  miss_table_name => 'svmc_miss_cat',
03:54:58  10  	  data_table_name => '&scoretable',
03:54:58  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:54:58  12  
03:54:58  13  	-- Normalize the data to be scored
03:54:58  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:58  15  	  norm_table_name => 'svmc_norm',
03:54:58  16  	  data_table_name => '&scoretable',
03:54:58  17  	  xform_view_name => 'svmc_apply_prep');
03:54:58  18  END;
03:54:58  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:54:59 SQL> 
03:54:59 SQL> -- Maybe I already collected a score for this prdate.
03:54:59 SQL> -- DELETE it if I did:
03:54:59 SQL> DELETE svm24scores
03:54:59   2  WHERE score > 0
03:54:59   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:54:59   4  -- I need to supply the target attribute name:
03:54:59   5  AND targ = '&1'
03:54:59   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:54:59 SQL> 
03:54:59 SQL> -- We do a drumroll here:
03:54:59 SQL> 
03:54:59 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:54:59   2  SELECT
03:54:59   3  prdate
03:54:59   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:54:59   5  ,sysdate
03:54:59   6  ,SUBSTR(prdate,1,7)pair
03:54:59   7  ,SUBSTR(prdate,-19)ydate
03:54:59   8  ,'&1'
03:54:59   9  FROM svmc_apply_prep
03:54:59  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:54:59 SQL> @score1_5min.sql	      2011-01-26 15:45:00 eur_usd
03:54:59 SQL> --
03:54:59 SQL> -- score1_5min.sql
03:54:59 SQL> --
03:54:59 SQL> 
03:54:59 SQL> -- Demo:
03:54:59 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:54:59 SQL> 
03:54:59 SQL> CREATE OR REPLACE VIEW sme AS
03:54:59   2  SELECT
03:54:59   3  prdate
03:54:59   4  ,NULL gatt
03:54:59   5  ,g00
03:54:59   6  ,g01
03:54:59   7  ,g02
03:54:59   8  ,g03
03:54:59   9  ,g04
03:54:59  10  ,g05
03:54:59  11  ,g06
03:54:59  12  ,g07
03:54:59  13  ,g08
03:54:59  14  ,g09
03:54:59  15  ,g10
03:54:59  16  ,g11
03:54:59  17  ,g12
03:54:59  18  ,g13
03:54:59  19  ,g14
03:54:59  20  ,g15
03:54:59  21  ,g16
03:54:59  22  ,g17
03:54:59  23  ,g18
03:54:59  24  ,g19
03:54:59  25  ,g20
03:54:59  26  ,g21
03:54:59  27  ,g22
03:54:59  28  ,g23
03:54:59  29  ,g24
03:54:59  30  ,g25
03:54:59  31  ,g26
03:54:59  32  ,g27
03:54:59  33  ,g28
03:54:59  34  ,g29
03:54:59  35  ,g30
03:54:59  36  ,g31
03:54:59  37  ,g32
03:54:59  38  ,g33
03:54:59  39  ,g34
03:54:59  40  ,g35
03:54:59  41  ,g36
03:54:59  42  ,g37
03:54:59  43  ,g38
03:54:59  44  ,g39
03:54:59  45  ,g40
03:54:59  46  ,g41
03:54:59  47  ,s.sc_corr
03:54:59  48  FROM modsrc24
03:54:59  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:54:59  50  WHERE ydate = '&1'||' '||'&2'
03:54:59  51  AND pair = '&3'
03:54:59  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-26'||' '||'15:45:00'AND ydate<'2011-01-26'||' '||'15:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-26'||' '||'15:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:54:59 SQL> 
03:54:59 SQL> -- rpt
03:54:59 SQL> -- We should see just 1 row:
03:54:59 SQL> 
03:54:59 SQL> SELECT COUNT(prdate) FROM sme
03:54:59   2  
03:54:59 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:54:59   2  
03:54:59 SQL> 
03:54:59 SQL> -- Build the model:
03:54:59 SQL> CREATE OR REPLACE VIEW bme AS
03:54:59   2  SELECT
03:54:59   3  prdate
03:54:59   4  ,gatt
03:54:59   5  ,g00
03:54:59   6  ,g01
03:54:59   7  ,g02
03:54:59   8  ,g03
03:54:59   9  ,g04
03:54:59  10  ,g05
03:54:59  11  ,g06
03:54:59  12  ,g07
03:54:59  13  ,g08
03:54:59  14  ,g09
03:54:59  15  ,g10
03:54:59  16  ,g11
03:54:59  17  ,g12
03:54:59  18  ,g13
03:54:59  19  ,g14
03:54:59  20  ,g15
03:54:59  21  ,g16
03:54:59  22  ,g17
03:54:59  23  ,g18
03:54:59  24  ,g19
03:54:59  25  ,g20
03:54:59  26  ,g21
03:54:59  27  ,g22
03:54:59  28  ,g23
03:54:59  29  ,g24
03:54:59  30  ,g25
03:54:59  31  ,g26
03:54:59  32  ,g27
03:54:59  33  ,g28
03:54:59  34  ,g29
03:54:59  35  ,g30
03:54:59  36  ,g31
03:54:59  37  ,g32
03:54:59  38  ,g33
03:54:59  39  ,g34
03:54:59  40  ,g35
03:54:59  41  ,g36
03:54:59  42  ,g37
03:54:59  43  ,g38
03:54:59  44  ,g39
03:54:59  45  ,g40
03:54:59  46  ,g41
03:54:59  47  ,sc_corr
03:54:59  48  FROM modsrc24
03:54:59  49  WHERE gatt IN('nup','up')
03:54:59  50  -- Use only rows which are older than 1 day:
03:54:59  51  AND 1+ydate < '&1'||' '||'&2'
03:54:59  52  AND pair = '&3'
03:54:59  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-26'||' '||'15:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:54:59 SQL> 
03:54:59 SQL> -- rpt
03:54:59 SQL> 
03:54:59 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:54:59   2  
03:54:59 SQL> SELECT MAX(prdate) FROM bme
03:54:59   2  
03:54:59 SQL> -- Now build model from bme and score sme
03:54:59 SQL> @score1.sql gatt
03:54:59 SQL> --
03:54:59 SQL> -- score1.sql
03:54:59 SQL> --
03:54:59 SQL> 
03:54:59 SQL> -- I use this script to send 5 params to score.sql
03:54:59 SQL> -- which does the heavy lifting of creating an SVM model.
03:54:59 SQL> -- Then at the very end of this script I use the model
03:54:59 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:54:59 SQL> 
03:54:59 SQL> -- I call this script from 2 other scripts:
03:54:59 SQL> -- score1_5min.sql
03:54:59 SQL> -- score1_5min_gattn.sql
03:54:59 SQL> 
03:54:59 SQL> -- The 1st param is the name of the target attribute.
03:54:59 SQL> -- I like to call my target attributes either gatt or gattn.
03:54:59 SQL> 
03:54:59 SQL> -- Demo:
03:54:59 SQL> -- @score1.sql 'gatt'
03:54:59 SQL> -- @score1.sql 'gattn'
03:54:59 SQL> 
03:54:59 SQL> -- Now, I fill up svmc_apply_prep.
03:54:59 SQL> -- I use same model_name used in score.sql
03:54:59 SQL> DEFINE model_name = 'svmfx101'
03:54:59 SQL> DEFINE bldtable	= 'bme'
03:54:59 SQL> DEFINE scoretable = 'sme'
03:54:59 SQL> DEFINE case_id	= 'prdate'
03:54:59 SQL> -- Demo:
03:54:59 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:54:59 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:54:59 SQL> --
03:54:59 SQL> -- score.sql
03:54:59 SQL> --
03:54:59 SQL> 
03:54:59 SQL> -- usage: score.sql
03:54:59 SQL> 
03:54:59 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:54:59 SQL> 
03:54:59 SQL> -- DEFINE target	   = 'gatt'
03:54:59 SQL> -- DEFINE model_name = 'svmfx101'
03:54:59 SQL> -- DEFINE bldtable   = 'bme'
03:54:59 SQL> -- DEFINE scoretable = 'sme'
03:54:59 SQL> -- DEFINE case_id    = 'prdate'
03:54:59 SQL> 
03:54:59 SQL> DEFINE target	= '&1'
03:54:59 SQL> DEFINE model_name = '&2'
03:54:59 SQL> DEFINE bldtable	= '&3'
03:54:59 SQL> DEFINE scoretable = '&4'
03:54:59 SQL> DEFINE case_id	= '&5'
03:54:59 SQL> 
03:54:59 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:54:59 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:54:59 SQL> 
03:54:59 SQL> -- Builds an SVM model using pl/sql.
03:54:59 SQL> 
03:54:59 SQL> -----------------------------------------------------------------------
03:54:59 SQL> --			    BUILD THE MODEL
03:54:59 SQL> -----------------------------------------------------------------------
03:54:59 SQL> 
03:54:59 SQL> -- Cleanup old build data preparation objects for repeat runs
03:54:59 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:54:59 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:54:59 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:54:59 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:54:59 SQL> 
03:54:59 SQL> 
03:54:59 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:54:59 SQL> --
03:54:59 SQL> -- DROP	TABLE svmc_settings ;
03:54:59 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:54:59 SQL> -- DELETE svmc_settings;
03:54:59 SQL> 
03:54:59 SQL> -- The default classification algorithm is Naive Bayes. So override
03:54:59 SQL> -- this choice to SVM using a settings table.
03:54:59 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:54:59 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:54:59 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:54:59 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:54:59 SQL> -- models.
03:54:59 SQL> --
03:54:59 SQL> 
03:54:59 SQL> -- Do this once and then comment it out.
03:54:59 SQL> -- That makes script go faster.
03:54:59 SQL> -- BEGIN
03:54:59 SQL> -- -- Populate settings table
03:54:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:59 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:54:59 SQL> --
03:54:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:59 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:54:59 SQL> --
03:54:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:54:59 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:54:59 SQL> --   COMMIT;
03:54:59 SQL> -- END;
03:54:59 SQL> -- /
03:54:59 SQL> 
03:54:59 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:54:59 SQL> 
03:54:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:54:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:54:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:54:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:54:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:54:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:54:59 SQL> 
03:54:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:54:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:54:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:54:59 SQL> 
03:54:59 SQL> --------------------------------
03:54:59 SQL> -- PREPARE BUILD (TRAINING) DATA
03:54:59 SQL> --
03:54:59 SQL> 
03:54:59 SQL> -- 1. Missing Value treatment for all Predictors and
03:54:59 SQL> -- 2. Outlier Treatment and
03:54:59 SQL> -- 3. Normalization are performed below.
03:54:59 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:54:59 SQL> --    normalized here.
03:54:59 SQL> 
03:54:59 SQL> BEGIN
03:54:59   2  	-- Perform missing value treatment for all predictors
03:54:59   3  	-- create miss tables
03:54:59   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:54:59   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:54:59   6  
03:54:59   7  	-- populate miss tables
03:54:59   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:54:59   9  	  miss_table_name => 'svmc_miss_num',
03:54:59  10  	  data_table_name => '&bldtable',
03:54:59  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:59  12  
03:54:59  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:54:59  14  	  miss_table_name => 'svmc_miss_cat',
03:54:59  15  	  data_table_name => '&bldtable',
03:54:59  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:59  17  
03:54:59  18  	-- xform input data to replace missing values
03:54:59  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:54:59  20  	  miss_table_name => 'svmc_miss_num',
03:54:59  21  	  data_table_name => '&bldtable',
03:54:59  22  	  xform_view_name => 'xformed_build_miss_num');
03:54:59  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:54:59  24  	  miss_table_name => 'svmc_miss_cat',
03:54:59  25  	  data_table_name => '&bldtable',
03:54:59  26  	  xform_view_name => 'xformed_build_miss_cat');
03:54:59  27  
03:54:59  28  	-- Perform outlier treatment.
03:54:59  29  	-- create clip table
03:54:59  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:54:59  31  
03:54:59  32  	-- populate clip table
03:54:59  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:54:59  34  	  clip_table_name => 'svmc_clip',
03:54:59  35  	  data_table_name => '&bldtable',
03:54:59  36  	  tail_frac	  => 0.025,
03:54:59  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:59  38  
03:54:59  39  	-- xform input data to winsorized data
03:54:59  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:54:59  41  	  clip_table_name => 'svmc_clip',
03:54:59  42  	  data_table_name => '&bldtable',
03:54:59  43  	  xform_view_name => 'svmc_winsor');
03:54:59  44  
03:54:59  45  	-- create normalization table
03:54:59  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:54:59  47  
03:54:59  48  	-- populate normalization table based on winsorized data
03:54:59  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:54:59  50  	  norm_table_name => 'svmc_norm',
03:54:59  51  	  data_table_name => 'svmc_winsor',
03:54:59  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:54:59  53  
03:54:59  54  	-- normalize the original data
03:54:59  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:54:59  56  	  norm_table_name => 'svmc_norm',
03:54:59  57  	  data_table_name => '&bldtable',
03:54:59  58  	  xform_view_name => 'svmc_build_prep');
03:54:59  59  END;
03:54:59  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.65
03:55:02 SQL> 
03:55:02 SQL> ---------------------
03:55:02 SQL> -- CREATE A NEW MODEL
03:55:02 SQL> --
03:55:02 SQL> -- Cleanup old model with the same name for repeat runs
03:55:02 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:55:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:02   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.43
03:55:03 SQL> 
03:55:03 SQL> -- Build a new SVM Model
03:55:03 SQL> BEGIN
03:55:03   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:55:03   3  	  model_name	      => '&model_name',
03:55:03   4  	  mining_function     => dbms_data_mining.classification,
03:55:03   5  	  data_table_name     => 'svmc_build_prep',
03:55:03   6  	  case_id_column_name => '&case_id',
03:55:03   7  	  target_column_name  => '&target',
03:55:03   8  	  settings_table_name => 'svmc_settings');
03:55:03   9  END;
03:55:03  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.30
03:55:08 SQL> 
03:55:08 SQL> -----------------------------------------------------------------------
03:55:08 SQL> --			       APPLY/score THE MODEL
03:55:08 SQL> -----------------------------------------------------------------------
03:55:08 SQL> 
03:55:08 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:55:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:55:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:55:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:55:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:08 SQL> -----------------------
03:55:08 SQL> -- PREPARE SCORING DATA
03:55:08 SQL> --
03:55:08 SQL> -- If the data for model creation has been prepared, then the data
03:55:08 SQL> -- to be scored using the model must be prepared in the same manner
03:55:08 SQL> -- in order to obtain meaningful results.
03:55:08 SQL> --
03:55:08 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:08 SQL> -- 2. Normalization
03:55:08 SQL> -- No outlier treatment will be performed during test and apply. The
03:55:08 SQL> -- normalization step is sufficient, since the normalization parameters
03:55:08 SQL> -- already capture the effects of outlier treatment done with build data.
03:55:08 SQL> --
03:55:08 SQL> BEGIN
03:55:08   2  	-- Xform Test data to replace missing values
03:55:08   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:08   4  	  miss_table_name => 'svmc_miss_num',
03:55:08   5  	  data_table_name => '&scoretable',
03:55:08   6  	  xform_view_name => 'xformed_apply_miss_num');
03:55:08   7  
03:55:08   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:08   9  	  miss_table_name => 'svmc_miss_cat',
03:55:08  10  	  data_table_name => '&scoretable',
03:55:08  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:55:08  12  
03:55:08  13  	-- Normalize the data to be scored
03:55:08  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:08  15  	  norm_table_name => 'svmc_norm',
03:55:08  16  	  data_table_name => '&scoretable',
03:55:08  17  	  xform_view_name => 'svmc_apply_prep');
03:55:08  18  END;
03:55:08  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:55:09 SQL> 
03:55:09 SQL> -- Maybe I already collected a score for this prdate.
03:55:09 SQL> -- DELETE it if I did:
03:55:09 SQL> DELETE svm24scores
03:55:09   2  WHERE score > 0
03:55:09   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:55:09   4  -- I need to supply the target attribute name:
03:55:09   5  AND targ = '&1'
03:55:09   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:55:09 SQL> 
03:55:09 SQL> -- We do a drumroll here:
03:55:09 SQL> 
03:55:09 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:55:09   2  SELECT
03:55:09   3  prdate
03:55:09   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:55:09   5  ,sysdate
03:55:09   6  ,SUBSTR(prdate,1,7)pair
03:55:09   7  ,SUBSTR(prdate,-19)ydate
03:55:09   8  ,'&1'
03:55:09   9  FROM svmc_apply_prep
03:55:09  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:55:09 SQL> @score1_5min_gattn.sql	2011-01-19 04:00:00 eur_usd
03:55:09 SQL> --
03:55:09 SQL> -- score1_5min_gattn.sql
03:55:09 SQL> --
03:55:09 SQL> 
03:55:09 SQL> -- Demo:
03:55:09 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:55:09 SQL> 
03:55:09 SQL> CREATE OR REPLACE VIEW sme AS
03:55:09   2  SELECT
03:55:09   3  prdate
03:55:09   4  ,NULL gattn
03:55:09   5  ,g00
03:55:09   6  ,g01
03:55:09   7  ,g02
03:55:09   8  ,g03
03:55:09   9  ,g04
03:55:09  10  ,g05
03:55:09  11  ,g06
03:55:09  12  ,g07
03:55:09  13  ,g08
03:55:09  14  ,g09
03:55:09  15  ,g10
03:55:09  16  ,g11
03:55:09  17  ,g12
03:55:09  18  ,g13
03:55:09  19  ,g14
03:55:09  20  ,g15
03:55:09  21  ,g16
03:55:09  22  ,g17
03:55:09  23  ,g18
03:55:09  24  ,g19
03:55:09  25  ,g20
03:55:09  26  ,g21
03:55:09  27  ,g22
03:55:09  28  ,g23
03:55:09  29  ,g24
03:55:09  30  ,g25
03:55:09  31  ,g26
03:55:09  32  ,g27
03:55:09  33  ,g28
03:55:09  34  ,g29
03:55:09  35  ,g30
03:55:09  36  ,g31
03:55:09  37  ,g32
03:55:09  38  ,g33
03:55:09  39  ,g34
03:55:09  40  ,g35
03:55:09  41  ,g36
03:55:09  42  ,g37
03:55:09  43  ,g38
03:55:09  44  ,g39
03:55:09  45  ,g40
03:55:09  46  ,g41
03:55:09  47  ,s.sc_corr
03:55:09  48  FROM modsrc24
03:55:09  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:55:09  50  WHERE ydate = '&1'||' '||'&2'
03:55:09  51  AND pair = '&3'
03:55:09  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'04:00:00'AND ydate<'2011-01-19'||' '||'04:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'04:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:55:09 SQL> 
03:55:09 SQL> -- rpt
03:55:09 SQL> -- We should see just 1 row:
03:55:09 SQL> 
03:55:09 SQL> SELECT COUNT(prdate) FROM sme
03:55:09   2  
03:55:09 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:55:09   2  
03:55:09 SQL> 
03:55:09 SQL> -- Build the model:
03:55:09 SQL> CREATE OR REPLACE VIEW bme AS
03:55:09   2  SELECT
03:55:09   3  prdate
03:55:09   4  ,gattn
03:55:09   5  ,g00
03:55:09   6  ,g01
03:55:09   7  ,g02
03:55:09   8  ,g03
03:55:09   9  ,g04
03:55:09  10  ,g05
03:55:09  11  ,g06
03:55:09  12  ,g07
03:55:09  13  ,g08
03:55:09  14  ,g09
03:55:09  15  ,g10
03:55:09  16  ,g11
03:55:09  17  ,g12
03:55:09  18  ,g13
03:55:09  19  ,g14
03:55:09  20  ,g15
03:55:09  21  ,g16
03:55:09  22  ,g17
03:55:09  23  ,g18
03:55:09  24  ,g19
03:55:09  25  ,g20
03:55:09  26  ,g21
03:55:09  27  ,g22
03:55:09  28  ,g23
03:55:09  29  ,g24
03:55:09  30  ,g25
03:55:09  31  ,g26
03:55:09  32  ,g27
03:55:09  33  ,g28
03:55:09  34  ,g29
03:55:09  35  ,g30
03:55:09  36  ,g31
03:55:09  37  ,g32
03:55:09  38  ,g33
03:55:09  39  ,g34
03:55:09  40  ,g35
03:55:09  41  ,g36
03:55:09  42  ,g37
03:55:09  43  ,g38
03:55:09  44  ,g39
03:55:09  45  ,g40
03:55:09  46  ,g41
03:55:09  47  ,sc_corr
03:55:09  48  FROM modsrc24
03:55:09  49  WHERE gattn IN('nup','up')
03:55:09  50  -- Use only rows which are older than 1 day:
03:55:09  51  AND 1+ydate < '&1'||' '||'&2'
03:55:09  52  AND pair = '&3'
03:55:09  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'04:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.11
03:55:09 SQL> 
03:55:09 SQL> -- rpt
03:55:09 SQL> 
03:55:09 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:55:09   2  
03:55:09 SQL> SELECT MAX(prdate) FROM bme
03:55:09   2  
03:55:09 SQL> -- Now build model from bme and score sme
03:55:09 SQL> @score1.sql gattn
03:55:09 SQL> --
03:55:09 SQL> -- score1.sql
03:55:09 SQL> --
03:55:09 SQL> 
03:55:09 SQL> -- I use this script to send 5 params to score.sql
03:55:09 SQL> -- which does the heavy lifting of creating an SVM model.
03:55:09 SQL> -- Then at the very end of this script I use the model
03:55:09 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:55:09 SQL> 
03:55:09 SQL> -- I call this script from 2 other scripts:
03:55:09 SQL> -- score1_5min.sql
03:55:09 SQL> -- score1_5min_gattn.sql
03:55:09 SQL> 
03:55:09 SQL> -- The 1st param is the name of the target attribute.
03:55:09 SQL> -- I like to call my target attributes either gatt or gattn.
03:55:09 SQL> 
03:55:09 SQL> -- Demo:
03:55:09 SQL> -- @score1.sql 'gatt'
03:55:09 SQL> -- @score1.sql 'gattn'
03:55:09 SQL> 
03:55:09 SQL> -- Now, I fill up svmc_apply_prep.
03:55:09 SQL> -- I use same model_name used in score.sql
03:55:09 SQL> DEFINE model_name = 'svmfx101'
03:55:09 SQL> DEFINE bldtable	= 'bme'
03:55:09 SQL> DEFINE scoretable = 'sme'
03:55:09 SQL> DEFINE case_id	= 'prdate'
03:55:09 SQL> -- Demo:
03:55:09 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:55:09 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:55:09 SQL> --
03:55:09 SQL> -- score.sql
03:55:09 SQL> --
03:55:09 SQL> 
03:55:09 SQL> -- usage: score.sql
03:55:09 SQL> 
03:55:09 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:55:09 SQL> 
03:55:09 SQL> -- DEFINE target	   = 'gatt'
03:55:09 SQL> -- DEFINE model_name = 'svmfx101'
03:55:09 SQL> -- DEFINE bldtable   = 'bme'
03:55:09 SQL> -- DEFINE scoretable = 'sme'
03:55:09 SQL> -- DEFINE case_id    = 'prdate'
03:55:09 SQL> 
03:55:09 SQL> DEFINE target	= '&1'
03:55:09 SQL> DEFINE model_name = '&2'
03:55:09 SQL> DEFINE bldtable	= '&3'
03:55:09 SQL> DEFINE scoretable = '&4'
03:55:09 SQL> DEFINE case_id	= '&5'
03:55:09 SQL> 
03:55:09 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:55:09 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:55:09 SQL> 
03:55:09 SQL> -- Builds an SVM model using pl/sql.
03:55:09 SQL> 
03:55:09 SQL> -----------------------------------------------------------------------
03:55:09 SQL> --			    BUILD THE MODEL
03:55:09 SQL> -----------------------------------------------------------------------
03:55:09 SQL> 
03:55:09 SQL> -- Cleanup old build data preparation objects for repeat runs
03:55:09 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:09 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
03:55:09 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:09 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:55:09 SQL> 
03:55:09 SQL> 
03:55:09 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:55:09 SQL> --
03:55:09 SQL> -- DROP	TABLE svmc_settings ;
03:55:09 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:55:09 SQL> -- DELETE svmc_settings;
03:55:09 SQL> 
03:55:09 SQL> -- The default classification algorithm is Naive Bayes. So override
03:55:09 SQL> -- this choice to SVM using a settings table.
03:55:09 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:55:09 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:55:09 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:55:09 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:55:09 SQL> -- models.
03:55:09 SQL> --
03:55:09 SQL> 
03:55:09 SQL> -- Do this once and then comment it out.
03:55:09 SQL> -- That makes script go faster.
03:55:09 SQL> -- BEGIN
03:55:09 SQL> -- -- Populate settings table
03:55:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:09 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:55:09 SQL> --
03:55:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:09 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:55:09 SQL> --
03:55:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:09 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:55:09 SQL> --   COMMIT;
03:55:09 SQL> -- END;
03:55:09 SQL> -- /
03:55:09 SQL> 
03:55:09 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:55:09 SQL> 
03:55:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:55:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:55:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:55:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:55:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:09 SQL> 
03:55:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:55:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:09 SQL> 
03:55:09 SQL> --------------------------------
03:55:09 SQL> -- PREPARE BUILD (TRAINING) DATA
03:55:09 SQL> --
03:55:09 SQL> 
03:55:09 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:09 SQL> -- 2. Outlier Treatment and
03:55:09 SQL> -- 3. Normalization are performed below.
03:55:09 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:55:09 SQL> --    normalized here.
03:55:09 SQL> 
03:55:09 SQL> BEGIN
03:55:09   2  	-- Perform missing value treatment for all predictors
03:55:09   3  	-- create miss tables
03:55:09   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:55:09   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:55:09   6  
03:55:09   7  	-- populate miss tables
03:55:09   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:55:09   9  	  miss_table_name => 'svmc_miss_num',
03:55:09  10  	  data_table_name => '&bldtable',
03:55:09  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:09  12  
03:55:09  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:55:09  14  	  miss_table_name => 'svmc_miss_cat',
03:55:09  15  	  data_table_name => '&bldtable',
03:55:09  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:09  17  
03:55:09  18  	-- xform input data to replace missing values
03:55:09  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:09  20  	  miss_table_name => 'svmc_miss_num',
03:55:09  21  	  data_table_name => '&bldtable',
03:55:09  22  	  xform_view_name => 'xformed_build_miss_num');
03:55:09  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:09  24  	  miss_table_name => 'svmc_miss_cat',
03:55:09  25  	  data_table_name => '&bldtable',
03:55:09  26  	  xform_view_name => 'xformed_build_miss_cat');
03:55:09  27  
03:55:09  28  	-- Perform outlier treatment.
03:55:09  29  	-- create clip table
03:55:09  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:55:09  31  
03:55:09  32  	-- populate clip table
03:55:09  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:55:09  34  	  clip_table_name => 'svmc_clip',
03:55:09  35  	  data_table_name => '&bldtable',
03:55:09  36  	  tail_frac	  => 0.025,
03:55:09  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:09  38  
03:55:09  39  	-- xform input data to winsorized data
03:55:09  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:55:09  41  	  clip_table_name => 'svmc_clip',
03:55:09  42  	  data_table_name => '&bldtable',
03:55:09  43  	  xform_view_name => 'svmc_winsor');
03:55:09  44  
03:55:09  45  	-- create normalization table
03:55:09  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:55:09  47  
03:55:09  48  	-- populate normalization table based on winsorized data
03:55:09  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:55:09  50  	  norm_table_name => 'svmc_norm',
03:55:09  51  	  data_table_name => 'svmc_winsor',
03:55:09  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:09  53  
03:55:09  54  	-- normalize the original data
03:55:09  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:09  56  	  norm_table_name => 'svmc_norm',
03:55:09  57  	  data_table_name => '&bldtable',
03:55:09  58  	  xform_view_name => 'svmc_build_prep');
03:55:09  59  END;
03:55:09  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.55
03:55:12 SQL> 
03:55:12 SQL> ---------------------
03:55:12 SQL> -- CREATE A NEW MODEL
03:55:12 SQL> --
03:55:12 SQL> -- Cleanup old model with the same name for repeat runs
03:55:12 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:55:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:12   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.44
03:55:13 SQL> 
03:55:13 SQL> -- Build a new SVM Model
03:55:13 SQL> BEGIN
03:55:13   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:55:13   3  	  model_name	      => '&model_name',
03:55:13   4  	  mining_function     => dbms_data_mining.classification,
03:55:13   5  	  data_table_name     => 'svmc_build_prep',
03:55:13   6  	  case_id_column_name => '&case_id',
03:55:13   7  	  target_column_name  => '&target',
03:55:13   8  	  settings_table_name => 'svmc_settings');
03:55:13   9  END;
03:55:13  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.05
03:55:18 SQL> 
03:55:18 SQL> -----------------------------------------------------------------------
03:55:18 SQL> --			       APPLY/score THE MODEL
03:55:18 SQL> -----------------------------------------------------------------------
03:55:18 SQL> 
03:55:18 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:55:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:55:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:55:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:55:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:18 SQL> -----------------------
03:55:18 SQL> -- PREPARE SCORING DATA
03:55:18 SQL> --
03:55:18 SQL> -- If the data for model creation has been prepared, then the data
03:55:18 SQL> -- to be scored using the model must be prepared in the same manner
03:55:18 SQL> -- in order to obtain meaningful results.
03:55:18 SQL> --
03:55:18 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:18 SQL> -- 2. Normalization
03:55:18 SQL> -- No outlier treatment will be performed during test and apply. The
03:55:18 SQL> -- normalization step is sufficient, since the normalization parameters
03:55:18 SQL> -- already capture the effects of outlier treatment done with build data.
03:55:18 SQL> --
03:55:18 SQL> BEGIN
03:55:18   2  	-- Xform Test data to replace missing values
03:55:18   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:18   4  	  miss_table_name => 'svmc_miss_num',
03:55:18   5  	  data_table_name => '&scoretable',
03:55:18   6  	  xform_view_name => 'xformed_apply_miss_num');
03:55:18   7  
03:55:18   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:18   9  	  miss_table_name => 'svmc_miss_cat',
03:55:18  10  	  data_table_name => '&scoretable',
03:55:18  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:55:18  12  
03:55:18  13  	-- Normalize the data to be scored
03:55:18  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:18  15  	  norm_table_name => 'svmc_norm',
03:55:18  16  	  data_table_name => '&scoretable',
03:55:18  17  	  xform_view_name => 'svmc_apply_prep');
03:55:18  18  END;
03:55:18  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:55:18 SQL> 
03:55:18 SQL> -- Maybe I already collected a score for this prdate.
03:55:18 SQL> -- DELETE it if I did:
03:55:18 SQL> DELETE svm24scores
03:55:18   2  WHERE score > 0
03:55:18   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:55:18   4  -- I need to supply the target attribute name:
03:55:18   5  AND targ = '&1'
03:55:18   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:55:18 SQL> 
03:55:18 SQL> -- We do a drumroll here:
03:55:18 SQL> 
03:55:18 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:55:18   2  SELECT
03:55:18   3  prdate
03:55:18   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:55:18   5  ,sysdate
03:55:18   6  ,SUBSTR(prdate,1,7)pair
03:55:18   7  ,SUBSTR(prdate,-19)ydate
03:55:18   8  ,'&1'
03:55:18   9  FROM svmc_apply_prep
03:55:18  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:55:18 SQL> @score1_5min.sql	      2011-01-25 17:25:00 eur_usd
03:55:18 SQL> --
03:55:18 SQL> -- score1_5min.sql
03:55:18 SQL> --
03:55:18 SQL> 
03:55:18 SQL> -- Demo:
03:55:18 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:55:18 SQL> 
03:55:18 SQL> CREATE OR REPLACE VIEW sme AS
03:55:18   2  SELECT
03:55:18   3  prdate
03:55:18   4  ,NULL gatt
03:55:18   5  ,g00
03:55:18   6  ,g01
03:55:18   7  ,g02
03:55:18   8  ,g03
03:55:18   9  ,g04
03:55:18  10  ,g05
03:55:18  11  ,g06
03:55:18  12  ,g07
03:55:18  13  ,g08
03:55:18  14  ,g09
03:55:18  15  ,g10
03:55:18  16  ,g11
03:55:18  17  ,g12
03:55:18  18  ,g13
03:55:18  19  ,g14
03:55:18  20  ,g15
03:55:18  21  ,g16
03:55:18  22  ,g17
03:55:18  23  ,g18
03:55:18  24  ,g19
03:55:18  25  ,g20
03:55:18  26  ,g21
03:55:18  27  ,g22
03:55:18  28  ,g23
03:55:18  29  ,g24
03:55:18  30  ,g25
03:55:18  31  ,g26
03:55:18  32  ,g27
03:55:18  33  ,g28
03:55:18  34  ,g29
03:55:18  35  ,g30
03:55:18  36  ,g31
03:55:18  37  ,g32
03:55:18  38  ,g33
03:55:18  39  ,g34
03:55:18  40  ,g35
03:55:18  41  ,g36
03:55:18  42  ,g37
03:55:18  43  ,g38
03:55:18  44  ,g39
03:55:18  45  ,g40
03:55:18  46  ,g41
03:55:18  47  ,s.sc_corr
03:55:18  48  FROM modsrc24
03:55:18  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:55:18  50  WHERE ydate = '&1'||' '||'&2'
03:55:18  51  AND pair = '&3'
03:55:18  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'17:25:00'AND ydate<'2011-01-25'||' '||'17:25:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'17:25:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:55:18 SQL> 
03:55:18 SQL> -- rpt
03:55:18 SQL> -- We should see just 1 row:
03:55:18 SQL> 
03:55:18 SQL> SELECT COUNT(prdate) FROM sme
03:55:18   2  
03:55:18 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:55:18   2  
03:55:18 SQL> 
03:55:18 SQL> -- Build the model:
03:55:18 SQL> CREATE OR REPLACE VIEW bme AS
03:55:18   2  SELECT
03:55:18   3  prdate
03:55:18   4  ,gatt
03:55:18   5  ,g00
03:55:18   6  ,g01
03:55:18   7  ,g02
03:55:18   8  ,g03
03:55:18   9  ,g04
03:55:18  10  ,g05
03:55:18  11  ,g06
03:55:18  12  ,g07
03:55:18  13  ,g08
03:55:18  14  ,g09
03:55:18  15  ,g10
03:55:18  16  ,g11
03:55:18  17  ,g12
03:55:18  18  ,g13
03:55:18  19  ,g14
03:55:18  20  ,g15
03:55:18  21  ,g16
03:55:18  22  ,g17
03:55:18  23  ,g18
03:55:18  24  ,g19
03:55:18  25  ,g20
03:55:18  26  ,g21
03:55:18  27  ,g22
03:55:18  28  ,g23
03:55:18  29  ,g24
03:55:18  30  ,g25
03:55:18  31  ,g26
03:55:18  32  ,g27
03:55:18  33  ,g28
03:55:18  34  ,g29
03:55:18  35  ,g30
03:55:18  36  ,g31
03:55:18  37  ,g32
03:55:18  38  ,g33
03:55:18  39  ,g34
03:55:18  40  ,g35
03:55:18  41  ,g36
03:55:18  42  ,g37
03:55:18  43  ,g38
03:55:18  44  ,g39
03:55:18  45  ,g40
03:55:18  46  ,g41
03:55:18  47  ,sc_corr
03:55:18  48  FROM modsrc24
03:55:18  49  WHERE gatt IN('nup','up')
03:55:18  50  -- Use only rows which are older than 1 day:
03:55:18  51  AND 1+ydate < '&1'||' '||'&2'
03:55:18  52  AND pair = '&3'
03:55:18  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'17:25:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:55:19 SQL> 
03:55:19 SQL> -- rpt
03:55:19 SQL> 
03:55:19 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:55:19   2  
03:55:19 SQL> SELECT MAX(prdate) FROM bme
03:55:19   2  
03:55:19 SQL> -- Now build model from bme and score sme
03:55:19 SQL> @score1.sql gatt
03:55:19 SQL> --
03:55:19 SQL> -- score1.sql
03:55:19 SQL> --
03:55:19 SQL> 
03:55:19 SQL> -- I use this script to send 5 params to score.sql
03:55:19 SQL> -- which does the heavy lifting of creating an SVM model.
03:55:19 SQL> -- Then at the very end of this script I use the model
03:55:19 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:55:19 SQL> 
03:55:19 SQL> -- I call this script from 2 other scripts:
03:55:19 SQL> -- score1_5min.sql
03:55:19 SQL> -- score1_5min_gattn.sql
03:55:19 SQL> 
03:55:19 SQL> -- The 1st param is the name of the target attribute.
03:55:19 SQL> -- I like to call my target attributes either gatt or gattn.
03:55:19 SQL> 
03:55:19 SQL> -- Demo:
03:55:19 SQL> -- @score1.sql 'gatt'
03:55:19 SQL> -- @score1.sql 'gattn'
03:55:19 SQL> 
03:55:19 SQL> -- Now, I fill up svmc_apply_prep.
03:55:19 SQL> -- I use same model_name used in score.sql
03:55:19 SQL> DEFINE model_name = 'svmfx101'
03:55:19 SQL> DEFINE bldtable	= 'bme'
03:55:19 SQL> DEFINE scoretable = 'sme'
03:55:19 SQL> DEFINE case_id	= 'prdate'
03:55:19 SQL> -- Demo:
03:55:19 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:55:19 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:55:19 SQL> --
03:55:19 SQL> -- score.sql
03:55:19 SQL> --
03:55:19 SQL> 
03:55:19 SQL> -- usage: score.sql
03:55:19 SQL> 
03:55:19 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:55:19 SQL> 
03:55:19 SQL> -- DEFINE target	   = 'gatt'
03:55:19 SQL> -- DEFINE model_name = 'svmfx101'
03:55:19 SQL> -- DEFINE bldtable   = 'bme'
03:55:19 SQL> -- DEFINE scoretable = 'sme'
03:55:19 SQL> -- DEFINE case_id    = 'prdate'
03:55:19 SQL> 
03:55:19 SQL> DEFINE target	= '&1'
03:55:19 SQL> DEFINE model_name = '&2'
03:55:19 SQL> DEFINE bldtable	= '&3'
03:55:19 SQL> DEFINE scoretable = '&4'
03:55:19 SQL> DEFINE case_id	= '&5'
03:55:19 SQL> 
03:55:19 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:55:19 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:55:19 SQL> 
03:55:19 SQL> -- Builds an SVM model using pl/sql.
03:55:19 SQL> 
03:55:19 SQL> -----------------------------------------------------------------------
03:55:19 SQL> --			    BUILD THE MODEL
03:55:19 SQL> -----------------------------------------------------------------------
03:55:19 SQL> 
03:55:19 SQL> -- Cleanup old build data preparation objects for repeat runs
03:55:19 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:19 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:55:19 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:19 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:55:19 SQL> 
03:55:19 SQL> 
03:55:19 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:55:19 SQL> --
03:55:19 SQL> -- DROP	TABLE svmc_settings ;
03:55:19 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:55:19 SQL> -- DELETE svmc_settings;
03:55:19 SQL> 
03:55:19 SQL> -- The default classification algorithm is Naive Bayes. So override
03:55:19 SQL> -- this choice to SVM using a settings table.
03:55:19 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:55:19 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:55:19 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:55:19 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:55:19 SQL> -- models.
03:55:19 SQL> --
03:55:19 SQL> 
03:55:19 SQL> -- Do this once and then comment it out.
03:55:19 SQL> -- That makes script go faster.
03:55:19 SQL> -- BEGIN
03:55:19 SQL> -- -- Populate settings table
03:55:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:19 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:55:19 SQL> --
03:55:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:19 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:55:19 SQL> --
03:55:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:19 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:55:19 SQL> --   COMMIT;
03:55:19 SQL> -- END;
03:55:19 SQL> -- /
03:55:19 SQL> 
03:55:19 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:55:19 SQL> 
03:55:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:55:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:55:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:55:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:55:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:19 SQL> 
03:55:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:55:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:19 SQL> 
03:55:19 SQL> --------------------------------
03:55:19 SQL> -- PREPARE BUILD (TRAINING) DATA
03:55:19 SQL> --
03:55:19 SQL> 
03:55:19 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:19 SQL> -- 2. Outlier Treatment and
03:55:19 SQL> -- 3. Normalization are performed below.
03:55:19 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:55:19 SQL> --    normalized here.
03:55:19 SQL> 
03:55:19 SQL> BEGIN
03:55:19   2  	-- Perform missing value treatment for all predictors
03:55:19   3  	-- create miss tables
03:55:19   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:55:19   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:55:19   6  
03:55:19   7  	-- populate miss tables
03:55:19   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:55:19   9  	  miss_table_name => 'svmc_miss_num',
03:55:19  10  	  data_table_name => '&bldtable',
03:55:19  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:19  12  
03:55:19  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:55:19  14  	  miss_table_name => 'svmc_miss_cat',
03:55:19  15  	  data_table_name => '&bldtable',
03:55:19  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:19  17  
03:55:19  18  	-- xform input data to replace missing values
03:55:19  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:19  20  	  miss_table_name => 'svmc_miss_num',
03:55:19  21  	  data_table_name => '&bldtable',
03:55:19  22  	  xform_view_name => 'xformed_build_miss_num');
03:55:19  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:19  24  	  miss_table_name => 'svmc_miss_cat',
03:55:19  25  	  data_table_name => '&bldtable',
03:55:19  26  	  xform_view_name => 'xformed_build_miss_cat');
03:55:19  27  
03:55:19  28  	-- Perform outlier treatment.
03:55:19  29  	-- create clip table
03:55:19  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:55:19  31  
03:55:19  32  	-- populate clip table
03:55:19  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:55:19  34  	  clip_table_name => 'svmc_clip',
03:55:19  35  	  data_table_name => '&bldtable',
03:55:19  36  	  tail_frac	  => 0.025,
03:55:19  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:19  38  
03:55:19  39  	-- xform input data to winsorized data
03:55:19  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:55:19  41  	  clip_table_name => 'svmc_clip',
03:55:19  42  	  data_table_name => '&bldtable',
03:55:19  43  	  xform_view_name => 'svmc_winsor');
03:55:19  44  
03:55:19  45  	-- create normalization table
03:55:19  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:55:19  47  
03:55:19  48  	-- populate normalization table based on winsorized data
03:55:19  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:55:19  50  	  norm_table_name => 'svmc_norm',
03:55:19  51  	  data_table_name => 'svmc_winsor',
03:55:19  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:19  53  
03:55:19  54  	-- normalize the original data
03:55:19  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:19  56  	  norm_table_name => 'svmc_norm',
03:55:19  57  	  data_table_name => '&bldtable',
03:55:19  58  	  xform_view_name => 'svmc_build_prep');
03:55:19  59  END;
03:55:19  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.66
03:55:21 SQL> 
03:55:21 SQL> ---------------------
03:55:21 SQL> -- CREATE A NEW MODEL
03:55:21 SQL> --
03:55:21 SQL> -- Cleanup old model with the same name for repeat runs
03:55:21 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:55:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:21   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
03:55:23 SQL> 
03:55:23 SQL> -- Build a new SVM Model
03:55:23 SQL> BEGIN
03:55:23   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:55:23   3  	  model_name	      => '&model_name',
03:55:23   4  	  mining_function     => dbms_data_mining.classification,
03:55:23   5  	  data_table_name     => 'svmc_build_prep',
03:55:23   6  	  case_id_column_name => '&case_id',
03:55:23   7  	  target_column_name  => '&target',
03:55:23   8  	  settings_table_name => 'svmc_settings');
03:55:23   9  END;
03:55:23  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.41
03:55:29 SQL> 
03:55:29 SQL> -----------------------------------------------------------------------
03:55:29 SQL> --			       APPLY/score THE MODEL
03:55:29 SQL> -----------------------------------------------------------------------
03:55:29 SQL> 
03:55:29 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:55:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:55:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:55:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:55:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:29 SQL> -----------------------
03:55:29 SQL> -- PREPARE SCORING DATA
03:55:29 SQL> --
03:55:29 SQL> -- If the data for model creation has been prepared, then the data
03:55:29 SQL> -- to be scored using the model must be prepared in the same manner
03:55:29 SQL> -- in order to obtain meaningful results.
03:55:29 SQL> --
03:55:29 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:29 SQL> -- 2. Normalization
03:55:29 SQL> -- No outlier treatment will be performed during test and apply. The
03:55:29 SQL> -- normalization step is sufficient, since the normalization parameters
03:55:29 SQL> -- already capture the effects of outlier treatment done with build data.
03:55:29 SQL> --
03:55:29 SQL> BEGIN
03:55:29   2  	-- Xform Test data to replace missing values
03:55:29   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:29   4  	  miss_table_name => 'svmc_miss_num',
03:55:29   5  	  data_table_name => '&scoretable',
03:55:29   6  	  xform_view_name => 'xformed_apply_miss_num');
03:55:29   7  
03:55:29   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:29   9  	  miss_table_name => 'svmc_miss_cat',
03:55:29  10  	  data_table_name => '&scoretable',
03:55:29  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:55:29  12  
03:55:29  13  	-- Normalize the data to be scored
03:55:29  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:29  15  	  norm_table_name => 'svmc_norm',
03:55:29  16  	  data_table_name => '&scoretable',
03:55:29  17  	  xform_view_name => 'svmc_apply_prep');
03:55:29  18  END;
03:55:29  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
03:55:30 SQL> 
03:55:30 SQL> -- Maybe I already collected a score for this prdate.
03:55:30 SQL> -- DELETE it if I did:
03:55:30 SQL> DELETE svm24scores
03:55:30   2  WHERE score > 0
03:55:30   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:55:30   4  -- I need to supply the target attribute name:
03:55:30   5  AND targ = '&1'
03:55:30   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:55:30 SQL> 
03:55:30 SQL> -- We do a drumroll here:
03:55:30 SQL> 
03:55:30 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:55:30   2  SELECT
03:55:30   3  prdate
03:55:30   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:55:30   5  ,sysdate
03:55:30   6  ,SUBSTR(prdate,1,7)pair
03:55:30   7  ,SUBSTR(prdate,-19)ydate
03:55:30   8  ,'&1'
03:55:30   9  FROM svmc_apply_prep
03:55:30  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:55:30 SQL> @score1_5min_gattn.sql	2011-01-24 19:25:00 eur_usd
03:55:30 SQL> --
03:55:30 SQL> -- score1_5min_gattn.sql
03:55:30 SQL> --
03:55:30 SQL> 
03:55:30 SQL> -- Demo:
03:55:30 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:55:30 SQL> 
03:55:30 SQL> CREATE OR REPLACE VIEW sme AS
03:55:30   2  SELECT
03:55:30   3  prdate
03:55:30   4  ,NULL gattn
03:55:30   5  ,g00
03:55:30   6  ,g01
03:55:30   7  ,g02
03:55:30   8  ,g03
03:55:30   9  ,g04
03:55:30  10  ,g05
03:55:30  11  ,g06
03:55:30  12  ,g07
03:55:30  13  ,g08
03:55:30  14  ,g09
03:55:30  15  ,g10
03:55:30  16  ,g11
03:55:30  17  ,g12
03:55:30  18  ,g13
03:55:30  19  ,g14
03:55:30  20  ,g15
03:55:30  21  ,g16
03:55:30  22  ,g17
03:55:30  23  ,g18
03:55:30  24  ,g19
03:55:30  25  ,g20
03:55:30  26  ,g21
03:55:30  27  ,g22
03:55:30  28  ,g23
03:55:30  29  ,g24
03:55:30  30  ,g25
03:55:30  31  ,g26
03:55:30  32  ,g27
03:55:30  33  ,g28
03:55:30  34  ,g29
03:55:30  35  ,g30
03:55:30  36  ,g31
03:55:30  37  ,g32
03:55:30  38  ,g33
03:55:30  39  ,g34
03:55:30  40  ,g35
03:55:30  41  ,g36
03:55:30  42  ,g37
03:55:30  43  ,g38
03:55:30  44  ,g39
03:55:30  45  ,g40
03:55:30  46  ,g41
03:55:30  47  ,s.sc_corr
03:55:30  48  FROM modsrc24
03:55:30  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:55:30  50  WHERE ydate = '&1'||' '||'&2'
03:55:30  51  AND pair = '&3'
03:55:30  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-24'||' '||'19:25:00'AND ydate<'2011-01-24'||' '||'19:25:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-24'||' '||'19:25:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:55:30 SQL> 
03:55:30 SQL> -- rpt
03:55:30 SQL> -- We should see just 1 row:
03:55:30 SQL> 
03:55:30 SQL> SELECT COUNT(prdate) FROM sme
03:55:30   2  
03:55:30 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:55:30   2  
03:55:30 SQL> 
03:55:30 SQL> -- Build the model:
03:55:30 SQL> CREATE OR REPLACE VIEW bme AS
03:55:30   2  SELECT
03:55:30   3  prdate
03:55:30   4  ,gattn
03:55:30   5  ,g00
03:55:30   6  ,g01
03:55:30   7  ,g02
03:55:30   8  ,g03
03:55:30   9  ,g04
03:55:30  10  ,g05
03:55:30  11  ,g06
03:55:30  12  ,g07
03:55:30  13  ,g08
03:55:30  14  ,g09
03:55:30  15  ,g10
03:55:30  16  ,g11
03:55:30  17  ,g12
03:55:30  18  ,g13
03:55:30  19  ,g14
03:55:30  20  ,g15
03:55:30  21  ,g16
03:55:30  22  ,g17
03:55:30  23  ,g18
03:55:30  24  ,g19
03:55:30  25  ,g20
03:55:30  26  ,g21
03:55:30  27  ,g22
03:55:30  28  ,g23
03:55:30  29  ,g24
03:55:30  30  ,g25
03:55:30  31  ,g26
03:55:30  32  ,g27
03:55:30  33  ,g28
03:55:30  34  ,g29
03:55:30  35  ,g30
03:55:30  36  ,g31
03:55:30  37  ,g32
03:55:30  38  ,g33
03:55:30  39  ,g34
03:55:30  40  ,g35
03:55:30  41  ,g36
03:55:30  42  ,g37
03:55:30  43  ,g38
03:55:30  44  ,g39
03:55:30  45  ,g40
03:55:30  46  ,g41
03:55:30  47  ,sc_corr
03:55:30  48  FROM modsrc24
03:55:30  49  WHERE gattn IN('nup','up')
03:55:30  50  -- Use only rows which are older than 1 day:
03:55:30  51  AND 1+ydate < '&1'||' '||'&2'
03:55:30  52  AND pair = '&3'
03:55:30  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-24'||' '||'19:25:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:55:30 SQL> 
03:55:30 SQL> -- rpt
03:55:30 SQL> 
03:55:30 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:55:30   2  
03:55:30 SQL> SELECT MAX(prdate) FROM bme
03:55:30   2  
03:55:30 SQL> -- Now build model from bme and score sme
03:55:30 SQL> @score1.sql gattn
03:55:30 SQL> --
03:55:30 SQL> -- score1.sql
03:55:30 SQL> --
03:55:30 SQL> 
03:55:30 SQL> -- I use this script to send 5 params to score.sql
03:55:30 SQL> -- which does the heavy lifting of creating an SVM model.
03:55:30 SQL> -- Then at the very end of this script I use the model
03:55:30 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:55:30 SQL> 
03:55:30 SQL> -- I call this script from 2 other scripts:
03:55:30 SQL> -- score1_5min.sql
03:55:30 SQL> -- score1_5min_gattn.sql
03:55:30 SQL> 
03:55:30 SQL> -- The 1st param is the name of the target attribute.
03:55:30 SQL> -- I like to call my target attributes either gatt or gattn.
03:55:30 SQL> 
03:55:30 SQL> -- Demo:
03:55:30 SQL> -- @score1.sql 'gatt'
03:55:30 SQL> -- @score1.sql 'gattn'
03:55:30 SQL> 
03:55:30 SQL> -- Now, I fill up svmc_apply_prep.
03:55:30 SQL> -- I use same model_name used in score.sql
03:55:30 SQL> DEFINE model_name = 'svmfx101'
03:55:30 SQL> DEFINE bldtable	= 'bme'
03:55:30 SQL> DEFINE scoretable = 'sme'
03:55:30 SQL> DEFINE case_id	= 'prdate'
03:55:30 SQL> -- Demo:
03:55:30 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:55:30 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:55:30 SQL> --
03:55:30 SQL> -- score.sql
03:55:30 SQL> --
03:55:30 SQL> 
03:55:30 SQL> -- usage: score.sql
03:55:30 SQL> 
03:55:30 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:55:30 SQL> 
03:55:30 SQL> -- DEFINE target	   = 'gatt'
03:55:30 SQL> -- DEFINE model_name = 'svmfx101'
03:55:30 SQL> -- DEFINE bldtable   = 'bme'
03:55:30 SQL> -- DEFINE scoretable = 'sme'
03:55:30 SQL> -- DEFINE case_id    = 'prdate'
03:55:30 SQL> 
03:55:30 SQL> DEFINE target	= '&1'
03:55:30 SQL> DEFINE model_name = '&2'
03:55:30 SQL> DEFINE bldtable	= '&3'
03:55:30 SQL> DEFINE scoretable = '&4'
03:55:30 SQL> DEFINE case_id	= '&5'
03:55:30 SQL> 
03:55:30 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:55:30 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:55:30 SQL> 
03:55:30 SQL> -- Builds an SVM model using pl/sql.
03:55:30 SQL> 
03:55:30 SQL> -----------------------------------------------------------------------
03:55:30 SQL> --			    BUILD THE MODEL
03:55:30 SQL> -----------------------------------------------------------------------
03:55:30 SQL> 
03:55:30 SQL> -- Cleanup old build data preparation objects for repeat runs
03:55:30 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:55:30 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:55:30 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:30 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:55:30 SQL> 
03:55:30 SQL> 
03:55:30 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:55:30 SQL> --
03:55:30 SQL> -- DROP	TABLE svmc_settings ;
03:55:30 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:55:30 SQL> -- DELETE svmc_settings;
03:55:30 SQL> 
03:55:30 SQL> -- The default classification algorithm is Naive Bayes. So override
03:55:30 SQL> -- this choice to SVM using a settings table.
03:55:30 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:55:30 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:55:30 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:55:30 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:55:30 SQL> -- models.
03:55:30 SQL> --
03:55:30 SQL> 
03:55:30 SQL> -- Do this once and then comment it out.
03:55:30 SQL> -- That makes script go faster.
03:55:30 SQL> -- BEGIN
03:55:30 SQL> -- -- Populate settings table
03:55:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:30 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:55:30 SQL> --
03:55:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:30 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:55:30 SQL> --
03:55:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:30 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:55:30 SQL> --   COMMIT;
03:55:30 SQL> -- END;
03:55:30 SQL> -- /
03:55:30 SQL> 
03:55:30 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:55:30 SQL> 
03:55:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:55:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:55:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:55:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:55:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:30 SQL> 
03:55:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:55:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:30 SQL> 
03:55:30 SQL> --------------------------------
03:55:30 SQL> -- PREPARE BUILD (TRAINING) DATA
03:55:30 SQL> --
03:55:30 SQL> 
03:55:30 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:30 SQL> -- 2. Outlier Treatment and
03:55:30 SQL> -- 3. Normalization are performed below.
03:55:30 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:55:30 SQL> --    normalized here.
03:55:30 SQL> 
03:55:30 SQL> BEGIN
03:55:30   2  	-- Perform missing value treatment for all predictors
03:55:30   3  	-- create miss tables
03:55:30   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:55:30   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:55:30   6  
03:55:30   7  	-- populate miss tables
03:55:30   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:55:30   9  	  miss_table_name => 'svmc_miss_num',
03:55:30  10  	  data_table_name => '&bldtable',
03:55:30  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:30  12  
03:55:30  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:55:30  14  	  miss_table_name => 'svmc_miss_cat',
03:55:30  15  	  data_table_name => '&bldtable',
03:55:30  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:30  17  
03:55:30  18  	-- xform input data to replace missing values
03:55:30  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:30  20  	  miss_table_name => 'svmc_miss_num',
03:55:30  21  	  data_table_name => '&bldtable',
03:55:30  22  	  xform_view_name => 'xformed_build_miss_num');
03:55:30  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:30  24  	  miss_table_name => 'svmc_miss_cat',
03:55:30  25  	  data_table_name => '&bldtable',
03:55:30  26  	  xform_view_name => 'xformed_build_miss_cat');
03:55:30  27  
03:55:30  28  	-- Perform outlier treatment.
03:55:30  29  	-- create clip table
03:55:30  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:55:30  31  
03:55:30  32  	-- populate clip table
03:55:30  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:55:30  34  	  clip_table_name => 'svmc_clip',
03:55:30  35  	  data_table_name => '&bldtable',
03:55:30  36  	  tail_frac	  => 0.025,
03:55:30  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:30  38  
03:55:30  39  	-- xform input data to winsorized data
03:55:30  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:55:30  41  	  clip_table_name => 'svmc_clip',
03:55:30  42  	  data_table_name => '&bldtable',
03:55:30  43  	  xform_view_name => 'svmc_winsor');
03:55:30  44  
03:55:30  45  	-- create normalization table
03:55:30  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:55:30  47  
03:55:30  48  	-- populate normalization table based on winsorized data
03:55:30  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:55:30  50  	  norm_table_name => 'svmc_norm',
03:55:30  51  	  data_table_name => 'svmc_winsor',
03:55:30  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:30  53  
03:55:30  54  	-- normalize the original data
03:55:30  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:30  56  	  norm_table_name => 'svmc_norm',
03:55:30  57  	  data_table_name => '&bldtable',
03:55:30  58  	  xform_view_name => 'svmc_build_prep');
03:55:30  59  END;
03:55:30  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.60
03:55:33 SQL> 
03:55:33 SQL> ---------------------
03:55:33 SQL> -- CREATE A NEW MODEL
03:55:33 SQL> --
03:55:33 SQL> -- Cleanup old model with the same name for repeat runs
03:55:33 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:55:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:33   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.40
03:55:34 SQL> 
03:55:34 SQL> -- Build a new SVM Model
03:55:34 SQL> BEGIN
03:55:34   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:55:34   3  	  model_name	      => '&model_name',
03:55:34   4  	  mining_function     => dbms_data_mining.classification,
03:55:34   5  	  data_table_name     => 'svmc_build_prep',
03:55:34   6  	  case_id_column_name => '&case_id',
03:55:34   7  	  target_column_name  => '&target',
03:55:34   8  	  settings_table_name => 'svmc_settings');
03:55:34   9  END;
03:55:34  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.41
03:55:39 SQL> 
03:55:39 SQL> -----------------------------------------------------------------------
03:55:39 SQL> --			       APPLY/score THE MODEL
03:55:39 SQL> -----------------------------------------------------------------------
03:55:39 SQL> 
03:55:39 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:55:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:55:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:55:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:55:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:39 SQL> -----------------------
03:55:39 SQL> -- PREPARE SCORING DATA
03:55:39 SQL> --
03:55:39 SQL> -- If the data for model creation has been prepared, then the data
03:55:39 SQL> -- to be scored using the model must be prepared in the same manner
03:55:39 SQL> -- in order to obtain meaningful results.
03:55:39 SQL> --
03:55:39 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:39 SQL> -- 2. Normalization
03:55:39 SQL> -- No outlier treatment will be performed during test and apply. The
03:55:39 SQL> -- normalization step is sufficient, since the normalization parameters
03:55:39 SQL> -- already capture the effects of outlier treatment done with build data.
03:55:39 SQL> --
03:55:39 SQL> BEGIN
03:55:39   2  	-- Xform Test data to replace missing values
03:55:39   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:39   4  	  miss_table_name => 'svmc_miss_num',
03:55:39   5  	  data_table_name => '&scoretable',
03:55:39   6  	  xform_view_name => 'xformed_apply_miss_num');
03:55:39   7  
03:55:39   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:39   9  	  miss_table_name => 'svmc_miss_cat',
03:55:39  10  	  data_table_name => '&scoretable',
03:55:39  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:55:39  12  
03:55:39  13  	-- Normalize the data to be scored
03:55:39  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:39  15  	  norm_table_name => 'svmc_norm',
03:55:39  16  	  data_table_name => '&scoretable',
03:55:39  17  	  xform_view_name => 'svmc_apply_prep');
03:55:39  18  END;
03:55:39  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:55:40 SQL> 
03:55:40 SQL> -- Maybe I already collected a score for this prdate.
03:55:40 SQL> -- DELETE it if I did:
03:55:40 SQL> DELETE svm24scores
03:55:40   2  WHERE score > 0
03:55:40   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:55:40   4  -- I need to supply the target attribute name:
03:55:40   5  AND targ = '&1'
03:55:40   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:55:40 SQL> 
03:55:40 SQL> -- We do a drumroll here:
03:55:40 SQL> 
03:55:40 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:55:40   2  SELECT
03:55:40   3  prdate
03:55:40   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:55:40   5  ,sysdate
03:55:40   6  ,SUBSTR(prdate,1,7)pair
03:55:40   7  ,SUBSTR(prdate,-19)ydate
03:55:40   8  ,'&1'
03:55:40   9  FROM svmc_apply_prep
03:55:40  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:55:40 SQL> @score1_5min.sql	      2011-01-21 14:15:00 eur_usd
03:55:40 SQL> --
03:55:40 SQL> -- score1_5min.sql
03:55:40 SQL> --
03:55:40 SQL> 
03:55:40 SQL> -- Demo:
03:55:40 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:55:40 SQL> 
03:55:40 SQL> CREATE OR REPLACE VIEW sme AS
03:55:40   2  SELECT
03:55:40   3  prdate
03:55:40   4  ,NULL gatt
03:55:40   5  ,g00
03:55:40   6  ,g01
03:55:40   7  ,g02
03:55:40   8  ,g03
03:55:40   9  ,g04
03:55:40  10  ,g05
03:55:40  11  ,g06
03:55:40  12  ,g07
03:55:40  13  ,g08
03:55:40  14  ,g09
03:55:40  15  ,g10
03:55:40  16  ,g11
03:55:40  17  ,g12
03:55:40  18  ,g13
03:55:40  19  ,g14
03:55:40  20  ,g15
03:55:40  21  ,g16
03:55:40  22  ,g17
03:55:40  23  ,g18
03:55:40  24  ,g19
03:55:40  25  ,g20
03:55:40  26  ,g21
03:55:40  27  ,g22
03:55:40  28  ,g23
03:55:40  29  ,g24
03:55:40  30  ,g25
03:55:40  31  ,g26
03:55:40  32  ,g27
03:55:40  33  ,g28
03:55:40  34  ,g29
03:55:40  35  ,g30
03:55:40  36  ,g31
03:55:40  37  ,g32
03:55:40  38  ,g33
03:55:40  39  ,g34
03:55:40  40  ,g35
03:55:40  41  ,g36
03:55:40  42  ,g37
03:55:40  43  ,g38
03:55:40  44  ,g39
03:55:40  45  ,g40
03:55:40  46  ,g41
03:55:40  47  ,s.sc_corr
03:55:40  48  FROM modsrc24
03:55:40  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:55:40  50  WHERE ydate = '&1'||' '||'&2'
03:55:40  51  AND pair = '&3'
03:55:40  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'14:15:00'AND ydate<'2011-01-21'||' '||'14:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'14:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:55:40 SQL> 
03:55:40 SQL> -- rpt
03:55:40 SQL> -- We should see just 1 row:
03:55:40 SQL> 
03:55:40 SQL> SELECT COUNT(prdate) FROM sme
03:55:40   2  
03:55:40 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:55:40   2  
03:55:40 SQL> 
03:55:40 SQL> -- Build the model:
03:55:40 SQL> CREATE OR REPLACE VIEW bme AS
03:55:40   2  SELECT
03:55:40   3  prdate
03:55:40   4  ,gatt
03:55:40   5  ,g00
03:55:40   6  ,g01
03:55:40   7  ,g02
03:55:40   8  ,g03
03:55:40   9  ,g04
03:55:40  10  ,g05
03:55:40  11  ,g06
03:55:40  12  ,g07
03:55:40  13  ,g08
03:55:40  14  ,g09
03:55:40  15  ,g10
03:55:40  16  ,g11
03:55:40  17  ,g12
03:55:40  18  ,g13
03:55:40  19  ,g14
03:55:40  20  ,g15
03:55:40  21  ,g16
03:55:40  22  ,g17
03:55:40  23  ,g18
03:55:40  24  ,g19
03:55:40  25  ,g20
03:55:40  26  ,g21
03:55:40  27  ,g22
03:55:40  28  ,g23
03:55:40  29  ,g24
03:55:40  30  ,g25
03:55:40  31  ,g26
03:55:40  32  ,g27
03:55:40  33  ,g28
03:55:40  34  ,g29
03:55:40  35  ,g30
03:55:40  36  ,g31
03:55:40  37  ,g32
03:55:40  38  ,g33
03:55:40  39  ,g34
03:55:40  40  ,g35
03:55:40  41  ,g36
03:55:40  42  ,g37
03:55:40  43  ,g38
03:55:40  44  ,g39
03:55:40  45  ,g40
03:55:40  46  ,g41
03:55:40  47  ,sc_corr
03:55:40  48  FROM modsrc24
03:55:40  49  WHERE gatt IN('nup','up')
03:55:40  50  -- Use only rows which are older than 1 day:
03:55:40  51  AND 1+ydate < '&1'||' '||'&2'
03:55:40  52  AND pair = '&3'
03:55:40  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'14:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:55:40 SQL> 
03:55:40 SQL> -- rpt
03:55:40 SQL> 
03:55:40 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:55:40   2  
03:55:40 SQL> SELECT MAX(prdate) FROM bme
03:55:40   2  
03:55:40 SQL> -- Now build model from bme and score sme
03:55:40 SQL> @score1.sql gatt
03:55:40 SQL> --
03:55:40 SQL> -- score1.sql
03:55:40 SQL> --
03:55:40 SQL> 
03:55:40 SQL> -- I use this script to send 5 params to score.sql
03:55:40 SQL> -- which does the heavy lifting of creating an SVM model.
03:55:40 SQL> -- Then at the very end of this script I use the model
03:55:40 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:55:40 SQL> 
03:55:40 SQL> -- I call this script from 2 other scripts:
03:55:40 SQL> -- score1_5min.sql
03:55:40 SQL> -- score1_5min_gattn.sql
03:55:40 SQL> 
03:55:40 SQL> -- The 1st param is the name of the target attribute.
03:55:40 SQL> -- I like to call my target attributes either gatt or gattn.
03:55:40 SQL> 
03:55:40 SQL> -- Demo:
03:55:40 SQL> -- @score1.sql 'gatt'
03:55:40 SQL> -- @score1.sql 'gattn'
03:55:40 SQL> 
03:55:40 SQL> -- Now, I fill up svmc_apply_prep.
03:55:40 SQL> -- I use same model_name used in score.sql
03:55:40 SQL> DEFINE model_name = 'svmfx101'
03:55:40 SQL> DEFINE bldtable	= 'bme'
03:55:40 SQL> DEFINE scoretable = 'sme'
03:55:40 SQL> DEFINE case_id	= 'prdate'
03:55:40 SQL> -- Demo:
03:55:40 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:55:40 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:55:40 SQL> --
03:55:40 SQL> -- score.sql
03:55:40 SQL> --
03:55:40 SQL> 
03:55:40 SQL> -- usage: score.sql
03:55:40 SQL> 
03:55:40 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:55:40 SQL> 
03:55:40 SQL> -- DEFINE target	   = 'gatt'
03:55:40 SQL> -- DEFINE model_name = 'svmfx101'
03:55:40 SQL> -- DEFINE bldtable   = 'bme'
03:55:40 SQL> -- DEFINE scoretable = 'sme'
03:55:40 SQL> -- DEFINE case_id    = 'prdate'
03:55:40 SQL> 
03:55:40 SQL> DEFINE target	= '&1'
03:55:40 SQL> DEFINE model_name = '&2'
03:55:40 SQL> DEFINE bldtable	= '&3'
03:55:40 SQL> DEFINE scoretable = '&4'
03:55:40 SQL> DEFINE case_id	= '&5'
03:55:40 SQL> 
03:55:40 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:55:40 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:55:40 SQL> 
03:55:40 SQL> -- Builds an SVM model using pl/sql.
03:55:40 SQL> 
03:55:40 SQL> -----------------------------------------------------------------------
03:55:40 SQL> --			    BUILD THE MODEL
03:55:40 SQL> -----------------------------------------------------------------------
03:55:40 SQL> 
03:55:40 SQL> -- Cleanup old build data preparation objects for repeat runs
03:55:40 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:40 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:55:40 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:55:40 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:55:40 SQL> 
03:55:40 SQL> 
03:55:40 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:55:40 SQL> --
03:55:40 SQL> -- DROP	TABLE svmc_settings ;
03:55:40 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:55:40 SQL> -- DELETE svmc_settings;
03:55:40 SQL> 
03:55:40 SQL> -- The default classification algorithm is Naive Bayes. So override
03:55:40 SQL> -- this choice to SVM using a settings table.
03:55:40 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:55:40 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:55:40 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:55:40 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:55:40 SQL> -- models.
03:55:40 SQL> --
03:55:40 SQL> 
03:55:40 SQL> -- Do this once and then comment it out.
03:55:40 SQL> -- That makes script go faster.
03:55:40 SQL> -- BEGIN
03:55:40 SQL> -- -- Populate settings table
03:55:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:40 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:55:40 SQL> --
03:55:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:40 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:55:40 SQL> --
03:55:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:40 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:55:40 SQL> --   COMMIT;
03:55:40 SQL> -- END;
03:55:40 SQL> -- /
03:55:40 SQL> 
03:55:40 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:55:40 SQL> 
03:55:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:55:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:55:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:55:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:55:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:40 SQL> 
03:55:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:55:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:40 SQL> 
03:55:40 SQL> --------------------------------
03:55:40 SQL> -- PREPARE BUILD (TRAINING) DATA
03:55:40 SQL> --
03:55:40 SQL> 
03:55:40 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:40 SQL> -- 2. Outlier Treatment and
03:55:40 SQL> -- 3. Normalization are performed below.
03:55:40 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:55:40 SQL> --    normalized here.
03:55:40 SQL> 
03:55:40 SQL> BEGIN
03:55:40   2  	-- Perform missing value treatment for all predictors
03:55:40   3  	-- create miss tables
03:55:40   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:55:40   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:55:40   6  
03:55:40   7  	-- populate miss tables
03:55:40   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:55:40   9  	  miss_table_name => 'svmc_miss_num',
03:55:40  10  	  data_table_name => '&bldtable',
03:55:40  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:40  12  
03:55:40  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:55:40  14  	  miss_table_name => 'svmc_miss_cat',
03:55:40  15  	  data_table_name => '&bldtable',
03:55:40  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:40  17  
03:55:40  18  	-- xform input data to replace missing values
03:55:40  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:40  20  	  miss_table_name => 'svmc_miss_num',
03:55:40  21  	  data_table_name => '&bldtable',
03:55:40  22  	  xform_view_name => 'xformed_build_miss_num');
03:55:40  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:40  24  	  miss_table_name => 'svmc_miss_cat',
03:55:40  25  	  data_table_name => '&bldtable',
03:55:40  26  	  xform_view_name => 'xformed_build_miss_cat');
03:55:40  27  
03:55:40  28  	-- Perform outlier treatment.
03:55:40  29  	-- create clip table
03:55:40  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:55:40  31  
03:55:40  32  	-- populate clip table
03:55:40  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:55:40  34  	  clip_table_name => 'svmc_clip',
03:55:40  35  	  data_table_name => '&bldtable',
03:55:40  36  	  tail_frac	  => 0.025,
03:55:40  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:40  38  
03:55:40  39  	-- xform input data to winsorized data
03:55:40  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:55:40  41  	  clip_table_name => 'svmc_clip',
03:55:40  42  	  data_table_name => '&bldtable',
03:55:40  43  	  xform_view_name => 'svmc_winsor');
03:55:40  44  
03:55:40  45  	-- create normalization table
03:55:40  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:55:40  47  
03:55:40  48  	-- populate normalization table based on winsorized data
03:55:40  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:55:40  50  	  norm_table_name => 'svmc_norm',
03:55:40  51  	  data_table_name => 'svmc_winsor',
03:55:40  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:40  53  
03:55:40  54  	-- normalize the original data
03:55:40  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:40  56  	  norm_table_name => 'svmc_norm',
03:55:40  57  	  data_table_name => '&bldtable',
03:55:40  58  	  xform_view_name => 'svmc_build_prep');
03:55:40  59  END;
03:55:40  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
03:55:43 SQL> 
03:55:43 SQL> ---------------------
03:55:43 SQL> -- CREATE A NEW MODEL
03:55:43 SQL> --
03:55:43 SQL> -- Cleanup old model with the same name for repeat runs
03:55:43 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:55:43   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:43   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.72
03:55:44 SQL> 
03:55:44 SQL> -- Build a new SVM Model
03:55:44 SQL> BEGIN
03:55:44   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:55:44   3  	  model_name	      => '&model_name',
03:55:44   4  	  mining_function     => dbms_data_mining.classification,
03:55:44   5  	  data_table_name     => 'svmc_build_prep',
03:55:44   6  	  case_id_column_name => '&case_id',
03:55:44   7  	  target_column_name  => '&target',
03:55:44   8  	  settings_table_name => 'svmc_settings');
03:55:44   9  END;
03:55:44  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.33
03:55:50 SQL> 
03:55:50 SQL> -----------------------------------------------------------------------
03:55:50 SQL> --			       APPLY/score THE MODEL
03:55:50 SQL> -----------------------------------------------------------------------
03:55:50 SQL> 
03:55:50 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:50 SQL> -----------------------
03:55:50 SQL> -- PREPARE SCORING DATA
03:55:50 SQL> --
03:55:50 SQL> -- If the data for model creation has been prepared, then the data
03:55:50 SQL> -- to be scored using the model must be prepared in the same manner
03:55:50 SQL> -- in order to obtain meaningful results.
03:55:50 SQL> --
03:55:50 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:50 SQL> -- 2. Normalization
03:55:50 SQL> -- No outlier treatment will be performed during test and apply. The
03:55:50 SQL> -- normalization step is sufficient, since the normalization parameters
03:55:50 SQL> -- already capture the effects of outlier treatment done with build data.
03:55:50 SQL> --
03:55:50 SQL> BEGIN
03:55:50   2  	-- Xform Test data to replace missing values
03:55:50   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:50   4  	  miss_table_name => 'svmc_miss_num',
03:55:50   5  	  data_table_name => '&scoretable',
03:55:50   6  	  xform_view_name => 'xformed_apply_miss_num');
03:55:50   7  
03:55:50   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:50   9  	  miss_table_name => 'svmc_miss_cat',
03:55:50  10  	  data_table_name => '&scoretable',
03:55:50  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:55:50  12  
03:55:50  13  	-- Normalize the data to be scored
03:55:50  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:50  15  	  norm_table_name => 'svmc_norm',
03:55:50  16  	  data_table_name => '&scoretable',
03:55:50  17  	  xform_view_name => 'svmc_apply_prep');
03:55:50  18  END;
03:55:50  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:55:50 SQL> 
03:55:50 SQL> -- Maybe I already collected a score for this prdate.
03:55:50 SQL> -- DELETE it if I did:
03:55:50 SQL> DELETE svm24scores
03:55:50   2  WHERE score > 0
03:55:50   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:55:50   4  -- I need to supply the target attribute name:
03:55:50   5  AND targ = '&1'
03:55:50   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.03
03:55:50 SQL> 
03:55:50 SQL> -- We do a drumroll here:
03:55:50 SQL> 
03:55:50 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:55:50   2  SELECT
03:55:50   3  prdate
03:55:50   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:55:50   5  ,sysdate
03:55:50   6  ,SUBSTR(prdate,1,7)pair
03:55:50   7  ,SUBSTR(prdate,-19)ydate
03:55:50   8  ,'&1'
03:55:50   9  FROM svmc_apply_prep
03:55:50  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:55:50 SQL> @score1_5min_gattn.sql	2011-01-25 18:45:00 eur_usd
03:55:50 SQL> --
03:55:50 SQL> -- score1_5min_gattn.sql
03:55:50 SQL> --
03:55:50 SQL> 
03:55:50 SQL> -- Demo:
03:55:50 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:55:50 SQL> 
03:55:50 SQL> CREATE OR REPLACE VIEW sme AS
03:55:50   2  SELECT
03:55:50   3  prdate
03:55:50   4  ,NULL gattn
03:55:50   5  ,g00
03:55:50   6  ,g01
03:55:50   7  ,g02
03:55:50   8  ,g03
03:55:50   9  ,g04
03:55:50  10  ,g05
03:55:50  11  ,g06
03:55:50  12  ,g07
03:55:50  13  ,g08
03:55:50  14  ,g09
03:55:50  15  ,g10
03:55:50  16  ,g11
03:55:50  17  ,g12
03:55:50  18  ,g13
03:55:50  19  ,g14
03:55:50  20  ,g15
03:55:50  21  ,g16
03:55:50  22  ,g17
03:55:50  23  ,g18
03:55:50  24  ,g19
03:55:50  25  ,g20
03:55:50  26  ,g21
03:55:50  27  ,g22
03:55:50  28  ,g23
03:55:50  29  ,g24
03:55:50  30  ,g25
03:55:50  31  ,g26
03:55:50  32  ,g27
03:55:50  33  ,g28
03:55:50  34  ,g29
03:55:50  35  ,g30
03:55:50  36  ,g31
03:55:50  37  ,g32
03:55:50  38  ,g33
03:55:50  39  ,g34
03:55:50  40  ,g35
03:55:50  41  ,g36
03:55:50  42  ,g37
03:55:50  43  ,g38
03:55:50  44  ,g39
03:55:50  45  ,g40
03:55:50  46  ,g41
03:55:50  47  ,s.sc_corr
03:55:50  48  FROM modsrc24
03:55:50  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:55:50  50  WHERE ydate = '&1'||' '||'&2'
03:55:50  51  AND pair = '&3'
03:55:50  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'18:45:00'AND ydate<'2011-01-25'||' '||'18:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'18:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:55:50 SQL> 
03:55:50 SQL> -- rpt
03:55:50 SQL> -- We should see just 1 row:
03:55:50 SQL> 
03:55:50 SQL> SELECT COUNT(prdate) FROM sme
03:55:50   2  
03:55:50 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:55:50   2  
03:55:50 SQL> 
03:55:50 SQL> -- Build the model:
03:55:50 SQL> CREATE OR REPLACE VIEW bme AS
03:55:50   2  SELECT
03:55:50   3  prdate
03:55:50   4  ,gattn
03:55:50   5  ,g00
03:55:50   6  ,g01
03:55:50   7  ,g02
03:55:50   8  ,g03
03:55:50   9  ,g04
03:55:50  10  ,g05
03:55:50  11  ,g06
03:55:50  12  ,g07
03:55:50  13  ,g08
03:55:50  14  ,g09
03:55:50  15  ,g10
03:55:50  16  ,g11
03:55:50  17  ,g12
03:55:50  18  ,g13
03:55:50  19  ,g14
03:55:50  20  ,g15
03:55:50  21  ,g16
03:55:50  22  ,g17
03:55:50  23  ,g18
03:55:50  24  ,g19
03:55:50  25  ,g20
03:55:50  26  ,g21
03:55:50  27  ,g22
03:55:50  28  ,g23
03:55:50  29  ,g24
03:55:50  30  ,g25
03:55:50  31  ,g26
03:55:50  32  ,g27
03:55:50  33  ,g28
03:55:50  34  ,g29
03:55:50  35  ,g30
03:55:50  36  ,g31
03:55:50  37  ,g32
03:55:50  38  ,g33
03:55:50  39  ,g34
03:55:50  40  ,g35
03:55:50  41  ,g36
03:55:50  42  ,g37
03:55:50  43  ,g38
03:55:50  44  ,g39
03:55:50  45  ,g40
03:55:50  46  ,g41
03:55:50  47  ,sc_corr
03:55:50  48  FROM modsrc24
03:55:50  49  WHERE gattn IN('nup','up')
03:55:50  50  -- Use only rows which are older than 1 day:
03:55:50  51  AND 1+ydate < '&1'||' '||'&2'
03:55:50  52  AND pair = '&3'
03:55:50  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'18:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:55:50 SQL> 
03:55:50 SQL> -- rpt
03:55:50 SQL> 
03:55:50 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:55:50   2  
03:55:50 SQL> SELECT MAX(prdate) FROM bme
03:55:50   2  
03:55:50 SQL> -- Now build model from bme and score sme
03:55:50 SQL> @score1.sql gattn
03:55:50 SQL> --
03:55:50 SQL> -- score1.sql
03:55:50 SQL> --
03:55:50 SQL> 
03:55:50 SQL> -- I use this script to send 5 params to score.sql
03:55:50 SQL> -- which does the heavy lifting of creating an SVM model.
03:55:50 SQL> -- Then at the very end of this script I use the model
03:55:50 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:55:50 SQL> 
03:55:50 SQL> -- I call this script from 2 other scripts:
03:55:50 SQL> -- score1_5min.sql
03:55:50 SQL> -- score1_5min_gattn.sql
03:55:50 SQL> 
03:55:50 SQL> -- The 1st param is the name of the target attribute.
03:55:50 SQL> -- I like to call my target attributes either gatt or gattn.
03:55:50 SQL> 
03:55:50 SQL> -- Demo:
03:55:50 SQL> -- @score1.sql 'gatt'
03:55:50 SQL> -- @score1.sql 'gattn'
03:55:50 SQL> 
03:55:50 SQL> -- Now, I fill up svmc_apply_prep.
03:55:50 SQL> -- I use same model_name used in score.sql
03:55:50 SQL> DEFINE model_name = 'svmfx101'
03:55:50 SQL> DEFINE bldtable	= 'bme'
03:55:50 SQL> DEFINE scoretable = 'sme'
03:55:50 SQL> DEFINE case_id	= 'prdate'
03:55:50 SQL> -- Demo:
03:55:50 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:55:50 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:55:50 SQL> --
03:55:50 SQL> -- score.sql
03:55:50 SQL> --
03:55:50 SQL> 
03:55:50 SQL> -- usage: score.sql
03:55:50 SQL> 
03:55:50 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:55:50 SQL> 
03:55:50 SQL> -- DEFINE target	   = 'gatt'
03:55:50 SQL> -- DEFINE model_name = 'svmfx101'
03:55:50 SQL> -- DEFINE bldtable   = 'bme'
03:55:50 SQL> -- DEFINE scoretable = 'sme'
03:55:50 SQL> -- DEFINE case_id    = 'prdate'
03:55:50 SQL> 
03:55:50 SQL> DEFINE target	= '&1'
03:55:50 SQL> DEFINE model_name = '&2'
03:55:50 SQL> DEFINE bldtable	= '&3'
03:55:50 SQL> DEFINE scoretable = '&4'
03:55:50 SQL> DEFINE case_id	= '&5'
03:55:50 SQL> 
03:55:50 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:55:50 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:55:50 SQL> 
03:55:50 SQL> -- Builds an SVM model using pl/sql.
03:55:50 SQL> 
03:55:50 SQL> -----------------------------------------------------------------------
03:55:50 SQL> --			    BUILD THE MODEL
03:55:50 SQL> -----------------------------------------------------------------------
03:55:50 SQL> 
03:55:50 SQL> -- Cleanup old build data preparation objects for repeat runs
03:55:50 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:50 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
03:55:50 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:55:50 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:55:50 SQL> 
03:55:50 SQL> 
03:55:50 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:55:50 SQL> --
03:55:50 SQL> -- DROP	TABLE svmc_settings ;
03:55:50 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:55:50 SQL> -- DELETE svmc_settings;
03:55:50 SQL> 
03:55:50 SQL> -- The default classification algorithm is Naive Bayes. So override
03:55:50 SQL> -- this choice to SVM using a settings table.
03:55:50 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:55:50 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:55:50 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:55:50 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:55:50 SQL> -- models.
03:55:50 SQL> --
03:55:50 SQL> 
03:55:50 SQL> -- Do this once and then comment it out.
03:55:50 SQL> -- That makes script go faster.
03:55:50 SQL> -- BEGIN
03:55:50 SQL> -- -- Populate settings table
03:55:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:50 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:55:50 SQL> --
03:55:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:50 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:55:50 SQL> --
03:55:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:55:50 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:55:50 SQL> --   COMMIT;
03:55:50 SQL> -- END;
03:55:50 SQL> -- /
03:55:50 SQL> 
03:55:50 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:55:50 SQL> 
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:55:50 SQL> 
03:55:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:55:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:55:50 SQL> 
03:55:50 SQL> --------------------------------
03:55:50 SQL> -- PREPARE BUILD (TRAINING) DATA
03:55:50 SQL> --
03:55:50 SQL> 
03:55:50 SQL> -- 1. Missing Value treatment for all Predictors and
03:55:50 SQL> -- 2. Outlier Treatment and
03:55:50 SQL> -- 3. Normalization are performed below.
03:55:50 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:55:50 SQL> --    normalized here.
03:55:50 SQL> 
03:55:50 SQL> BEGIN
03:55:50   2  	-- Perform missing value treatment for all predictors
03:55:50   3  	-- create miss tables
03:55:50   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:55:50   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:55:50   6  
03:55:50   7  	-- populate miss tables
03:55:50   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:55:50   9  	  miss_table_name => 'svmc_miss_num',
03:55:50  10  	  data_table_name => '&bldtable',
03:55:50  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:50  12  
03:55:50  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:55:50  14  	  miss_table_name => 'svmc_miss_cat',
03:55:50  15  	  data_table_name => '&bldtable',
03:55:50  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:50  17  
03:55:50  18  	-- xform input data to replace missing values
03:55:50  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:55:50  20  	  miss_table_name => 'svmc_miss_num',
03:55:50  21  	  data_table_name => '&bldtable',
03:55:50  22  	  xform_view_name => 'xformed_build_miss_num');
03:55:50  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:55:50  24  	  miss_table_name => 'svmc_miss_cat',
03:55:50  25  	  data_table_name => '&bldtable',
03:55:50  26  	  xform_view_name => 'xformed_build_miss_cat');
03:55:50  27  
03:55:50  28  	-- Perform outlier treatment.
03:55:50  29  	-- create clip table
03:55:50  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:55:50  31  
03:55:50  32  	-- populate clip table
03:55:50  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:55:50  34  	  clip_table_name => 'svmc_clip',
03:55:50  35  	  data_table_name => '&bldtable',
03:55:50  36  	  tail_frac	  => 0.025,
03:55:50  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:50  38  
03:55:50  39  	-- xform input data to winsorized data
03:55:50  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:55:50  41  	  clip_table_name => 'svmc_clip',
03:55:50  42  	  data_table_name => '&bldtable',
03:55:50  43  	  xform_view_name => 'svmc_winsor');
03:55:50  44  
03:55:50  45  	-- create normalization table
03:55:50  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:55:50  47  
03:55:50  48  	-- populate normalization table based on winsorized data
03:55:50  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:55:50  50  	  norm_table_name => 'svmc_norm',
03:55:50  51  	  data_table_name => 'svmc_winsor',
03:55:50  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:55:50  53  
03:55:50  54  	-- normalize the original data
03:55:50  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:55:50  56  	  norm_table_name => 'svmc_norm',
03:55:50  57  	  data_table_name => '&bldtable',
03:55:50  58  	  xform_view_name => 'svmc_build_prep');
03:55:50  59  END;
03:55:50  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.65
03:55:53 SQL> 
03:55:53 SQL> ---------------------
03:55:53 SQL> -- CREATE A NEW MODEL
03:55:53 SQL> --
03:55:53 SQL> -- Cleanup old model with the same name for repeat runs
03:55:53 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:55:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:55:53   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.45
03:55:54 SQL> 
03:55:54 SQL> -- Build a new SVM Model
03:55:54 SQL> BEGIN
03:55:54   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:55:54   3  	  model_name	      => '&model_name',
03:55:54   4  	  mining_function     => dbms_data_mining.classification,
03:55:54   5  	  data_table_name     => 'svmc_build_prep',
03:55:54   6  	  case_id_column_name => '&case_id',
03:55:54   7  	  target_column_name  => '&target',
03:55:54   8  	  settings_table_name => 'svmc_settings');
03:55:54   9  END;
03:55:54  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.15
03:56:00 SQL> 
03:56:00 SQL> -----------------------------------------------------------------------
03:56:00 SQL> --			       APPLY/score THE MODEL
03:56:00 SQL> -----------------------------------------------------------------------
03:56:00 SQL> 
03:56:00 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:00 SQL> -----------------------
03:56:00 SQL> -- PREPARE SCORING DATA
03:56:00 SQL> --
03:56:00 SQL> -- If the data for model creation has been prepared, then the data
03:56:00 SQL> -- to be scored using the model must be prepared in the same manner
03:56:00 SQL> -- in order to obtain meaningful results.
03:56:00 SQL> --
03:56:00 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:00 SQL> -- 2. Normalization
03:56:00 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:00 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:00 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:00 SQL> --
03:56:00 SQL> BEGIN
03:56:00   2  	-- Xform Test data to replace missing values
03:56:00   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:00   4  	  miss_table_name => 'svmc_miss_num',
03:56:00   5  	  data_table_name => '&scoretable',
03:56:00   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:00   7  
03:56:00   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:00   9  	  miss_table_name => 'svmc_miss_cat',
03:56:00  10  	  data_table_name => '&scoretable',
03:56:00  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:00  12  
03:56:00  13  	-- Normalize the data to be scored
03:56:00  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:00  15  	  norm_table_name => 'svmc_norm',
03:56:00  16  	  data_table_name => '&scoretable',
03:56:00  17  	  xform_view_name => 'svmc_apply_prep');
03:56:00  18  END;
03:56:00  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
03:56:00 SQL> 
03:56:00 SQL> -- Maybe I already collected a score for this prdate.
03:56:00 SQL> -- DELETE it if I did:
03:56:00 SQL> DELETE svm24scores
03:56:00   2  WHERE score > 0
03:56:00   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:00   4  -- I need to supply the target attribute name:
03:56:00   5  AND targ = '&1'
03:56:00   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:56:00 SQL> 
03:56:00 SQL> -- We do a drumroll here:
03:56:00 SQL> 
03:56:00 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:00   2  SELECT
03:56:00   3  prdate
03:56:00   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:00   5  ,sysdate
03:56:00   6  ,SUBSTR(prdate,1,7)pair
03:56:00   7  ,SUBSTR(prdate,-19)ydate
03:56:00   8  ,'&1'
03:56:00   9  FROM svmc_apply_prep
03:56:00  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:56:00 SQL> @score1_5min.sql	      2011-01-19 14:55:00 eur_usd
03:56:00 SQL> --
03:56:00 SQL> -- score1_5min.sql
03:56:00 SQL> --
03:56:00 SQL> 
03:56:00 SQL> -- Demo:
03:56:00 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:56:00 SQL> 
03:56:00 SQL> CREATE OR REPLACE VIEW sme AS
03:56:00   2  SELECT
03:56:00   3  prdate
03:56:00   4  ,NULL gatt
03:56:00   5  ,g00
03:56:00   6  ,g01
03:56:00   7  ,g02
03:56:00   8  ,g03
03:56:00   9  ,g04
03:56:00  10  ,g05
03:56:00  11  ,g06
03:56:00  12  ,g07
03:56:00  13  ,g08
03:56:00  14  ,g09
03:56:00  15  ,g10
03:56:00  16  ,g11
03:56:00  17  ,g12
03:56:00  18  ,g13
03:56:00  19  ,g14
03:56:00  20  ,g15
03:56:00  21  ,g16
03:56:00  22  ,g17
03:56:00  23  ,g18
03:56:00  24  ,g19
03:56:00  25  ,g20
03:56:00  26  ,g21
03:56:00  27  ,g22
03:56:00  28  ,g23
03:56:00  29  ,g24
03:56:00  30  ,g25
03:56:00  31  ,g26
03:56:00  32  ,g27
03:56:00  33  ,g28
03:56:00  34  ,g29
03:56:00  35  ,g30
03:56:00  36  ,g31
03:56:00  37  ,g32
03:56:00  38  ,g33
03:56:00  39  ,g34
03:56:00  40  ,g35
03:56:00  41  ,g36
03:56:00  42  ,g37
03:56:00  43  ,g38
03:56:00  44  ,g39
03:56:00  45  ,g40
03:56:00  46  ,g41
03:56:00  47  ,s.sc_corr
03:56:00  48  FROM modsrc24
03:56:00  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:00  50  WHERE ydate = '&1'||' '||'&2'
03:56:00  51  AND pair = '&3'
03:56:00  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'14:55:00'AND ydate<'2011-01-19'||' '||'14:55:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'14:55:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:00 SQL> 
03:56:00 SQL> -- rpt
03:56:00 SQL> -- We should see just 1 row:
03:56:00 SQL> 
03:56:00 SQL> SELECT COUNT(prdate) FROM sme
03:56:00   2  
03:56:00 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:00   2  
03:56:00 SQL> 
03:56:00 SQL> -- Build the model:
03:56:00 SQL> CREATE OR REPLACE VIEW bme AS
03:56:00   2  SELECT
03:56:00   3  prdate
03:56:00   4  ,gatt
03:56:00   5  ,g00
03:56:00   6  ,g01
03:56:00   7  ,g02
03:56:00   8  ,g03
03:56:00   9  ,g04
03:56:00  10  ,g05
03:56:00  11  ,g06
03:56:00  12  ,g07
03:56:00  13  ,g08
03:56:00  14  ,g09
03:56:00  15  ,g10
03:56:00  16  ,g11
03:56:00  17  ,g12
03:56:00  18  ,g13
03:56:00  19  ,g14
03:56:00  20  ,g15
03:56:00  21  ,g16
03:56:00  22  ,g17
03:56:00  23  ,g18
03:56:00  24  ,g19
03:56:00  25  ,g20
03:56:00  26  ,g21
03:56:00  27  ,g22
03:56:00  28  ,g23
03:56:00  29  ,g24
03:56:00  30  ,g25
03:56:00  31  ,g26
03:56:00  32  ,g27
03:56:00  33  ,g28
03:56:00  34  ,g29
03:56:00  35  ,g30
03:56:00  36  ,g31
03:56:00  37  ,g32
03:56:00  38  ,g33
03:56:00  39  ,g34
03:56:00  40  ,g35
03:56:00  41  ,g36
03:56:00  42  ,g37
03:56:00  43  ,g38
03:56:00  44  ,g39
03:56:00  45  ,g40
03:56:00  46  ,g41
03:56:00  47  ,sc_corr
03:56:00  48  FROM modsrc24
03:56:00  49  WHERE gatt IN('nup','up')
03:56:00  50  -- Use only rows which are older than 1 day:
03:56:00  51  AND 1+ydate < '&1'||' '||'&2'
03:56:00  52  AND pair = '&3'
03:56:00  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'14:55:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:00 SQL> 
03:56:00 SQL> -- rpt
03:56:00 SQL> 
03:56:00 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:56:00   2  
03:56:00 SQL> SELECT MAX(prdate) FROM bme
03:56:00   2  
03:56:00 SQL> -- Now build model from bme and score sme
03:56:00 SQL> @score1.sql gatt
03:56:00 SQL> --
03:56:00 SQL> -- score1.sql
03:56:00 SQL> --
03:56:00 SQL> 
03:56:00 SQL> -- I use this script to send 5 params to score.sql
03:56:00 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:00 SQL> -- Then at the very end of this script I use the model
03:56:00 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:00 SQL> 
03:56:00 SQL> -- I call this script from 2 other scripts:
03:56:00 SQL> -- score1_5min.sql
03:56:00 SQL> -- score1_5min_gattn.sql
03:56:00 SQL> 
03:56:00 SQL> -- The 1st param is the name of the target attribute.
03:56:00 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:00 SQL> 
03:56:00 SQL> -- Demo:
03:56:00 SQL> -- @score1.sql 'gatt'
03:56:00 SQL> -- @score1.sql 'gattn'
03:56:00 SQL> 
03:56:00 SQL> -- Now, I fill up svmc_apply_prep.
03:56:00 SQL> -- I use same model_name used in score.sql
03:56:00 SQL> DEFINE model_name = 'svmfx101'
03:56:00 SQL> DEFINE bldtable	= 'bme'
03:56:00 SQL> DEFINE scoretable = 'sme'
03:56:00 SQL> DEFINE case_id	= 'prdate'
03:56:00 SQL> -- Demo:
03:56:00 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:00 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:00 SQL> --
03:56:00 SQL> -- score.sql
03:56:00 SQL> --
03:56:00 SQL> 
03:56:00 SQL> -- usage: score.sql
03:56:00 SQL> 
03:56:00 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:00 SQL> 
03:56:00 SQL> -- DEFINE target	   = 'gatt'
03:56:00 SQL> -- DEFINE model_name = 'svmfx101'
03:56:00 SQL> -- DEFINE bldtable   = 'bme'
03:56:00 SQL> -- DEFINE scoretable = 'sme'
03:56:00 SQL> -- DEFINE case_id    = 'prdate'
03:56:00 SQL> 
03:56:00 SQL> DEFINE target	= '&1'
03:56:00 SQL> DEFINE model_name = '&2'
03:56:00 SQL> DEFINE bldtable	= '&3'
03:56:00 SQL> DEFINE scoretable = '&4'
03:56:00 SQL> DEFINE case_id	= '&5'
03:56:00 SQL> 
03:56:00 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:00 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:00 SQL> 
03:56:00 SQL> -- Builds an SVM model using pl/sql.
03:56:00 SQL> 
03:56:00 SQL> -----------------------------------------------------------------------
03:56:00 SQL> --			    BUILD THE MODEL
03:56:00 SQL> -----------------------------------------------------------------------
03:56:00 SQL> 
03:56:00 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:00 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:00 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:56:00 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:56:00 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:00 SQL> 
03:56:00 SQL> 
03:56:00 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:00 SQL> --
03:56:00 SQL> -- DROP	TABLE svmc_settings ;
03:56:00 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:00 SQL> -- DELETE svmc_settings;
03:56:00 SQL> 
03:56:00 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:00 SQL> -- this choice to SVM using a settings table.
03:56:00 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:00 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:00 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:00 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:00 SQL> -- models.
03:56:00 SQL> --
03:56:00 SQL> 
03:56:00 SQL> -- Do this once and then comment it out.
03:56:00 SQL> -- That makes script go faster.
03:56:00 SQL> -- BEGIN
03:56:00 SQL> -- -- Populate settings table
03:56:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:00 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:00 SQL> --
03:56:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:00 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:00 SQL> --
03:56:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:00 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:00 SQL> --   COMMIT;
03:56:00 SQL> -- END;
03:56:00 SQL> -- /
03:56:00 SQL> 
03:56:00 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:00 SQL> 
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:00 SQL> 
03:56:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:00 SQL> 
03:56:00 SQL> --------------------------------
03:56:00 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:00 SQL> --
03:56:00 SQL> 
03:56:00 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:00 SQL> -- 2. Outlier Treatment and
03:56:00 SQL> -- 3. Normalization are performed below.
03:56:00 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:00 SQL> --    normalized here.
03:56:00 SQL> 
03:56:00 SQL> BEGIN
03:56:00   2  	-- Perform missing value treatment for all predictors
03:56:00   3  	-- create miss tables
03:56:00   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:00   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:00   6  
03:56:00   7  	-- populate miss tables
03:56:00   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:00   9  	  miss_table_name => 'svmc_miss_num',
03:56:00  10  	  data_table_name => '&bldtable',
03:56:00  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:00  12  
03:56:00  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:00  14  	  miss_table_name => 'svmc_miss_cat',
03:56:00  15  	  data_table_name => '&bldtable',
03:56:00  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:00  17  
03:56:00  18  	-- xform input data to replace missing values
03:56:00  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:00  20  	  miss_table_name => 'svmc_miss_num',
03:56:00  21  	  data_table_name => '&bldtable',
03:56:00  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:00  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:00  24  	  miss_table_name => 'svmc_miss_cat',
03:56:00  25  	  data_table_name => '&bldtable',
03:56:00  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:00  27  
03:56:00  28  	-- Perform outlier treatment.
03:56:00  29  	-- create clip table
03:56:00  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:00  31  
03:56:00  32  	-- populate clip table
03:56:00  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:00  34  	  clip_table_name => 'svmc_clip',
03:56:00  35  	  data_table_name => '&bldtable',
03:56:00  36  	  tail_frac	  => 0.025,
03:56:00  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:00  38  
03:56:00  39  	-- xform input data to winsorized data
03:56:00  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:00  41  	  clip_table_name => 'svmc_clip',
03:56:00  42  	  data_table_name => '&bldtable',
03:56:00  43  	  xform_view_name => 'svmc_winsor');
03:56:00  44  
03:56:00  45  	-- create normalization table
03:56:00  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:00  47  
03:56:00  48  	-- populate normalization table based on winsorized data
03:56:00  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:00  50  	  norm_table_name => 'svmc_norm',
03:56:00  51  	  data_table_name => 'svmc_winsor',
03:56:00  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:00  53  
03:56:00  54  	-- normalize the original data
03:56:00  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:00  56  	  norm_table_name => 'svmc_norm',
03:56:00  57  	  data_table_name => '&bldtable',
03:56:00  58  	  xform_view_name => 'svmc_build_prep');
03:56:00  59  END;
03:56:00  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.51
03:56:03 SQL> 
03:56:03 SQL> ---------------------
03:56:03 SQL> -- CREATE A NEW MODEL
03:56:03 SQL> --
03:56:03 SQL> -- Cleanup old model with the same name for repeat runs
03:56:03 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:56:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:03   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.46
03:56:04 SQL> 
03:56:04 SQL> -- Build a new SVM Model
03:56:04 SQL> BEGIN
03:56:04   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:56:04   3  	  model_name	      => '&model_name',
03:56:04   4  	  mining_function     => dbms_data_mining.classification,
03:56:04   5  	  data_table_name     => 'svmc_build_prep',
03:56:04   6  	  case_id_column_name => '&case_id',
03:56:04   7  	  target_column_name  => '&target',
03:56:04   8  	  settings_table_name => 'svmc_settings');
03:56:04   9  END;
03:56:04  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.14
03:56:08 SQL> 
03:56:08 SQL> -----------------------------------------------------------------------
03:56:08 SQL> --			       APPLY/score THE MODEL
03:56:08 SQL> -----------------------------------------------------------------------
03:56:08 SQL> 
03:56:08 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:56:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:08 SQL> -----------------------
03:56:08 SQL> -- PREPARE SCORING DATA
03:56:08 SQL> --
03:56:08 SQL> -- If the data for model creation has been prepared, then the data
03:56:08 SQL> -- to be scored using the model must be prepared in the same manner
03:56:08 SQL> -- in order to obtain meaningful results.
03:56:08 SQL> --
03:56:08 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:08 SQL> -- 2. Normalization
03:56:08 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:08 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:08 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:08 SQL> --
03:56:08 SQL> BEGIN
03:56:08   2  	-- Xform Test data to replace missing values
03:56:08   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:08   4  	  miss_table_name => 'svmc_miss_num',
03:56:08   5  	  data_table_name => '&scoretable',
03:56:08   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:08   7  
03:56:08   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:08   9  	  miss_table_name => 'svmc_miss_cat',
03:56:08  10  	  data_table_name => '&scoretable',
03:56:08  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:08  12  
03:56:08  13  	-- Normalize the data to be scored
03:56:08  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:08  15  	  norm_table_name => 'svmc_norm',
03:56:08  16  	  data_table_name => '&scoretable',
03:56:08  17  	  xform_view_name => 'svmc_apply_prep');
03:56:08  18  END;
03:56:08  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:56:09 SQL> 
03:56:09 SQL> -- Maybe I already collected a score for this prdate.
03:56:09 SQL> -- DELETE it if I did:
03:56:09 SQL> DELETE svm24scores
03:56:09   2  WHERE score > 0
03:56:09   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:09   4  -- I need to supply the target attribute name:
03:56:09   5  AND targ = '&1'
03:56:09   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:56:09 SQL> 
03:56:09 SQL> -- We do a drumroll here:
03:56:09 SQL> 
03:56:09 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:09   2  SELECT
03:56:09   3  prdate
03:56:09   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:09   5  ,sysdate
03:56:09   6  ,SUBSTR(prdate,1,7)pair
03:56:09   7  ,SUBSTR(prdate,-19)ydate
03:56:09   8  ,'&1'
03:56:09   9  FROM svmc_apply_prep
03:56:09  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:56:09 SQL> @score1_5min.sql	      2011-01-19 17:00:00 eur_usd
03:56:09 SQL> --
03:56:09 SQL> -- score1_5min.sql
03:56:09 SQL> --
03:56:09 SQL> 
03:56:09 SQL> -- Demo:
03:56:09 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:56:09 SQL> 
03:56:09 SQL> CREATE OR REPLACE VIEW sme AS
03:56:09   2  SELECT
03:56:09   3  prdate
03:56:09   4  ,NULL gatt
03:56:09   5  ,g00
03:56:09   6  ,g01
03:56:09   7  ,g02
03:56:09   8  ,g03
03:56:09   9  ,g04
03:56:09  10  ,g05
03:56:09  11  ,g06
03:56:09  12  ,g07
03:56:09  13  ,g08
03:56:09  14  ,g09
03:56:09  15  ,g10
03:56:09  16  ,g11
03:56:09  17  ,g12
03:56:09  18  ,g13
03:56:09  19  ,g14
03:56:09  20  ,g15
03:56:09  21  ,g16
03:56:09  22  ,g17
03:56:09  23  ,g18
03:56:09  24  ,g19
03:56:09  25  ,g20
03:56:09  26  ,g21
03:56:09  27  ,g22
03:56:09  28  ,g23
03:56:09  29  ,g24
03:56:09  30  ,g25
03:56:09  31  ,g26
03:56:09  32  ,g27
03:56:09  33  ,g28
03:56:09  34  ,g29
03:56:09  35  ,g30
03:56:09  36  ,g31
03:56:09  37  ,g32
03:56:09  38  ,g33
03:56:09  39  ,g34
03:56:09  40  ,g35
03:56:09  41  ,g36
03:56:09  42  ,g37
03:56:09  43  ,g38
03:56:09  44  ,g39
03:56:09  45  ,g40
03:56:09  46  ,g41
03:56:09  47  ,s.sc_corr
03:56:09  48  FROM modsrc24
03:56:09  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:09  50  WHERE ydate = '&1'||' '||'&2'
03:56:09  51  AND pair = '&3'
03:56:09  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'17:00:00'AND ydate<'2011-01-19'||' '||'17:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'17:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:56:09 SQL> 
03:56:09 SQL> -- rpt
03:56:09 SQL> -- We should see just 1 row:
03:56:09 SQL> 
03:56:09 SQL> SELECT COUNT(prdate) FROM sme
03:56:09   2  
03:56:09 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:09   2  
03:56:09 SQL> 
03:56:09 SQL> -- Build the model:
03:56:09 SQL> CREATE OR REPLACE VIEW bme AS
03:56:09   2  SELECT
03:56:09   3  prdate
03:56:09   4  ,gatt
03:56:09   5  ,g00
03:56:09   6  ,g01
03:56:09   7  ,g02
03:56:09   8  ,g03
03:56:09   9  ,g04
03:56:09  10  ,g05
03:56:09  11  ,g06
03:56:09  12  ,g07
03:56:09  13  ,g08
03:56:09  14  ,g09
03:56:09  15  ,g10
03:56:09  16  ,g11
03:56:09  17  ,g12
03:56:09  18  ,g13
03:56:09  19  ,g14
03:56:09  20  ,g15
03:56:09  21  ,g16
03:56:09  22  ,g17
03:56:09  23  ,g18
03:56:09  24  ,g19
03:56:09  25  ,g20
03:56:09  26  ,g21
03:56:09  27  ,g22
03:56:09  28  ,g23
03:56:09  29  ,g24
03:56:09  30  ,g25
03:56:09  31  ,g26
03:56:09  32  ,g27
03:56:09  33  ,g28
03:56:09  34  ,g29
03:56:09  35  ,g30
03:56:09  36  ,g31
03:56:09  37  ,g32
03:56:09  38  ,g33
03:56:09  39  ,g34
03:56:09  40  ,g35
03:56:09  41  ,g36
03:56:09  42  ,g37
03:56:09  43  ,g38
03:56:09  44  ,g39
03:56:09  45  ,g40
03:56:09  46  ,g41
03:56:09  47  ,sc_corr
03:56:09  48  FROM modsrc24
03:56:09  49  WHERE gatt IN('nup','up')
03:56:09  50  -- Use only rows which are older than 1 day:
03:56:09  51  AND 1+ydate < '&1'||' '||'&2'
03:56:09  52  AND pair = '&3'
03:56:09  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'17:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:56:09 SQL> 
03:56:09 SQL> -- rpt
03:56:09 SQL> 
03:56:09 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:56:09   2  
03:56:09 SQL> SELECT MAX(prdate) FROM bme
03:56:09   2  
03:56:09 SQL> -- Now build model from bme and score sme
03:56:09 SQL> @score1.sql gatt
03:56:09 SQL> --
03:56:09 SQL> -- score1.sql
03:56:09 SQL> --
03:56:09 SQL> 
03:56:09 SQL> -- I use this script to send 5 params to score.sql
03:56:09 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:09 SQL> -- Then at the very end of this script I use the model
03:56:09 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:09 SQL> 
03:56:09 SQL> -- I call this script from 2 other scripts:
03:56:09 SQL> -- score1_5min.sql
03:56:09 SQL> -- score1_5min_gattn.sql
03:56:09 SQL> 
03:56:09 SQL> -- The 1st param is the name of the target attribute.
03:56:09 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:09 SQL> 
03:56:09 SQL> -- Demo:
03:56:09 SQL> -- @score1.sql 'gatt'
03:56:09 SQL> -- @score1.sql 'gattn'
03:56:09 SQL> 
03:56:09 SQL> -- Now, I fill up svmc_apply_prep.
03:56:09 SQL> -- I use same model_name used in score.sql
03:56:09 SQL> DEFINE model_name = 'svmfx101'
03:56:09 SQL> DEFINE bldtable	= 'bme'
03:56:09 SQL> DEFINE scoretable = 'sme'
03:56:09 SQL> DEFINE case_id	= 'prdate'
03:56:09 SQL> -- Demo:
03:56:09 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:09 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:09 SQL> --
03:56:09 SQL> -- score.sql
03:56:09 SQL> --
03:56:09 SQL> 
03:56:09 SQL> -- usage: score.sql
03:56:09 SQL> 
03:56:09 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:09 SQL> 
03:56:09 SQL> -- DEFINE target	   = 'gatt'
03:56:09 SQL> -- DEFINE model_name = 'svmfx101'
03:56:09 SQL> -- DEFINE bldtable   = 'bme'
03:56:09 SQL> -- DEFINE scoretable = 'sme'
03:56:09 SQL> -- DEFINE case_id    = 'prdate'
03:56:09 SQL> 
03:56:09 SQL> DEFINE target	= '&1'
03:56:09 SQL> DEFINE model_name = '&2'
03:56:09 SQL> DEFINE bldtable	= '&3'
03:56:09 SQL> DEFINE scoretable = '&4'
03:56:09 SQL> DEFINE case_id	= '&5'
03:56:09 SQL> 
03:56:09 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:09 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:09 SQL> 
03:56:09 SQL> -- Builds an SVM model using pl/sql.
03:56:09 SQL> 
03:56:09 SQL> -----------------------------------------------------------------------
03:56:09 SQL> --			    BUILD THE MODEL
03:56:09 SQL> -----------------------------------------------------------------------
03:56:09 SQL> 
03:56:09 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:09 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:09 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
03:56:09 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:09 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:09 SQL> 
03:56:09 SQL> 
03:56:09 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:09 SQL> --
03:56:09 SQL> -- DROP	TABLE svmc_settings ;
03:56:09 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:09 SQL> -- DELETE svmc_settings;
03:56:09 SQL> 
03:56:09 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:09 SQL> -- this choice to SVM using a settings table.
03:56:09 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:09 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:09 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:09 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:09 SQL> -- models.
03:56:09 SQL> --
03:56:09 SQL> 
03:56:09 SQL> -- Do this once and then comment it out.
03:56:09 SQL> -- That makes script go faster.
03:56:09 SQL> -- BEGIN
03:56:09 SQL> -- -- Populate settings table
03:56:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:09 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:09 SQL> --
03:56:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:09 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:09 SQL> --
03:56:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:09 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:09 SQL> --   COMMIT;
03:56:09 SQL> -- END;
03:56:09 SQL> -- /
03:56:09 SQL> 
03:56:09 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:09 SQL> 
03:56:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:56:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:56:09 SQL> 
03:56:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:56:09 SQL> 
03:56:09 SQL> --------------------------------
03:56:09 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:09 SQL> --
03:56:09 SQL> 
03:56:09 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:09 SQL> -- 2. Outlier Treatment and
03:56:09 SQL> -- 3. Normalization are performed below.
03:56:09 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:09 SQL> --    normalized here.
03:56:09 SQL> 
03:56:09 SQL> BEGIN
03:56:09   2  	-- Perform missing value treatment for all predictors
03:56:09   3  	-- create miss tables
03:56:09   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:09   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:09   6  
03:56:09   7  	-- populate miss tables
03:56:09   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:09   9  	  miss_table_name => 'svmc_miss_num',
03:56:09  10  	  data_table_name => '&bldtable',
03:56:09  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:09  12  
03:56:09  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:09  14  	  miss_table_name => 'svmc_miss_cat',
03:56:09  15  	  data_table_name => '&bldtable',
03:56:09  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:09  17  
03:56:09  18  	-- xform input data to replace missing values
03:56:09  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:09  20  	  miss_table_name => 'svmc_miss_num',
03:56:09  21  	  data_table_name => '&bldtable',
03:56:09  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:09  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:09  24  	  miss_table_name => 'svmc_miss_cat',
03:56:09  25  	  data_table_name => '&bldtable',
03:56:09  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:09  27  
03:56:09  28  	-- Perform outlier treatment.
03:56:09  29  	-- create clip table
03:56:09  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:09  31  
03:56:09  32  	-- populate clip table
03:56:09  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:09  34  	  clip_table_name => 'svmc_clip',
03:56:09  35  	  data_table_name => '&bldtable',
03:56:09  36  	  tail_frac	  => 0.025,
03:56:09  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:09  38  
03:56:09  39  	-- xform input data to winsorized data
03:56:09  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:09  41  	  clip_table_name => 'svmc_clip',
03:56:09  42  	  data_table_name => '&bldtable',
03:56:09  43  	  xform_view_name => 'svmc_winsor');
03:56:09  44  
03:56:09  45  	-- create normalization table
03:56:09  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:09  47  
03:56:09  48  	-- populate normalization table based on winsorized data
03:56:09  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:09  50  	  norm_table_name => 'svmc_norm',
03:56:09  51  	  data_table_name => 'svmc_winsor',
03:56:09  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:09  53  
03:56:09  54  	-- normalize the original data
03:56:09  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:09  56  	  norm_table_name => 'svmc_norm',
03:56:09  57  	  data_table_name => '&bldtable',
03:56:09  58  	  xform_view_name => 'svmc_build_prep');
03:56:09  59  END;
03:56:09  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.53
03:56:12 SQL> 
03:56:12 SQL> ---------------------
03:56:12 SQL> -- CREATE A NEW MODEL
03:56:12 SQL> --
03:56:12 SQL> -- Cleanup old model with the same name for repeat runs
03:56:12 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:56:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:12   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.37
03:56:13 SQL> 
03:56:13 SQL> -- Build a new SVM Model
03:56:13 SQL> BEGIN
03:56:13   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:56:13   3  	  model_name	      => '&model_name',
03:56:13   4  	  mining_function     => dbms_data_mining.classification,
03:56:13   5  	  data_table_name     => 'svmc_build_prep',
03:56:13   6  	  case_id_column_name => '&case_id',
03:56:13   7  	  target_column_name  => '&target',
03:56:13   8  	  settings_table_name => 'svmc_settings');
03:56:13   9  END;
03:56:13  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.93
03:56:17 SQL> 
03:56:17 SQL> -----------------------------------------------------------------------
03:56:17 SQL> --			       APPLY/score THE MODEL
03:56:17 SQL> -----------------------------------------------------------------------
03:56:17 SQL> 
03:56:17 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:17 SQL> -----------------------
03:56:17 SQL> -- PREPARE SCORING DATA
03:56:17 SQL> --
03:56:17 SQL> -- If the data for model creation has been prepared, then the data
03:56:17 SQL> -- to be scored using the model must be prepared in the same manner
03:56:17 SQL> -- in order to obtain meaningful results.
03:56:17 SQL> --
03:56:17 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:17 SQL> -- 2. Normalization
03:56:17 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:17 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:17 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:17 SQL> --
03:56:17 SQL> BEGIN
03:56:17   2  	-- Xform Test data to replace missing values
03:56:17   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:17   4  	  miss_table_name => 'svmc_miss_num',
03:56:17   5  	  data_table_name => '&scoretable',
03:56:17   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:17   7  
03:56:17   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:17   9  	  miss_table_name => 'svmc_miss_cat',
03:56:17  10  	  data_table_name => '&scoretable',
03:56:17  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:17  12  
03:56:17  13  	-- Normalize the data to be scored
03:56:17  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:17  15  	  norm_table_name => 'svmc_norm',
03:56:17  16  	  data_table_name => '&scoretable',
03:56:17  17  	  xform_view_name => 'svmc_apply_prep');
03:56:17  18  END;
03:56:17  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:56:17 SQL> 
03:56:17 SQL> -- Maybe I already collected a score for this prdate.
03:56:17 SQL> -- DELETE it if I did:
03:56:17 SQL> DELETE svm24scores
03:56:17   2  WHERE score > 0
03:56:17   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:17   4  -- I need to supply the target attribute name:
03:56:17   5  AND targ = '&1'
03:56:17   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:56:17 SQL> 
03:56:17 SQL> -- We do a drumroll here:
03:56:17 SQL> 
03:56:17 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:17   2  SELECT
03:56:17   3  prdate
03:56:17   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:17   5  ,sysdate
03:56:17   6  ,SUBSTR(prdate,1,7)pair
03:56:17   7  ,SUBSTR(prdate,-19)ydate
03:56:17   8  ,'&1'
03:56:17   9  FROM svmc_apply_prep
03:56:17  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:56:17 SQL> @score1_5min.sql	      2011-01-19 18:30:00 eur_usd
03:56:17 SQL> --
03:56:17 SQL> -- score1_5min.sql
03:56:17 SQL> --
03:56:17 SQL> 
03:56:17 SQL> -- Demo:
03:56:17 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:56:17 SQL> 
03:56:17 SQL> CREATE OR REPLACE VIEW sme AS
03:56:17   2  SELECT
03:56:17   3  prdate
03:56:17   4  ,NULL gatt
03:56:17   5  ,g00
03:56:17   6  ,g01
03:56:17   7  ,g02
03:56:17   8  ,g03
03:56:17   9  ,g04
03:56:17  10  ,g05
03:56:17  11  ,g06
03:56:17  12  ,g07
03:56:17  13  ,g08
03:56:17  14  ,g09
03:56:17  15  ,g10
03:56:17  16  ,g11
03:56:17  17  ,g12
03:56:17  18  ,g13
03:56:17  19  ,g14
03:56:17  20  ,g15
03:56:17  21  ,g16
03:56:17  22  ,g17
03:56:17  23  ,g18
03:56:17  24  ,g19
03:56:17  25  ,g20
03:56:17  26  ,g21
03:56:17  27  ,g22
03:56:17  28  ,g23
03:56:17  29  ,g24
03:56:17  30  ,g25
03:56:17  31  ,g26
03:56:17  32  ,g27
03:56:17  33  ,g28
03:56:17  34  ,g29
03:56:17  35  ,g30
03:56:17  36  ,g31
03:56:17  37  ,g32
03:56:17  38  ,g33
03:56:17  39  ,g34
03:56:17  40  ,g35
03:56:17  41  ,g36
03:56:17  42  ,g37
03:56:17  43  ,g38
03:56:17  44  ,g39
03:56:17  45  ,g40
03:56:17  46  ,g41
03:56:17  47  ,s.sc_corr
03:56:17  48  FROM modsrc24
03:56:17  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:17  50  WHERE ydate = '&1'||' '||'&2'
03:56:17  51  AND pair = '&3'
03:56:17  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'18:30:00'AND ydate<'2011-01-19'||' '||'18:30:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'18:30:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:56:17 SQL> 
03:56:17 SQL> -- rpt
03:56:17 SQL> -- We should see just 1 row:
03:56:17 SQL> 
03:56:17 SQL> SELECT COUNT(prdate) FROM sme
03:56:17   2  
03:56:17 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:17   2  
03:56:17 SQL> 
03:56:17 SQL> -- Build the model:
03:56:17 SQL> CREATE OR REPLACE VIEW bme AS
03:56:17   2  SELECT
03:56:17   3  prdate
03:56:17   4  ,gatt
03:56:17   5  ,g00
03:56:17   6  ,g01
03:56:17   7  ,g02
03:56:17   8  ,g03
03:56:17   9  ,g04
03:56:17  10  ,g05
03:56:17  11  ,g06
03:56:17  12  ,g07
03:56:17  13  ,g08
03:56:17  14  ,g09
03:56:17  15  ,g10
03:56:17  16  ,g11
03:56:17  17  ,g12
03:56:17  18  ,g13
03:56:17  19  ,g14
03:56:17  20  ,g15
03:56:17  21  ,g16
03:56:17  22  ,g17
03:56:17  23  ,g18
03:56:17  24  ,g19
03:56:17  25  ,g20
03:56:17  26  ,g21
03:56:17  27  ,g22
03:56:17  28  ,g23
03:56:17  29  ,g24
03:56:17  30  ,g25
03:56:17  31  ,g26
03:56:17  32  ,g27
03:56:17  33  ,g28
03:56:17  34  ,g29
03:56:17  35  ,g30
03:56:17  36  ,g31
03:56:17  37  ,g32
03:56:17  38  ,g33
03:56:17  39  ,g34
03:56:17  40  ,g35
03:56:17  41  ,g36
03:56:17  42  ,g37
03:56:17  43  ,g38
03:56:17  44  ,g39
03:56:17  45  ,g40
03:56:17  46  ,g41
03:56:17  47  ,sc_corr
03:56:17  48  FROM modsrc24
03:56:17  49  WHERE gatt IN('nup','up')
03:56:17  50  -- Use only rows which are older than 1 day:
03:56:17  51  AND 1+ydate < '&1'||' '||'&2'
03:56:17  52  AND pair = '&3'
03:56:17  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'18:30:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:56:17 SQL> 
03:56:17 SQL> -- rpt
03:56:17 SQL> 
03:56:17 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:56:17   2  
03:56:17 SQL> SELECT MAX(prdate) FROM bme
03:56:17   2  
03:56:17 SQL> -- Now build model from bme and score sme
03:56:17 SQL> @score1.sql gatt
03:56:17 SQL> --
03:56:17 SQL> -- score1.sql
03:56:17 SQL> --
03:56:17 SQL> 
03:56:17 SQL> -- I use this script to send 5 params to score.sql
03:56:17 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:17 SQL> -- Then at the very end of this script I use the model
03:56:17 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:17 SQL> 
03:56:17 SQL> -- I call this script from 2 other scripts:
03:56:17 SQL> -- score1_5min.sql
03:56:17 SQL> -- score1_5min_gattn.sql
03:56:17 SQL> 
03:56:17 SQL> -- The 1st param is the name of the target attribute.
03:56:17 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:17 SQL> 
03:56:17 SQL> -- Demo:
03:56:17 SQL> -- @score1.sql 'gatt'
03:56:17 SQL> -- @score1.sql 'gattn'
03:56:17 SQL> 
03:56:17 SQL> -- Now, I fill up svmc_apply_prep.
03:56:17 SQL> -- I use same model_name used in score.sql
03:56:17 SQL> DEFINE model_name = 'svmfx101'
03:56:17 SQL> DEFINE bldtable	= 'bme'
03:56:17 SQL> DEFINE scoretable = 'sme'
03:56:17 SQL> DEFINE case_id	= 'prdate'
03:56:17 SQL> -- Demo:
03:56:17 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:17 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:17 SQL> --
03:56:17 SQL> -- score.sql
03:56:17 SQL> --
03:56:17 SQL> 
03:56:17 SQL> -- usage: score.sql
03:56:17 SQL> 
03:56:17 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:17 SQL> 
03:56:17 SQL> -- DEFINE target	   = 'gatt'
03:56:17 SQL> -- DEFINE model_name = 'svmfx101'
03:56:17 SQL> -- DEFINE bldtable   = 'bme'
03:56:17 SQL> -- DEFINE scoretable = 'sme'
03:56:17 SQL> -- DEFINE case_id    = 'prdate'
03:56:17 SQL> 
03:56:17 SQL> DEFINE target	= '&1'
03:56:17 SQL> DEFINE model_name = '&2'
03:56:17 SQL> DEFINE bldtable	= '&3'
03:56:17 SQL> DEFINE scoretable = '&4'
03:56:17 SQL> DEFINE case_id	= '&5'
03:56:17 SQL> 
03:56:17 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:17 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:17 SQL> 
03:56:17 SQL> -- Builds an SVM model using pl/sql.
03:56:17 SQL> 
03:56:17 SQL> -----------------------------------------------------------------------
03:56:17 SQL> --			    BUILD THE MODEL
03:56:17 SQL> -----------------------------------------------------------------------
03:56:17 SQL> 
03:56:17 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:17 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:17 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:56:17 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:56:17 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:17 SQL> 
03:56:17 SQL> 
03:56:17 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:17 SQL> --
03:56:17 SQL> -- DROP	TABLE svmc_settings ;
03:56:17 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:17 SQL> -- DELETE svmc_settings;
03:56:17 SQL> 
03:56:17 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:17 SQL> -- this choice to SVM using a settings table.
03:56:17 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:17 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:17 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:17 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:17 SQL> -- models.
03:56:17 SQL> --
03:56:17 SQL> 
03:56:17 SQL> -- Do this once and then comment it out.
03:56:17 SQL> -- That makes script go faster.
03:56:17 SQL> -- BEGIN
03:56:17 SQL> -- -- Populate settings table
03:56:17 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:17 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:17 SQL> --
03:56:17 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:17 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:17 SQL> --
03:56:17 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:17 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:17 SQL> --   COMMIT;
03:56:17 SQL> -- END;
03:56:17 SQL> -- /
03:56:17 SQL> 
03:56:17 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:17 SQL> 
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:17 SQL> 
03:56:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:56:17 SQL> 
03:56:17 SQL> --------------------------------
03:56:17 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:17 SQL> --
03:56:17 SQL> 
03:56:17 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:17 SQL> -- 2. Outlier Treatment and
03:56:17 SQL> -- 3. Normalization are performed below.
03:56:17 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:17 SQL> --    normalized here.
03:56:17 SQL> 
03:56:17 SQL> BEGIN
03:56:17   2  	-- Perform missing value treatment for all predictors
03:56:17   3  	-- create miss tables
03:56:17   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:17   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:17   6  
03:56:17   7  	-- populate miss tables
03:56:17   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:17   9  	  miss_table_name => 'svmc_miss_num',
03:56:17  10  	  data_table_name => '&bldtable',
03:56:17  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:17  12  
03:56:17  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:17  14  	  miss_table_name => 'svmc_miss_cat',
03:56:17  15  	  data_table_name => '&bldtable',
03:56:17  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:17  17  
03:56:17  18  	-- xform input data to replace missing values
03:56:17  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:17  20  	  miss_table_name => 'svmc_miss_num',
03:56:17  21  	  data_table_name => '&bldtable',
03:56:17  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:17  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:17  24  	  miss_table_name => 'svmc_miss_cat',
03:56:17  25  	  data_table_name => '&bldtable',
03:56:17  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:17  27  
03:56:17  28  	-- Perform outlier treatment.
03:56:17  29  	-- create clip table
03:56:17  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:17  31  
03:56:17  32  	-- populate clip table
03:56:17  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:17  34  	  clip_table_name => 'svmc_clip',
03:56:17  35  	  data_table_name => '&bldtable',
03:56:17  36  	  tail_frac	  => 0.025,
03:56:17  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:17  38  
03:56:17  39  	-- xform input data to winsorized data
03:56:17  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:17  41  	  clip_table_name => 'svmc_clip',
03:56:17  42  	  data_table_name => '&bldtable',
03:56:17  43  	  xform_view_name => 'svmc_winsor');
03:56:17  44  
03:56:17  45  	-- create normalization table
03:56:17  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:17  47  
03:56:17  48  	-- populate normalization table based on winsorized data
03:56:17  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:17  50  	  norm_table_name => 'svmc_norm',
03:56:17  51  	  data_table_name => 'svmc_winsor',
03:56:17  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:17  53  
03:56:17  54  	-- normalize the original data
03:56:17  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:17  56  	  norm_table_name => 'svmc_norm',
03:56:17  57  	  data_table_name => '&bldtable',
03:56:17  58  	  xform_view_name => 'svmc_build_prep');
03:56:17  59  END;
03:56:17  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.52
03:56:20 SQL> 
03:56:20 SQL> ---------------------
03:56:20 SQL> -- CREATE A NEW MODEL
03:56:20 SQL> --
03:56:20 SQL> -- Cleanup old model with the same name for repeat runs
03:56:20 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:56:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:20   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.49
03:56:22 SQL> 
03:56:22 SQL> -- Build a new SVM Model
03:56:22 SQL> BEGIN
03:56:22   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:56:22   3  	  model_name	      => '&model_name',
03:56:22   4  	  mining_function     => dbms_data_mining.classification,
03:56:22   5  	  data_table_name     => 'svmc_build_prep',
03:56:22   6  	  case_id_column_name => '&case_id',
03:56:22   7  	  target_column_name  => '&target',
03:56:22   8  	  settings_table_name => 'svmc_settings');
03:56:22   9  END;
03:56:22  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.97
03:56:25 SQL> 
03:56:25 SQL> -----------------------------------------------------------------------
03:56:25 SQL> --			       APPLY/score THE MODEL
03:56:25 SQL> -----------------------------------------------------------------------
03:56:25 SQL> 
03:56:25 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:26 SQL> -----------------------
03:56:26 SQL> -- PREPARE SCORING DATA
03:56:26 SQL> --
03:56:26 SQL> -- If the data for model creation has been prepared, then the data
03:56:26 SQL> -- to be scored using the model must be prepared in the same manner
03:56:26 SQL> -- in order to obtain meaningful results.
03:56:26 SQL> --
03:56:26 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:26 SQL> -- 2. Normalization
03:56:26 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:26 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:26 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:26 SQL> --
03:56:26 SQL> BEGIN
03:56:26   2  	-- Xform Test data to replace missing values
03:56:26   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:26   4  	  miss_table_name => 'svmc_miss_num',
03:56:26   5  	  data_table_name => '&scoretable',
03:56:26   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:26   7  
03:56:26   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:26   9  	  miss_table_name => 'svmc_miss_cat',
03:56:26  10  	  data_table_name => '&scoretable',
03:56:26  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:26  12  
03:56:26  13  	-- Normalize the data to be scored
03:56:26  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:26  15  	  norm_table_name => 'svmc_norm',
03:56:26  16  	  data_table_name => '&scoretable',
03:56:26  17  	  xform_view_name => 'svmc_apply_prep');
03:56:26  18  END;
03:56:26  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:56:26 SQL> 
03:56:26 SQL> -- Maybe I already collected a score for this prdate.
03:56:26 SQL> -- DELETE it if I did:
03:56:26 SQL> DELETE svm24scores
03:56:26   2  WHERE score > 0
03:56:26   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:26   4  -- I need to supply the target attribute name:
03:56:26   5  AND targ = '&1'
03:56:26   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.03
03:56:26 SQL> 
03:56:26 SQL> -- We do a drumroll here:
03:56:26 SQL> 
03:56:26 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:26   2  SELECT
03:56:26   3  prdate
03:56:26   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:26   5  ,sysdate
03:56:26   6  ,SUBSTR(prdate,1,7)pair
03:56:26   7  ,SUBSTR(prdate,-19)ydate
03:56:26   8  ,'&1'
03:56:26   9  FROM svmc_apply_prep
03:56:26  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:56:26 SQL> @score1_5min.sql	      2011-01-27 10:45:00 eur_usd
03:56:26 SQL> --
03:56:26 SQL> -- score1_5min.sql
03:56:26 SQL> --
03:56:26 SQL> 
03:56:26 SQL> -- Demo:
03:56:26 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:56:26 SQL> 
03:56:26 SQL> CREATE OR REPLACE VIEW sme AS
03:56:26   2  SELECT
03:56:26   3  prdate
03:56:26   4  ,NULL gatt
03:56:26   5  ,g00
03:56:26   6  ,g01
03:56:26   7  ,g02
03:56:26   8  ,g03
03:56:26   9  ,g04
03:56:26  10  ,g05
03:56:26  11  ,g06
03:56:26  12  ,g07
03:56:26  13  ,g08
03:56:26  14  ,g09
03:56:26  15  ,g10
03:56:26  16  ,g11
03:56:26  17  ,g12
03:56:26  18  ,g13
03:56:26  19  ,g14
03:56:26  20  ,g15
03:56:26  21  ,g16
03:56:26  22  ,g17
03:56:26  23  ,g18
03:56:26  24  ,g19
03:56:26  25  ,g20
03:56:26  26  ,g21
03:56:26  27  ,g22
03:56:26  28  ,g23
03:56:26  29  ,g24
03:56:26  30  ,g25
03:56:26  31  ,g26
03:56:26  32  ,g27
03:56:26  33  ,g28
03:56:26  34  ,g29
03:56:26  35  ,g30
03:56:26  36  ,g31
03:56:26  37  ,g32
03:56:26  38  ,g33
03:56:26  39  ,g34
03:56:26  40  ,g35
03:56:26  41  ,g36
03:56:26  42  ,g37
03:56:26  43  ,g38
03:56:26  44  ,g39
03:56:26  45  ,g40
03:56:26  46  ,g41
03:56:26  47  ,s.sc_corr
03:56:26  48  FROM modsrc24
03:56:26  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:26  50  WHERE ydate = '&1'||' '||'&2'
03:56:26  51  AND pair = '&3'
03:56:26  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'10:45:00'AND ydate<'2011-01-27'||' '||'10:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'10:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:56:26 SQL> 
03:56:26 SQL> -- rpt
03:56:26 SQL> -- We should see just 1 row:
03:56:26 SQL> 
03:56:26 SQL> SELECT COUNT(prdate) FROM sme
03:56:26   2  
03:56:26 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:26   2  
03:56:26 SQL> 
03:56:26 SQL> -- Build the model:
03:56:26 SQL> CREATE OR REPLACE VIEW bme AS
03:56:26   2  SELECT
03:56:26   3  prdate
03:56:26   4  ,gatt
03:56:26   5  ,g00
03:56:26   6  ,g01
03:56:26   7  ,g02
03:56:26   8  ,g03
03:56:26   9  ,g04
03:56:26  10  ,g05
03:56:26  11  ,g06
03:56:26  12  ,g07
03:56:26  13  ,g08
03:56:26  14  ,g09
03:56:26  15  ,g10
03:56:26  16  ,g11
03:56:26  17  ,g12
03:56:26  18  ,g13
03:56:26  19  ,g14
03:56:26  20  ,g15
03:56:26  21  ,g16
03:56:26  22  ,g17
03:56:26  23  ,g18
03:56:26  24  ,g19
03:56:26  25  ,g20
03:56:26  26  ,g21
03:56:26  27  ,g22
03:56:26  28  ,g23
03:56:26  29  ,g24
03:56:26  30  ,g25
03:56:26  31  ,g26
03:56:26  32  ,g27
03:56:26  33  ,g28
03:56:26  34  ,g29
03:56:26  35  ,g30
03:56:26  36  ,g31
03:56:26  37  ,g32
03:56:26  38  ,g33
03:56:26  39  ,g34
03:56:26  40  ,g35
03:56:26  41  ,g36
03:56:26  42  ,g37
03:56:26  43  ,g38
03:56:26  44  ,g39
03:56:26  45  ,g40
03:56:26  46  ,g41
03:56:26  47  ,sc_corr
03:56:26  48  FROM modsrc24
03:56:26  49  WHERE gatt IN('nup','up')
03:56:26  50  -- Use only rows which are older than 1 day:
03:56:26  51  AND 1+ydate < '&1'||' '||'&2'
03:56:26  52  AND pair = '&3'
03:56:26  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'10:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:26 SQL> 
03:56:26 SQL> -- rpt
03:56:26 SQL> 
03:56:26 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:56:26   2  
03:56:26 SQL> SELECT MAX(prdate) FROM bme
03:56:26   2  
03:56:26 SQL> -- Now build model from bme and score sme
03:56:26 SQL> @score1.sql gatt
03:56:26 SQL> --
03:56:26 SQL> -- score1.sql
03:56:26 SQL> --
03:56:26 SQL> 
03:56:26 SQL> -- I use this script to send 5 params to score.sql
03:56:26 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:26 SQL> -- Then at the very end of this script I use the model
03:56:26 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:26 SQL> 
03:56:26 SQL> -- I call this script from 2 other scripts:
03:56:26 SQL> -- score1_5min.sql
03:56:26 SQL> -- score1_5min_gattn.sql
03:56:26 SQL> 
03:56:26 SQL> -- The 1st param is the name of the target attribute.
03:56:26 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:26 SQL> 
03:56:26 SQL> -- Demo:
03:56:26 SQL> -- @score1.sql 'gatt'
03:56:26 SQL> -- @score1.sql 'gattn'
03:56:26 SQL> 
03:56:26 SQL> -- Now, I fill up svmc_apply_prep.
03:56:26 SQL> -- I use same model_name used in score.sql
03:56:26 SQL> DEFINE model_name = 'svmfx101'
03:56:26 SQL> DEFINE bldtable	= 'bme'
03:56:26 SQL> DEFINE scoretable = 'sme'
03:56:26 SQL> DEFINE case_id	= 'prdate'
03:56:26 SQL> -- Demo:
03:56:26 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:26 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:26 SQL> --
03:56:26 SQL> -- score.sql
03:56:26 SQL> --
03:56:26 SQL> 
03:56:26 SQL> -- usage: score.sql
03:56:26 SQL> 
03:56:26 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:26 SQL> 
03:56:26 SQL> -- DEFINE target	   = 'gatt'
03:56:26 SQL> -- DEFINE model_name = 'svmfx101'
03:56:26 SQL> -- DEFINE bldtable   = 'bme'
03:56:26 SQL> -- DEFINE scoretable = 'sme'
03:56:26 SQL> -- DEFINE case_id    = 'prdate'
03:56:26 SQL> 
03:56:26 SQL> DEFINE target	= '&1'
03:56:26 SQL> DEFINE model_name = '&2'
03:56:26 SQL> DEFINE bldtable	= '&3'
03:56:26 SQL> DEFINE scoretable = '&4'
03:56:26 SQL> DEFINE case_id	= '&5'
03:56:26 SQL> 
03:56:26 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:26 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:26 SQL> 
03:56:26 SQL> -- Builds an SVM model using pl/sql.
03:56:26 SQL> 
03:56:26 SQL> -----------------------------------------------------------------------
03:56:26 SQL> --			    BUILD THE MODEL
03:56:26 SQL> -----------------------------------------------------------------------
03:56:26 SQL> 
03:56:26 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:26 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:56:26 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:56:26 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:26 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:26 SQL> 
03:56:26 SQL> 
03:56:26 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:26 SQL> --
03:56:26 SQL> -- DROP	TABLE svmc_settings ;
03:56:26 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:26 SQL> -- DELETE svmc_settings;
03:56:26 SQL> 
03:56:26 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:26 SQL> -- this choice to SVM using a settings table.
03:56:26 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:26 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:26 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:26 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:26 SQL> -- models.
03:56:26 SQL> --
03:56:26 SQL> 
03:56:26 SQL> -- Do this once and then comment it out.
03:56:26 SQL> -- That makes script go faster.
03:56:26 SQL> -- BEGIN
03:56:26 SQL> -- -- Populate settings table
03:56:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:26 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:26 SQL> --
03:56:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:26 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:26 SQL> --
03:56:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:26 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:26 SQL> --   COMMIT;
03:56:26 SQL> -- END;
03:56:26 SQL> -- /
03:56:26 SQL> 
03:56:26 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:26 SQL> 
03:56:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:56:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:26 SQL> 
03:56:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:26 SQL> 
03:56:26 SQL> --------------------------------
03:56:26 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:26 SQL> --
03:56:26 SQL> 
03:56:26 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:26 SQL> -- 2. Outlier Treatment and
03:56:26 SQL> -- 3. Normalization are performed below.
03:56:26 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:26 SQL> --    normalized here.
03:56:26 SQL> 
03:56:26 SQL> BEGIN
03:56:26   2  	-- Perform missing value treatment for all predictors
03:56:26   3  	-- create miss tables
03:56:26   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:26   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:26   6  
03:56:26   7  	-- populate miss tables
03:56:26   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:26   9  	  miss_table_name => 'svmc_miss_num',
03:56:26  10  	  data_table_name => '&bldtable',
03:56:26  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:26  12  
03:56:26  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:26  14  	  miss_table_name => 'svmc_miss_cat',
03:56:26  15  	  data_table_name => '&bldtable',
03:56:26  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:26  17  
03:56:26  18  	-- xform input data to replace missing values
03:56:26  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:26  20  	  miss_table_name => 'svmc_miss_num',
03:56:26  21  	  data_table_name => '&bldtable',
03:56:26  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:26  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:26  24  	  miss_table_name => 'svmc_miss_cat',
03:56:26  25  	  data_table_name => '&bldtable',
03:56:26  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:26  27  
03:56:26  28  	-- Perform outlier treatment.
03:56:26  29  	-- create clip table
03:56:26  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:26  31  
03:56:26  32  	-- populate clip table
03:56:26  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:26  34  	  clip_table_name => 'svmc_clip',
03:56:26  35  	  data_table_name => '&bldtable',
03:56:26  36  	  tail_frac	  => 0.025,
03:56:26  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:26  38  
03:56:26  39  	-- xform input data to winsorized data
03:56:26  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:26  41  	  clip_table_name => 'svmc_clip',
03:56:26  42  	  data_table_name => '&bldtable',
03:56:26  43  	  xform_view_name => 'svmc_winsor');
03:56:26  44  
03:56:26  45  	-- create normalization table
03:56:26  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:26  47  
03:56:26  48  	-- populate normalization table based on winsorized data
03:56:26  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:26  50  	  norm_table_name => 'svmc_norm',
03:56:26  51  	  data_table_name => 'svmc_winsor',
03:56:26  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:26  53  
03:56:26  54  	-- normalize the original data
03:56:26  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:26  56  	  norm_table_name => 'svmc_norm',
03:56:26  57  	  data_table_name => '&bldtable',
03:56:26  58  	  xform_view_name => 'svmc_build_prep');
03:56:26  59  END;
03:56:26  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.67
03:56:29 SQL> 
03:56:29 SQL> ---------------------
03:56:29 SQL> -- CREATE A NEW MODEL
03:56:29 SQL> --
03:56:29 SQL> -- Cleanup old model with the same name for repeat runs
03:56:29 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:56:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:29   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
03:56:30 SQL> 
03:56:30 SQL> -- Build a new SVM Model
03:56:30 SQL> BEGIN
03:56:30   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:56:30   3  	  model_name	      => '&model_name',
03:56:30   4  	  mining_function     => dbms_data_mining.classification,
03:56:30   5  	  data_table_name     => 'svmc_build_prep',
03:56:30   6  	  case_id_column_name => '&case_id',
03:56:30   7  	  target_column_name  => '&target',
03:56:30   8  	  settings_table_name => 'svmc_settings');
03:56:30   9  END;
03:56:30  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:07.04
03:56:37 SQL> 
03:56:37 SQL> -----------------------------------------------------------------------
03:56:37 SQL> --			       APPLY/score THE MODEL
03:56:37 SQL> -----------------------------------------------------------------------
03:56:37 SQL> 
03:56:37 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.13
03:56:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
03:56:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.09
03:56:38 SQL> -----------------------
03:56:38 SQL> -- PREPARE SCORING DATA
03:56:38 SQL> --
03:56:38 SQL> -- If the data for model creation has been prepared, then the data
03:56:38 SQL> -- to be scored using the model must be prepared in the same manner
03:56:38 SQL> -- in order to obtain meaningful results.
03:56:38 SQL> --
03:56:38 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:38 SQL> -- 2. Normalization
03:56:38 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:38 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:38 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:38 SQL> --
03:56:38 SQL> BEGIN
03:56:38   2  	-- Xform Test data to replace missing values
03:56:38   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:38   4  	  miss_table_name => 'svmc_miss_num',
03:56:38   5  	  data_table_name => '&scoretable',
03:56:38   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:38   7  
03:56:38   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:38   9  	  miss_table_name => 'svmc_miss_cat',
03:56:38  10  	  data_table_name => '&scoretable',
03:56:38  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:38  12  
03:56:38  13  	-- Normalize the data to be scored
03:56:38  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:38  15  	  norm_table_name => 'svmc_norm',
03:56:38  16  	  data_table_name => '&scoretable',
03:56:38  17  	  xform_view_name => 'svmc_apply_prep');
03:56:38  18  END;
03:56:38  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.26
03:56:38 SQL> 
03:56:38 SQL> -- Maybe I already collected a score for this prdate.
03:56:38 SQL> -- DELETE it if I did:
03:56:38 SQL> DELETE svm24scores
03:56:38   2  WHERE score > 0
03:56:38   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:38   4  -- I need to supply the target attribute name:
03:56:38   5  AND targ = '&1'
03:56:38   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:56:38 SQL> 
03:56:38 SQL> -- We do a drumroll here:
03:56:38 SQL> 
03:56:38 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:38   2  SELECT
03:56:38   3  prdate
03:56:38   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:38   5  ,sysdate
03:56:38   6  ,SUBSTR(prdate,1,7)pair
03:56:38   7  ,SUBSTR(prdate,-19)ydate
03:56:38   8  ,'&1'
03:56:38   9  FROM svmc_apply_prep
03:56:38  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:56:38 SQL> @score1_5min_gattn.sql	2011-01-19 04:30:00 eur_usd
03:56:38 SQL> --
03:56:38 SQL> -- score1_5min_gattn.sql
03:56:38 SQL> --
03:56:38 SQL> 
03:56:38 SQL> -- Demo:
03:56:38 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:56:38 SQL> 
03:56:38 SQL> CREATE OR REPLACE VIEW sme AS
03:56:38   2  SELECT
03:56:38   3  prdate
03:56:38   4  ,NULL gattn
03:56:38   5  ,g00
03:56:38   6  ,g01
03:56:38   7  ,g02
03:56:38   8  ,g03
03:56:38   9  ,g04
03:56:38  10  ,g05
03:56:38  11  ,g06
03:56:38  12  ,g07
03:56:38  13  ,g08
03:56:38  14  ,g09
03:56:38  15  ,g10
03:56:38  16  ,g11
03:56:38  17  ,g12
03:56:38  18  ,g13
03:56:38  19  ,g14
03:56:38  20  ,g15
03:56:38  21  ,g16
03:56:38  22  ,g17
03:56:38  23  ,g18
03:56:38  24  ,g19
03:56:38  25  ,g20
03:56:38  26  ,g21
03:56:38  27  ,g22
03:56:38  28  ,g23
03:56:38  29  ,g24
03:56:38  30  ,g25
03:56:38  31  ,g26
03:56:38  32  ,g27
03:56:38  33  ,g28
03:56:38  34  ,g29
03:56:38  35  ,g30
03:56:38  36  ,g31
03:56:38  37  ,g32
03:56:38  38  ,g33
03:56:38  39  ,g34
03:56:38  40  ,g35
03:56:38  41  ,g36
03:56:38  42  ,g37
03:56:38  43  ,g38
03:56:38  44  ,g39
03:56:38  45  ,g40
03:56:38  46  ,g41
03:56:38  47  ,s.sc_corr
03:56:38  48  FROM modsrc24
03:56:38  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:38  50  WHERE ydate = '&1'||' '||'&2'
03:56:38  51  AND pair = '&3'
03:56:38  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'04:30:00'AND ydate<'2011-01-19'||' '||'04:30:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'04:30:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.14
03:56:38 SQL> 
03:56:38 SQL> -- rpt
03:56:38 SQL> -- We should see just 1 row:
03:56:38 SQL> 
03:56:38 SQL> SELECT COUNT(prdate) FROM sme
03:56:38   2  
03:56:38 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:38   2  
03:56:38 SQL> 
03:56:38 SQL> -- Build the model:
03:56:38 SQL> CREATE OR REPLACE VIEW bme AS
03:56:38   2  SELECT
03:56:38   3  prdate
03:56:38   4  ,gattn
03:56:38   5  ,g00
03:56:38   6  ,g01
03:56:38   7  ,g02
03:56:38   8  ,g03
03:56:38   9  ,g04
03:56:38  10  ,g05
03:56:38  11  ,g06
03:56:38  12  ,g07
03:56:38  13  ,g08
03:56:38  14  ,g09
03:56:38  15  ,g10
03:56:38  16  ,g11
03:56:38  17  ,g12
03:56:38  18  ,g13
03:56:38  19  ,g14
03:56:38  20  ,g15
03:56:38  21  ,g16
03:56:38  22  ,g17
03:56:38  23  ,g18
03:56:38  24  ,g19
03:56:38  25  ,g20
03:56:38  26  ,g21
03:56:38  27  ,g22
03:56:38  28  ,g23
03:56:38  29  ,g24
03:56:38  30  ,g25
03:56:38  31  ,g26
03:56:38  32  ,g27
03:56:38  33  ,g28
03:56:38  34  ,g29
03:56:38  35  ,g30
03:56:38  36  ,g31
03:56:38  37  ,g32
03:56:38  38  ,g33
03:56:38  39  ,g34
03:56:38  40  ,g35
03:56:38  41  ,g36
03:56:38  42  ,g37
03:56:38  43  ,g38
03:56:38  44  ,g39
03:56:38  45  ,g40
03:56:38  46  ,g41
03:56:38  47  ,sc_corr
03:56:38  48  FROM modsrc24
03:56:38  49  WHERE gattn IN('nup','up')
03:56:38  50  -- Use only rows which are older than 1 day:
03:56:38  51  AND 1+ydate < '&1'||' '||'&2'
03:56:38  52  AND pair = '&3'
03:56:38  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'04:30:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.17
03:56:38 SQL> 
03:56:38 SQL> -- rpt
03:56:38 SQL> 
03:56:38 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:56:38   2  
03:56:38 SQL> SELECT MAX(prdate) FROM bme
03:56:38   2  
03:56:38 SQL> -- Now build model from bme and score sme
03:56:38 SQL> @score1.sql gattn
03:56:38 SQL> --
03:56:38 SQL> -- score1.sql
03:56:38 SQL> --
03:56:38 SQL> 
03:56:38 SQL> -- I use this script to send 5 params to score.sql
03:56:38 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:38 SQL> -- Then at the very end of this script I use the model
03:56:38 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:38 SQL> 
03:56:38 SQL> -- I call this script from 2 other scripts:
03:56:38 SQL> -- score1_5min.sql
03:56:38 SQL> -- score1_5min_gattn.sql
03:56:38 SQL> 
03:56:38 SQL> -- The 1st param is the name of the target attribute.
03:56:38 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:38 SQL> 
03:56:38 SQL> -- Demo:
03:56:38 SQL> -- @score1.sql 'gatt'
03:56:38 SQL> -- @score1.sql 'gattn'
03:56:38 SQL> 
03:56:38 SQL> -- Now, I fill up svmc_apply_prep.
03:56:38 SQL> -- I use same model_name used in score.sql
03:56:38 SQL> DEFINE model_name = 'svmfx101'
03:56:38 SQL> DEFINE bldtable	= 'bme'
03:56:38 SQL> DEFINE scoretable = 'sme'
03:56:38 SQL> DEFINE case_id	= 'prdate'
03:56:38 SQL> -- Demo:
03:56:38 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:38 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:38 SQL> --
03:56:38 SQL> -- score.sql
03:56:38 SQL> --
03:56:38 SQL> 
03:56:38 SQL> -- usage: score.sql
03:56:38 SQL> 
03:56:38 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:38 SQL> 
03:56:38 SQL> -- DEFINE target	   = 'gatt'
03:56:38 SQL> -- DEFINE model_name = 'svmfx101'
03:56:38 SQL> -- DEFINE bldtable   = 'bme'
03:56:38 SQL> -- DEFINE scoretable = 'sme'
03:56:38 SQL> -- DEFINE case_id    = 'prdate'
03:56:38 SQL> 
03:56:38 SQL> DEFINE target	= '&1'
03:56:38 SQL> DEFINE model_name = '&2'
03:56:38 SQL> DEFINE bldtable	= '&3'
03:56:38 SQL> DEFINE scoretable = '&4'
03:56:38 SQL> DEFINE case_id	= '&5'
03:56:38 SQL> 
03:56:38 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:38 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:38 SQL> 
03:56:38 SQL> -- Builds an SVM model using pl/sql.
03:56:38 SQL> 
03:56:38 SQL> -----------------------------------------------------------------------
03:56:38 SQL> --			    BUILD THE MODEL
03:56:38 SQL> -----------------------------------------------------------------------
03:56:38 SQL> 
03:56:38 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:38 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:38 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:56:38 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:38 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:38 SQL> 
03:56:38 SQL> 
03:56:38 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:38 SQL> --
03:56:38 SQL> -- DROP	TABLE svmc_settings ;
03:56:38 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:38 SQL> -- DELETE svmc_settings;
03:56:38 SQL> 
03:56:38 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:38 SQL> -- this choice to SVM using a settings table.
03:56:38 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:38 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:38 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:38 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:38 SQL> -- models.
03:56:38 SQL> --
03:56:38 SQL> 
03:56:38 SQL> -- Do this once and then comment it out.
03:56:38 SQL> -- That makes script go faster.
03:56:38 SQL> -- BEGIN
03:56:38 SQL> -- -- Populate settings table
03:56:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:38 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:38 SQL> --
03:56:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:38 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:38 SQL> --
03:56:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:38 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:38 SQL> --   COMMIT;
03:56:38 SQL> -- END;
03:56:38 SQL> -- /
03:56:38 SQL> 
03:56:38 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:38 SQL> 
03:56:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.09
03:56:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.13
03:56:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.13
03:56:39 SQL> 
03:56:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
03:56:39 SQL> 
03:56:39 SQL> --------------------------------
03:56:39 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:39 SQL> --
03:56:39 SQL> 
03:56:39 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:39 SQL> -- 2. Outlier Treatment and
03:56:39 SQL> -- 3. Normalization are performed below.
03:56:39 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:39 SQL> --    normalized here.
03:56:39 SQL> 
03:56:39 SQL> BEGIN
03:56:39   2  	-- Perform missing value treatment for all predictors
03:56:39   3  	-- create miss tables
03:56:39   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:39   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:39   6  
03:56:39   7  	-- populate miss tables
03:56:39   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:39   9  	  miss_table_name => 'svmc_miss_num',
03:56:39  10  	  data_table_name => '&bldtable',
03:56:39  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:39  12  
03:56:39  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:39  14  	  miss_table_name => 'svmc_miss_cat',
03:56:39  15  	  data_table_name => '&bldtable',
03:56:39  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:39  17  
03:56:39  18  	-- xform input data to replace missing values
03:56:39  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:39  20  	  miss_table_name => 'svmc_miss_num',
03:56:39  21  	  data_table_name => '&bldtable',
03:56:39  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:39  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:39  24  	  miss_table_name => 'svmc_miss_cat',
03:56:39  25  	  data_table_name => '&bldtable',
03:56:39  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:39  27  
03:56:39  28  	-- Perform outlier treatment.
03:56:39  29  	-- create clip table
03:56:39  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:39  31  
03:56:39  32  	-- populate clip table
03:56:39  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:39  34  	  clip_table_name => 'svmc_clip',
03:56:39  35  	  data_table_name => '&bldtable',
03:56:39  36  	  tail_frac	  => 0.025,
03:56:39  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:39  38  
03:56:39  39  	-- xform input data to winsorized data
03:56:39  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:39  41  	  clip_table_name => 'svmc_clip',
03:56:39  42  	  data_table_name => '&bldtable',
03:56:39  43  	  xform_view_name => 'svmc_winsor');
03:56:39  44  
03:56:39  45  	-- create normalization table
03:56:39  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:39  47  
03:56:39  48  	-- populate normalization table based on winsorized data
03:56:39  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:39  50  	  norm_table_name => 'svmc_norm',
03:56:39  51  	  data_table_name => 'svmc_winsor',
03:56:39  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:39  53  
03:56:39  54  	-- normalize the original data
03:56:39  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:39  56  	  norm_table_name => 'svmc_norm',
03:56:39  57  	  data_table_name => '&bldtable',
03:56:39  58  	  xform_view_name => 'svmc_build_prep');
03:56:39  59  END;
03:56:39  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.63
03:56:41 SQL> 
03:56:41 SQL> ---------------------
03:56:41 SQL> -- CREATE A NEW MODEL
03:56:41 SQL> --
03:56:41 SQL> -- Cleanup old model with the same name for repeat runs
03:56:41 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:56:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:41   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.23
03:56:44 SQL> 
03:56:44 SQL> -- Build a new SVM Model
03:56:44 SQL> BEGIN
03:56:44   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:56:44   3  	  model_name	      => '&model_name',
03:56:44   4  	  mining_function     => dbms_data_mining.classification,
03:56:44   5  	  data_table_name     => 'svmc_build_prep',
03:56:44   6  	  case_id_column_name => '&case_id',
03:56:44   7  	  target_column_name  => '&target',
03:56:44   8  	  settings_table_name => 'svmc_settings');
03:56:44   9  END;
03:56:44  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.39
03:56:49 SQL> 
03:56:49 SQL> -----------------------------------------------------------------------
03:56:49 SQL> --			       APPLY/score THE MODEL
03:56:49 SQL> -----------------------------------------------------------------------
03:56:49 SQL> 
03:56:49 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
03:56:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.15
03:56:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:49 SQL> -----------------------
03:56:49 SQL> -- PREPARE SCORING DATA
03:56:49 SQL> --
03:56:49 SQL> -- If the data for model creation has been prepared, then the data
03:56:49 SQL> -- to be scored using the model must be prepared in the same manner
03:56:49 SQL> -- in order to obtain meaningful results.
03:56:49 SQL> --
03:56:49 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:49 SQL> -- 2. Normalization
03:56:49 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:49 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:49 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:49 SQL> --
03:56:49 SQL> BEGIN
03:56:49   2  	-- Xform Test data to replace missing values
03:56:49   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:49   4  	  miss_table_name => 'svmc_miss_num',
03:56:49   5  	  data_table_name => '&scoretable',
03:56:49   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:49   7  
03:56:49   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:49   9  	  miss_table_name => 'svmc_miss_cat',
03:56:49  10  	  data_table_name => '&scoretable',
03:56:49  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:49  12  
03:56:49  13  	-- Normalize the data to be scored
03:56:49  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:49  15  	  norm_table_name => 'svmc_norm',
03:56:49  16  	  data_table_name => '&scoretable',
03:56:49  17  	  xform_view_name => 'svmc_apply_prep');
03:56:49  18  END;
03:56:49  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:56:50 SQL> 
03:56:50 SQL> -- Maybe I already collected a score for this prdate.
03:56:50 SQL> -- DELETE it if I did:
03:56:50 SQL> DELETE svm24scores
03:56:50   2  WHERE score > 0
03:56:50   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:50   4  -- I need to supply the target attribute name:
03:56:50   5  AND targ = '&1'
03:56:50   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:56:50 SQL> 
03:56:50 SQL> -- We do a drumroll here:
03:56:50 SQL> 
03:56:50 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:50   2  SELECT
03:56:50   3  prdate
03:56:50   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:50   5  ,sysdate
03:56:50   6  ,SUBSTR(prdate,1,7)pair
03:56:50   7  ,SUBSTR(prdate,-19)ydate
03:56:50   8  ,'&1'
03:56:50   9  FROM svmc_apply_prep
03:56:50  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:56:50 SQL> @score1_5min_gattn.sql	2011-01-19 23:50:00 eur_usd
03:56:50 SQL> --
03:56:50 SQL> -- score1_5min_gattn.sql
03:56:50 SQL> --
03:56:50 SQL> 
03:56:50 SQL> -- Demo:
03:56:50 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:56:50 SQL> 
03:56:50 SQL> CREATE OR REPLACE VIEW sme AS
03:56:50   2  SELECT
03:56:50   3  prdate
03:56:50   4  ,NULL gattn
03:56:50   5  ,g00
03:56:50   6  ,g01
03:56:50   7  ,g02
03:56:50   8  ,g03
03:56:50   9  ,g04
03:56:50  10  ,g05
03:56:50  11  ,g06
03:56:50  12  ,g07
03:56:50  13  ,g08
03:56:50  14  ,g09
03:56:50  15  ,g10
03:56:50  16  ,g11
03:56:50  17  ,g12
03:56:50  18  ,g13
03:56:50  19  ,g14
03:56:50  20  ,g15
03:56:50  21  ,g16
03:56:50  22  ,g17
03:56:50  23  ,g18
03:56:50  24  ,g19
03:56:50  25  ,g20
03:56:50  26  ,g21
03:56:50  27  ,g22
03:56:50  28  ,g23
03:56:50  29  ,g24
03:56:50  30  ,g25
03:56:50  31  ,g26
03:56:50  32  ,g27
03:56:50  33  ,g28
03:56:50  34  ,g29
03:56:50  35  ,g30
03:56:50  36  ,g31
03:56:50  37  ,g32
03:56:50  38  ,g33
03:56:50  39  ,g34
03:56:50  40  ,g35
03:56:50  41  ,g36
03:56:50  42  ,g37
03:56:50  43  ,g38
03:56:50  44  ,g39
03:56:50  45  ,g40
03:56:50  46  ,g41
03:56:50  47  ,s.sc_corr
03:56:50  48  FROM modsrc24
03:56:50  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:50  50  WHERE ydate = '&1'||' '||'&2'
03:56:50  51  AND pair = '&3'
03:56:50  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'23:50:00'AND ydate<'2011-01-19'||' '||'23:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'23:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:50 SQL> 
03:56:50 SQL> -- rpt
03:56:50 SQL> -- We should see just 1 row:
03:56:50 SQL> 
03:56:50 SQL> SELECT COUNT(prdate) FROM sme
03:56:50   2  
03:56:50 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:50   2  
03:56:50 SQL> 
03:56:50 SQL> -- Build the model:
03:56:50 SQL> CREATE OR REPLACE VIEW bme AS
03:56:50   2  SELECT
03:56:50   3  prdate
03:56:50   4  ,gattn
03:56:50   5  ,g00
03:56:50   6  ,g01
03:56:50   7  ,g02
03:56:50   8  ,g03
03:56:50   9  ,g04
03:56:50  10  ,g05
03:56:50  11  ,g06
03:56:50  12  ,g07
03:56:50  13  ,g08
03:56:50  14  ,g09
03:56:50  15  ,g10
03:56:50  16  ,g11
03:56:50  17  ,g12
03:56:50  18  ,g13
03:56:50  19  ,g14
03:56:50  20  ,g15
03:56:50  21  ,g16
03:56:50  22  ,g17
03:56:50  23  ,g18
03:56:50  24  ,g19
03:56:50  25  ,g20
03:56:50  26  ,g21
03:56:50  27  ,g22
03:56:50  28  ,g23
03:56:50  29  ,g24
03:56:50  30  ,g25
03:56:50  31  ,g26
03:56:50  32  ,g27
03:56:50  33  ,g28
03:56:50  34  ,g29
03:56:50  35  ,g30
03:56:50  36  ,g31
03:56:50  37  ,g32
03:56:50  38  ,g33
03:56:50  39  ,g34
03:56:50  40  ,g35
03:56:50  41  ,g36
03:56:50  42  ,g37
03:56:50  43  ,g38
03:56:50  44  ,g39
03:56:50  45  ,g40
03:56:50  46  ,g41
03:56:50  47  ,sc_corr
03:56:50  48  FROM modsrc24
03:56:50  49  WHERE gattn IN('nup','up')
03:56:50  50  -- Use only rows which are older than 1 day:
03:56:50  51  AND 1+ydate < '&1'||' '||'&2'
03:56:50  52  AND pair = '&3'
03:56:50  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'23:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:50 SQL> 
03:56:50 SQL> -- rpt
03:56:50 SQL> 
03:56:50 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:56:50   2  
03:56:50 SQL> SELECT MAX(prdate) FROM bme
03:56:50   2  
03:56:50 SQL> -- Now build model from bme and score sme
03:56:50 SQL> @score1.sql gattn
03:56:50 SQL> --
03:56:50 SQL> -- score1.sql
03:56:50 SQL> --
03:56:50 SQL> 
03:56:50 SQL> -- I use this script to send 5 params to score.sql
03:56:50 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:50 SQL> -- Then at the very end of this script I use the model
03:56:50 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:50 SQL> 
03:56:50 SQL> -- I call this script from 2 other scripts:
03:56:50 SQL> -- score1_5min.sql
03:56:50 SQL> -- score1_5min_gattn.sql
03:56:50 SQL> 
03:56:50 SQL> -- The 1st param is the name of the target attribute.
03:56:50 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:50 SQL> 
03:56:50 SQL> -- Demo:
03:56:50 SQL> -- @score1.sql 'gatt'
03:56:50 SQL> -- @score1.sql 'gattn'
03:56:50 SQL> 
03:56:50 SQL> -- Now, I fill up svmc_apply_prep.
03:56:50 SQL> -- I use same model_name used in score.sql
03:56:50 SQL> DEFINE model_name = 'svmfx101'
03:56:50 SQL> DEFINE bldtable	= 'bme'
03:56:50 SQL> DEFINE scoretable = 'sme'
03:56:50 SQL> DEFINE case_id	= 'prdate'
03:56:50 SQL> -- Demo:
03:56:50 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:50 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:50 SQL> --
03:56:50 SQL> -- score.sql
03:56:50 SQL> --
03:56:50 SQL> 
03:56:50 SQL> -- usage: score.sql
03:56:50 SQL> 
03:56:50 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:50 SQL> 
03:56:50 SQL> -- DEFINE target	   = 'gatt'
03:56:50 SQL> -- DEFINE model_name = 'svmfx101'
03:56:50 SQL> -- DEFINE bldtable   = 'bme'
03:56:50 SQL> -- DEFINE scoretable = 'sme'
03:56:50 SQL> -- DEFINE case_id    = 'prdate'
03:56:50 SQL> 
03:56:50 SQL> DEFINE target	= '&1'
03:56:50 SQL> DEFINE model_name = '&2'
03:56:50 SQL> DEFINE bldtable	= '&3'
03:56:50 SQL> DEFINE scoretable = '&4'
03:56:50 SQL> DEFINE case_id	= '&5'
03:56:50 SQL> 
03:56:50 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:50 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:50 SQL> 
03:56:50 SQL> -- Builds an SVM model using pl/sql.
03:56:50 SQL> 
03:56:50 SQL> -----------------------------------------------------------------------
03:56:50 SQL> --			    BUILD THE MODEL
03:56:50 SQL> -----------------------------------------------------------------------
03:56:50 SQL> 
03:56:50 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:50 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:50 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:56:50 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:56:50 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:50 SQL> 
03:56:50 SQL> 
03:56:50 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:50 SQL> --
03:56:50 SQL> -- DROP	TABLE svmc_settings ;
03:56:50 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:50 SQL> -- DELETE svmc_settings;
03:56:50 SQL> 
03:56:50 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:50 SQL> -- this choice to SVM using a settings table.
03:56:50 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:50 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:50 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:50 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:50 SQL> -- models.
03:56:50 SQL> --
03:56:50 SQL> 
03:56:50 SQL> -- Do this once and then comment it out.
03:56:50 SQL> -- That makes script go faster.
03:56:50 SQL> -- BEGIN
03:56:50 SQL> -- -- Populate settings table
03:56:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:50 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:50 SQL> --
03:56:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:50 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:50 SQL> --
03:56:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:50 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:50 SQL> --   COMMIT;
03:56:50 SQL> -- END;
03:56:50 SQL> -- /
03:56:50 SQL> 
03:56:50 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:50 SQL> 
03:56:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:50 SQL> 
03:56:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:50 SQL> 
03:56:50 SQL> --------------------------------
03:56:50 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:50 SQL> --
03:56:50 SQL> 
03:56:50 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:50 SQL> -- 2. Outlier Treatment and
03:56:50 SQL> -- 3. Normalization are performed below.
03:56:50 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:50 SQL> --    normalized here.
03:56:50 SQL> 
03:56:50 SQL> BEGIN
03:56:50   2  	-- Perform missing value treatment for all predictors
03:56:50   3  	-- create miss tables
03:56:50   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:50   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:50   6  
03:56:50   7  	-- populate miss tables
03:56:50   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:50   9  	  miss_table_name => 'svmc_miss_num',
03:56:50  10  	  data_table_name => '&bldtable',
03:56:50  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:50  12  
03:56:50  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:50  14  	  miss_table_name => 'svmc_miss_cat',
03:56:50  15  	  data_table_name => '&bldtable',
03:56:50  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:50  17  
03:56:50  18  	-- xform input data to replace missing values
03:56:50  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:50  20  	  miss_table_name => 'svmc_miss_num',
03:56:50  21  	  data_table_name => '&bldtable',
03:56:50  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:50  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:50  24  	  miss_table_name => 'svmc_miss_cat',
03:56:50  25  	  data_table_name => '&bldtable',
03:56:50  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:50  27  
03:56:50  28  	-- Perform outlier treatment.
03:56:50  29  	-- create clip table
03:56:50  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:50  31  
03:56:50  32  	-- populate clip table
03:56:50  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:50  34  	  clip_table_name => 'svmc_clip',
03:56:50  35  	  data_table_name => '&bldtable',
03:56:50  36  	  tail_frac	  => 0.025,
03:56:50  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:50  38  
03:56:50  39  	-- xform input data to winsorized data
03:56:50  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:50  41  	  clip_table_name => 'svmc_clip',
03:56:50  42  	  data_table_name => '&bldtable',
03:56:50  43  	  xform_view_name => 'svmc_winsor');
03:56:50  44  
03:56:50  45  	-- create normalization table
03:56:50  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:50  47  
03:56:50  48  	-- populate normalization table based on winsorized data
03:56:50  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:50  50  	  norm_table_name => 'svmc_norm',
03:56:50  51  	  data_table_name => 'svmc_winsor',
03:56:50  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:50  53  
03:56:50  54  	-- normalize the original data
03:56:50  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:50  56  	  norm_table_name => 'svmc_norm',
03:56:50  57  	  data_table_name => '&bldtable',
03:56:50  58  	  xform_view_name => 'svmc_build_prep');
03:56:50  59  END;
03:56:50  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
03:56:53 SQL> 
03:56:53 SQL> ---------------------
03:56:53 SQL> -- CREATE A NEW MODEL
03:56:53 SQL> --
03:56:53 SQL> -- Cleanup old model with the same name for repeat runs
03:56:53 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:56:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:53   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.27
03:56:54 SQL> 
03:56:54 SQL> -- Build a new SVM Model
03:56:54 SQL> BEGIN
03:56:54   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:56:54   3  	  model_name	      => '&model_name',
03:56:54   4  	  mining_function     => dbms_data_mining.classification,
03:56:54   5  	  data_table_name     => 'svmc_build_prep',
03:56:54   6  	  case_id_column_name => '&case_id',
03:56:54   7  	  target_column_name  => '&target',
03:56:54   8  	  settings_table_name => 'svmc_settings');
03:56:54   9  END;
03:56:54  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.83
03:56:59 SQL> 
03:56:59 SQL> -----------------------------------------------------------------------
03:56:59 SQL> --			       APPLY/score THE MODEL
03:56:59 SQL> -----------------------------------------------------------------------
03:56:59 SQL> 
03:56:59 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:59 SQL> -----------------------
03:56:59 SQL> -- PREPARE SCORING DATA
03:56:59 SQL> --
03:56:59 SQL> -- If the data for model creation has been prepared, then the data
03:56:59 SQL> -- to be scored using the model must be prepared in the same manner
03:56:59 SQL> -- in order to obtain meaningful results.
03:56:59 SQL> --
03:56:59 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:59 SQL> -- 2. Normalization
03:56:59 SQL> -- No outlier treatment will be performed during test and apply. The
03:56:59 SQL> -- normalization step is sufficient, since the normalization parameters
03:56:59 SQL> -- already capture the effects of outlier treatment done with build data.
03:56:59 SQL> --
03:56:59 SQL> BEGIN
03:56:59   2  	-- Xform Test data to replace missing values
03:56:59   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:59   4  	  miss_table_name => 'svmc_miss_num',
03:56:59   5  	  data_table_name => '&scoretable',
03:56:59   6  	  xform_view_name => 'xformed_apply_miss_num');
03:56:59   7  
03:56:59   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:59   9  	  miss_table_name => 'svmc_miss_cat',
03:56:59  10  	  data_table_name => '&scoretable',
03:56:59  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:56:59  12  
03:56:59  13  	-- Normalize the data to be scored
03:56:59  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:59  15  	  norm_table_name => 'svmc_norm',
03:56:59  16  	  data_table_name => '&scoretable',
03:56:59  17  	  xform_view_name => 'svmc_apply_prep');
03:56:59  18  END;
03:56:59  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:56:59 SQL> 
03:56:59 SQL> -- Maybe I already collected a score for this prdate.
03:56:59 SQL> -- DELETE it if I did:
03:56:59 SQL> DELETE svm24scores
03:56:59   2  WHERE score > 0
03:56:59   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:56:59   4  -- I need to supply the target attribute name:
03:56:59   5  AND targ = '&1'
03:56:59   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:56:59 SQL> 
03:56:59 SQL> -- We do a drumroll here:
03:56:59 SQL> 
03:56:59 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:56:59   2  SELECT
03:56:59   3  prdate
03:56:59   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:56:59   5  ,sysdate
03:56:59   6  ,SUBSTR(prdate,1,7)pair
03:56:59   7  ,SUBSTR(prdate,-19)ydate
03:56:59   8  ,'&1'
03:56:59   9  FROM svmc_apply_prep
03:56:59  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:56:59 SQL> @score1_5min_gattn.sql	2011-01-28 07:00:00 eur_usd
03:56:59 SQL> --
03:56:59 SQL> -- score1_5min_gattn.sql
03:56:59 SQL> --
03:56:59 SQL> 
03:56:59 SQL> -- Demo:
03:56:59 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:56:59 SQL> 
03:56:59 SQL> CREATE OR REPLACE VIEW sme AS
03:56:59   2  SELECT
03:56:59   3  prdate
03:56:59   4  ,NULL gattn
03:56:59   5  ,g00
03:56:59   6  ,g01
03:56:59   7  ,g02
03:56:59   8  ,g03
03:56:59   9  ,g04
03:56:59  10  ,g05
03:56:59  11  ,g06
03:56:59  12  ,g07
03:56:59  13  ,g08
03:56:59  14  ,g09
03:56:59  15  ,g10
03:56:59  16  ,g11
03:56:59  17  ,g12
03:56:59  18  ,g13
03:56:59  19  ,g14
03:56:59  20  ,g15
03:56:59  21  ,g16
03:56:59  22  ,g17
03:56:59  23  ,g18
03:56:59  24  ,g19
03:56:59  25  ,g20
03:56:59  26  ,g21
03:56:59  27  ,g22
03:56:59  28  ,g23
03:56:59  29  ,g24
03:56:59  30  ,g25
03:56:59  31  ,g26
03:56:59  32  ,g27
03:56:59  33  ,g28
03:56:59  34  ,g29
03:56:59  35  ,g30
03:56:59  36  ,g31
03:56:59  37  ,g32
03:56:59  38  ,g33
03:56:59  39  ,g34
03:56:59  40  ,g35
03:56:59  41  ,g36
03:56:59  42  ,g37
03:56:59  43  ,g38
03:56:59  44  ,g39
03:56:59  45  ,g40
03:56:59  46  ,g41
03:56:59  47  ,s.sc_corr
03:56:59  48  FROM modsrc24
03:56:59  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:56:59  50  WHERE ydate = '&1'||' '||'&2'
03:56:59  51  AND pair = '&3'
03:56:59  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-28'||' '||'07:00:00'AND ydate<'2011-01-28'||' '||'07:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-28'||' '||'07:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:59 SQL> 
03:56:59 SQL> -- rpt
03:56:59 SQL> -- We should see just 1 row:
03:56:59 SQL> 
03:56:59 SQL> SELECT COUNT(prdate) FROM sme
03:56:59   2  
03:56:59 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:56:59   2  
03:56:59 SQL> 
03:56:59 SQL> -- Build the model:
03:56:59 SQL> CREATE OR REPLACE VIEW bme AS
03:56:59   2  SELECT
03:56:59   3  prdate
03:56:59   4  ,gattn
03:56:59   5  ,g00
03:56:59   6  ,g01
03:56:59   7  ,g02
03:56:59   8  ,g03
03:56:59   9  ,g04
03:56:59  10  ,g05
03:56:59  11  ,g06
03:56:59  12  ,g07
03:56:59  13  ,g08
03:56:59  14  ,g09
03:56:59  15  ,g10
03:56:59  16  ,g11
03:56:59  17  ,g12
03:56:59  18  ,g13
03:56:59  19  ,g14
03:56:59  20  ,g15
03:56:59  21  ,g16
03:56:59  22  ,g17
03:56:59  23  ,g18
03:56:59  24  ,g19
03:56:59  25  ,g20
03:56:59  26  ,g21
03:56:59  27  ,g22
03:56:59  28  ,g23
03:56:59  29  ,g24
03:56:59  30  ,g25
03:56:59  31  ,g26
03:56:59  32  ,g27
03:56:59  33  ,g28
03:56:59  34  ,g29
03:56:59  35  ,g30
03:56:59  36  ,g31
03:56:59  37  ,g32
03:56:59  38  ,g33
03:56:59  39  ,g34
03:56:59  40  ,g35
03:56:59  41  ,g36
03:56:59  42  ,g37
03:56:59  43  ,g38
03:56:59  44  ,g39
03:56:59  45  ,g40
03:56:59  46  ,g41
03:56:59  47  ,sc_corr
03:56:59  48  FROM modsrc24
03:56:59  49  WHERE gattn IN('nup','up')
03:56:59  50  -- Use only rows which are older than 1 day:
03:56:59  51  AND 1+ydate < '&1'||' '||'&2'
03:56:59  52  AND pair = '&3'
03:56:59  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-28'||' '||'07:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:56:59 SQL> 
03:56:59 SQL> -- rpt
03:56:59 SQL> 
03:56:59 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:56:59   2  
03:56:59 SQL> SELECT MAX(prdate) FROM bme
03:56:59   2  
03:56:59 SQL> -- Now build model from bme and score sme
03:56:59 SQL> @score1.sql gattn
03:56:59 SQL> --
03:56:59 SQL> -- score1.sql
03:56:59 SQL> --
03:56:59 SQL> 
03:56:59 SQL> -- I use this script to send 5 params to score.sql
03:56:59 SQL> -- which does the heavy lifting of creating an SVM model.
03:56:59 SQL> -- Then at the very end of this script I use the model
03:56:59 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:56:59 SQL> 
03:56:59 SQL> -- I call this script from 2 other scripts:
03:56:59 SQL> -- score1_5min.sql
03:56:59 SQL> -- score1_5min_gattn.sql
03:56:59 SQL> 
03:56:59 SQL> -- The 1st param is the name of the target attribute.
03:56:59 SQL> -- I like to call my target attributes either gatt or gattn.
03:56:59 SQL> 
03:56:59 SQL> -- Demo:
03:56:59 SQL> -- @score1.sql 'gatt'
03:56:59 SQL> -- @score1.sql 'gattn'
03:56:59 SQL> 
03:56:59 SQL> -- Now, I fill up svmc_apply_prep.
03:56:59 SQL> -- I use same model_name used in score.sql
03:56:59 SQL> DEFINE model_name = 'svmfx101'
03:56:59 SQL> DEFINE bldtable	= 'bme'
03:56:59 SQL> DEFINE scoretable = 'sme'
03:56:59 SQL> DEFINE case_id	= 'prdate'
03:56:59 SQL> -- Demo:
03:56:59 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:56:59 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:56:59 SQL> --
03:56:59 SQL> -- score.sql
03:56:59 SQL> --
03:56:59 SQL> 
03:56:59 SQL> -- usage: score.sql
03:56:59 SQL> 
03:56:59 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:56:59 SQL> 
03:56:59 SQL> -- DEFINE target	   = 'gatt'
03:56:59 SQL> -- DEFINE model_name = 'svmfx101'
03:56:59 SQL> -- DEFINE bldtable   = 'bme'
03:56:59 SQL> -- DEFINE scoretable = 'sme'
03:56:59 SQL> -- DEFINE case_id    = 'prdate'
03:56:59 SQL> 
03:56:59 SQL> DEFINE target	= '&1'
03:56:59 SQL> DEFINE model_name = '&2'
03:56:59 SQL> DEFINE bldtable	= '&3'
03:56:59 SQL> DEFINE scoretable = '&4'
03:56:59 SQL> DEFINE case_id	= '&5'
03:56:59 SQL> 
03:56:59 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:56:59 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:56:59 SQL> 
03:56:59 SQL> -- Builds an SVM model using pl/sql.
03:56:59 SQL> 
03:56:59 SQL> -----------------------------------------------------------------------
03:56:59 SQL> --			    BUILD THE MODEL
03:56:59 SQL> -----------------------------------------------------------------------
03:56:59 SQL> 
03:56:59 SQL> -- Cleanup old build data preparation objects for repeat runs
03:56:59 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:56:59 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:56:59 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:56:59 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:56:59 SQL> 
03:56:59 SQL> 
03:56:59 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:56:59 SQL> --
03:56:59 SQL> -- DROP	TABLE svmc_settings ;
03:56:59 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:56:59 SQL> -- DELETE svmc_settings;
03:56:59 SQL> 
03:56:59 SQL> -- The default classification algorithm is Naive Bayes. So override
03:56:59 SQL> -- this choice to SVM using a settings table.
03:56:59 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:56:59 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:56:59 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:56:59 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:56:59 SQL> -- models.
03:56:59 SQL> --
03:56:59 SQL> 
03:56:59 SQL> -- Do this once and then comment it out.
03:56:59 SQL> -- That makes script go faster.
03:56:59 SQL> -- BEGIN
03:56:59 SQL> -- -- Populate settings table
03:56:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:59 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:56:59 SQL> --
03:56:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:59 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:56:59 SQL> --
03:56:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:56:59 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:56:59 SQL> --   COMMIT;
03:56:59 SQL> -- END;
03:56:59 SQL> -- /
03:56:59 SQL> 
03:56:59 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:56:59 SQL> 
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:56:59 SQL> 
03:56:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:56:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:56:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:56:59 SQL> 
03:56:59 SQL> --------------------------------
03:56:59 SQL> -- PREPARE BUILD (TRAINING) DATA
03:56:59 SQL> --
03:56:59 SQL> 
03:56:59 SQL> -- 1. Missing Value treatment for all Predictors and
03:56:59 SQL> -- 2. Outlier Treatment and
03:56:59 SQL> -- 3. Normalization are performed below.
03:56:59 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:56:59 SQL> --    normalized here.
03:56:59 SQL> 
03:56:59 SQL> BEGIN
03:56:59   2  	-- Perform missing value treatment for all predictors
03:56:59   3  	-- create miss tables
03:56:59   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:56:59   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:56:59   6  
03:56:59   7  	-- populate miss tables
03:56:59   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:56:59   9  	  miss_table_name => 'svmc_miss_num',
03:56:59  10  	  data_table_name => '&bldtable',
03:56:59  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:59  12  
03:56:59  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:56:59  14  	  miss_table_name => 'svmc_miss_cat',
03:56:59  15  	  data_table_name => '&bldtable',
03:56:59  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:59  17  
03:56:59  18  	-- xform input data to replace missing values
03:56:59  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:56:59  20  	  miss_table_name => 'svmc_miss_num',
03:56:59  21  	  data_table_name => '&bldtable',
03:56:59  22  	  xform_view_name => 'xformed_build_miss_num');
03:56:59  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:56:59  24  	  miss_table_name => 'svmc_miss_cat',
03:56:59  25  	  data_table_name => '&bldtable',
03:56:59  26  	  xform_view_name => 'xformed_build_miss_cat');
03:56:59  27  
03:56:59  28  	-- Perform outlier treatment.
03:56:59  29  	-- create clip table
03:56:59  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:56:59  31  
03:56:59  32  	-- populate clip table
03:56:59  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:56:59  34  	  clip_table_name => 'svmc_clip',
03:56:59  35  	  data_table_name => '&bldtable',
03:56:59  36  	  tail_frac	  => 0.025,
03:56:59  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:59  38  
03:56:59  39  	-- xform input data to winsorized data
03:56:59  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:56:59  41  	  clip_table_name => 'svmc_clip',
03:56:59  42  	  data_table_name => '&bldtable',
03:56:59  43  	  xform_view_name => 'svmc_winsor');
03:56:59  44  
03:56:59  45  	-- create normalization table
03:56:59  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:56:59  47  
03:56:59  48  	-- populate normalization table based on winsorized data
03:56:59  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:56:59  50  	  norm_table_name => 'svmc_norm',
03:56:59  51  	  data_table_name => 'svmc_winsor',
03:56:59  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:56:59  53  
03:56:59  54  	-- normalize the original data
03:56:59  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:56:59  56  	  norm_table_name => 'svmc_norm',
03:56:59  57  	  data_table_name => '&bldtable',
03:56:59  58  	  xform_view_name => 'svmc_build_prep');
03:56:59  59  END;
03:56:59  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.73
03:57:02 SQL> 
03:57:02 SQL> ---------------------
03:57:02 SQL> -- CREATE A NEW MODEL
03:57:02 SQL> --
03:57:02 SQL> -- Cleanup old model with the same name for repeat runs
03:57:02 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:57:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:02   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.40
03:57:03 SQL> 
03:57:03 SQL> -- Build a new SVM Model
03:57:03 SQL> BEGIN
03:57:03   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:57:03   3  	  model_name	      => '&model_name',
03:57:03   4  	  mining_function     => dbms_data_mining.classification,
03:57:03   5  	  data_table_name     => 'svmc_build_prep',
03:57:03   6  	  case_id_column_name => '&case_id',
03:57:03   7  	  target_column_name  => '&target',
03:57:03   8  	  settings_table_name => 'svmc_settings');
03:57:03   9  END;
03:57:03  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:09.27
03:57:13 SQL> 
03:57:13 SQL> -----------------------------------------------------------------------
03:57:13 SQL> --			       APPLY/score THE MODEL
03:57:13 SQL> -----------------------------------------------------------------------
03:57:13 SQL> 
03:57:13 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:13 SQL> -----------------------
03:57:13 SQL> -- PREPARE SCORING DATA
03:57:13 SQL> --
03:57:13 SQL> -- If the data for model creation has been prepared, then the data
03:57:13 SQL> -- to be scored using the model must be prepared in the same manner
03:57:13 SQL> -- in order to obtain meaningful results.
03:57:13 SQL> --
03:57:13 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:13 SQL> -- 2. Normalization
03:57:13 SQL> -- No outlier treatment will be performed during test and apply. The
03:57:13 SQL> -- normalization step is sufficient, since the normalization parameters
03:57:13 SQL> -- already capture the effects of outlier treatment done with build data.
03:57:13 SQL> --
03:57:13 SQL> BEGIN
03:57:13   2  	-- Xform Test data to replace missing values
03:57:13   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:13   4  	  miss_table_name => 'svmc_miss_num',
03:57:13   5  	  data_table_name => '&scoretable',
03:57:13   6  	  xform_view_name => 'xformed_apply_miss_num');
03:57:13   7  
03:57:13   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:13   9  	  miss_table_name => 'svmc_miss_cat',
03:57:13  10  	  data_table_name => '&scoretable',
03:57:13  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:57:13  12  
03:57:13  13  	-- Normalize the data to be scored
03:57:13  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:13  15  	  norm_table_name => 'svmc_norm',
03:57:13  16  	  data_table_name => '&scoretable',
03:57:13  17  	  xform_view_name => 'svmc_apply_prep');
03:57:13  18  END;
03:57:13  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:57:13 SQL> 
03:57:13 SQL> -- Maybe I already collected a score for this prdate.
03:57:13 SQL> -- DELETE it if I did:
03:57:13 SQL> DELETE svm24scores
03:57:13   2  WHERE score > 0
03:57:13   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:57:13   4  -- I need to supply the target attribute name:
03:57:13   5  AND targ = '&1'
03:57:13   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:57:13 SQL> 
03:57:13 SQL> -- We do a drumroll here:
03:57:13 SQL> 
03:57:13 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:57:13   2  SELECT
03:57:13   3  prdate
03:57:13   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:57:13   5  ,sysdate
03:57:13   6  ,SUBSTR(prdate,1,7)pair
03:57:13   7  ,SUBSTR(prdate,-19)ydate
03:57:13   8  ,'&1'
03:57:13   9  FROM svmc_apply_prep
03:57:13  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:57:13 SQL> @score1_5min_gattn.sql	2011-01-27 11:10:00 eur_usd
03:57:13 SQL> --
03:57:13 SQL> -- score1_5min_gattn.sql
03:57:13 SQL> --
03:57:13 SQL> 
03:57:13 SQL> -- Demo:
03:57:13 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:57:13 SQL> 
03:57:13 SQL> CREATE OR REPLACE VIEW sme AS
03:57:13   2  SELECT
03:57:13   3  prdate
03:57:13   4  ,NULL gattn
03:57:13   5  ,g00
03:57:13   6  ,g01
03:57:13   7  ,g02
03:57:13   8  ,g03
03:57:13   9  ,g04
03:57:13  10  ,g05
03:57:13  11  ,g06
03:57:13  12  ,g07
03:57:13  13  ,g08
03:57:13  14  ,g09
03:57:13  15  ,g10
03:57:13  16  ,g11
03:57:13  17  ,g12
03:57:13  18  ,g13
03:57:13  19  ,g14
03:57:13  20  ,g15
03:57:13  21  ,g16
03:57:13  22  ,g17
03:57:13  23  ,g18
03:57:13  24  ,g19
03:57:13  25  ,g20
03:57:13  26  ,g21
03:57:13  27  ,g22
03:57:13  28  ,g23
03:57:13  29  ,g24
03:57:13  30  ,g25
03:57:13  31  ,g26
03:57:13  32  ,g27
03:57:13  33  ,g28
03:57:13  34  ,g29
03:57:13  35  ,g30
03:57:13  36  ,g31
03:57:13  37  ,g32
03:57:13  38  ,g33
03:57:13  39  ,g34
03:57:13  40  ,g35
03:57:13  41  ,g36
03:57:13  42  ,g37
03:57:13  43  ,g38
03:57:13  44  ,g39
03:57:13  45  ,g40
03:57:13  46  ,g41
03:57:13  47  ,s.sc_corr
03:57:13  48  FROM modsrc24
03:57:13  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:57:13  50  WHERE ydate = '&1'||' '||'&2'
03:57:13  51  AND pair = '&3'
03:57:13  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'11:10:00'AND ydate<'2011-01-27'||' '||'11:10:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'11:10:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:57:13 SQL> 
03:57:13 SQL> -- rpt
03:57:13 SQL> -- We should see just 1 row:
03:57:13 SQL> 
03:57:13 SQL> SELECT COUNT(prdate) FROM sme
03:57:13   2  
03:57:13 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:57:13   2  
03:57:13 SQL> 
03:57:13 SQL> -- Build the model:
03:57:13 SQL> CREATE OR REPLACE VIEW bme AS
03:57:13   2  SELECT
03:57:13   3  prdate
03:57:13   4  ,gattn
03:57:13   5  ,g00
03:57:13   6  ,g01
03:57:13   7  ,g02
03:57:13   8  ,g03
03:57:13   9  ,g04
03:57:13  10  ,g05
03:57:13  11  ,g06
03:57:13  12  ,g07
03:57:13  13  ,g08
03:57:13  14  ,g09
03:57:13  15  ,g10
03:57:13  16  ,g11
03:57:13  17  ,g12
03:57:13  18  ,g13
03:57:13  19  ,g14
03:57:13  20  ,g15
03:57:13  21  ,g16
03:57:13  22  ,g17
03:57:13  23  ,g18
03:57:13  24  ,g19
03:57:13  25  ,g20
03:57:13  26  ,g21
03:57:13  27  ,g22
03:57:13  28  ,g23
03:57:13  29  ,g24
03:57:13  30  ,g25
03:57:13  31  ,g26
03:57:13  32  ,g27
03:57:13  33  ,g28
03:57:13  34  ,g29
03:57:13  35  ,g30
03:57:13  36  ,g31
03:57:13  37  ,g32
03:57:13  38  ,g33
03:57:13  39  ,g34
03:57:13  40  ,g35
03:57:13  41  ,g36
03:57:13  42  ,g37
03:57:13  43  ,g38
03:57:13  44  ,g39
03:57:13  45  ,g40
03:57:13  46  ,g41
03:57:13  47  ,sc_corr
03:57:13  48  FROM modsrc24
03:57:13  49  WHERE gattn IN('nup','up')
03:57:13  50  -- Use only rows which are older than 1 day:
03:57:13  51  AND 1+ydate < '&1'||' '||'&2'
03:57:13  52  AND pair = '&3'
03:57:13  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'11:10:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:57:13 SQL> 
03:57:13 SQL> -- rpt
03:57:13 SQL> 
03:57:13 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:57:13   2  
03:57:13 SQL> SELECT MAX(prdate) FROM bme
03:57:13   2  
03:57:13 SQL> -- Now build model from bme and score sme
03:57:13 SQL> @score1.sql gattn
03:57:13 SQL> --
03:57:13 SQL> -- score1.sql
03:57:13 SQL> --
03:57:13 SQL> 
03:57:13 SQL> -- I use this script to send 5 params to score.sql
03:57:13 SQL> -- which does the heavy lifting of creating an SVM model.
03:57:13 SQL> -- Then at the very end of this script I use the model
03:57:13 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:57:13 SQL> 
03:57:13 SQL> -- I call this script from 2 other scripts:
03:57:13 SQL> -- score1_5min.sql
03:57:13 SQL> -- score1_5min_gattn.sql
03:57:13 SQL> 
03:57:13 SQL> -- The 1st param is the name of the target attribute.
03:57:13 SQL> -- I like to call my target attributes either gatt or gattn.
03:57:13 SQL> 
03:57:13 SQL> -- Demo:
03:57:13 SQL> -- @score1.sql 'gatt'
03:57:13 SQL> -- @score1.sql 'gattn'
03:57:13 SQL> 
03:57:13 SQL> -- Now, I fill up svmc_apply_prep.
03:57:13 SQL> -- I use same model_name used in score.sql
03:57:13 SQL> DEFINE model_name = 'svmfx101'
03:57:13 SQL> DEFINE bldtable	= 'bme'
03:57:13 SQL> DEFINE scoretable = 'sme'
03:57:13 SQL> DEFINE case_id	= 'prdate'
03:57:13 SQL> -- Demo:
03:57:13 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:57:13 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:57:13 SQL> --
03:57:13 SQL> -- score.sql
03:57:13 SQL> --
03:57:13 SQL> 
03:57:13 SQL> -- usage: score.sql
03:57:13 SQL> 
03:57:13 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:57:13 SQL> 
03:57:13 SQL> -- DEFINE target	   = 'gatt'
03:57:13 SQL> -- DEFINE model_name = 'svmfx101'
03:57:13 SQL> -- DEFINE bldtable   = 'bme'
03:57:13 SQL> -- DEFINE scoretable = 'sme'
03:57:13 SQL> -- DEFINE case_id    = 'prdate'
03:57:13 SQL> 
03:57:13 SQL> DEFINE target	= '&1'
03:57:13 SQL> DEFINE model_name = '&2'
03:57:13 SQL> DEFINE bldtable	= '&3'
03:57:13 SQL> DEFINE scoretable = '&4'
03:57:13 SQL> DEFINE case_id	= '&5'
03:57:13 SQL> 
03:57:13 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:57:13 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:57:13 SQL> 
03:57:13 SQL> -- Builds an SVM model using pl/sql.
03:57:13 SQL> 
03:57:13 SQL> -----------------------------------------------------------------------
03:57:13 SQL> --			    BUILD THE MODEL
03:57:13 SQL> -----------------------------------------------------------------------
03:57:13 SQL> 
03:57:13 SQL> -- Cleanup old build data preparation objects for repeat runs
03:57:13 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:13 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:57:13 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:13 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:57:13 SQL> 
03:57:13 SQL> 
03:57:13 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:57:13 SQL> --
03:57:13 SQL> -- DROP	TABLE svmc_settings ;
03:57:13 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:57:13 SQL> -- DELETE svmc_settings;
03:57:13 SQL> 
03:57:13 SQL> -- The default classification algorithm is Naive Bayes. So override
03:57:13 SQL> -- this choice to SVM using a settings table.
03:57:13 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:57:13 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:57:13 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:57:13 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:57:13 SQL> -- models.
03:57:13 SQL> --
03:57:13 SQL> 
03:57:13 SQL> -- Do this once and then comment it out.
03:57:13 SQL> -- That makes script go faster.
03:57:13 SQL> -- BEGIN
03:57:13 SQL> -- -- Populate settings table
03:57:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:13 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:57:13 SQL> --
03:57:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:13 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:57:13 SQL> --
03:57:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:13 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:57:13 SQL> --   COMMIT;
03:57:13 SQL> -- END;
03:57:13 SQL> -- /
03:57:13 SQL> 
03:57:13 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:57:13 SQL> 
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:13 SQL> 
03:57:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:57:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:13 SQL> 
03:57:13 SQL> --------------------------------
03:57:13 SQL> -- PREPARE BUILD (TRAINING) DATA
03:57:13 SQL> --
03:57:13 SQL> 
03:57:13 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:13 SQL> -- 2. Outlier Treatment and
03:57:13 SQL> -- 3. Normalization are performed below.
03:57:13 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:57:13 SQL> --    normalized here.
03:57:13 SQL> 
03:57:13 SQL> BEGIN
03:57:13   2  	-- Perform missing value treatment for all predictors
03:57:13   3  	-- create miss tables
03:57:13   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:57:13   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:57:13   6  
03:57:13   7  	-- populate miss tables
03:57:13   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:57:13   9  	  miss_table_name => 'svmc_miss_num',
03:57:13  10  	  data_table_name => '&bldtable',
03:57:13  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:13  12  
03:57:13  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:57:13  14  	  miss_table_name => 'svmc_miss_cat',
03:57:13  15  	  data_table_name => '&bldtable',
03:57:13  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:13  17  
03:57:13  18  	-- xform input data to replace missing values
03:57:13  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:13  20  	  miss_table_name => 'svmc_miss_num',
03:57:13  21  	  data_table_name => '&bldtable',
03:57:13  22  	  xform_view_name => 'xformed_build_miss_num');
03:57:13  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:13  24  	  miss_table_name => 'svmc_miss_cat',
03:57:13  25  	  data_table_name => '&bldtable',
03:57:13  26  	  xform_view_name => 'xformed_build_miss_cat');
03:57:13  27  
03:57:13  28  	-- Perform outlier treatment.
03:57:13  29  	-- create clip table
03:57:13  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:57:13  31  
03:57:13  32  	-- populate clip table
03:57:13  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:57:13  34  	  clip_table_name => 'svmc_clip',
03:57:13  35  	  data_table_name => '&bldtable',
03:57:13  36  	  tail_frac	  => 0.025,
03:57:13  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:13  38  
03:57:13  39  	-- xform input data to winsorized data
03:57:13  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:57:13  41  	  clip_table_name => 'svmc_clip',
03:57:13  42  	  data_table_name => '&bldtable',
03:57:13  43  	  xform_view_name => 'svmc_winsor');
03:57:13  44  
03:57:13  45  	-- create normalization table
03:57:13  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:57:13  47  
03:57:13  48  	-- populate normalization table based on winsorized data
03:57:13  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:57:13  50  	  norm_table_name => 'svmc_norm',
03:57:13  51  	  data_table_name => 'svmc_winsor',
03:57:13  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:13  53  
03:57:13  54  	-- normalize the original data
03:57:13  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:13  56  	  norm_table_name => 'svmc_norm',
03:57:13  57  	  data_table_name => '&bldtable',
03:57:13  58  	  xform_view_name => 'svmc_build_prep');
03:57:13  59  END;
03:57:13  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.76
03:57:16 SQL> 
03:57:16 SQL> ---------------------
03:57:16 SQL> -- CREATE A NEW MODEL
03:57:16 SQL> --
03:57:16 SQL> -- Cleanup old model with the same name for repeat runs
03:57:16 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:57:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:16   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.59
03:57:18 SQL> 
03:57:18 SQL> -- Build a new SVM Model
03:57:18 SQL> BEGIN
03:57:18   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:57:18   3  	  model_name	      => '&model_name',
03:57:18   4  	  mining_function     => dbms_data_mining.classification,
03:57:18   5  	  data_table_name     => 'svmc_build_prep',
03:57:18   6  	  case_id_column_name => '&case_id',
03:57:18   7  	  target_column_name  => '&target',
03:57:18   8  	  settings_table_name => 'svmc_settings');
03:57:18   9  END;
03:57:18  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.56
03:57:23 SQL> 
03:57:23 SQL> -----------------------------------------------------------------------
03:57:23 SQL> --			       APPLY/score THE MODEL
03:57:23 SQL> -----------------------------------------------------------------------
03:57:23 SQL> 
03:57:23 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:57:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:57:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:57:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:57:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:23 SQL> -----------------------
03:57:23 SQL> -- PREPARE SCORING DATA
03:57:23 SQL> --
03:57:23 SQL> -- If the data for model creation has been prepared, then the data
03:57:23 SQL> -- to be scored using the model must be prepared in the same manner
03:57:23 SQL> -- in order to obtain meaningful results.
03:57:23 SQL> --
03:57:23 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:23 SQL> -- 2. Normalization
03:57:23 SQL> -- No outlier treatment will be performed during test and apply. The
03:57:23 SQL> -- normalization step is sufficient, since the normalization parameters
03:57:23 SQL> -- already capture the effects of outlier treatment done with build data.
03:57:23 SQL> --
03:57:23 SQL> BEGIN
03:57:23   2  	-- Xform Test data to replace missing values
03:57:23   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:23   4  	  miss_table_name => 'svmc_miss_num',
03:57:23   5  	  data_table_name => '&scoretable',
03:57:23   6  	  xform_view_name => 'xformed_apply_miss_num');
03:57:23   7  
03:57:23   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:23   9  	  miss_table_name => 'svmc_miss_cat',
03:57:23  10  	  data_table_name => '&scoretable',
03:57:23  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:57:23  12  
03:57:23  13  	-- Normalize the data to be scored
03:57:23  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:23  15  	  norm_table_name => 'svmc_norm',
03:57:23  16  	  data_table_name => '&scoretable',
03:57:23  17  	  xform_view_name => 'svmc_apply_prep');
03:57:23  18  END;
03:57:23  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:57:24 SQL> 
03:57:24 SQL> -- Maybe I already collected a score for this prdate.
03:57:24 SQL> -- DELETE it if I did:
03:57:24 SQL> DELETE svm24scores
03:57:24   2  WHERE score > 0
03:57:24   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:57:24   4  -- I need to supply the target attribute name:
03:57:24   5  AND targ = '&1'
03:57:24   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:57:24 SQL> 
03:57:24 SQL> -- We do a drumroll here:
03:57:24 SQL> 
03:57:24 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:57:24   2  SELECT
03:57:24   3  prdate
03:57:24   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:57:24   5  ,sysdate
03:57:24   6  ,SUBSTR(prdate,1,7)pair
03:57:24   7  ,SUBSTR(prdate,-19)ydate
03:57:24   8  ,'&1'
03:57:24   9  FROM svmc_apply_prep
03:57:24  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:57:24 SQL> @score1_5min.sql	      2011-01-26 20:50:00 eur_usd
03:57:24 SQL> --
03:57:24 SQL> -- score1_5min.sql
03:57:24 SQL> --
03:57:24 SQL> 
03:57:24 SQL> -- Demo:
03:57:24 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:57:24 SQL> 
03:57:24 SQL> CREATE OR REPLACE VIEW sme AS
03:57:24   2  SELECT
03:57:24   3  prdate
03:57:24   4  ,NULL gatt
03:57:24   5  ,g00
03:57:24   6  ,g01
03:57:24   7  ,g02
03:57:24   8  ,g03
03:57:24   9  ,g04
03:57:24  10  ,g05
03:57:24  11  ,g06
03:57:24  12  ,g07
03:57:24  13  ,g08
03:57:24  14  ,g09
03:57:24  15  ,g10
03:57:24  16  ,g11
03:57:24  17  ,g12
03:57:24  18  ,g13
03:57:24  19  ,g14
03:57:24  20  ,g15
03:57:24  21  ,g16
03:57:24  22  ,g17
03:57:24  23  ,g18
03:57:24  24  ,g19
03:57:24  25  ,g20
03:57:24  26  ,g21
03:57:24  27  ,g22
03:57:24  28  ,g23
03:57:24  29  ,g24
03:57:24  30  ,g25
03:57:24  31  ,g26
03:57:24  32  ,g27
03:57:24  33  ,g28
03:57:24  34  ,g29
03:57:24  35  ,g30
03:57:24  36  ,g31
03:57:24  37  ,g32
03:57:24  38  ,g33
03:57:24  39  ,g34
03:57:24  40  ,g35
03:57:24  41  ,g36
03:57:24  42  ,g37
03:57:24  43  ,g38
03:57:24  44  ,g39
03:57:24  45  ,g40
03:57:24  46  ,g41
03:57:24  47  ,s.sc_corr
03:57:24  48  FROM modsrc24
03:57:24  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:57:24  50  WHERE ydate = '&1'||' '||'&2'
03:57:24  51  AND pair = '&3'
03:57:24  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-26'||' '||'20:50:00'AND ydate<'2011-01-26'||' '||'20:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-26'||' '||'20:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.08
03:57:24 SQL> 
03:57:24 SQL> -- rpt
03:57:24 SQL> -- We should see just 1 row:
03:57:24 SQL> 
03:57:24 SQL> SELECT COUNT(prdate) FROM sme
03:57:24   2  
03:57:24 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:57:24   2  
03:57:24 SQL> 
03:57:24 SQL> -- Build the model:
03:57:24 SQL> CREATE OR REPLACE VIEW bme AS
03:57:24   2  SELECT
03:57:24   3  prdate
03:57:24   4  ,gatt
03:57:24   5  ,g00
03:57:24   6  ,g01
03:57:24   7  ,g02
03:57:24   8  ,g03
03:57:24   9  ,g04
03:57:24  10  ,g05
03:57:24  11  ,g06
03:57:24  12  ,g07
03:57:24  13  ,g08
03:57:24  14  ,g09
03:57:24  15  ,g10
03:57:24  16  ,g11
03:57:24  17  ,g12
03:57:24  18  ,g13
03:57:24  19  ,g14
03:57:24  20  ,g15
03:57:24  21  ,g16
03:57:24  22  ,g17
03:57:24  23  ,g18
03:57:24  24  ,g19
03:57:24  25  ,g20
03:57:24  26  ,g21
03:57:24  27  ,g22
03:57:24  28  ,g23
03:57:24  29  ,g24
03:57:24  30  ,g25
03:57:24  31  ,g26
03:57:24  32  ,g27
03:57:24  33  ,g28
03:57:24  34  ,g29
03:57:24  35  ,g30
03:57:24  36  ,g31
03:57:24  37  ,g32
03:57:24  38  ,g33
03:57:24  39  ,g34
03:57:24  40  ,g35
03:57:24  41  ,g36
03:57:24  42  ,g37
03:57:24  43  ,g38
03:57:24  44  ,g39
03:57:24  45  ,g40
03:57:24  46  ,g41
03:57:24  47  ,sc_corr
03:57:24  48  FROM modsrc24
03:57:24  49  WHERE gatt IN('nup','up')
03:57:24  50  -- Use only rows which are older than 1 day:
03:57:24  51  AND 1+ydate < '&1'||' '||'&2'
03:57:24  52  AND pair = '&3'
03:57:24  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-26'||' '||'20:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:57:24 SQL> 
03:57:24 SQL> -- rpt
03:57:24 SQL> 
03:57:24 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:57:24   2  
03:57:24 SQL> SELECT MAX(prdate) FROM bme
03:57:24   2  
03:57:24 SQL> -- Now build model from bme and score sme
03:57:24 SQL> @score1.sql gatt
03:57:24 SQL> --
03:57:24 SQL> -- score1.sql
03:57:24 SQL> --
03:57:24 SQL> 
03:57:24 SQL> -- I use this script to send 5 params to score.sql
03:57:24 SQL> -- which does the heavy lifting of creating an SVM model.
03:57:24 SQL> -- Then at the very end of this script I use the model
03:57:24 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:57:24 SQL> 
03:57:24 SQL> -- I call this script from 2 other scripts:
03:57:24 SQL> -- score1_5min.sql
03:57:24 SQL> -- score1_5min_gattn.sql
03:57:24 SQL> 
03:57:24 SQL> -- The 1st param is the name of the target attribute.
03:57:24 SQL> -- I like to call my target attributes either gatt or gattn.
03:57:24 SQL> 
03:57:24 SQL> -- Demo:
03:57:24 SQL> -- @score1.sql 'gatt'
03:57:24 SQL> -- @score1.sql 'gattn'
03:57:24 SQL> 
03:57:24 SQL> -- Now, I fill up svmc_apply_prep.
03:57:24 SQL> -- I use same model_name used in score.sql
03:57:24 SQL> DEFINE model_name = 'svmfx101'
03:57:24 SQL> DEFINE bldtable	= 'bme'
03:57:24 SQL> DEFINE scoretable = 'sme'
03:57:24 SQL> DEFINE case_id	= 'prdate'
03:57:24 SQL> -- Demo:
03:57:24 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:57:24 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:57:24 SQL> --
03:57:24 SQL> -- score.sql
03:57:24 SQL> --
03:57:24 SQL> 
03:57:24 SQL> -- usage: score.sql
03:57:24 SQL> 
03:57:24 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:57:24 SQL> 
03:57:24 SQL> -- DEFINE target	   = 'gatt'
03:57:24 SQL> -- DEFINE model_name = 'svmfx101'
03:57:24 SQL> -- DEFINE bldtable   = 'bme'
03:57:24 SQL> -- DEFINE scoretable = 'sme'
03:57:24 SQL> -- DEFINE case_id    = 'prdate'
03:57:24 SQL> 
03:57:24 SQL> DEFINE target	= '&1'
03:57:24 SQL> DEFINE model_name = '&2'
03:57:24 SQL> DEFINE bldtable	= '&3'
03:57:24 SQL> DEFINE scoretable = '&4'
03:57:24 SQL> DEFINE case_id	= '&5'
03:57:24 SQL> 
03:57:24 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:57:24 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:57:24 SQL> 
03:57:24 SQL> -- Builds an SVM model using pl/sql.
03:57:24 SQL> 
03:57:24 SQL> -----------------------------------------------------------------------
03:57:24 SQL> --			    BUILD THE MODEL
03:57:24 SQL> -----------------------------------------------------------------------
03:57:24 SQL> 
03:57:24 SQL> -- Cleanup old build data preparation objects for repeat runs
03:57:24 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:57:24 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:57:24 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:24 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:57:24 SQL> 
03:57:24 SQL> 
03:57:24 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:57:24 SQL> --
03:57:24 SQL> -- DROP	TABLE svmc_settings ;
03:57:24 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:57:24 SQL> -- DELETE svmc_settings;
03:57:24 SQL> 
03:57:24 SQL> -- The default classification algorithm is Naive Bayes. So override
03:57:24 SQL> -- this choice to SVM using a settings table.
03:57:24 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:57:24 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:57:24 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:57:24 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:57:24 SQL> -- models.
03:57:24 SQL> --
03:57:24 SQL> 
03:57:24 SQL> -- Do this once and then comment it out.
03:57:24 SQL> -- That makes script go faster.
03:57:24 SQL> -- BEGIN
03:57:24 SQL> -- -- Populate settings table
03:57:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:24 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:57:24 SQL> --
03:57:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:24 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:57:24 SQL> --
03:57:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:24 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:57:24 SQL> --   COMMIT;
03:57:24 SQL> -- END;
03:57:24 SQL> -- /
03:57:24 SQL> 
03:57:24 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:57:24 SQL> 
03:57:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:57:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:57:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:57:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:24 SQL> 
03:57:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:57:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:24 SQL> 
03:57:24 SQL> --------------------------------
03:57:24 SQL> -- PREPARE BUILD (TRAINING) DATA
03:57:24 SQL> --
03:57:24 SQL> 
03:57:24 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:24 SQL> -- 2. Outlier Treatment and
03:57:24 SQL> -- 3. Normalization are performed below.
03:57:24 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:57:24 SQL> --    normalized here.
03:57:24 SQL> 
03:57:24 SQL> BEGIN
03:57:24   2  	-- Perform missing value treatment for all predictors
03:57:24   3  	-- create miss tables
03:57:24   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:57:24   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:57:24   6  
03:57:24   7  	-- populate miss tables
03:57:24   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:57:24   9  	  miss_table_name => 'svmc_miss_num',
03:57:24  10  	  data_table_name => '&bldtable',
03:57:24  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:24  12  
03:57:24  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:57:24  14  	  miss_table_name => 'svmc_miss_cat',
03:57:24  15  	  data_table_name => '&bldtable',
03:57:24  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:24  17  
03:57:24  18  	-- xform input data to replace missing values
03:57:24  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:24  20  	  miss_table_name => 'svmc_miss_num',
03:57:24  21  	  data_table_name => '&bldtable',
03:57:24  22  	  xform_view_name => 'xformed_build_miss_num');
03:57:24  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:24  24  	  miss_table_name => 'svmc_miss_cat',
03:57:24  25  	  data_table_name => '&bldtable',
03:57:24  26  	  xform_view_name => 'xformed_build_miss_cat');
03:57:24  27  
03:57:24  28  	-- Perform outlier treatment.
03:57:24  29  	-- create clip table
03:57:24  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:57:24  31  
03:57:24  32  	-- populate clip table
03:57:24  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:57:24  34  	  clip_table_name => 'svmc_clip',
03:57:24  35  	  data_table_name => '&bldtable',
03:57:24  36  	  tail_frac	  => 0.025,
03:57:24  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:24  38  
03:57:24  39  	-- xform input data to winsorized data
03:57:24  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:57:24  41  	  clip_table_name => 'svmc_clip',
03:57:24  42  	  data_table_name => '&bldtable',
03:57:24  43  	  xform_view_name => 'svmc_winsor');
03:57:24  44  
03:57:24  45  	-- create normalization table
03:57:24  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:57:24  47  
03:57:24  48  	-- populate normalization table based on winsorized data
03:57:24  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:57:24  50  	  norm_table_name => 'svmc_norm',
03:57:24  51  	  data_table_name => 'svmc_winsor',
03:57:24  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:24  53  
03:57:24  54  	-- normalize the original data
03:57:24  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:24  56  	  norm_table_name => 'svmc_norm',
03:57:24  57  	  data_table_name => '&bldtable',
03:57:24  58  	  xform_view_name => 'svmc_build_prep');
03:57:24  59  END;
03:57:24  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.67
03:57:27 SQL> 
03:57:27 SQL> ---------------------
03:57:27 SQL> -- CREATE A NEW MODEL
03:57:27 SQL> --
03:57:27 SQL> -- Cleanup old model with the same name for repeat runs
03:57:27 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:57:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:27   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.40
03:57:28 SQL> 
03:57:28 SQL> -- Build a new SVM Model
03:57:28 SQL> BEGIN
03:57:28   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:57:28   3  	  model_name	      => '&model_name',
03:57:28   4  	  mining_function     => dbms_data_mining.classification,
03:57:28   5  	  data_table_name     => 'svmc_build_prep',
03:57:28   6  	  case_id_column_name => '&case_id',
03:57:28   7  	  target_column_name  => '&target',
03:57:28   8  	  settings_table_name => 'svmc_settings');
03:57:28   9  END;
03:57:28  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.72
03:57:34 SQL> 
03:57:34 SQL> -----------------------------------------------------------------------
03:57:34 SQL> --			       APPLY/score THE MODEL
03:57:34 SQL> -----------------------------------------------------------------------
03:57:34 SQL> 
03:57:34 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:34 SQL> -----------------------
03:57:34 SQL> -- PREPARE SCORING DATA
03:57:34 SQL> --
03:57:34 SQL> -- If the data for model creation has been prepared, then the data
03:57:34 SQL> -- to be scored using the model must be prepared in the same manner
03:57:34 SQL> -- in order to obtain meaningful results.
03:57:34 SQL> --
03:57:34 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:34 SQL> -- 2. Normalization
03:57:34 SQL> -- No outlier treatment will be performed during test and apply. The
03:57:34 SQL> -- normalization step is sufficient, since the normalization parameters
03:57:34 SQL> -- already capture the effects of outlier treatment done with build data.
03:57:34 SQL> --
03:57:34 SQL> BEGIN
03:57:34   2  	-- Xform Test data to replace missing values
03:57:34   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:34   4  	  miss_table_name => 'svmc_miss_num',
03:57:34   5  	  data_table_name => '&scoretable',
03:57:34   6  	  xform_view_name => 'xformed_apply_miss_num');
03:57:34   7  
03:57:34   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:34   9  	  miss_table_name => 'svmc_miss_cat',
03:57:34  10  	  data_table_name => '&scoretable',
03:57:34  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:57:34  12  
03:57:34  13  	-- Normalize the data to be scored
03:57:34  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:34  15  	  norm_table_name => 'svmc_norm',
03:57:34  16  	  data_table_name => '&scoretable',
03:57:34  17  	  xform_view_name => 'svmc_apply_prep');
03:57:34  18  END;
03:57:34  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:57:34 SQL> 
03:57:34 SQL> -- Maybe I already collected a score for this prdate.
03:57:34 SQL> -- DELETE it if I did:
03:57:34 SQL> DELETE svm24scores
03:57:34   2  WHERE score > 0
03:57:34   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:57:34   4  -- I need to supply the target attribute name:
03:57:34   5  AND targ = '&1'
03:57:34   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:57:34 SQL> 
03:57:34 SQL> -- We do a drumroll here:
03:57:34 SQL> 
03:57:34 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:57:34   2  SELECT
03:57:34   3  prdate
03:57:34   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:57:34   5  ,sysdate
03:57:34   6  ,SUBSTR(prdate,1,7)pair
03:57:34   7  ,SUBSTR(prdate,-19)ydate
03:57:34   8  ,'&1'
03:57:34   9  FROM svmc_apply_prep
03:57:34  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:57:34 SQL> @score1_5min_gattn.sql	2011-01-20 22:15:00 eur_usd
03:57:34 SQL> --
03:57:34 SQL> -- score1_5min_gattn.sql
03:57:34 SQL> --
03:57:34 SQL> 
03:57:34 SQL> -- Demo:
03:57:34 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:57:34 SQL> 
03:57:34 SQL> CREATE OR REPLACE VIEW sme AS
03:57:34   2  SELECT
03:57:34   3  prdate
03:57:34   4  ,NULL gattn
03:57:34   5  ,g00
03:57:34   6  ,g01
03:57:34   7  ,g02
03:57:34   8  ,g03
03:57:34   9  ,g04
03:57:34  10  ,g05
03:57:34  11  ,g06
03:57:34  12  ,g07
03:57:34  13  ,g08
03:57:34  14  ,g09
03:57:34  15  ,g10
03:57:34  16  ,g11
03:57:34  17  ,g12
03:57:34  18  ,g13
03:57:34  19  ,g14
03:57:34  20  ,g15
03:57:34  21  ,g16
03:57:34  22  ,g17
03:57:34  23  ,g18
03:57:34  24  ,g19
03:57:34  25  ,g20
03:57:34  26  ,g21
03:57:34  27  ,g22
03:57:34  28  ,g23
03:57:34  29  ,g24
03:57:34  30  ,g25
03:57:34  31  ,g26
03:57:34  32  ,g27
03:57:34  33  ,g28
03:57:34  34  ,g29
03:57:34  35  ,g30
03:57:34  36  ,g31
03:57:34  37  ,g32
03:57:34  38  ,g33
03:57:34  39  ,g34
03:57:34  40  ,g35
03:57:34  41  ,g36
03:57:34  42  ,g37
03:57:34  43  ,g38
03:57:34  44  ,g39
03:57:34  45  ,g40
03:57:34  46  ,g41
03:57:34  47  ,s.sc_corr
03:57:34  48  FROM modsrc24
03:57:34  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:57:34  50  WHERE ydate = '&1'||' '||'&2'
03:57:34  51  AND pair = '&3'
03:57:34  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'22:15:00'AND ydate<'2011-01-20'||' '||'22:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'22:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:57:34 SQL> 
03:57:34 SQL> -- rpt
03:57:34 SQL> -- We should see just 1 row:
03:57:34 SQL> 
03:57:34 SQL> SELECT COUNT(prdate) FROM sme
03:57:34   2  
03:57:34 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:57:34   2  
03:57:34 SQL> 
03:57:34 SQL> -- Build the model:
03:57:34 SQL> CREATE OR REPLACE VIEW bme AS
03:57:34   2  SELECT
03:57:34   3  prdate
03:57:34   4  ,gattn
03:57:34   5  ,g00
03:57:34   6  ,g01
03:57:34   7  ,g02
03:57:34   8  ,g03
03:57:34   9  ,g04
03:57:34  10  ,g05
03:57:34  11  ,g06
03:57:34  12  ,g07
03:57:34  13  ,g08
03:57:34  14  ,g09
03:57:34  15  ,g10
03:57:34  16  ,g11
03:57:34  17  ,g12
03:57:34  18  ,g13
03:57:34  19  ,g14
03:57:34  20  ,g15
03:57:34  21  ,g16
03:57:34  22  ,g17
03:57:34  23  ,g18
03:57:34  24  ,g19
03:57:34  25  ,g20
03:57:34  26  ,g21
03:57:34  27  ,g22
03:57:34  28  ,g23
03:57:34  29  ,g24
03:57:34  30  ,g25
03:57:34  31  ,g26
03:57:34  32  ,g27
03:57:34  33  ,g28
03:57:34  34  ,g29
03:57:34  35  ,g30
03:57:34  36  ,g31
03:57:34  37  ,g32
03:57:34  38  ,g33
03:57:34  39  ,g34
03:57:34  40  ,g35
03:57:34  41  ,g36
03:57:34  42  ,g37
03:57:34  43  ,g38
03:57:34  44  ,g39
03:57:34  45  ,g40
03:57:34  46  ,g41
03:57:34  47  ,sc_corr
03:57:34  48  FROM modsrc24
03:57:34  49  WHERE gattn IN('nup','up')
03:57:34  50  -- Use only rows which are older than 1 day:
03:57:34  51  AND 1+ydate < '&1'||' '||'&2'
03:57:34  52  AND pair = '&3'
03:57:34  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'22:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:57:34 SQL> 
03:57:34 SQL> -- rpt
03:57:34 SQL> 
03:57:34 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:57:34   2  
03:57:34 SQL> SELECT MAX(prdate) FROM bme
03:57:34   2  
03:57:34 SQL> -- Now build model from bme and score sme
03:57:34 SQL> @score1.sql gattn
03:57:34 SQL> --
03:57:34 SQL> -- score1.sql
03:57:34 SQL> --
03:57:34 SQL> 
03:57:34 SQL> -- I use this script to send 5 params to score.sql
03:57:34 SQL> -- which does the heavy lifting of creating an SVM model.
03:57:34 SQL> -- Then at the very end of this script I use the model
03:57:34 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:57:34 SQL> 
03:57:34 SQL> -- I call this script from 2 other scripts:
03:57:34 SQL> -- score1_5min.sql
03:57:34 SQL> -- score1_5min_gattn.sql
03:57:34 SQL> 
03:57:34 SQL> -- The 1st param is the name of the target attribute.
03:57:34 SQL> -- I like to call my target attributes either gatt or gattn.
03:57:34 SQL> 
03:57:34 SQL> -- Demo:
03:57:34 SQL> -- @score1.sql 'gatt'
03:57:34 SQL> -- @score1.sql 'gattn'
03:57:34 SQL> 
03:57:34 SQL> -- Now, I fill up svmc_apply_prep.
03:57:34 SQL> -- I use same model_name used in score.sql
03:57:34 SQL> DEFINE model_name = 'svmfx101'
03:57:34 SQL> DEFINE bldtable	= 'bme'
03:57:34 SQL> DEFINE scoretable = 'sme'
03:57:34 SQL> DEFINE case_id	= 'prdate'
03:57:34 SQL> -- Demo:
03:57:34 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:57:34 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:57:34 SQL> --
03:57:34 SQL> -- score.sql
03:57:34 SQL> --
03:57:34 SQL> 
03:57:34 SQL> -- usage: score.sql
03:57:34 SQL> 
03:57:34 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:57:34 SQL> 
03:57:34 SQL> -- DEFINE target	   = 'gatt'
03:57:34 SQL> -- DEFINE model_name = 'svmfx101'
03:57:34 SQL> -- DEFINE bldtable   = 'bme'
03:57:34 SQL> -- DEFINE scoretable = 'sme'
03:57:34 SQL> -- DEFINE case_id    = 'prdate'
03:57:34 SQL> 
03:57:34 SQL> DEFINE target	= '&1'
03:57:34 SQL> DEFINE model_name = '&2'
03:57:34 SQL> DEFINE bldtable	= '&3'
03:57:34 SQL> DEFINE scoretable = '&4'
03:57:34 SQL> DEFINE case_id	= '&5'
03:57:34 SQL> 
03:57:34 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:57:34 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:57:34 SQL> 
03:57:34 SQL> -- Builds an SVM model using pl/sql.
03:57:34 SQL> 
03:57:34 SQL> -----------------------------------------------------------------------
03:57:34 SQL> --			    BUILD THE MODEL
03:57:34 SQL> -----------------------------------------------------------------------
03:57:34 SQL> 
03:57:34 SQL> -- Cleanup old build data preparation objects for repeat runs
03:57:34 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:34 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:57:34 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:34 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:57:34 SQL> 
03:57:34 SQL> 
03:57:34 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:57:34 SQL> --
03:57:34 SQL> -- DROP	TABLE svmc_settings ;
03:57:34 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:57:34 SQL> -- DELETE svmc_settings;
03:57:34 SQL> 
03:57:34 SQL> -- The default classification algorithm is Naive Bayes. So override
03:57:34 SQL> -- this choice to SVM using a settings table.
03:57:34 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:57:34 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:57:34 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:57:34 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:57:34 SQL> -- models.
03:57:34 SQL> --
03:57:34 SQL> 
03:57:34 SQL> -- Do this once and then comment it out.
03:57:34 SQL> -- That makes script go faster.
03:57:34 SQL> -- BEGIN
03:57:34 SQL> -- -- Populate settings table
03:57:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:34 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:57:34 SQL> --
03:57:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:34 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:57:34 SQL> --
03:57:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:34 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:57:34 SQL> --   COMMIT;
03:57:34 SQL> -- END;
03:57:34 SQL> -- /
03:57:34 SQL> 
03:57:34 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:57:34 SQL> 
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:34 SQL> 
03:57:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:57:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:35 SQL> 
03:57:35 SQL> --------------------------------
03:57:35 SQL> -- PREPARE BUILD (TRAINING) DATA
03:57:35 SQL> --
03:57:35 SQL> 
03:57:35 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:35 SQL> -- 2. Outlier Treatment and
03:57:35 SQL> -- 3. Normalization are performed below.
03:57:35 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:57:35 SQL> --    normalized here.
03:57:35 SQL> 
03:57:35 SQL> BEGIN
03:57:35   2  	-- Perform missing value treatment for all predictors
03:57:35   3  	-- create miss tables
03:57:35   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:57:35   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:57:35   6  
03:57:35   7  	-- populate miss tables
03:57:35   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:57:35   9  	  miss_table_name => 'svmc_miss_num',
03:57:35  10  	  data_table_name => '&bldtable',
03:57:35  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:35  12  
03:57:35  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:57:35  14  	  miss_table_name => 'svmc_miss_cat',
03:57:35  15  	  data_table_name => '&bldtable',
03:57:35  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:35  17  
03:57:35  18  	-- xform input data to replace missing values
03:57:35  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:35  20  	  miss_table_name => 'svmc_miss_num',
03:57:35  21  	  data_table_name => '&bldtable',
03:57:35  22  	  xform_view_name => 'xformed_build_miss_num');
03:57:35  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:35  24  	  miss_table_name => 'svmc_miss_cat',
03:57:35  25  	  data_table_name => '&bldtable',
03:57:35  26  	  xform_view_name => 'xformed_build_miss_cat');
03:57:35  27  
03:57:35  28  	-- Perform outlier treatment.
03:57:35  29  	-- create clip table
03:57:35  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:57:35  31  
03:57:35  32  	-- populate clip table
03:57:35  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:57:35  34  	  clip_table_name => 'svmc_clip',
03:57:35  35  	  data_table_name => '&bldtable',
03:57:35  36  	  tail_frac	  => 0.025,
03:57:35  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:35  38  
03:57:35  39  	-- xform input data to winsorized data
03:57:35  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:57:35  41  	  clip_table_name => 'svmc_clip',
03:57:35  42  	  data_table_name => '&bldtable',
03:57:35  43  	  xform_view_name => 'svmc_winsor');
03:57:35  44  
03:57:35  45  	-- create normalization table
03:57:35  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:57:35  47  
03:57:35  48  	-- populate normalization table based on winsorized data
03:57:35  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:57:35  50  	  norm_table_name => 'svmc_norm',
03:57:35  51  	  data_table_name => 'svmc_winsor',
03:57:35  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:35  53  
03:57:35  54  	-- normalize the original data
03:57:35  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:35  56  	  norm_table_name => 'svmc_norm',
03:57:35  57  	  data_table_name => '&bldtable',
03:57:35  58  	  xform_view_name => 'svmc_build_prep');
03:57:35  59  END;
03:57:35  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
03:57:37 SQL> 
03:57:37 SQL> ---------------------
03:57:37 SQL> -- CREATE A NEW MODEL
03:57:37 SQL> --
03:57:37 SQL> -- Cleanup old model with the same name for repeat runs
03:57:37 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:57:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:37   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.62
03:57:39 SQL> 
03:57:39 SQL> -- Build a new SVM Model
03:57:39 SQL> BEGIN
03:57:39   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:57:39   3  	  model_name	      => '&model_name',
03:57:39   4  	  mining_function     => dbms_data_mining.classification,
03:57:39   5  	  data_table_name     => 'svmc_build_prep',
03:57:39   6  	  case_id_column_name => '&case_id',
03:57:39   7  	  target_column_name  => '&target',
03:57:39   8  	  settings_table_name => 'svmc_settings');
03:57:39   9  END;
03:57:39  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.47
03:57:44 SQL> 
03:57:44 SQL> -----------------------------------------------------------------------
03:57:44 SQL> --			       APPLY/score THE MODEL
03:57:44 SQL> -----------------------------------------------------------------------
03:57:44 SQL> 
03:57:44 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:57:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:57:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:57:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:57:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:57:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:44 SQL> -----------------------
03:57:44 SQL> -- PREPARE SCORING DATA
03:57:44 SQL> --
03:57:44 SQL> -- If the data for model creation has been prepared, then the data
03:57:44 SQL> -- to be scored using the model must be prepared in the same manner
03:57:44 SQL> -- in order to obtain meaningful results.
03:57:44 SQL> --
03:57:44 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:44 SQL> -- 2. Normalization
03:57:44 SQL> -- No outlier treatment will be performed during test and apply. The
03:57:44 SQL> -- normalization step is sufficient, since the normalization parameters
03:57:44 SQL> -- already capture the effects of outlier treatment done with build data.
03:57:44 SQL> --
03:57:44 SQL> BEGIN
03:57:44   2  	-- Xform Test data to replace missing values
03:57:44   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:44   4  	  miss_table_name => 'svmc_miss_num',
03:57:44   5  	  data_table_name => '&scoretable',
03:57:44   6  	  xform_view_name => 'xformed_apply_miss_num');
03:57:44   7  
03:57:44   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:44   9  	  miss_table_name => 'svmc_miss_cat',
03:57:44  10  	  data_table_name => '&scoretable',
03:57:44  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:57:44  12  
03:57:44  13  	-- Normalize the data to be scored
03:57:44  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:44  15  	  norm_table_name => 'svmc_norm',
03:57:44  16  	  data_table_name => '&scoretable',
03:57:44  17  	  xform_view_name => 'svmc_apply_prep');
03:57:44  18  END;
03:57:44  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:57:44 SQL> 
03:57:44 SQL> -- Maybe I already collected a score for this prdate.
03:57:44 SQL> -- DELETE it if I did:
03:57:44 SQL> DELETE svm24scores
03:57:44   2  WHERE score > 0
03:57:44   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:57:44   4  -- I need to supply the target attribute name:
03:57:44   5  AND targ = '&1'
03:57:44   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:57:45 SQL> 
03:57:45 SQL> -- We do a drumroll here:
03:57:45 SQL> 
03:57:45 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:57:45   2  SELECT
03:57:45   3  prdate
03:57:45   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:57:45   5  ,sysdate
03:57:45   6  ,SUBSTR(prdate,1,7)pair
03:57:45   7  ,SUBSTR(prdate,-19)ydate
03:57:45   8  ,'&1'
03:57:45   9  FROM svmc_apply_prep
03:57:45  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:57:45 SQL> @score1_5min_gattn.sql	2011-01-19 08:20:00 eur_usd
03:57:45 SQL> --
03:57:45 SQL> -- score1_5min_gattn.sql
03:57:45 SQL> --
03:57:45 SQL> 
03:57:45 SQL> -- Demo:
03:57:45 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:57:45 SQL> 
03:57:45 SQL> CREATE OR REPLACE VIEW sme AS
03:57:45   2  SELECT
03:57:45   3  prdate
03:57:45   4  ,NULL gattn
03:57:45   5  ,g00
03:57:45   6  ,g01
03:57:45   7  ,g02
03:57:45   8  ,g03
03:57:45   9  ,g04
03:57:45  10  ,g05
03:57:45  11  ,g06
03:57:45  12  ,g07
03:57:45  13  ,g08
03:57:45  14  ,g09
03:57:45  15  ,g10
03:57:45  16  ,g11
03:57:45  17  ,g12
03:57:45  18  ,g13
03:57:45  19  ,g14
03:57:45  20  ,g15
03:57:45  21  ,g16
03:57:45  22  ,g17
03:57:45  23  ,g18
03:57:45  24  ,g19
03:57:45  25  ,g20
03:57:45  26  ,g21
03:57:45  27  ,g22
03:57:45  28  ,g23
03:57:45  29  ,g24
03:57:45  30  ,g25
03:57:45  31  ,g26
03:57:45  32  ,g27
03:57:45  33  ,g28
03:57:45  34  ,g29
03:57:45  35  ,g30
03:57:45  36  ,g31
03:57:45  37  ,g32
03:57:45  38  ,g33
03:57:45  39  ,g34
03:57:45  40  ,g35
03:57:45  41  ,g36
03:57:45  42  ,g37
03:57:45  43  ,g38
03:57:45  44  ,g39
03:57:45  45  ,g40
03:57:45  46  ,g41
03:57:45  47  ,s.sc_corr
03:57:45  48  FROM modsrc24
03:57:45  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:57:45  50  WHERE ydate = '&1'||' '||'&2'
03:57:45  51  AND pair = '&3'
03:57:45  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'08:20:00'AND ydate<'2011-01-19'||' '||'08:20:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'08:20:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:57:45 SQL> 
03:57:45 SQL> -- rpt
03:57:45 SQL> -- We should see just 1 row:
03:57:45 SQL> 
03:57:45 SQL> SELECT COUNT(prdate) FROM sme
03:57:45   2  
03:57:45 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:57:45   2  
03:57:45 SQL> 
03:57:45 SQL> -- Build the model:
03:57:45 SQL> CREATE OR REPLACE VIEW bme AS
03:57:45   2  SELECT
03:57:45   3  prdate
03:57:45   4  ,gattn
03:57:45   5  ,g00
03:57:45   6  ,g01
03:57:45   7  ,g02
03:57:45   8  ,g03
03:57:45   9  ,g04
03:57:45  10  ,g05
03:57:45  11  ,g06
03:57:45  12  ,g07
03:57:45  13  ,g08
03:57:45  14  ,g09
03:57:45  15  ,g10
03:57:45  16  ,g11
03:57:45  17  ,g12
03:57:45  18  ,g13
03:57:45  19  ,g14
03:57:45  20  ,g15
03:57:45  21  ,g16
03:57:45  22  ,g17
03:57:45  23  ,g18
03:57:45  24  ,g19
03:57:45  25  ,g20
03:57:45  26  ,g21
03:57:45  27  ,g22
03:57:45  28  ,g23
03:57:45  29  ,g24
03:57:45  30  ,g25
03:57:45  31  ,g26
03:57:45  32  ,g27
03:57:45  33  ,g28
03:57:45  34  ,g29
03:57:45  35  ,g30
03:57:45  36  ,g31
03:57:45  37  ,g32
03:57:45  38  ,g33
03:57:45  39  ,g34
03:57:45  40  ,g35
03:57:45  41  ,g36
03:57:45  42  ,g37
03:57:45  43  ,g38
03:57:45  44  ,g39
03:57:45  45  ,g40
03:57:45  46  ,g41
03:57:45  47  ,sc_corr
03:57:45  48  FROM modsrc24
03:57:45  49  WHERE gattn IN('nup','up')
03:57:45  50  -- Use only rows which are older than 1 day:
03:57:45  51  AND 1+ydate < '&1'||' '||'&2'
03:57:45  52  AND pair = '&3'
03:57:45  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'08:20:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:57:45 SQL> 
03:57:45 SQL> -- rpt
03:57:45 SQL> 
03:57:45 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:57:45   2  
03:57:45 SQL> SELECT MAX(prdate) FROM bme
03:57:45   2  
03:57:45 SQL> -- Now build model from bme and score sme
03:57:45 SQL> @score1.sql gattn
03:57:45 SQL> --
03:57:45 SQL> -- score1.sql
03:57:45 SQL> --
03:57:45 SQL> 
03:57:45 SQL> -- I use this script to send 5 params to score.sql
03:57:45 SQL> -- which does the heavy lifting of creating an SVM model.
03:57:45 SQL> -- Then at the very end of this script I use the model
03:57:45 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:57:45 SQL> 
03:57:45 SQL> -- I call this script from 2 other scripts:
03:57:45 SQL> -- score1_5min.sql
03:57:45 SQL> -- score1_5min_gattn.sql
03:57:45 SQL> 
03:57:45 SQL> -- The 1st param is the name of the target attribute.
03:57:45 SQL> -- I like to call my target attributes either gatt or gattn.
03:57:45 SQL> 
03:57:45 SQL> -- Demo:
03:57:45 SQL> -- @score1.sql 'gatt'
03:57:45 SQL> -- @score1.sql 'gattn'
03:57:45 SQL> 
03:57:45 SQL> -- Now, I fill up svmc_apply_prep.
03:57:45 SQL> -- I use same model_name used in score.sql
03:57:45 SQL> DEFINE model_name = 'svmfx101'
03:57:45 SQL> DEFINE bldtable	= 'bme'
03:57:45 SQL> DEFINE scoretable = 'sme'
03:57:45 SQL> DEFINE case_id	= 'prdate'
03:57:45 SQL> -- Demo:
03:57:45 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:57:45 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:57:45 SQL> --
03:57:45 SQL> -- score.sql
03:57:45 SQL> --
03:57:45 SQL> 
03:57:45 SQL> -- usage: score.sql
03:57:45 SQL> 
03:57:45 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:57:45 SQL> 
03:57:45 SQL> -- DEFINE target	   = 'gatt'
03:57:45 SQL> -- DEFINE model_name = 'svmfx101'
03:57:45 SQL> -- DEFINE bldtable   = 'bme'
03:57:45 SQL> -- DEFINE scoretable = 'sme'
03:57:45 SQL> -- DEFINE case_id    = 'prdate'
03:57:45 SQL> 
03:57:45 SQL> DEFINE target	= '&1'
03:57:45 SQL> DEFINE model_name = '&2'
03:57:45 SQL> DEFINE bldtable	= '&3'
03:57:45 SQL> DEFINE scoretable = '&4'
03:57:45 SQL> DEFINE case_id	= '&5'
03:57:45 SQL> 
03:57:45 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:57:45 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:57:45 SQL> 
03:57:45 SQL> -- Builds an SVM model using pl/sql.
03:57:45 SQL> 
03:57:45 SQL> -----------------------------------------------------------------------
03:57:45 SQL> --			    BUILD THE MODEL
03:57:45 SQL> -----------------------------------------------------------------------
03:57:45 SQL> 
03:57:45 SQL> -- Cleanup old build data preparation objects for repeat runs
03:57:45 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:45 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:57:45 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:57:45 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:57:45 SQL> 
03:57:45 SQL> 
03:57:45 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:57:45 SQL> --
03:57:45 SQL> -- DROP	TABLE svmc_settings ;
03:57:45 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:57:45 SQL> -- DELETE svmc_settings;
03:57:45 SQL> 
03:57:45 SQL> -- The default classification algorithm is Naive Bayes. So override
03:57:45 SQL> -- this choice to SVM using a settings table.
03:57:45 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:57:45 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:57:45 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:57:45 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:57:45 SQL> -- models.
03:57:45 SQL> --
03:57:45 SQL> 
03:57:45 SQL> -- Do this once and then comment it out.
03:57:45 SQL> -- That makes script go faster.
03:57:45 SQL> -- BEGIN
03:57:45 SQL> -- -- Populate settings table
03:57:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:45 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:57:45 SQL> --
03:57:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:45 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:57:45 SQL> --
03:57:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:45 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:57:45 SQL> --   COMMIT;
03:57:45 SQL> -- END;
03:57:45 SQL> -- /
03:57:45 SQL> 
03:57:45 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:57:45 SQL> 
03:57:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:57:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:57:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:57:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:57:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:45 SQL> 
03:57:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:57:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:57:45 SQL> 
03:57:45 SQL> --------------------------------
03:57:45 SQL> -- PREPARE BUILD (TRAINING) DATA
03:57:45 SQL> --
03:57:45 SQL> 
03:57:45 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:45 SQL> -- 2. Outlier Treatment and
03:57:45 SQL> -- 3. Normalization are performed below.
03:57:45 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:57:45 SQL> --    normalized here.
03:57:45 SQL> 
03:57:45 SQL> BEGIN
03:57:45   2  	-- Perform missing value treatment for all predictors
03:57:45   3  	-- create miss tables
03:57:45   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:57:45   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:57:45   6  
03:57:45   7  	-- populate miss tables
03:57:45   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:57:45   9  	  miss_table_name => 'svmc_miss_num',
03:57:45  10  	  data_table_name => '&bldtable',
03:57:45  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:45  12  
03:57:45  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:57:45  14  	  miss_table_name => 'svmc_miss_cat',
03:57:45  15  	  data_table_name => '&bldtable',
03:57:45  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:45  17  
03:57:45  18  	-- xform input data to replace missing values
03:57:45  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:45  20  	  miss_table_name => 'svmc_miss_num',
03:57:45  21  	  data_table_name => '&bldtable',
03:57:45  22  	  xform_view_name => 'xformed_build_miss_num');
03:57:45  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:45  24  	  miss_table_name => 'svmc_miss_cat',
03:57:45  25  	  data_table_name => '&bldtable',
03:57:45  26  	  xform_view_name => 'xformed_build_miss_cat');
03:57:45  27  
03:57:45  28  	-- Perform outlier treatment.
03:57:45  29  	-- create clip table
03:57:45  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:57:45  31  
03:57:45  32  	-- populate clip table
03:57:45  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:57:45  34  	  clip_table_name => 'svmc_clip',
03:57:45  35  	  data_table_name => '&bldtable',
03:57:45  36  	  tail_frac	  => 0.025,
03:57:45  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:45  38  
03:57:45  39  	-- xform input data to winsorized data
03:57:45  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:57:45  41  	  clip_table_name => 'svmc_clip',
03:57:45  42  	  data_table_name => '&bldtable',
03:57:45  43  	  xform_view_name => 'svmc_winsor');
03:57:45  44  
03:57:45  45  	-- create normalization table
03:57:45  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:57:45  47  
03:57:45  48  	-- populate normalization table based on winsorized data
03:57:45  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:57:45  50  	  norm_table_name => 'svmc_norm',
03:57:45  51  	  data_table_name => 'svmc_winsor',
03:57:45  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:45  53  
03:57:45  54  	-- normalize the original data
03:57:45  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:45  56  	  norm_table_name => 'svmc_norm',
03:57:45  57  	  data_table_name => '&bldtable',
03:57:45  58  	  xform_view_name => 'svmc_build_prep');
03:57:45  59  END;
03:57:45  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.51
03:57:47 SQL> 
03:57:47 SQL> ---------------------
03:57:47 SQL> -- CREATE A NEW MODEL
03:57:47 SQL> --
03:57:47 SQL> -- Cleanup old model with the same name for repeat runs
03:57:47 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:57:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:47   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.59
03:57:49 SQL> 
03:57:49 SQL> -- Build a new SVM Model
03:57:49 SQL> BEGIN
03:57:49   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:57:49   3  	  model_name	      => '&model_name',
03:57:49   4  	  mining_function     => dbms_data_mining.classification,
03:57:49   5  	  data_table_name     => 'svmc_build_prep',
03:57:49   6  	  case_id_column_name => '&case_id',
03:57:49   7  	  target_column_name  => '&target',
03:57:49   8  	  settings_table_name => 'svmc_settings');
03:57:49   9  END;
03:57:49  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.65
03:57:54 SQL> 
03:57:54 SQL> -----------------------------------------------------------------------
03:57:54 SQL> --			       APPLY/score THE MODEL
03:57:54 SQL> -----------------------------------------------------------------------
03:57:54 SQL> 
03:57:54 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:54 SQL> -----------------------
03:57:54 SQL> -- PREPARE SCORING DATA
03:57:54 SQL> --
03:57:54 SQL> -- If the data for model creation has been prepared, then the data
03:57:54 SQL> -- to be scored using the model must be prepared in the same manner
03:57:54 SQL> -- in order to obtain meaningful results.
03:57:54 SQL> --
03:57:54 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:54 SQL> -- 2. Normalization
03:57:54 SQL> -- No outlier treatment will be performed during test and apply. The
03:57:54 SQL> -- normalization step is sufficient, since the normalization parameters
03:57:54 SQL> -- already capture the effects of outlier treatment done with build data.
03:57:54 SQL> --
03:57:54 SQL> BEGIN
03:57:54   2  	-- Xform Test data to replace missing values
03:57:54   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:54   4  	  miss_table_name => 'svmc_miss_num',
03:57:54   5  	  data_table_name => '&scoretable',
03:57:54   6  	  xform_view_name => 'xformed_apply_miss_num');
03:57:54   7  
03:57:54   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:54   9  	  miss_table_name => 'svmc_miss_cat',
03:57:54  10  	  data_table_name => '&scoretable',
03:57:54  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:57:54  12  
03:57:54  13  	-- Normalize the data to be scored
03:57:54  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:54  15  	  norm_table_name => 'svmc_norm',
03:57:54  16  	  data_table_name => '&scoretable',
03:57:54  17  	  xform_view_name => 'svmc_apply_prep');
03:57:54  18  END;
03:57:54  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:57:54 SQL> 
03:57:54 SQL> -- Maybe I already collected a score for this prdate.
03:57:54 SQL> -- DELETE it if I did:
03:57:54 SQL> DELETE svm24scores
03:57:54   2  WHERE score > 0
03:57:54   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:57:54   4  -- I need to supply the target attribute name:
03:57:54   5  AND targ = '&1'
03:57:54   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:57:54 SQL> 
03:57:54 SQL> -- We do a drumroll here:
03:57:54 SQL> 
03:57:54 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:57:54   2  SELECT
03:57:54   3  prdate
03:57:54   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:57:54   5  ,sysdate
03:57:54   6  ,SUBSTR(prdate,1,7)pair
03:57:54   7  ,SUBSTR(prdate,-19)ydate
03:57:54   8  ,'&1'
03:57:54   9  FROM svmc_apply_prep
03:57:54  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:57:54 SQL> @score1_5min.sql	      2011-01-19 09:40:00 eur_usd
03:57:54 SQL> --
03:57:54 SQL> -- score1_5min.sql
03:57:54 SQL> --
03:57:54 SQL> 
03:57:54 SQL> -- Demo:
03:57:54 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:57:54 SQL> 
03:57:54 SQL> CREATE OR REPLACE VIEW sme AS
03:57:54   2  SELECT
03:57:54   3  prdate
03:57:54   4  ,NULL gatt
03:57:54   5  ,g00
03:57:54   6  ,g01
03:57:54   7  ,g02
03:57:54   8  ,g03
03:57:54   9  ,g04
03:57:54  10  ,g05
03:57:54  11  ,g06
03:57:54  12  ,g07
03:57:54  13  ,g08
03:57:54  14  ,g09
03:57:54  15  ,g10
03:57:54  16  ,g11
03:57:54  17  ,g12
03:57:54  18  ,g13
03:57:54  19  ,g14
03:57:54  20  ,g15
03:57:54  21  ,g16
03:57:54  22  ,g17
03:57:54  23  ,g18
03:57:54  24  ,g19
03:57:54  25  ,g20
03:57:54  26  ,g21
03:57:54  27  ,g22
03:57:54  28  ,g23
03:57:54  29  ,g24
03:57:54  30  ,g25
03:57:54  31  ,g26
03:57:54  32  ,g27
03:57:54  33  ,g28
03:57:54  34  ,g29
03:57:54  35  ,g30
03:57:54  36  ,g31
03:57:54  37  ,g32
03:57:54  38  ,g33
03:57:54  39  ,g34
03:57:54  40  ,g35
03:57:54  41  ,g36
03:57:54  42  ,g37
03:57:54  43  ,g38
03:57:54  44  ,g39
03:57:54  45  ,g40
03:57:54  46  ,g41
03:57:54  47  ,s.sc_corr
03:57:54  48  FROM modsrc24
03:57:54  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:57:54  50  WHERE ydate = '&1'||' '||'&2'
03:57:54  51  AND pair = '&3'
03:57:54  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'09:40:00'AND ydate<'2011-01-19'||' '||'09:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'09:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:57:54 SQL> 
03:57:54 SQL> -- rpt
03:57:54 SQL> -- We should see just 1 row:
03:57:54 SQL> 
03:57:54 SQL> SELECT COUNT(prdate) FROM sme
03:57:54   2  
03:57:54 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:57:54   2  
03:57:54 SQL> 
03:57:54 SQL> -- Build the model:
03:57:54 SQL> CREATE OR REPLACE VIEW bme AS
03:57:54   2  SELECT
03:57:54   3  prdate
03:57:54   4  ,gatt
03:57:54   5  ,g00
03:57:54   6  ,g01
03:57:54   7  ,g02
03:57:54   8  ,g03
03:57:54   9  ,g04
03:57:54  10  ,g05
03:57:54  11  ,g06
03:57:54  12  ,g07
03:57:54  13  ,g08
03:57:54  14  ,g09
03:57:54  15  ,g10
03:57:54  16  ,g11
03:57:54  17  ,g12
03:57:54  18  ,g13
03:57:54  19  ,g14
03:57:54  20  ,g15
03:57:54  21  ,g16
03:57:54  22  ,g17
03:57:54  23  ,g18
03:57:54  24  ,g19
03:57:54  25  ,g20
03:57:54  26  ,g21
03:57:54  27  ,g22
03:57:54  28  ,g23
03:57:54  29  ,g24
03:57:54  30  ,g25
03:57:54  31  ,g26
03:57:54  32  ,g27
03:57:54  33  ,g28
03:57:54  34  ,g29
03:57:54  35  ,g30
03:57:54  36  ,g31
03:57:54  37  ,g32
03:57:54  38  ,g33
03:57:54  39  ,g34
03:57:54  40  ,g35
03:57:54  41  ,g36
03:57:54  42  ,g37
03:57:54  43  ,g38
03:57:54  44  ,g39
03:57:54  45  ,g40
03:57:54  46  ,g41
03:57:54  47  ,sc_corr
03:57:54  48  FROM modsrc24
03:57:54  49  WHERE gatt IN('nup','up')
03:57:54  50  -- Use only rows which are older than 1 day:
03:57:54  51  AND 1+ydate < '&1'||' '||'&2'
03:57:54  52  AND pair = '&3'
03:57:54  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'09:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:57:54 SQL> 
03:57:54 SQL> -- rpt
03:57:54 SQL> 
03:57:54 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:57:54   2  
03:57:54 SQL> SELECT MAX(prdate) FROM bme
03:57:54   2  
03:57:54 SQL> -- Now build model from bme and score sme
03:57:54 SQL> @score1.sql gatt
03:57:54 SQL> --
03:57:54 SQL> -- score1.sql
03:57:54 SQL> --
03:57:54 SQL> 
03:57:54 SQL> -- I use this script to send 5 params to score.sql
03:57:54 SQL> -- which does the heavy lifting of creating an SVM model.
03:57:54 SQL> -- Then at the very end of this script I use the model
03:57:54 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:57:54 SQL> 
03:57:54 SQL> -- I call this script from 2 other scripts:
03:57:54 SQL> -- score1_5min.sql
03:57:54 SQL> -- score1_5min_gattn.sql
03:57:54 SQL> 
03:57:54 SQL> -- The 1st param is the name of the target attribute.
03:57:54 SQL> -- I like to call my target attributes either gatt or gattn.
03:57:54 SQL> 
03:57:54 SQL> -- Demo:
03:57:54 SQL> -- @score1.sql 'gatt'
03:57:54 SQL> -- @score1.sql 'gattn'
03:57:54 SQL> 
03:57:54 SQL> -- Now, I fill up svmc_apply_prep.
03:57:54 SQL> -- I use same model_name used in score.sql
03:57:54 SQL> DEFINE model_name = 'svmfx101'
03:57:54 SQL> DEFINE bldtable	= 'bme'
03:57:54 SQL> DEFINE scoretable = 'sme'
03:57:54 SQL> DEFINE case_id	= 'prdate'
03:57:54 SQL> -- Demo:
03:57:54 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:57:54 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:57:54 SQL> --
03:57:54 SQL> -- score.sql
03:57:54 SQL> --
03:57:54 SQL> 
03:57:54 SQL> -- usage: score.sql
03:57:54 SQL> 
03:57:54 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:57:54 SQL> 
03:57:54 SQL> -- DEFINE target	   = 'gatt'
03:57:54 SQL> -- DEFINE model_name = 'svmfx101'
03:57:54 SQL> -- DEFINE bldtable   = 'bme'
03:57:54 SQL> -- DEFINE scoretable = 'sme'
03:57:54 SQL> -- DEFINE case_id    = 'prdate'
03:57:54 SQL> 
03:57:54 SQL> DEFINE target	= '&1'
03:57:54 SQL> DEFINE model_name = '&2'
03:57:54 SQL> DEFINE bldtable	= '&3'
03:57:54 SQL> DEFINE scoretable = '&4'
03:57:54 SQL> DEFINE case_id	= '&5'
03:57:54 SQL> 
03:57:54 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:57:54 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:57:54 SQL> 
03:57:54 SQL> -- Builds an SVM model using pl/sql.
03:57:54 SQL> 
03:57:54 SQL> -----------------------------------------------------------------------
03:57:54 SQL> --			    BUILD THE MODEL
03:57:54 SQL> -----------------------------------------------------------------------
03:57:54 SQL> 
03:57:54 SQL> -- Cleanup old build data preparation objects for repeat runs
03:57:54 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:57:54 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:57:54 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:57:54 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:57:54 SQL> 
03:57:54 SQL> 
03:57:54 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:57:54 SQL> --
03:57:54 SQL> -- DROP	TABLE svmc_settings ;
03:57:54 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:57:54 SQL> -- DELETE svmc_settings;
03:57:54 SQL> 
03:57:54 SQL> -- The default classification algorithm is Naive Bayes. So override
03:57:54 SQL> -- this choice to SVM using a settings table.
03:57:54 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:57:54 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:57:54 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:57:54 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:57:54 SQL> -- models.
03:57:54 SQL> --
03:57:54 SQL> 
03:57:54 SQL> -- Do this once and then comment it out.
03:57:54 SQL> -- That makes script go faster.
03:57:54 SQL> -- BEGIN
03:57:54 SQL> -- -- Populate settings table
03:57:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:54 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:57:54 SQL> --
03:57:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:54 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:57:54 SQL> --
03:57:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:57:54 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:57:54 SQL> --   COMMIT;
03:57:54 SQL> -- END;
03:57:54 SQL> -- /
03:57:54 SQL> 
03:57:54 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:57:54 SQL> 
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:57:54 SQL> 
03:57:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:57:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:57:54 SQL> 
03:57:54 SQL> --------------------------------
03:57:54 SQL> -- PREPARE BUILD (TRAINING) DATA
03:57:54 SQL> --
03:57:54 SQL> 
03:57:54 SQL> -- 1. Missing Value treatment for all Predictors and
03:57:54 SQL> -- 2. Outlier Treatment and
03:57:54 SQL> -- 3. Normalization are performed below.
03:57:54 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:57:54 SQL> --    normalized here.
03:57:54 SQL> 
03:57:54 SQL> BEGIN
03:57:54   2  	-- Perform missing value treatment for all predictors
03:57:54   3  	-- create miss tables
03:57:54   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:57:54   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:57:54   6  
03:57:54   7  	-- populate miss tables
03:57:54   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:57:54   9  	  miss_table_name => 'svmc_miss_num',
03:57:54  10  	  data_table_name => '&bldtable',
03:57:54  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:54  12  
03:57:54  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:57:54  14  	  miss_table_name => 'svmc_miss_cat',
03:57:54  15  	  data_table_name => '&bldtable',
03:57:54  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:54  17  
03:57:54  18  	-- xform input data to replace missing values
03:57:54  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:57:54  20  	  miss_table_name => 'svmc_miss_num',
03:57:54  21  	  data_table_name => '&bldtable',
03:57:54  22  	  xform_view_name => 'xformed_build_miss_num');
03:57:54  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:57:54  24  	  miss_table_name => 'svmc_miss_cat',
03:57:54  25  	  data_table_name => '&bldtable',
03:57:54  26  	  xform_view_name => 'xformed_build_miss_cat');
03:57:54  27  
03:57:54  28  	-- Perform outlier treatment.
03:57:54  29  	-- create clip table
03:57:54  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:57:54  31  
03:57:54  32  	-- populate clip table
03:57:54  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:57:54  34  	  clip_table_name => 'svmc_clip',
03:57:54  35  	  data_table_name => '&bldtable',
03:57:54  36  	  tail_frac	  => 0.025,
03:57:54  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:54  38  
03:57:54  39  	-- xform input data to winsorized data
03:57:54  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:57:54  41  	  clip_table_name => 'svmc_clip',
03:57:54  42  	  data_table_name => '&bldtable',
03:57:54  43  	  xform_view_name => 'svmc_winsor');
03:57:54  44  
03:57:54  45  	-- create normalization table
03:57:54  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:57:54  47  
03:57:54  48  	-- populate normalization table based on winsorized data
03:57:54  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:57:54  50  	  norm_table_name => 'svmc_norm',
03:57:54  51  	  data_table_name => 'svmc_winsor',
03:57:54  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:57:54  53  
03:57:54  54  	-- normalize the original data
03:57:54  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:57:54  56  	  norm_table_name => 'svmc_norm',
03:57:54  57  	  data_table_name => '&bldtable',
03:57:54  58  	  xform_view_name => 'svmc_build_prep');
03:57:54  59  END;
03:57:54  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.53
03:57:57 SQL> 
03:57:57 SQL> ---------------------
03:57:57 SQL> -- CREATE A NEW MODEL
03:57:57 SQL> --
03:57:57 SQL> -- Cleanup old model with the same name for repeat runs
03:57:57 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:57:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:57:57   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.49
03:57:58 SQL> 
03:57:58 SQL> -- Build a new SVM Model
03:57:58 SQL> BEGIN
03:57:58   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:57:58   3  	  model_name	      => '&model_name',
03:57:58   4  	  mining_function     => dbms_data_mining.classification,
03:57:58   5  	  data_table_name     => 'svmc_build_prep',
03:57:58   6  	  case_id_column_name => '&case_id',
03:57:58   7  	  target_column_name  => '&target',
03:57:58   8  	  settings_table_name => 'svmc_settings');
03:57:58   9  END;
03:57:58  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.17
03:58:02 SQL> 
03:58:02 SQL> -----------------------------------------------------------------------
03:58:02 SQL> --			       APPLY/score THE MODEL
03:58:02 SQL> -----------------------------------------------------------------------
03:58:02 SQL> 
03:58:02 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:58:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:58:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:58:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:58:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:58:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.11
03:58:03 SQL> -----------------------
03:58:03 SQL> -- PREPARE SCORING DATA
03:58:03 SQL> --
03:58:03 SQL> -- If the data for model creation has been prepared, then the data
03:58:03 SQL> -- to be scored using the model must be prepared in the same manner
03:58:03 SQL> -- in order to obtain meaningful results.
03:58:03 SQL> --
03:58:03 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:03 SQL> -- 2. Normalization
03:58:03 SQL> -- No outlier treatment will be performed during test and apply. The
03:58:03 SQL> -- normalization step is sufficient, since the normalization parameters
03:58:03 SQL> -- already capture the effects of outlier treatment done with build data.
03:58:03 SQL> --
03:58:03 SQL> BEGIN
03:58:03   2  	-- Xform Test data to replace missing values
03:58:03   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:03   4  	  miss_table_name => 'svmc_miss_num',
03:58:03   5  	  data_table_name => '&scoretable',
03:58:03   6  	  xform_view_name => 'xformed_apply_miss_num');
03:58:03   7  
03:58:03   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:03   9  	  miss_table_name => 'svmc_miss_cat',
03:58:03  10  	  data_table_name => '&scoretable',
03:58:03  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:58:03  12  
03:58:03  13  	-- Normalize the data to be scored
03:58:03  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:03  15  	  norm_table_name => 'svmc_norm',
03:58:03  16  	  data_table_name => '&scoretable',
03:58:03  17  	  xform_view_name => 'svmc_apply_prep');
03:58:03  18  END;
03:58:03  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.31
03:58:03 SQL> 
03:58:03 SQL> -- Maybe I already collected a score for this prdate.
03:58:03 SQL> -- DELETE it if I did:
03:58:03 SQL> DELETE svm24scores
03:58:03   2  WHERE score > 0
03:58:03   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:58:03   4  -- I need to supply the target attribute name:
03:58:03   5  AND targ = '&1'
03:58:03   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:58:03 SQL> 
03:58:03 SQL> -- We do a drumroll here:
03:58:03 SQL> 
03:58:03 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:58:03   2  SELECT
03:58:03   3  prdate
03:58:03   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:58:03   5  ,sysdate
03:58:03   6  ,SUBSTR(prdate,1,7)pair
03:58:03   7  ,SUBSTR(prdate,-19)ydate
03:58:03   8  ,'&1'
03:58:03   9  FROM svmc_apply_prep
03:58:03  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:58:03 SQL> @score1_5min.sql	      2011-01-21 12:50:00 eur_usd
03:58:03 SQL> --
03:58:03 SQL> -- score1_5min.sql
03:58:03 SQL> --
03:58:03 SQL> 
03:58:03 SQL> -- Demo:
03:58:03 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:58:03 SQL> 
03:58:03 SQL> CREATE OR REPLACE VIEW sme AS
03:58:03   2  SELECT
03:58:03   3  prdate
03:58:03   4  ,NULL gatt
03:58:03   5  ,g00
03:58:03   6  ,g01
03:58:03   7  ,g02
03:58:03   8  ,g03
03:58:03   9  ,g04
03:58:03  10  ,g05
03:58:03  11  ,g06
03:58:03  12  ,g07
03:58:03  13  ,g08
03:58:03  14  ,g09
03:58:03  15  ,g10
03:58:03  16  ,g11
03:58:03  17  ,g12
03:58:03  18  ,g13
03:58:03  19  ,g14
03:58:03  20  ,g15
03:58:03  21  ,g16
03:58:03  22  ,g17
03:58:03  23  ,g18
03:58:03  24  ,g19
03:58:03  25  ,g20
03:58:03  26  ,g21
03:58:03  27  ,g22
03:58:03  28  ,g23
03:58:03  29  ,g24
03:58:03  30  ,g25
03:58:03  31  ,g26
03:58:03  32  ,g27
03:58:03  33  ,g28
03:58:03  34  ,g29
03:58:03  35  ,g30
03:58:03  36  ,g31
03:58:03  37  ,g32
03:58:03  38  ,g33
03:58:03  39  ,g34
03:58:03  40  ,g35
03:58:03  41  ,g36
03:58:03  42  ,g37
03:58:03  43  ,g38
03:58:03  44  ,g39
03:58:03  45  ,g40
03:58:03  46  ,g41
03:58:03  47  ,s.sc_corr
03:58:03  48  FROM modsrc24
03:58:03  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:58:03  50  WHERE ydate = '&1'||' '||'&2'
03:58:03  51  AND pair = '&3'
03:58:03  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'12:50:00'AND ydate<'2011-01-21'||' '||'12:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'12:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:58:03 SQL> 
03:58:03 SQL> -- rpt
03:58:03 SQL> -- We should see just 1 row:
03:58:03 SQL> 
03:58:03 SQL> SELECT COUNT(prdate) FROM sme
03:58:03   2  
03:58:03 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:58:03   2  
03:58:03 SQL> 
03:58:03 SQL> -- Build the model:
03:58:03 SQL> CREATE OR REPLACE VIEW bme AS
03:58:03   2  SELECT
03:58:03   3  prdate
03:58:03   4  ,gatt
03:58:03   5  ,g00
03:58:03   6  ,g01
03:58:03   7  ,g02
03:58:03   8  ,g03
03:58:03   9  ,g04
03:58:03  10  ,g05
03:58:03  11  ,g06
03:58:03  12  ,g07
03:58:03  13  ,g08
03:58:03  14  ,g09
03:58:03  15  ,g10
03:58:03  16  ,g11
03:58:03  17  ,g12
03:58:03  18  ,g13
03:58:03  19  ,g14
03:58:03  20  ,g15
03:58:03  21  ,g16
03:58:03  22  ,g17
03:58:03  23  ,g18
03:58:03  24  ,g19
03:58:03  25  ,g20
03:58:03  26  ,g21
03:58:03  27  ,g22
03:58:03  28  ,g23
03:58:03  29  ,g24
03:58:03  30  ,g25
03:58:03  31  ,g26
03:58:03  32  ,g27
03:58:03  33  ,g28
03:58:03  34  ,g29
03:58:03  35  ,g30
03:58:03  36  ,g31
03:58:03  37  ,g32
03:58:03  38  ,g33
03:58:03  39  ,g34
03:58:03  40  ,g35
03:58:03  41  ,g36
03:58:03  42  ,g37
03:58:03  43  ,g38
03:58:03  44  ,g39
03:58:03  45  ,g40
03:58:03  46  ,g41
03:58:03  47  ,sc_corr
03:58:03  48  FROM modsrc24
03:58:03  49  WHERE gatt IN('nup','up')
03:58:03  50  -- Use only rows which are older than 1 day:
03:58:03  51  AND 1+ydate < '&1'||' '||'&2'
03:58:03  52  AND pair = '&3'
03:58:03  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'12:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:58:03 SQL> 
03:58:03 SQL> -- rpt
03:58:03 SQL> 
03:58:03 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:58:03   2  
03:58:03 SQL> SELECT MAX(prdate) FROM bme
03:58:03   2  
03:58:03 SQL> -- Now build model from bme and score sme
03:58:03 SQL> @score1.sql gatt
03:58:03 SQL> --
03:58:03 SQL> -- score1.sql
03:58:03 SQL> --
03:58:03 SQL> 
03:58:03 SQL> -- I use this script to send 5 params to score.sql
03:58:03 SQL> -- which does the heavy lifting of creating an SVM model.
03:58:03 SQL> -- Then at the very end of this script I use the model
03:58:03 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:58:03 SQL> 
03:58:03 SQL> -- I call this script from 2 other scripts:
03:58:03 SQL> -- score1_5min.sql
03:58:03 SQL> -- score1_5min_gattn.sql
03:58:03 SQL> 
03:58:03 SQL> -- The 1st param is the name of the target attribute.
03:58:03 SQL> -- I like to call my target attributes either gatt or gattn.
03:58:03 SQL> 
03:58:03 SQL> -- Demo:
03:58:03 SQL> -- @score1.sql 'gatt'
03:58:03 SQL> -- @score1.sql 'gattn'
03:58:03 SQL> 
03:58:03 SQL> -- Now, I fill up svmc_apply_prep.
03:58:03 SQL> -- I use same model_name used in score.sql
03:58:03 SQL> DEFINE model_name = 'svmfx101'
03:58:03 SQL> DEFINE bldtable	= 'bme'
03:58:03 SQL> DEFINE scoretable = 'sme'
03:58:03 SQL> DEFINE case_id	= 'prdate'
03:58:03 SQL> -- Demo:
03:58:03 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:58:03 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:58:03 SQL> --
03:58:03 SQL> -- score.sql
03:58:03 SQL> --
03:58:03 SQL> 
03:58:03 SQL> -- usage: score.sql
03:58:03 SQL> 
03:58:03 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:58:03 SQL> 
03:58:03 SQL> -- DEFINE target	   = 'gatt'
03:58:03 SQL> -- DEFINE model_name = 'svmfx101'
03:58:03 SQL> -- DEFINE bldtable   = 'bme'
03:58:03 SQL> -- DEFINE scoretable = 'sme'
03:58:03 SQL> -- DEFINE case_id    = 'prdate'
03:58:03 SQL> 
03:58:03 SQL> DEFINE target	= '&1'
03:58:03 SQL> DEFINE model_name = '&2'
03:58:03 SQL> DEFINE bldtable	= '&3'
03:58:03 SQL> DEFINE scoretable = '&4'
03:58:03 SQL> DEFINE case_id	= '&5'
03:58:03 SQL> 
03:58:03 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:58:03 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:58:03 SQL> 
03:58:03 SQL> -- Builds an SVM model using pl/sql.
03:58:03 SQL> 
03:58:03 SQL> -----------------------------------------------------------------------
03:58:03 SQL> --			    BUILD THE MODEL
03:58:03 SQL> -----------------------------------------------------------------------
03:58:03 SQL> 
03:58:03 SQL> -- Cleanup old build data preparation objects for repeat runs
03:58:03 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:58:03 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:58:03 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:03 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:58:03 SQL> 
03:58:03 SQL> 
03:58:03 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:58:03 SQL> --
03:58:03 SQL> -- DROP	TABLE svmc_settings ;
03:58:03 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:58:03 SQL> -- DELETE svmc_settings;
03:58:03 SQL> 
03:58:03 SQL> -- The default classification algorithm is Naive Bayes. So override
03:58:03 SQL> -- this choice to SVM using a settings table.
03:58:03 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:58:03 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:58:03 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:58:03 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:58:03 SQL> -- models.
03:58:03 SQL> --
03:58:03 SQL> 
03:58:03 SQL> -- Do this once and then comment it out.
03:58:03 SQL> -- That makes script go faster.
03:58:03 SQL> -- BEGIN
03:58:03 SQL> -- -- Populate settings table
03:58:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:03 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:58:03 SQL> --
03:58:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:03 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:58:03 SQL> --
03:58:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:03 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:58:03 SQL> --   COMMIT;
03:58:03 SQL> -- END;
03:58:03 SQL> -- /
03:58:03 SQL> 
03:58:03 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:58:03 SQL> 
03:58:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:58:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:58:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:58:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:58:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:58:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:03 SQL> 
03:58:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:58:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:03 SQL> 
03:58:03 SQL> --------------------------------
03:58:03 SQL> -- PREPARE BUILD (TRAINING) DATA
03:58:03 SQL> --
03:58:03 SQL> 
03:58:03 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:03 SQL> -- 2. Outlier Treatment and
03:58:03 SQL> -- 3. Normalization are performed below.
03:58:03 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:58:03 SQL> --    normalized here.
03:58:03 SQL> 
03:58:03 SQL> BEGIN
03:58:03   2  	-- Perform missing value treatment for all predictors
03:58:03   3  	-- create miss tables
03:58:03   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:58:03   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:58:03   6  
03:58:03   7  	-- populate miss tables
03:58:03   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:58:03   9  	  miss_table_name => 'svmc_miss_num',
03:58:03  10  	  data_table_name => '&bldtable',
03:58:03  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:03  12  
03:58:03  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:58:03  14  	  miss_table_name => 'svmc_miss_cat',
03:58:03  15  	  data_table_name => '&bldtable',
03:58:03  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:03  17  
03:58:03  18  	-- xform input data to replace missing values
03:58:03  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:03  20  	  miss_table_name => 'svmc_miss_num',
03:58:03  21  	  data_table_name => '&bldtable',
03:58:03  22  	  xform_view_name => 'xformed_build_miss_num');
03:58:03  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:03  24  	  miss_table_name => 'svmc_miss_cat',
03:58:03  25  	  data_table_name => '&bldtable',
03:58:03  26  	  xform_view_name => 'xformed_build_miss_cat');
03:58:03  27  
03:58:03  28  	-- Perform outlier treatment.
03:58:03  29  	-- create clip table
03:58:03  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:58:03  31  
03:58:03  32  	-- populate clip table
03:58:03  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:58:03  34  	  clip_table_name => 'svmc_clip',
03:58:03  35  	  data_table_name => '&bldtable',
03:58:03  36  	  tail_frac	  => 0.025,
03:58:03  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:03  38  
03:58:03  39  	-- xform input data to winsorized data
03:58:03  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:58:03  41  	  clip_table_name => 'svmc_clip',
03:58:03  42  	  data_table_name => '&bldtable',
03:58:03  43  	  xform_view_name => 'svmc_winsor');
03:58:03  44  
03:58:03  45  	-- create normalization table
03:58:03  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:58:03  47  
03:58:03  48  	-- populate normalization table based on winsorized data
03:58:03  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:58:03  50  	  norm_table_name => 'svmc_norm',
03:58:03  51  	  data_table_name => 'svmc_winsor',
03:58:03  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:03  53  
03:58:03  54  	-- normalize the original data
03:58:03  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:03  56  	  norm_table_name => 'svmc_norm',
03:58:03  57  	  data_table_name => '&bldtable',
03:58:03  58  	  xform_view_name => 'svmc_build_prep');
03:58:03  59  END;
03:58:03  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.62
03:58:06 SQL> 
03:58:06 SQL> ---------------------
03:58:06 SQL> -- CREATE A NEW MODEL
03:58:06 SQL> --
03:58:06 SQL> -- Cleanup old model with the same name for repeat runs
03:58:06 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:58:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:06   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.21
03:58:08 SQL> 
03:58:08 SQL> -- Build a new SVM Model
03:58:08 SQL> BEGIN
03:58:08   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:58:08   3  	  model_name	      => '&model_name',
03:58:08   4  	  mining_function     => dbms_data_mining.classification,
03:58:08   5  	  data_table_name     => 'svmc_build_prep',
03:58:08   6  	  case_id_column_name => '&case_id',
03:58:08   7  	  target_column_name  => '&target',
03:58:08   8  	  settings_table_name => 'svmc_settings');
03:58:08   9  END;
03:58:08  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.06
03:58:13 SQL> 
03:58:13 SQL> -----------------------------------------------------------------------
03:58:13 SQL> --			       APPLY/score THE MODEL
03:58:13 SQL> -----------------------------------------------------------------------
03:58:13 SQL> 
03:58:13 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:58:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:58:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:58:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:58:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:13 SQL> -----------------------
03:58:13 SQL> -- PREPARE SCORING DATA
03:58:13 SQL> --
03:58:13 SQL> -- If the data for model creation has been prepared, then the data
03:58:13 SQL> -- to be scored using the model must be prepared in the same manner
03:58:13 SQL> -- in order to obtain meaningful results.
03:58:13 SQL> --
03:58:13 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:13 SQL> -- 2. Normalization
03:58:13 SQL> -- No outlier treatment will be performed during test and apply. The
03:58:13 SQL> -- normalization step is sufficient, since the normalization parameters
03:58:13 SQL> -- already capture the effects of outlier treatment done with build data.
03:58:13 SQL> --
03:58:13 SQL> BEGIN
03:58:13   2  	-- Xform Test data to replace missing values
03:58:13   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:13   4  	  miss_table_name => 'svmc_miss_num',
03:58:13   5  	  data_table_name => '&scoretable',
03:58:13   6  	  xform_view_name => 'xformed_apply_miss_num');
03:58:13   7  
03:58:13   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:13   9  	  miss_table_name => 'svmc_miss_cat',
03:58:13  10  	  data_table_name => '&scoretable',
03:58:13  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:58:13  12  
03:58:13  13  	-- Normalize the data to be scored
03:58:13  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:13  15  	  norm_table_name => 'svmc_norm',
03:58:13  16  	  data_table_name => '&scoretable',
03:58:13  17  	  xform_view_name => 'svmc_apply_prep');
03:58:13  18  END;
03:58:13  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.26
03:58:14 SQL> 
03:58:14 SQL> -- Maybe I already collected a score for this prdate.
03:58:14 SQL> -- DELETE it if I did:
03:58:14 SQL> DELETE svm24scores
03:58:14   2  WHERE score > 0
03:58:14   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:58:14   4  -- I need to supply the target attribute name:
03:58:14   5  AND targ = '&1'
03:58:14   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:58:14 SQL> 
03:58:14 SQL> -- We do a drumroll here:
03:58:14 SQL> 
03:58:14 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:58:14   2  SELECT
03:58:14   3  prdate
03:58:14   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:58:14   5  ,sysdate
03:58:14   6  ,SUBSTR(prdate,1,7)pair
03:58:14   7  ,SUBSTR(prdate,-19)ydate
03:58:14   8  ,'&1'
03:58:14   9  FROM svmc_apply_prep
03:58:14  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:58:14 SQL> @score1_5min_gattn.sql	2011-01-20 07:30:00 eur_usd
03:58:14 SQL> --
03:58:14 SQL> -- score1_5min_gattn.sql
03:58:14 SQL> --
03:58:14 SQL> 
03:58:14 SQL> -- Demo:
03:58:14 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:58:14 SQL> 
03:58:14 SQL> CREATE OR REPLACE VIEW sme AS
03:58:14   2  SELECT
03:58:14   3  prdate
03:58:14   4  ,NULL gattn
03:58:14   5  ,g00
03:58:14   6  ,g01
03:58:14   7  ,g02
03:58:14   8  ,g03
03:58:14   9  ,g04
03:58:14  10  ,g05
03:58:14  11  ,g06
03:58:14  12  ,g07
03:58:14  13  ,g08
03:58:14  14  ,g09
03:58:14  15  ,g10
03:58:14  16  ,g11
03:58:14  17  ,g12
03:58:14  18  ,g13
03:58:14  19  ,g14
03:58:14  20  ,g15
03:58:14  21  ,g16
03:58:14  22  ,g17
03:58:14  23  ,g18
03:58:14  24  ,g19
03:58:14  25  ,g20
03:58:14  26  ,g21
03:58:14  27  ,g22
03:58:14  28  ,g23
03:58:14  29  ,g24
03:58:14  30  ,g25
03:58:14  31  ,g26
03:58:14  32  ,g27
03:58:14  33  ,g28
03:58:14  34  ,g29
03:58:14  35  ,g30
03:58:14  36  ,g31
03:58:14  37  ,g32
03:58:14  38  ,g33
03:58:14  39  ,g34
03:58:14  40  ,g35
03:58:14  41  ,g36
03:58:14  42  ,g37
03:58:14  43  ,g38
03:58:14  44  ,g39
03:58:14  45  ,g40
03:58:14  46  ,g41
03:58:14  47  ,s.sc_corr
03:58:14  48  FROM modsrc24
03:58:14  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:58:14  50  WHERE ydate = '&1'||' '||'&2'
03:58:14  51  AND pair = '&3'
03:58:14  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'07:30:00'AND ydate<'2011-01-20'||' '||'07:30:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'07:30:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:58:14 SQL> 
03:58:14 SQL> -- rpt
03:58:14 SQL> -- We should see just 1 row:
03:58:14 SQL> 
03:58:14 SQL> SELECT COUNT(prdate) FROM sme
03:58:14   2  
03:58:14 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:58:14   2  
03:58:14 SQL> 
03:58:14 SQL> -- Build the model:
03:58:14 SQL> CREATE OR REPLACE VIEW bme AS
03:58:14   2  SELECT
03:58:14   3  prdate
03:58:14   4  ,gattn
03:58:14   5  ,g00
03:58:14   6  ,g01
03:58:14   7  ,g02
03:58:14   8  ,g03
03:58:14   9  ,g04
03:58:14  10  ,g05
03:58:14  11  ,g06
03:58:14  12  ,g07
03:58:14  13  ,g08
03:58:14  14  ,g09
03:58:14  15  ,g10
03:58:14  16  ,g11
03:58:14  17  ,g12
03:58:14  18  ,g13
03:58:14  19  ,g14
03:58:14  20  ,g15
03:58:14  21  ,g16
03:58:14  22  ,g17
03:58:14  23  ,g18
03:58:14  24  ,g19
03:58:14  25  ,g20
03:58:14  26  ,g21
03:58:14  27  ,g22
03:58:14  28  ,g23
03:58:14  29  ,g24
03:58:14  30  ,g25
03:58:14  31  ,g26
03:58:14  32  ,g27
03:58:14  33  ,g28
03:58:14  34  ,g29
03:58:14  35  ,g30
03:58:14  36  ,g31
03:58:14  37  ,g32
03:58:14  38  ,g33
03:58:14  39  ,g34
03:58:14  40  ,g35
03:58:14  41  ,g36
03:58:14  42  ,g37
03:58:14  43  ,g38
03:58:14  44  ,g39
03:58:14  45  ,g40
03:58:14  46  ,g41
03:58:14  47  ,sc_corr
03:58:14  48  FROM modsrc24
03:58:14  49  WHERE gattn IN('nup','up')
03:58:14  50  -- Use only rows which are older than 1 day:
03:58:14  51  AND 1+ydate < '&1'||' '||'&2'
03:58:14  52  AND pair = '&3'
03:58:14  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'07:30:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:58:14 SQL> 
03:58:14 SQL> -- rpt
03:58:14 SQL> 
03:58:14 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:58:14   2  
03:58:14 SQL> SELECT MAX(prdate) FROM bme
03:58:14   2  
03:58:14 SQL> -- Now build model from bme and score sme
03:58:14 SQL> @score1.sql gattn
03:58:14 SQL> --
03:58:14 SQL> -- score1.sql
03:58:14 SQL> --
03:58:14 SQL> 
03:58:14 SQL> -- I use this script to send 5 params to score.sql
03:58:14 SQL> -- which does the heavy lifting of creating an SVM model.
03:58:14 SQL> -- Then at the very end of this script I use the model
03:58:14 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:58:14 SQL> 
03:58:14 SQL> -- I call this script from 2 other scripts:
03:58:14 SQL> -- score1_5min.sql
03:58:14 SQL> -- score1_5min_gattn.sql
03:58:14 SQL> 
03:58:14 SQL> -- The 1st param is the name of the target attribute.
03:58:14 SQL> -- I like to call my target attributes either gatt or gattn.
03:58:14 SQL> 
03:58:14 SQL> -- Demo:
03:58:14 SQL> -- @score1.sql 'gatt'
03:58:14 SQL> -- @score1.sql 'gattn'
03:58:14 SQL> 
03:58:14 SQL> -- Now, I fill up svmc_apply_prep.
03:58:14 SQL> -- I use same model_name used in score.sql
03:58:14 SQL> DEFINE model_name = 'svmfx101'
03:58:14 SQL> DEFINE bldtable	= 'bme'
03:58:14 SQL> DEFINE scoretable = 'sme'
03:58:14 SQL> DEFINE case_id	= 'prdate'
03:58:14 SQL> -- Demo:
03:58:14 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:58:14 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:58:14 SQL> --
03:58:14 SQL> -- score.sql
03:58:14 SQL> --
03:58:14 SQL> 
03:58:14 SQL> -- usage: score.sql
03:58:14 SQL> 
03:58:14 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:58:14 SQL> 
03:58:14 SQL> -- DEFINE target	   = 'gatt'
03:58:14 SQL> -- DEFINE model_name = 'svmfx101'
03:58:14 SQL> -- DEFINE bldtable   = 'bme'
03:58:14 SQL> -- DEFINE scoretable = 'sme'
03:58:14 SQL> -- DEFINE case_id    = 'prdate'
03:58:14 SQL> 
03:58:14 SQL> DEFINE target	= '&1'
03:58:14 SQL> DEFINE model_name = '&2'
03:58:14 SQL> DEFINE bldtable	= '&3'
03:58:14 SQL> DEFINE scoretable = '&4'
03:58:14 SQL> DEFINE case_id	= '&5'
03:58:14 SQL> 
03:58:14 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:58:14 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:58:14 SQL> 
03:58:14 SQL> -- Builds an SVM model using pl/sql.
03:58:14 SQL> 
03:58:14 SQL> -----------------------------------------------------------------------
03:58:14 SQL> --			    BUILD THE MODEL
03:58:14 SQL> -----------------------------------------------------------------------
03:58:14 SQL> 
03:58:14 SQL> -- Cleanup old build data preparation objects for repeat runs
03:58:14 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:14 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:58:14 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:58:14 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:58:14 SQL> 
03:58:14 SQL> 
03:58:14 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:58:14 SQL> --
03:58:14 SQL> -- DROP	TABLE svmc_settings ;
03:58:14 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:58:14 SQL> -- DELETE svmc_settings;
03:58:14 SQL> 
03:58:14 SQL> -- The default classification algorithm is Naive Bayes. So override
03:58:14 SQL> -- this choice to SVM using a settings table.
03:58:14 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:58:14 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:58:14 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:58:14 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:58:14 SQL> -- models.
03:58:14 SQL> --
03:58:14 SQL> 
03:58:14 SQL> -- Do this once and then comment it out.
03:58:14 SQL> -- That makes script go faster.
03:58:14 SQL> -- BEGIN
03:58:14 SQL> -- -- Populate settings table
03:58:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:14 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:58:14 SQL> --
03:58:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:14 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:58:14 SQL> --
03:58:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:14 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:58:14 SQL> --   COMMIT;
03:58:14 SQL> -- END;
03:58:14 SQL> -- /
03:58:14 SQL> 
03:58:14 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:58:14 SQL> 
03:58:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:58:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:58:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:58:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:58:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:14 SQL> 
03:58:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:58:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:14 SQL> 
03:58:14 SQL> --------------------------------
03:58:14 SQL> -- PREPARE BUILD (TRAINING) DATA
03:58:14 SQL> --
03:58:14 SQL> 
03:58:14 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:14 SQL> -- 2. Outlier Treatment and
03:58:14 SQL> -- 3. Normalization are performed below.
03:58:14 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:58:14 SQL> --    normalized here.
03:58:14 SQL> 
03:58:14 SQL> BEGIN
03:58:14   2  	-- Perform missing value treatment for all predictors
03:58:14   3  	-- create miss tables
03:58:14   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:58:14   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:58:14   6  
03:58:14   7  	-- populate miss tables
03:58:14   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:58:14   9  	  miss_table_name => 'svmc_miss_num',
03:58:14  10  	  data_table_name => '&bldtable',
03:58:14  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:14  12  
03:58:14  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:58:14  14  	  miss_table_name => 'svmc_miss_cat',
03:58:14  15  	  data_table_name => '&bldtable',
03:58:14  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:14  17  
03:58:14  18  	-- xform input data to replace missing values
03:58:14  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:14  20  	  miss_table_name => 'svmc_miss_num',
03:58:14  21  	  data_table_name => '&bldtable',
03:58:14  22  	  xform_view_name => 'xformed_build_miss_num');
03:58:14  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:14  24  	  miss_table_name => 'svmc_miss_cat',
03:58:14  25  	  data_table_name => '&bldtable',
03:58:14  26  	  xform_view_name => 'xformed_build_miss_cat');
03:58:14  27  
03:58:14  28  	-- Perform outlier treatment.
03:58:14  29  	-- create clip table
03:58:14  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:58:14  31  
03:58:14  32  	-- populate clip table
03:58:14  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:58:14  34  	  clip_table_name => 'svmc_clip',
03:58:14  35  	  data_table_name => '&bldtable',
03:58:14  36  	  tail_frac	  => 0.025,
03:58:14  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:14  38  
03:58:14  39  	-- xform input data to winsorized data
03:58:14  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:58:14  41  	  clip_table_name => 'svmc_clip',
03:58:14  42  	  data_table_name => '&bldtable',
03:58:14  43  	  xform_view_name => 'svmc_winsor');
03:58:14  44  
03:58:14  45  	-- create normalization table
03:58:14  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:58:14  47  
03:58:14  48  	-- populate normalization table based on winsorized data
03:58:14  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:58:14  50  	  norm_table_name => 'svmc_norm',
03:58:14  51  	  data_table_name => 'svmc_winsor',
03:58:14  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:14  53  
03:58:14  54  	-- normalize the original data
03:58:14  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:14  56  	  norm_table_name => 'svmc_norm',
03:58:14  57  	  data_table_name => '&bldtable',
03:58:14  58  	  xform_view_name => 'svmc_build_prep');
03:58:14  59  END;
03:58:14  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.53
03:58:16 SQL> 
03:58:16 SQL> ---------------------
03:58:16 SQL> -- CREATE A NEW MODEL
03:58:16 SQL> --
03:58:16 SQL> -- Cleanup old model with the same name for repeat runs
03:58:16 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:58:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:16   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.59
03:58:18 SQL> 
03:58:18 SQL> -- Build a new SVM Model
03:58:18 SQL> BEGIN
03:58:18   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:58:18   3  	  model_name	      => '&model_name',
03:58:18   4  	  mining_function     => dbms_data_mining.classification,
03:58:18   5  	  data_table_name     => 'svmc_build_prep',
03:58:18   6  	  case_id_column_name => '&case_id',
03:58:18   7  	  target_column_name  => '&target',
03:58:18   8  	  settings_table_name => 'svmc_settings');
03:58:18   9  END;
03:58:18  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.37
03:58:22 SQL> 
03:58:22 SQL> -----------------------------------------------------------------------
03:58:22 SQL> --			       APPLY/score THE MODEL
03:58:22 SQL> -----------------------------------------------------------------------
03:58:22 SQL> 
03:58:22 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:58:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:58:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:58:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:58:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:22 SQL> -----------------------
03:58:22 SQL> -- PREPARE SCORING DATA
03:58:22 SQL> --
03:58:22 SQL> -- If the data for model creation has been prepared, then the data
03:58:22 SQL> -- to be scored using the model must be prepared in the same manner
03:58:22 SQL> -- in order to obtain meaningful results.
03:58:22 SQL> --
03:58:22 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:22 SQL> -- 2. Normalization
03:58:22 SQL> -- No outlier treatment will be performed during test and apply. The
03:58:22 SQL> -- normalization step is sufficient, since the normalization parameters
03:58:22 SQL> -- already capture the effects of outlier treatment done with build data.
03:58:22 SQL> --
03:58:22 SQL> BEGIN
03:58:22   2  	-- Xform Test data to replace missing values
03:58:22   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:22   4  	  miss_table_name => 'svmc_miss_num',
03:58:22   5  	  data_table_name => '&scoretable',
03:58:22   6  	  xform_view_name => 'xformed_apply_miss_num');
03:58:22   7  
03:58:22   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:22   9  	  miss_table_name => 'svmc_miss_cat',
03:58:22  10  	  data_table_name => '&scoretable',
03:58:22  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:58:22  12  
03:58:22  13  	-- Normalize the data to be scored
03:58:22  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:22  15  	  norm_table_name => 'svmc_norm',
03:58:22  16  	  data_table_name => '&scoretable',
03:58:22  17  	  xform_view_name => 'svmc_apply_prep');
03:58:22  18  END;
03:58:22  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.25
03:58:23 SQL> 
03:58:23 SQL> -- Maybe I already collected a score for this prdate.
03:58:23 SQL> -- DELETE it if I did:
03:58:23 SQL> DELETE svm24scores
03:58:23   2  WHERE score > 0
03:58:23   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:58:23   4  -- I need to supply the target attribute name:
03:58:23   5  AND targ = '&1'
03:58:23   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:58:23 SQL> 
03:58:23 SQL> -- We do a drumroll here:
03:58:23 SQL> 
03:58:23 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:58:23   2  SELECT
03:58:23   3  prdate
03:58:23   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:58:23   5  ,sysdate
03:58:23   6  ,SUBSTR(prdate,1,7)pair
03:58:23   7  ,SUBSTR(prdate,-19)ydate
03:58:23   8  ,'&1'
03:58:23   9  FROM svmc_apply_prep
03:58:23  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:58:23 SQL> @score1_5min_gattn.sql	2011-01-27 18:40:00 eur_usd
03:58:23 SQL> --
03:58:23 SQL> -- score1_5min_gattn.sql
03:58:23 SQL> --
03:58:23 SQL> 
03:58:23 SQL> -- Demo:
03:58:23 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:58:23 SQL> 
03:58:23 SQL> CREATE OR REPLACE VIEW sme AS
03:58:23   2  SELECT
03:58:23   3  prdate
03:58:23   4  ,NULL gattn
03:58:23   5  ,g00
03:58:23   6  ,g01
03:58:23   7  ,g02
03:58:23   8  ,g03
03:58:23   9  ,g04
03:58:23  10  ,g05
03:58:23  11  ,g06
03:58:23  12  ,g07
03:58:23  13  ,g08
03:58:23  14  ,g09
03:58:23  15  ,g10
03:58:23  16  ,g11
03:58:23  17  ,g12
03:58:23  18  ,g13
03:58:23  19  ,g14
03:58:23  20  ,g15
03:58:23  21  ,g16
03:58:23  22  ,g17
03:58:23  23  ,g18
03:58:23  24  ,g19
03:58:23  25  ,g20
03:58:23  26  ,g21
03:58:23  27  ,g22
03:58:23  28  ,g23
03:58:23  29  ,g24
03:58:23  30  ,g25
03:58:23  31  ,g26
03:58:23  32  ,g27
03:58:23  33  ,g28
03:58:23  34  ,g29
03:58:23  35  ,g30
03:58:23  36  ,g31
03:58:23  37  ,g32
03:58:23  38  ,g33
03:58:23  39  ,g34
03:58:23  40  ,g35
03:58:23  41  ,g36
03:58:23  42  ,g37
03:58:23  43  ,g38
03:58:23  44  ,g39
03:58:23  45  ,g40
03:58:23  46  ,g41
03:58:23  47  ,s.sc_corr
03:58:23  48  FROM modsrc24
03:58:23  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:58:23  50  WHERE ydate = '&1'||' '||'&2'
03:58:23  51  AND pair = '&3'
03:58:23  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'18:40:00'AND ydate<'2011-01-27'||' '||'18:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'18:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:58:23 SQL> 
03:58:23 SQL> -- rpt
03:58:23 SQL> -- We should see just 1 row:
03:58:23 SQL> 
03:58:23 SQL> SELECT COUNT(prdate) FROM sme
03:58:23   2  
03:58:23 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:58:23   2  
03:58:23 SQL> 
03:58:23 SQL> -- Build the model:
03:58:23 SQL> CREATE OR REPLACE VIEW bme AS
03:58:23   2  SELECT
03:58:23   3  prdate
03:58:23   4  ,gattn
03:58:23   5  ,g00
03:58:23   6  ,g01
03:58:23   7  ,g02
03:58:23   8  ,g03
03:58:23   9  ,g04
03:58:23  10  ,g05
03:58:23  11  ,g06
03:58:23  12  ,g07
03:58:23  13  ,g08
03:58:23  14  ,g09
03:58:23  15  ,g10
03:58:23  16  ,g11
03:58:23  17  ,g12
03:58:23  18  ,g13
03:58:23  19  ,g14
03:58:23  20  ,g15
03:58:23  21  ,g16
03:58:23  22  ,g17
03:58:23  23  ,g18
03:58:23  24  ,g19
03:58:23  25  ,g20
03:58:23  26  ,g21
03:58:23  27  ,g22
03:58:23  28  ,g23
03:58:23  29  ,g24
03:58:23  30  ,g25
03:58:23  31  ,g26
03:58:23  32  ,g27
03:58:23  33  ,g28
03:58:23  34  ,g29
03:58:23  35  ,g30
03:58:23  36  ,g31
03:58:23  37  ,g32
03:58:23  38  ,g33
03:58:23  39  ,g34
03:58:23  40  ,g35
03:58:23  41  ,g36
03:58:23  42  ,g37
03:58:23  43  ,g38
03:58:23  44  ,g39
03:58:23  45  ,g40
03:58:23  46  ,g41
03:58:23  47  ,sc_corr
03:58:23  48  FROM modsrc24
03:58:23  49  WHERE gattn IN('nup','up')
03:58:23  50  -- Use only rows which are older than 1 day:
03:58:23  51  AND 1+ydate < '&1'||' '||'&2'
03:58:23  52  AND pair = '&3'
03:58:23  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'18:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:58:23 SQL> 
03:58:23 SQL> -- rpt
03:58:23 SQL> 
03:58:23 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:58:23   2  
03:58:23 SQL> SELECT MAX(prdate) FROM bme
03:58:23   2  
03:58:23 SQL> -- Now build model from bme and score sme
03:58:23 SQL> @score1.sql gattn
03:58:23 SQL> --
03:58:23 SQL> -- score1.sql
03:58:23 SQL> --
03:58:23 SQL> 
03:58:23 SQL> -- I use this script to send 5 params to score.sql
03:58:23 SQL> -- which does the heavy lifting of creating an SVM model.
03:58:23 SQL> -- Then at the very end of this script I use the model
03:58:23 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:58:23 SQL> 
03:58:23 SQL> -- I call this script from 2 other scripts:
03:58:23 SQL> -- score1_5min.sql
03:58:23 SQL> -- score1_5min_gattn.sql
03:58:23 SQL> 
03:58:23 SQL> -- The 1st param is the name of the target attribute.
03:58:23 SQL> -- I like to call my target attributes either gatt or gattn.
03:58:23 SQL> 
03:58:23 SQL> -- Demo:
03:58:23 SQL> -- @score1.sql 'gatt'
03:58:23 SQL> -- @score1.sql 'gattn'
03:58:23 SQL> 
03:58:23 SQL> -- Now, I fill up svmc_apply_prep.
03:58:23 SQL> -- I use same model_name used in score.sql
03:58:23 SQL> DEFINE model_name = 'svmfx101'
03:58:23 SQL> DEFINE bldtable	= 'bme'
03:58:23 SQL> DEFINE scoretable = 'sme'
03:58:23 SQL> DEFINE case_id	= 'prdate'
03:58:23 SQL> -- Demo:
03:58:23 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:58:23 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:58:23 SQL> --
03:58:23 SQL> -- score.sql
03:58:23 SQL> --
03:58:23 SQL> 
03:58:23 SQL> -- usage: score.sql
03:58:23 SQL> 
03:58:23 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:58:23 SQL> 
03:58:23 SQL> -- DEFINE target	   = 'gatt'
03:58:23 SQL> -- DEFINE model_name = 'svmfx101'
03:58:23 SQL> -- DEFINE bldtable   = 'bme'
03:58:23 SQL> -- DEFINE scoretable = 'sme'
03:58:23 SQL> -- DEFINE case_id    = 'prdate'
03:58:23 SQL> 
03:58:23 SQL> DEFINE target	= '&1'
03:58:23 SQL> DEFINE model_name = '&2'
03:58:23 SQL> DEFINE bldtable	= '&3'
03:58:23 SQL> DEFINE scoretable = '&4'
03:58:23 SQL> DEFINE case_id	= '&5'
03:58:23 SQL> 
03:58:23 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:58:23 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:58:23 SQL> 
03:58:23 SQL> -- Builds an SVM model using pl/sql.
03:58:23 SQL> 
03:58:23 SQL> -----------------------------------------------------------------------
03:58:23 SQL> --			    BUILD THE MODEL
03:58:23 SQL> -----------------------------------------------------------------------
03:58:23 SQL> 
03:58:23 SQL> -- Cleanup old build data preparation objects for repeat runs
03:58:23 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:23 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:58:23 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:23 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:58:23 SQL> 
03:58:23 SQL> 
03:58:23 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:58:23 SQL> --
03:58:23 SQL> -- DROP	TABLE svmc_settings ;
03:58:23 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:58:23 SQL> -- DELETE svmc_settings;
03:58:23 SQL> 
03:58:23 SQL> -- The default classification algorithm is Naive Bayes. So override
03:58:23 SQL> -- this choice to SVM using a settings table.
03:58:23 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:58:23 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:58:23 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:58:23 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:58:23 SQL> -- models.
03:58:23 SQL> --
03:58:23 SQL> 
03:58:23 SQL> -- Do this once and then comment it out.
03:58:23 SQL> -- That makes script go faster.
03:58:23 SQL> -- BEGIN
03:58:23 SQL> -- -- Populate settings table
03:58:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:23 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:58:23 SQL> --
03:58:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:23 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:58:23 SQL> --
03:58:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:23 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:58:23 SQL> --   COMMIT;
03:58:23 SQL> -- END;
03:58:23 SQL> -- /
03:58:23 SQL> 
03:58:23 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:58:23 SQL> 
03:58:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:58:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:58:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:58:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:23 SQL> 
03:58:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:58:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:23 SQL> 
03:58:23 SQL> --------------------------------
03:58:23 SQL> -- PREPARE BUILD (TRAINING) DATA
03:58:23 SQL> --
03:58:23 SQL> 
03:58:23 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:23 SQL> -- 2. Outlier Treatment and
03:58:23 SQL> -- 3. Normalization are performed below.
03:58:23 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:58:23 SQL> --    normalized here.
03:58:23 SQL> 
03:58:23 SQL> BEGIN
03:58:23   2  	-- Perform missing value treatment for all predictors
03:58:23   3  	-- create miss tables
03:58:23   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:58:23   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:58:23   6  
03:58:23   7  	-- populate miss tables
03:58:23   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:58:23   9  	  miss_table_name => 'svmc_miss_num',
03:58:23  10  	  data_table_name => '&bldtable',
03:58:23  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:23  12  
03:58:23  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:58:23  14  	  miss_table_name => 'svmc_miss_cat',
03:58:23  15  	  data_table_name => '&bldtable',
03:58:23  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:23  17  
03:58:23  18  	-- xform input data to replace missing values
03:58:23  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:23  20  	  miss_table_name => 'svmc_miss_num',
03:58:23  21  	  data_table_name => '&bldtable',
03:58:23  22  	  xform_view_name => 'xformed_build_miss_num');
03:58:23  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:23  24  	  miss_table_name => 'svmc_miss_cat',
03:58:23  25  	  data_table_name => '&bldtable',
03:58:23  26  	  xform_view_name => 'xformed_build_miss_cat');
03:58:23  27  
03:58:23  28  	-- Perform outlier treatment.
03:58:23  29  	-- create clip table
03:58:23  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:58:23  31  
03:58:23  32  	-- populate clip table
03:58:23  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:58:23  34  	  clip_table_name => 'svmc_clip',
03:58:23  35  	  data_table_name => '&bldtable',
03:58:23  36  	  tail_frac	  => 0.025,
03:58:23  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:23  38  
03:58:23  39  	-- xform input data to winsorized data
03:58:23  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:58:23  41  	  clip_table_name => 'svmc_clip',
03:58:23  42  	  data_table_name => '&bldtable',
03:58:23  43  	  xform_view_name => 'svmc_winsor');
03:58:23  44  
03:58:23  45  	-- create normalization table
03:58:23  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:58:23  47  
03:58:23  48  	-- populate normalization table based on winsorized data
03:58:23  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:58:23  50  	  norm_table_name => 'svmc_norm',
03:58:23  51  	  data_table_name => 'svmc_winsor',
03:58:23  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:23  53  
03:58:23  54  	-- normalize the original data
03:58:23  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:23  56  	  norm_table_name => 'svmc_norm',
03:58:23  57  	  data_table_name => '&bldtable',
03:58:23  58  	  xform_view_name => 'svmc_build_prep');
03:58:23  59  END;
03:58:23  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.71
03:58:26 SQL> 
03:58:26 SQL> ---------------------
03:58:26 SQL> -- CREATE A NEW MODEL
03:58:26 SQL> --
03:58:26 SQL> -- Cleanup old model with the same name for repeat runs
03:58:26 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:58:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:26   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.40
03:58:27 SQL> 
03:58:27 SQL> -- Build a new SVM Model
03:58:27 SQL> BEGIN
03:58:27   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:58:27   3  	  model_name	      => '&model_name',
03:58:27   4  	  mining_function     => dbms_data_mining.classification,
03:58:27   5  	  data_table_name     => 'svmc_build_prep',
03:58:27   6  	  case_id_column_name => '&case_id',
03:58:27   7  	  target_column_name  => '&target',
03:58:27   8  	  settings_table_name => 'svmc_settings');
03:58:27   9  END;
03:58:27  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.84
03:58:33 SQL> 
03:58:33 SQL> -----------------------------------------------------------------------
03:58:33 SQL> --			       APPLY/score THE MODEL
03:58:33 SQL> -----------------------------------------------------------------------
03:58:33 SQL> 
03:58:33 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:58:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:58:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:58:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
03:58:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:58:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:33 SQL> -----------------------
03:58:33 SQL> -- PREPARE SCORING DATA
03:58:33 SQL> --
03:58:33 SQL> -- If the data for model creation has been prepared, then the data
03:58:33 SQL> -- to be scored using the model must be prepared in the same manner
03:58:33 SQL> -- in order to obtain meaningful results.
03:58:33 SQL> --
03:58:33 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:33 SQL> -- 2. Normalization
03:58:33 SQL> -- No outlier treatment will be performed during test and apply. The
03:58:33 SQL> -- normalization step is sufficient, since the normalization parameters
03:58:33 SQL> -- already capture the effects of outlier treatment done with build data.
03:58:33 SQL> --
03:58:33 SQL> BEGIN
03:58:33   2  	-- Xform Test data to replace missing values
03:58:33   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:33   4  	  miss_table_name => 'svmc_miss_num',
03:58:33   5  	  data_table_name => '&scoretable',
03:58:33   6  	  xform_view_name => 'xformed_apply_miss_num');
03:58:33   7  
03:58:33   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:33   9  	  miss_table_name => 'svmc_miss_cat',
03:58:33  10  	  data_table_name => '&scoretable',
03:58:33  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:58:33  12  
03:58:33  13  	-- Normalize the data to be scored
03:58:33  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:33  15  	  norm_table_name => 'svmc_norm',
03:58:33  16  	  data_table_name => '&scoretable',
03:58:33  17  	  xform_view_name => 'svmc_apply_prep');
03:58:33  18  END;
03:58:33  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:58:33 SQL> 
03:58:33 SQL> -- Maybe I already collected a score for this prdate.
03:58:33 SQL> -- DELETE it if I did:
03:58:33 SQL> DELETE svm24scores
03:58:33   2  WHERE score > 0
03:58:33   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:58:33   4  -- I need to supply the target attribute name:
03:58:33   5  AND targ = '&1'
03:58:33   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:58:33 SQL> 
03:58:33 SQL> -- We do a drumroll here:
03:58:33 SQL> 
03:58:33 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:58:33   2  SELECT
03:58:33   3  prdate
03:58:33   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:58:33   5  ,sysdate
03:58:33   6  ,SUBSTR(prdate,1,7)pair
03:58:33   7  ,SUBSTR(prdate,-19)ydate
03:58:33   8  ,'&1'
03:58:33   9  FROM svmc_apply_prep
03:58:33  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:58:33 SQL> @score1_5min_gattn.sql	2011-01-20 22:50:00 eur_usd
03:58:33 SQL> --
03:58:33 SQL> -- score1_5min_gattn.sql
03:58:33 SQL> --
03:58:33 SQL> 
03:58:33 SQL> -- Demo:
03:58:33 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:58:33 SQL> 
03:58:33 SQL> CREATE OR REPLACE VIEW sme AS
03:58:33   2  SELECT
03:58:33   3  prdate
03:58:33   4  ,NULL gattn
03:58:33   5  ,g00
03:58:33   6  ,g01
03:58:33   7  ,g02
03:58:33   8  ,g03
03:58:33   9  ,g04
03:58:33  10  ,g05
03:58:33  11  ,g06
03:58:33  12  ,g07
03:58:33  13  ,g08
03:58:33  14  ,g09
03:58:33  15  ,g10
03:58:33  16  ,g11
03:58:33  17  ,g12
03:58:33  18  ,g13
03:58:33  19  ,g14
03:58:33  20  ,g15
03:58:33  21  ,g16
03:58:33  22  ,g17
03:58:33  23  ,g18
03:58:33  24  ,g19
03:58:33  25  ,g20
03:58:33  26  ,g21
03:58:33  27  ,g22
03:58:33  28  ,g23
03:58:33  29  ,g24
03:58:33  30  ,g25
03:58:33  31  ,g26
03:58:33  32  ,g27
03:58:33  33  ,g28
03:58:33  34  ,g29
03:58:33  35  ,g30
03:58:33  36  ,g31
03:58:33  37  ,g32
03:58:33  38  ,g33
03:58:33  39  ,g34
03:58:33  40  ,g35
03:58:33  41  ,g36
03:58:33  42  ,g37
03:58:33  43  ,g38
03:58:33  44  ,g39
03:58:33  45  ,g40
03:58:33  46  ,g41
03:58:33  47  ,s.sc_corr
03:58:33  48  FROM modsrc24
03:58:33  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:58:33  50  WHERE ydate = '&1'||' '||'&2'
03:58:33  51  AND pair = '&3'
03:58:33  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'22:50:00'AND ydate<'2011-01-20'||' '||'22:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'22:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
03:58:34 SQL> 
03:58:34 SQL> -- rpt
03:58:34 SQL> -- We should see just 1 row:
03:58:34 SQL> 
03:58:34 SQL> SELECT COUNT(prdate) FROM sme
03:58:34   2  
03:58:34 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:58:34   2  
03:58:34 SQL> 
03:58:34 SQL> -- Build the model:
03:58:34 SQL> CREATE OR REPLACE VIEW bme AS
03:58:34   2  SELECT
03:58:34   3  prdate
03:58:34   4  ,gattn
03:58:34   5  ,g00
03:58:34   6  ,g01
03:58:34   7  ,g02
03:58:34   8  ,g03
03:58:34   9  ,g04
03:58:34  10  ,g05
03:58:34  11  ,g06
03:58:34  12  ,g07
03:58:34  13  ,g08
03:58:34  14  ,g09
03:58:34  15  ,g10
03:58:34  16  ,g11
03:58:34  17  ,g12
03:58:34  18  ,g13
03:58:34  19  ,g14
03:58:34  20  ,g15
03:58:34  21  ,g16
03:58:34  22  ,g17
03:58:34  23  ,g18
03:58:34  24  ,g19
03:58:34  25  ,g20
03:58:34  26  ,g21
03:58:34  27  ,g22
03:58:34  28  ,g23
03:58:34  29  ,g24
03:58:34  30  ,g25
03:58:34  31  ,g26
03:58:34  32  ,g27
03:58:34  33  ,g28
03:58:34  34  ,g29
03:58:34  35  ,g30
03:58:34  36  ,g31
03:58:34  37  ,g32
03:58:34  38  ,g33
03:58:34  39  ,g34
03:58:34  40  ,g35
03:58:34  41  ,g36
03:58:34  42  ,g37
03:58:34  43  ,g38
03:58:34  44  ,g39
03:58:34  45  ,g40
03:58:34  46  ,g41
03:58:34  47  ,sc_corr
03:58:34  48  FROM modsrc24
03:58:34  49  WHERE gattn IN('nup','up')
03:58:34  50  -- Use only rows which are older than 1 day:
03:58:34  51  AND 1+ydate < '&1'||' '||'&2'
03:58:34  52  AND pair = '&3'
03:58:34  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'22:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:58:34 SQL> 
03:58:34 SQL> -- rpt
03:58:34 SQL> 
03:58:34 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:58:34   2  
03:58:34 SQL> SELECT MAX(prdate) FROM bme
03:58:34   2  
03:58:34 SQL> -- Now build model from bme and score sme
03:58:34 SQL> @score1.sql gattn
03:58:34 SQL> --
03:58:34 SQL> -- score1.sql
03:58:34 SQL> --
03:58:34 SQL> 
03:58:34 SQL> -- I use this script to send 5 params to score.sql
03:58:34 SQL> -- which does the heavy lifting of creating an SVM model.
03:58:34 SQL> -- Then at the very end of this script I use the model
03:58:34 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:58:34 SQL> 
03:58:34 SQL> -- I call this script from 2 other scripts:
03:58:34 SQL> -- score1_5min.sql
03:58:34 SQL> -- score1_5min_gattn.sql
03:58:34 SQL> 
03:58:34 SQL> -- The 1st param is the name of the target attribute.
03:58:34 SQL> -- I like to call my target attributes either gatt or gattn.
03:58:34 SQL> 
03:58:34 SQL> -- Demo:
03:58:34 SQL> -- @score1.sql 'gatt'
03:58:34 SQL> -- @score1.sql 'gattn'
03:58:34 SQL> 
03:58:34 SQL> -- Now, I fill up svmc_apply_prep.
03:58:34 SQL> -- I use same model_name used in score.sql
03:58:34 SQL> DEFINE model_name = 'svmfx101'
03:58:34 SQL> DEFINE bldtable	= 'bme'
03:58:34 SQL> DEFINE scoretable = 'sme'
03:58:34 SQL> DEFINE case_id	= 'prdate'
03:58:34 SQL> -- Demo:
03:58:34 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:58:34 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:58:34 SQL> --
03:58:34 SQL> -- score.sql
03:58:34 SQL> --
03:58:34 SQL> 
03:58:34 SQL> -- usage: score.sql
03:58:34 SQL> 
03:58:34 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:58:34 SQL> 
03:58:34 SQL> -- DEFINE target	   = 'gatt'
03:58:34 SQL> -- DEFINE model_name = 'svmfx101'
03:58:34 SQL> -- DEFINE bldtable   = 'bme'
03:58:34 SQL> -- DEFINE scoretable = 'sme'
03:58:34 SQL> -- DEFINE case_id    = 'prdate'
03:58:34 SQL> 
03:58:34 SQL> DEFINE target	= '&1'
03:58:34 SQL> DEFINE model_name = '&2'
03:58:34 SQL> DEFINE bldtable	= '&3'
03:58:34 SQL> DEFINE scoretable = '&4'
03:58:34 SQL> DEFINE case_id	= '&5'
03:58:34 SQL> 
03:58:34 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:58:34 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:58:34 SQL> 
03:58:34 SQL> -- Builds an SVM model using pl/sql.
03:58:34 SQL> 
03:58:34 SQL> -----------------------------------------------------------------------
03:58:34 SQL> --			    BUILD THE MODEL
03:58:34 SQL> -----------------------------------------------------------------------
03:58:34 SQL> 
03:58:34 SQL> -- Cleanup old build data preparation objects for repeat runs
03:58:34 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:34 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:58:34 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:34 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:58:34 SQL> 
03:58:34 SQL> 
03:58:34 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:58:34 SQL> --
03:58:34 SQL> -- DROP	TABLE svmc_settings ;
03:58:34 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:58:34 SQL> -- DELETE svmc_settings;
03:58:34 SQL> 
03:58:34 SQL> -- The default classification algorithm is Naive Bayes. So override
03:58:34 SQL> -- this choice to SVM using a settings table.
03:58:34 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:58:34 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:58:34 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:58:34 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:58:34 SQL> -- models.
03:58:34 SQL> --
03:58:34 SQL> 
03:58:34 SQL> -- Do this once and then comment it out.
03:58:34 SQL> -- That makes script go faster.
03:58:34 SQL> -- BEGIN
03:58:34 SQL> -- -- Populate settings table
03:58:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:34 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:58:34 SQL> --
03:58:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:34 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:58:34 SQL> --
03:58:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:34 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:58:34 SQL> --   COMMIT;
03:58:34 SQL> -- END;
03:58:34 SQL> -- /
03:58:34 SQL> 
03:58:34 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:58:34 SQL> 
03:58:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:58:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:58:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:58:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:58:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:34 SQL> 
03:58:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:58:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:58:34 SQL> 
03:58:34 SQL> --------------------------------
03:58:34 SQL> -- PREPARE BUILD (TRAINING) DATA
03:58:34 SQL> --
03:58:34 SQL> 
03:58:34 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:34 SQL> -- 2. Outlier Treatment and
03:58:34 SQL> -- 3. Normalization are performed below.
03:58:34 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:58:34 SQL> --    normalized here.
03:58:34 SQL> 
03:58:34 SQL> BEGIN
03:58:34   2  	-- Perform missing value treatment for all predictors
03:58:34   3  	-- create miss tables
03:58:34   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:58:34   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:58:34   6  
03:58:34   7  	-- populate miss tables
03:58:34   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:58:34   9  	  miss_table_name => 'svmc_miss_num',
03:58:34  10  	  data_table_name => '&bldtable',
03:58:34  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:34  12  
03:58:34  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:58:34  14  	  miss_table_name => 'svmc_miss_cat',
03:58:34  15  	  data_table_name => '&bldtable',
03:58:34  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:34  17  
03:58:34  18  	-- xform input data to replace missing values
03:58:34  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:34  20  	  miss_table_name => 'svmc_miss_num',
03:58:34  21  	  data_table_name => '&bldtable',
03:58:34  22  	  xform_view_name => 'xformed_build_miss_num');
03:58:34  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:34  24  	  miss_table_name => 'svmc_miss_cat',
03:58:34  25  	  data_table_name => '&bldtable',
03:58:34  26  	  xform_view_name => 'xformed_build_miss_cat');
03:58:34  27  
03:58:34  28  	-- Perform outlier treatment.
03:58:34  29  	-- create clip table
03:58:34  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:58:34  31  
03:58:34  32  	-- populate clip table
03:58:34  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:58:34  34  	  clip_table_name => 'svmc_clip',
03:58:34  35  	  data_table_name => '&bldtable',
03:58:34  36  	  tail_frac	  => 0.025,
03:58:34  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:34  38  
03:58:34  39  	-- xform input data to winsorized data
03:58:34  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:58:34  41  	  clip_table_name => 'svmc_clip',
03:58:34  42  	  data_table_name => '&bldtable',
03:58:34  43  	  xform_view_name => 'svmc_winsor');
03:58:34  44  
03:58:34  45  	-- create normalization table
03:58:34  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:58:34  47  
03:58:34  48  	-- populate normalization table based on winsorized data
03:58:34  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:58:34  50  	  norm_table_name => 'svmc_norm',
03:58:34  51  	  data_table_name => 'svmc_winsor',
03:58:34  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:34  53  
03:58:34  54  	-- normalize the original data
03:58:34  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:34  56  	  norm_table_name => 'svmc_norm',
03:58:34  57  	  data_table_name => '&bldtable',
03:58:34  58  	  xform_view_name => 'svmc_build_prep');
03:58:34  59  END;
03:58:34  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.59
03:58:36 SQL> 
03:58:36 SQL> ---------------------
03:58:36 SQL> -- CREATE A NEW MODEL
03:58:36 SQL> --
03:58:36 SQL> -- Cleanup old model with the same name for repeat runs
03:58:36 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:58:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:36   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.55
03:58:38 SQL> 
03:58:38 SQL> -- Build a new SVM Model
03:58:38 SQL> BEGIN
03:58:38   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:58:38   3  	  model_name	      => '&model_name',
03:58:38   4  	  mining_function     => dbms_data_mining.classification,
03:58:38   5  	  data_table_name     => 'svmc_build_prep',
03:58:38   6  	  case_id_column_name => '&case_id',
03:58:38   7  	  target_column_name  => '&target',
03:58:38   8  	  settings_table_name => 'svmc_settings');
03:58:38   9  END;
03:58:38  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:07.18
03:58:45 SQL> 
03:58:45 SQL> -----------------------------------------------------------------------
03:58:45 SQL> --			       APPLY/score THE MODEL
03:58:45 SQL> -----------------------------------------------------------------------
03:58:45 SQL> 
03:58:45 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:58:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:58:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:58:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:58:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:58:45 SQL> -----------------------
03:58:45 SQL> -- PREPARE SCORING DATA
03:58:45 SQL> --
03:58:45 SQL> -- If the data for model creation has been prepared, then the data
03:58:45 SQL> -- to be scored using the model must be prepared in the same manner
03:58:45 SQL> -- in order to obtain meaningful results.
03:58:45 SQL> --
03:58:45 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:45 SQL> -- 2. Normalization
03:58:45 SQL> -- No outlier treatment will be performed during test and apply. The
03:58:45 SQL> -- normalization step is sufficient, since the normalization parameters
03:58:45 SQL> -- already capture the effects of outlier treatment done with build data.
03:58:45 SQL> --
03:58:45 SQL> BEGIN
03:58:45   2  	-- Xform Test data to replace missing values
03:58:45   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:45   4  	  miss_table_name => 'svmc_miss_num',
03:58:45   5  	  data_table_name => '&scoretable',
03:58:45   6  	  xform_view_name => 'xformed_apply_miss_num');
03:58:45   7  
03:58:45   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:45   9  	  miss_table_name => 'svmc_miss_cat',
03:58:45  10  	  data_table_name => '&scoretable',
03:58:45  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:58:45  12  
03:58:45  13  	-- Normalize the data to be scored
03:58:45  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:45  15  	  norm_table_name => 'svmc_norm',
03:58:45  16  	  data_table_name => '&scoretable',
03:58:45  17  	  xform_view_name => 'svmc_apply_prep');
03:58:45  18  END;
03:58:45  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:58:45 SQL> 
03:58:45 SQL> -- Maybe I already collected a score for this prdate.
03:58:45 SQL> -- DELETE it if I did:
03:58:45 SQL> DELETE svm24scores
03:58:45   2  WHERE score > 0
03:58:45   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:58:45   4  -- I need to supply the target attribute name:
03:58:45   5  AND targ = '&1'
03:58:45   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:58:45 SQL> 
03:58:45 SQL> -- We do a drumroll here:
03:58:45 SQL> 
03:58:45 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:58:45   2  SELECT
03:58:45   3  prdate
03:58:45   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:58:45   5  ,sysdate
03:58:45   6  ,SUBSTR(prdate,1,7)pair
03:58:45   7  ,SUBSTR(prdate,-19)ydate
03:58:45   8  ,'&1'
03:58:45   9  FROM svmc_apply_prep
03:58:45  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:58:45 SQL> @score1_5min.sql	      2011-01-27 17:55:00 eur_usd
03:58:45 SQL> --
03:58:45 SQL> -- score1_5min.sql
03:58:45 SQL> --
03:58:45 SQL> 
03:58:45 SQL> -- Demo:
03:58:45 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:58:45 SQL> 
03:58:45 SQL> CREATE OR REPLACE VIEW sme AS
03:58:45   2  SELECT
03:58:45   3  prdate
03:58:45   4  ,NULL gatt
03:58:45   5  ,g00
03:58:45   6  ,g01
03:58:45   7  ,g02
03:58:45   8  ,g03
03:58:45   9  ,g04
03:58:45  10  ,g05
03:58:45  11  ,g06
03:58:45  12  ,g07
03:58:45  13  ,g08
03:58:45  14  ,g09
03:58:45  15  ,g10
03:58:45  16  ,g11
03:58:45  17  ,g12
03:58:45  18  ,g13
03:58:45  19  ,g14
03:58:45  20  ,g15
03:58:45  21  ,g16
03:58:45  22  ,g17
03:58:45  23  ,g18
03:58:45  24  ,g19
03:58:45  25  ,g20
03:58:45  26  ,g21
03:58:45  27  ,g22
03:58:45  28  ,g23
03:58:45  29  ,g24
03:58:45  30  ,g25
03:58:45  31  ,g26
03:58:45  32  ,g27
03:58:45  33  ,g28
03:58:45  34  ,g29
03:58:45  35  ,g30
03:58:45  36  ,g31
03:58:45  37  ,g32
03:58:45  38  ,g33
03:58:45  39  ,g34
03:58:45  40  ,g35
03:58:45  41  ,g36
03:58:45  42  ,g37
03:58:45  43  ,g38
03:58:45  44  ,g39
03:58:45  45  ,g40
03:58:45  46  ,g41
03:58:45  47  ,s.sc_corr
03:58:45  48  FROM modsrc24
03:58:45  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:58:45  50  WHERE ydate = '&1'||' '||'&2'
03:58:45  51  AND pair = '&3'
03:58:45  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'17:55:00'AND ydate<'2011-01-27'||' '||'17:55:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'17:55:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:58:46 SQL> 
03:58:46 SQL> -- rpt
03:58:46 SQL> -- We should see just 1 row:
03:58:46 SQL> 
03:58:46 SQL> SELECT COUNT(prdate) FROM sme
03:58:46   2  
03:58:46 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:58:46   2  
03:58:46 SQL> 
03:58:46 SQL> -- Build the model:
03:58:46 SQL> CREATE OR REPLACE VIEW bme AS
03:58:46   2  SELECT
03:58:46   3  prdate
03:58:46   4  ,gatt
03:58:46   5  ,g00
03:58:46   6  ,g01
03:58:46   7  ,g02
03:58:46   8  ,g03
03:58:46   9  ,g04
03:58:46  10  ,g05
03:58:46  11  ,g06
03:58:46  12  ,g07
03:58:46  13  ,g08
03:58:46  14  ,g09
03:58:46  15  ,g10
03:58:46  16  ,g11
03:58:46  17  ,g12
03:58:46  18  ,g13
03:58:46  19  ,g14
03:58:46  20  ,g15
03:58:46  21  ,g16
03:58:46  22  ,g17
03:58:46  23  ,g18
03:58:46  24  ,g19
03:58:46  25  ,g20
03:58:46  26  ,g21
03:58:46  27  ,g22
03:58:46  28  ,g23
03:58:46  29  ,g24
03:58:46  30  ,g25
03:58:46  31  ,g26
03:58:46  32  ,g27
03:58:46  33  ,g28
03:58:46  34  ,g29
03:58:46  35  ,g30
03:58:46  36  ,g31
03:58:46  37  ,g32
03:58:46  38  ,g33
03:58:46  39  ,g34
03:58:46  40  ,g35
03:58:46  41  ,g36
03:58:46  42  ,g37
03:58:46  43  ,g38
03:58:46  44  ,g39
03:58:46  45  ,g40
03:58:46  46  ,g41
03:58:46  47  ,sc_corr
03:58:46  48  FROM modsrc24
03:58:46  49  WHERE gatt IN('nup','up')
03:58:46  50  -- Use only rows which are older than 1 day:
03:58:46  51  AND 1+ydate < '&1'||' '||'&2'
03:58:46  52  AND pair = '&3'
03:58:46  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'17:55:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:58:46 SQL> 
03:58:46 SQL> -- rpt
03:58:46 SQL> 
03:58:46 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:58:46   2  
03:58:46 SQL> SELECT MAX(prdate) FROM bme
03:58:46   2  
03:58:46 SQL> -- Now build model from bme and score sme
03:58:46 SQL> @score1.sql gatt
03:58:46 SQL> --
03:58:46 SQL> -- score1.sql
03:58:46 SQL> --
03:58:46 SQL> 
03:58:46 SQL> -- I use this script to send 5 params to score.sql
03:58:46 SQL> -- which does the heavy lifting of creating an SVM model.
03:58:46 SQL> -- Then at the very end of this script I use the model
03:58:46 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:58:46 SQL> 
03:58:46 SQL> -- I call this script from 2 other scripts:
03:58:46 SQL> -- score1_5min.sql
03:58:46 SQL> -- score1_5min_gattn.sql
03:58:46 SQL> 
03:58:46 SQL> -- The 1st param is the name of the target attribute.
03:58:46 SQL> -- I like to call my target attributes either gatt or gattn.
03:58:46 SQL> 
03:58:46 SQL> -- Demo:
03:58:46 SQL> -- @score1.sql 'gatt'
03:58:46 SQL> -- @score1.sql 'gattn'
03:58:46 SQL> 
03:58:46 SQL> -- Now, I fill up svmc_apply_prep.
03:58:46 SQL> -- I use same model_name used in score.sql
03:58:46 SQL> DEFINE model_name = 'svmfx101'
03:58:46 SQL> DEFINE bldtable	= 'bme'
03:58:46 SQL> DEFINE scoretable = 'sme'
03:58:46 SQL> DEFINE case_id	= 'prdate'
03:58:46 SQL> -- Demo:
03:58:46 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:58:46 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:58:46 SQL> --
03:58:46 SQL> -- score.sql
03:58:46 SQL> --
03:58:46 SQL> 
03:58:46 SQL> -- usage: score.sql
03:58:46 SQL> 
03:58:46 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:58:46 SQL> 
03:58:46 SQL> -- DEFINE target	   = 'gatt'
03:58:46 SQL> -- DEFINE model_name = 'svmfx101'
03:58:46 SQL> -- DEFINE bldtable   = 'bme'
03:58:46 SQL> -- DEFINE scoretable = 'sme'
03:58:46 SQL> -- DEFINE case_id    = 'prdate'
03:58:46 SQL> 
03:58:46 SQL> DEFINE target	= '&1'
03:58:46 SQL> DEFINE model_name = '&2'
03:58:46 SQL> DEFINE bldtable	= '&3'
03:58:46 SQL> DEFINE scoretable = '&4'
03:58:46 SQL> DEFINE case_id	= '&5'
03:58:46 SQL> 
03:58:46 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:58:46 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:58:46 SQL> 
03:58:46 SQL> -- Builds an SVM model using pl/sql.
03:58:46 SQL> 
03:58:46 SQL> -----------------------------------------------------------------------
03:58:46 SQL> --			    BUILD THE MODEL
03:58:46 SQL> -----------------------------------------------------------------------
03:58:46 SQL> 
03:58:46 SQL> -- Cleanup old build data preparation objects for repeat runs
03:58:46 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:46 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:58:46 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:58:46 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:58:46 SQL> 
03:58:46 SQL> 
03:58:46 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:58:46 SQL> --
03:58:46 SQL> -- DROP	TABLE svmc_settings ;
03:58:46 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:58:46 SQL> -- DELETE svmc_settings;
03:58:46 SQL> 
03:58:46 SQL> -- The default classification algorithm is Naive Bayes. So override
03:58:46 SQL> -- this choice to SVM using a settings table.
03:58:46 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:58:46 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:58:46 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:58:46 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:58:46 SQL> -- models.
03:58:46 SQL> --
03:58:46 SQL> 
03:58:46 SQL> -- Do this once and then comment it out.
03:58:46 SQL> -- That makes script go faster.
03:58:46 SQL> -- BEGIN
03:58:46 SQL> -- -- Populate settings table
03:58:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:46 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:58:46 SQL> --
03:58:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:46 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:58:46 SQL> --
03:58:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:46 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:58:46 SQL> --   COMMIT;
03:58:46 SQL> -- END;
03:58:46 SQL> -- /
03:58:46 SQL> 
03:58:46 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:58:46 SQL> 
03:58:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:58:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:58:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:58:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:58:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:46 SQL> 
03:58:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:58:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:46 SQL> 
03:58:46 SQL> --------------------------------
03:58:46 SQL> -- PREPARE BUILD (TRAINING) DATA
03:58:46 SQL> --
03:58:46 SQL> 
03:58:46 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:46 SQL> -- 2. Outlier Treatment and
03:58:46 SQL> -- 3. Normalization are performed below.
03:58:46 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:58:46 SQL> --    normalized here.
03:58:46 SQL> 
03:58:46 SQL> BEGIN
03:58:46   2  	-- Perform missing value treatment for all predictors
03:58:46   3  	-- create miss tables
03:58:46   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:58:46   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:58:46   6  
03:58:46   7  	-- populate miss tables
03:58:46   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:58:46   9  	  miss_table_name => 'svmc_miss_num',
03:58:46  10  	  data_table_name => '&bldtable',
03:58:46  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:46  12  
03:58:46  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:58:46  14  	  miss_table_name => 'svmc_miss_cat',
03:58:46  15  	  data_table_name => '&bldtable',
03:58:46  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:46  17  
03:58:46  18  	-- xform input data to replace missing values
03:58:46  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:46  20  	  miss_table_name => 'svmc_miss_num',
03:58:46  21  	  data_table_name => '&bldtable',
03:58:46  22  	  xform_view_name => 'xformed_build_miss_num');
03:58:46  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:46  24  	  miss_table_name => 'svmc_miss_cat',
03:58:46  25  	  data_table_name => '&bldtable',
03:58:46  26  	  xform_view_name => 'xformed_build_miss_cat');
03:58:46  27  
03:58:46  28  	-- Perform outlier treatment.
03:58:46  29  	-- create clip table
03:58:46  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:58:46  31  
03:58:46  32  	-- populate clip table
03:58:46  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:58:46  34  	  clip_table_name => 'svmc_clip',
03:58:46  35  	  data_table_name => '&bldtable',
03:58:46  36  	  tail_frac	  => 0.025,
03:58:46  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:46  38  
03:58:46  39  	-- xform input data to winsorized data
03:58:46  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:58:46  41  	  clip_table_name => 'svmc_clip',
03:58:46  42  	  data_table_name => '&bldtable',
03:58:46  43  	  xform_view_name => 'svmc_winsor');
03:58:46  44  
03:58:46  45  	-- create normalization table
03:58:46  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:58:46  47  
03:58:46  48  	-- populate normalization table based on winsorized data
03:58:46  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:58:46  50  	  norm_table_name => 'svmc_norm',
03:58:46  51  	  data_table_name => 'svmc_winsor',
03:58:46  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:46  53  
03:58:46  54  	-- normalize the original data
03:58:46  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:46  56  	  norm_table_name => 'svmc_norm',
03:58:46  57  	  data_table_name => '&bldtable',
03:58:46  58  	  xform_view_name => 'svmc_build_prep');
03:58:46  59  END;
03:58:46  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.69
03:58:48 SQL> 
03:58:48 SQL> ---------------------
03:58:48 SQL> -- CREATE A NEW MODEL
03:58:48 SQL> --
03:58:48 SQL> -- Cleanup old model with the same name for repeat runs
03:58:48 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:58:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:48   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
03:58:50 SQL> 
03:58:50 SQL> -- Build a new SVM Model
03:58:50 SQL> BEGIN
03:58:50   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:58:50   3  	  model_name	      => '&model_name',
03:58:50   4  	  mining_function     => dbms_data_mining.classification,
03:58:50   5  	  data_table_name     => 'svmc_build_prep',
03:58:50   6  	  case_id_column_name => '&case_id',
03:58:50   7  	  target_column_name  => '&target',
03:58:50   8  	  settings_table_name => 'svmc_settings');
03:58:50   9  END;
03:58:50  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.40
03:58:55 SQL> 
03:58:55 SQL> -----------------------------------------------------------------------
03:58:55 SQL> --			       APPLY/score THE MODEL
03:58:55 SQL> -----------------------------------------------------------------------
03:58:55 SQL> 
03:58:55 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:58:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:58:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:58:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:58:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:58:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:55 SQL> -----------------------
03:58:55 SQL> -- PREPARE SCORING DATA
03:58:55 SQL> --
03:58:55 SQL> -- If the data for model creation has been prepared, then the data
03:58:55 SQL> -- to be scored using the model must be prepared in the same manner
03:58:55 SQL> -- in order to obtain meaningful results.
03:58:55 SQL> --
03:58:55 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:55 SQL> -- 2. Normalization
03:58:55 SQL> -- No outlier treatment will be performed during test and apply. The
03:58:55 SQL> -- normalization step is sufficient, since the normalization parameters
03:58:55 SQL> -- already capture the effects of outlier treatment done with build data.
03:58:55 SQL> --
03:58:55 SQL> BEGIN
03:58:55   2  	-- Xform Test data to replace missing values
03:58:55   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:55   4  	  miss_table_name => 'svmc_miss_num',
03:58:55   5  	  data_table_name => '&scoretable',
03:58:55   6  	  xform_view_name => 'xformed_apply_miss_num');
03:58:55   7  
03:58:55   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:55   9  	  miss_table_name => 'svmc_miss_cat',
03:58:55  10  	  data_table_name => '&scoretable',
03:58:55  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:58:55  12  
03:58:55  13  	-- Normalize the data to be scored
03:58:55  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:55  15  	  norm_table_name => 'svmc_norm',
03:58:55  16  	  data_table_name => '&scoretable',
03:58:55  17  	  xform_view_name => 'svmc_apply_prep');
03:58:55  18  END;
03:58:55  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:58:56 SQL> 
03:58:56 SQL> -- Maybe I already collected a score for this prdate.
03:58:56 SQL> -- DELETE it if I did:
03:58:56 SQL> DELETE svm24scores
03:58:56   2  WHERE score > 0
03:58:56   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:58:56   4  -- I need to supply the target attribute name:
03:58:56   5  AND targ = '&1'
03:58:56   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:58:56 SQL> 
03:58:56 SQL> -- We do a drumroll here:
03:58:56 SQL> 
03:58:56 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:58:56   2  SELECT
03:58:56   3  prdate
03:58:56   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:58:56   5  ,sysdate
03:58:56   6  ,SUBSTR(prdate,1,7)pair
03:58:56   7  ,SUBSTR(prdate,-19)ydate
03:58:56   8  ,'&1'
03:58:56   9  FROM svmc_apply_prep
03:58:56  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:58:56 SQL> @score1_5min_gattn.sql	2011-01-27 18:00:00 eur_usd
03:58:56 SQL> --
03:58:56 SQL> -- score1_5min_gattn.sql
03:58:56 SQL> --
03:58:56 SQL> 
03:58:56 SQL> -- Demo:
03:58:56 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:58:56 SQL> 
03:58:56 SQL> CREATE OR REPLACE VIEW sme AS
03:58:56   2  SELECT
03:58:56   3  prdate
03:58:56   4  ,NULL gattn
03:58:56   5  ,g00
03:58:56   6  ,g01
03:58:56   7  ,g02
03:58:56   8  ,g03
03:58:56   9  ,g04
03:58:56  10  ,g05
03:58:56  11  ,g06
03:58:56  12  ,g07
03:58:56  13  ,g08
03:58:56  14  ,g09
03:58:56  15  ,g10
03:58:56  16  ,g11
03:58:56  17  ,g12
03:58:56  18  ,g13
03:58:56  19  ,g14
03:58:56  20  ,g15
03:58:56  21  ,g16
03:58:56  22  ,g17
03:58:56  23  ,g18
03:58:56  24  ,g19
03:58:56  25  ,g20
03:58:56  26  ,g21
03:58:56  27  ,g22
03:58:56  28  ,g23
03:58:56  29  ,g24
03:58:56  30  ,g25
03:58:56  31  ,g26
03:58:56  32  ,g27
03:58:56  33  ,g28
03:58:56  34  ,g29
03:58:56  35  ,g30
03:58:56  36  ,g31
03:58:56  37  ,g32
03:58:56  38  ,g33
03:58:56  39  ,g34
03:58:56  40  ,g35
03:58:56  41  ,g36
03:58:56  42  ,g37
03:58:56  43  ,g38
03:58:56  44  ,g39
03:58:56  45  ,g40
03:58:56  46  ,g41
03:58:56  47  ,s.sc_corr
03:58:56  48  FROM modsrc24
03:58:56  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:58:56  50  WHERE ydate = '&1'||' '||'&2'
03:58:56  51  AND pair = '&3'
03:58:56  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'18:00:00'AND ydate<'2011-01-27'||' '||'18:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'18:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:58:56 SQL> 
03:58:56 SQL> -- rpt
03:58:56 SQL> -- We should see just 1 row:
03:58:56 SQL> 
03:58:56 SQL> SELECT COUNT(prdate) FROM sme
03:58:56   2  
03:58:56 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:58:56   2  
03:58:56 SQL> 
03:58:56 SQL> -- Build the model:
03:58:56 SQL> CREATE OR REPLACE VIEW bme AS
03:58:56   2  SELECT
03:58:56   3  prdate
03:58:56   4  ,gattn
03:58:56   5  ,g00
03:58:56   6  ,g01
03:58:56   7  ,g02
03:58:56   8  ,g03
03:58:56   9  ,g04
03:58:56  10  ,g05
03:58:56  11  ,g06
03:58:56  12  ,g07
03:58:56  13  ,g08
03:58:56  14  ,g09
03:58:56  15  ,g10
03:58:56  16  ,g11
03:58:56  17  ,g12
03:58:56  18  ,g13
03:58:56  19  ,g14
03:58:56  20  ,g15
03:58:56  21  ,g16
03:58:56  22  ,g17
03:58:56  23  ,g18
03:58:56  24  ,g19
03:58:56  25  ,g20
03:58:56  26  ,g21
03:58:56  27  ,g22
03:58:56  28  ,g23
03:58:56  29  ,g24
03:58:56  30  ,g25
03:58:56  31  ,g26
03:58:56  32  ,g27
03:58:56  33  ,g28
03:58:56  34  ,g29
03:58:56  35  ,g30
03:58:56  36  ,g31
03:58:56  37  ,g32
03:58:56  38  ,g33
03:58:56  39  ,g34
03:58:56  40  ,g35
03:58:56  41  ,g36
03:58:56  42  ,g37
03:58:56  43  ,g38
03:58:56  44  ,g39
03:58:56  45  ,g40
03:58:56  46  ,g41
03:58:56  47  ,sc_corr
03:58:56  48  FROM modsrc24
03:58:56  49  WHERE gattn IN('nup','up')
03:58:56  50  -- Use only rows which are older than 1 day:
03:58:56  51  AND 1+ydate < '&1'||' '||'&2'
03:58:56  52  AND pair = '&3'
03:58:56  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'18:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:58:56 SQL> 
03:58:56 SQL> -- rpt
03:58:56 SQL> 
03:58:56 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:58:56   2  
03:58:56 SQL> SELECT MAX(prdate) FROM bme
03:58:56   2  
03:58:56 SQL> -- Now build model from bme and score sme
03:58:56 SQL> @score1.sql gattn
03:58:56 SQL> --
03:58:56 SQL> -- score1.sql
03:58:56 SQL> --
03:58:56 SQL> 
03:58:56 SQL> -- I use this script to send 5 params to score.sql
03:58:56 SQL> -- which does the heavy lifting of creating an SVM model.
03:58:56 SQL> -- Then at the very end of this script I use the model
03:58:56 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:58:56 SQL> 
03:58:56 SQL> -- I call this script from 2 other scripts:
03:58:56 SQL> -- score1_5min.sql
03:58:56 SQL> -- score1_5min_gattn.sql
03:58:56 SQL> 
03:58:56 SQL> -- The 1st param is the name of the target attribute.
03:58:56 SQL> -- I like to call my target attributes either gatt or gattn.
03:58:56 SQL> 
03:58:56 SQL> -- Demo:
03:58:56 SQL> -- @score1.sql 'gatt'
03:58:56 SQL> -- @score1.sql 'gattn'
03:58:56 SQL> 
03:58:56 SQL> -- Now, I fill up svmc_apply_prep.
03:58:56 SQL> -- I use same model_name used in score.sql
03:58:56 SQL> DEFINE model_name = 'svmfx101'
03:58:56 SQL> DEFINE bldtable	= 'bme'
03:58:56 SQL> DEFINE scoretable = 'sme'
03:58:56 SQL> DEFINE case_id	= 'prdate'
03:58:56 SQL> -- Demo:
03:58:56 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:58:56 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:58:56 SQL> --
03:58:56 SQL> -- score.sql
03:58:56 SQL> --
03:58:56 SQL> 
03:58:56 SQL> -- usage: score.sql
03:58:56 SQL> 
03:58:56 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:58:56 SQL> 
03:58:56 SQL> -- DEFINE target	   = 'gatt'
03:58:56 SQL> -- DEFINE model_name = 'svmfx101'
03:58:56 SQL> -- DEFINE bldtable   = 'bme'
03:58:56 SQL> -- DEFINE scoretable = 'sme'
03:58:56 SQL> -- DEFINE case_id    = 'prdate'
03:58:56 SQL> 
03:58:56 SQL> DEFINE target	= '&1'
03:58:56 SQL> DEFINE model_name = '&2'
03:58:56 SQL> DEFINE bldtable	= '&3'
03:58:56 SQL> DEFINE scoretable = '&4'
03:58:56 SQL> DEFINE case_id	= '&5'
03:58:56 SQL> 
03:58:56 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:58:56 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:58:56 SQL> 
03:58:56 SQL> -- Builds an SVM model using pl/sql.
03:58:56 SQL> 
03:58:56 SQL> -----------------------------------------------------------------------
03:58:56 SQL> --			    BUILD THE MODEL
03:58:56 SQL> -----------------------------------------------------------------------
03:58:56 SQL> 
03:58:56 SQL> -- Cleanup old build data preparation objects for repeat runs
03:58:56 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:56 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:58:56 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:58:56 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:58:56 SQL> 
03:58:56 SQL> 
03:58:56 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:58:56 SQL> --
03:58:56 SQL> -- DROP	TABLE svmc_settings ;
03:58:56 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:58:56 SQL> -- DELETE svmc_settings;
03:58:56 SQL> 
03:58:56 SQL> -- The default classification algorithm is Naive Bayes. So override
03:58:56 SQL> -- this choice to SVM using a settings table.
03:58:56 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:58:56 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:58:56 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:58:56 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:58:56 SQL> -- models.
03:58:56 SQL> --
03:58:56 SQL> 
03:58:56 SQL> -- Do this once and then comment it out.
03:58:56 SQL> -- That makes script go faster.
03:58:56 SQL> -- BEGIN
03:58:56 SQL> -- -- Populate settings table
03:58:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:56 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:58:56 SQL> --
03:58:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:56 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:58:56 SQL> --
03:58:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:58:56 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:58:56 SQL> --   COMMIT;
03:58:56 SQL> -- END;
03:58:56 SQL> -- /
03:58:56 SQL> 
03:58:56 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:58:56 SQL> 
03:58:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:58:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:58:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:58:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:58:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:58:56 SQL> 
03:58:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:58:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:58:56 SQL> 
03:58:56 SQL> --------------------------------
03:58:56 SQL> -- PREPARE BUILD (TRAINING) DATA
03:58:56 SQL> --
03:58:56 SQL> 
03:58:56 SQL> -- 1. Missing Value treatment for all Predictors and
03:58:56 SQL> -- 2. Outlier Treatment and
03:58:56 SQL> -- 3. Normalization are performed below.
03:58:56 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:58:56 SQL> --    normalized here.
03:58:56 SQL> 
03:58:56 SQL> BEGIN
03:58:56   2  	-- Perform missing value treatment for all predictors
03:58:56   3  	-- create miss tables
03:58:56   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:58:56   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:58:56   6  
03:58:56   7  	-- populate miss tables
03:58:56   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:58:56   9  	  miss_table_name => 'svmc_miss_num',
03:58:56  10  	  data_table_name => '&bldtable',
03:58:56  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:56  12  
03:58:56  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:58:56  14  	  miss_table_name => 'svmc_miss_cat',
03:58:56  15  	  data_table_name => '&bldtable',
03:58:56  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:56  17  
03:58:56  18  	-- xform input data to replace missing values
03:58:56  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:58:56  20  	  miss_table_name => 'svmc_miss_num',
03:58:56  21  	  data_table_name => '&bldtable',
03:58:56  22  	  xform_view_name => 'xformed_build_miss_num');
03:58:56  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:58:56  24  	  miss_table_name => 'svmc_miss_cat',
03:58:56  25  	  data_table_name => '&bldtable',
03:58:56  26  	  xform_view_name => 'xformed_build_miss_cat');
03:58:56  27  
03:58:56  28  	-- Perform outlier treatment.
03:58:56  29  	-- create clip table
03:58:56  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:58:56  31  
03:58:56  32  	-- populate clip table
03:58:56  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:58:56  34  	  clip_table_name => 'svmc_clip',
03:58:56  35  	  data_table_name => '&bldtable',
03:58:56  36  	  tail_frac	  => 0.025,
03:58:56  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:56  38  
03:58:56  39  	-- xform input data to winsorized data
03:58:56  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:58:56  41  	  clip_table_name => 'svmc_clip',
03:58:56  42  	  data_table_name => '&bldtable',
03:58:56  43  	  xform_view_name => 'svmc_winsor');
03:58:56  44  
03:58:56  45  	-- create normalization table
03:58:56  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:58:56  47  
03:58:56  48  	-- populate normalization table based on winsorized data
03:58:56  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:58:56  50  	  norm_table_name => 'svmc_norm',
03:58:56  51  	  data_table_name => 'svmc_winsor',
03:58:56  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:58:56  53  
03:58:56  54  	-- normalize the original data
03:58:56  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:58:56  56  	  norm_table_name => 'svmc_norm',
03:58:56  57  	  data_table_name => '&bldtable',
03:58:56  58  	  xform_view_name => 'svmc_build_prep');
03:58:56  59  END;
03:58:56  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.69
03:58:59 SQL> 
03:58:59 SQL> ---------------------
03:58:59 SQL> -- CREATE A NEW MODEL
03:58:59 SQL> --
03:58:59 SQL> -- Cleanup old model with the same name for repeat runs
03:58:59 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:58:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:58:59   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.61
03:59:00 SQL> 
03:59:00 SQL> -- Build a new SVM Model
03:59:00 SQL> BEGIN
03:59:00   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:59:00   3  	  model_name	      => '&model_name',
03:59:00   4  	  mining_function     => dbms_data_mining.classification,
03:59:00   5  	  data_table_name     => 'svmc_build_prep',
03:59:00   6  	  case_id_column_name => '&case_id',
03:59:00   7  	  target_column_name  => '&target',
03:59:00   8  	  settings_table_name => 'svmc_settings');
03:59:00   9  END;
03:59:00  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.32
03:59:06 SQL> 
03:59:06 SQL> -----------------------------------------------------------------------
03:59:06 SQL> --			       APPLY/score THE MODEL
03:59:06 SQL> -----------------------------------------------------------------------
03:59:06 SQL> 
03:59:06 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:06 SQL> -----------------------
03:59:06 SQL> -- PREPARE SCORING DATA
03:59:06 SQL> --
03:59:06 SQL> -- If the data for model creation has been prepared, then the data
03:59:06 SQL> -- to be scored using the model must be prepared in the same manner
03:59:06 SQL> -- in order to obtain meaningful results.
03:59:06 SQL> --
03:59:06 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:06 SQL> -- 2. Normalization
03:59:06 SQL> -- No outlier treatment will be performed during test and apply. The
03:59:06 SQL> -- normalization step is sufficient, since the normalization parameters
03:59:06 SQL> -- already capture the effects of outlier treatment done with build data.
03:59:06 SQL> --
03:59:06 SQL> BEGIN
03:59:06   2  	-- Xform Test data to replace missing values
03:59:06   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:06   4  	  miss_table_name => 'svmc_miss_num',
03:59:06   5  	  data_table_name => '&scoretable',
03:59:06   6  	  xform_view_name => 'xformed_apply_miss_num');
03:59:06   7  
03:59:06   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:06   9  	  miss_table_name => 'svmc_miss_cat',
03:59:06  10  	  data_table_name => '&scoretable',
03:59:06  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:59:06  12  
03:59:06  13  	-- Normalize the data to be scored
03:59:06  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:06  15  	  norm_table_name => 'svmc_norm',
03:59:06  16  	  data_table_name => '&scoretable',
03:59:06  17  	  xform_view_name => 'svmc_apply_prep');
03:59:06  18  END;
03:59:06  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.23
03:59:06 SQL> 
03:59:06 SQL> -- Maybe I already collected a score for this prdate.
03:59:06 SQL> -- DELETE it if I did:
03:59:06 SQL> DELETE svm24scores
03:59:06   2  WHERE score > 0
03:59:06   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:59:06   4  -- I need to supply the target attribute name:
03:59:06   5  AND targ = '&1'
03:59:06   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:59:06 SQL> 
03:59:06 SQL> -- We do a drumroll here:
03:59:06 SQL> 
03:59:06 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:59:06   2  SELECT
03:59:06   3  prdate
03:59:06   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:59:06   5  ,sysdate
03:59:06   6  ,SUBSTR(prdate,1,7)pair
03:59:06   7  ,SUBSTR(prdate,-19)ydate
03:59:06   8  ,'&1'
03:59:06   9  FROM svmc_apply_prep
03:59:06  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:59:06 SQL> @score1_5min_gattn.sql	2011-01-25 16:50:00 eur_usd
03:59:06 SQL> --
03:59:06 SQL> -- score1_5min_gattn.sql
03:59:06 SQL> --
03:59:06 SQL> 
03:59:06 SQL> -- Demo:
03:59:06 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:59:06 SQL> 
03:59:06 SQL> CREATE OR REPLACE VIEW sme AS
03:59:06   2  SELECT
03:59:06   3  prdate
03:59:06   4  ,NULL gattn
03:59:06   5  ,g00
03:59:06   6  ,g01
03:59:06   7  ,g02
03:59:06   8  ,g03
03:59:06   9  ,g04
03:59:06  10  ,g05
03:59:06  11  ,g06
03:59:06  12  ,g07
03:59:06  13  ,g08
03:59:06  14  ,g09
03:59:06  15  ,g10
03:59:06  16  ,g11
03:59:06  17  ,g12
03:59:06  18  ,g13
03:59:06  19  ,g14
03:59:06  20  ,g15
03:59:06  21  ,g16
03:59:06  22  ,g17
03:59:06  23  ,g18
03:59:06  24  ,g19
03:59:06  25  ,g20
03:59:06  26  ,g21
03:59:06  27  ,g22
03:59:06  28  ,g23
03:59:06  29  ,g24
03:59:06  30  ,g25
03:59:06  31  ,g26
03:59:06  32  ,g27
03:59:06  33  ,g28
03:59:06  34  ,g29
03:59:06  35  ,g30
03:59:06  36  ,g31
03:59:06  37  ,g32
03:59:06  38  ,g33
03:59:06  39  ,g34
03:59:06  40  ,g35
03:59:06  41  ,g36
03:59:06  42  ,g37
03:59:06  43  ,g38
03:59:06  44  ,g39
03:59:06  45  ,g40
03:59:06  46  ,g41
03:59:06  47  ,s.sc_corr
03:59:06  48  FROM modsrc24
03:59:06  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:59:06  50  WHERE ydate = '&1'||' '||'&2'
03:59:06  51  AND pair = '&3'
03:59:06  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'16:50:00'AND ydate<'2011-01-25'||' '||'16:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'16:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:59:06 SQL> 
03:59:06 SQL> -- rpt
03:59:06 SQL> -- We should see just 1 row:
03:59:06 SQL> 
03:59:06 SQL> SELECT COUNT(prdate) FROM sme
03:59:06   2  
03:59:06 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:59:06   2  
03:59:06 SQL> 
03:59:06 SQL> -- Build the model:
03:59:06 SQL> CREATE OR REPLACE VIEW bme AS
03:59:06   2  SELECT
03:59:06   3  prdate
03:59:06   4  ,gattn
03:59:06   5  ,g00
03:59:06   6  ,g01
03:59:06   7  ,g02
03:59:06   8  ,g03
03:59:06   9  ,g04
03:59:06  10  ,g05
03:59:06  11  ,g06
03:59:06  12  ,g07
03:59:06  13  ,g08
03:59:06  14  ,g09
03:59:06  15  ,g10
03:59:06  16  ,g11
03:59:06  17  ,g12
03:59:06  18  ,g13
03:59:06  19  ,g14
03:59:06  20  ,g15
03:59:06  21  ,g16
03:59:06  22  ,g17
03:59:06  23  ,g18
03:59:06  24  ,g19
03:59:06  25  ,g20
03:59:06  26  ,g21
03:59:06  27  ,g22
03:59:06  28  ,g23
03:59:06  29  ,g24
03:59:06  30  ,g25
03:59:06  31  ,g26
03:59:06  32  ,g27
03:59:06  33  ,g28
03:59:06  34  ,g29
03:59:06  35  ,g30
03:59:06  36  ,g31
03:59:06  37  ,g32
03:59:06  38  ,g33
03:59:06  39  ,g34
03:59:06  40  ,g35
03:59:06  41  ,g36
03:59:06  42  ,g37
03:59:06  43  ,g38
03:59:06  44  ,g39
03:59:06  45  ,g40
03:59:06  46  ,g41
03:59:06  47  ,sc_corr
03:59:06  48  FROM modsrc24
03:59:06  49  WHERE gattn IN('nup','up')
03:59:06  50  -- Use only rows which are older than 1 day:
03:59:06  51  AND 1+ydate < '&1'||' '||'&2'
03:59:06  52  AND pair = '&3'
03:59:06  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'16:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:59:06 SQL> 
03:59:06 SQL> -- rpt
03:59:06 SQL> 
03:59:06 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:59:06   2  
03:59:06 SQL> SELECT MAX(prdate) FROM bme
03:59:06   2  
03:59:06 SQL> -- Now build model from bme and score sme
03:59:06 SQL> @score1.sql gattn
03:59:06 SQL> --
03:59:06 SQL> -- score1.sql
03:59:06 SQL> --
03:59:06 SQL> 
03:59:06 SQL> -- I use this script to send 5 params to score.sql
03:59:06 SQL> -- which does the heavy lifting of creating an SVM model.
03:59:06 SQL> -- Then at the very end of this script I use the model
03:59:06 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:59:06 SQL> 
03:59:06 SQL> -- I call this script from 2 other scripts:
03:59:06 SQL> -- score1_5min.sql
03:59:06 SQL> -- score1_5min_gattn.sql
03:59:06 SQL> 
03:59:06 SQL> -- The 1st param is the name of the target attribute.
03:59:06 SQL> -- I like to call my target attributes either gatt or gattn.
03:59:06 SQL> 
03:59:06 SQL> -- Demo:
03:59:06 SQL> -- @score1.sql 'gatt'
03:59:06 SQL> -- @score1.sql 'gattn'
03:59:06 SQL> 
03:59:06 SQL> -- Now, I fill up svmc_apply_prep.
03:59:06 SQL> -- I use same model_name used in score.sql
03:59:06 SQL> DEFINE model_name = 'svmfx101'
03:59:06 SQL> DEFINE bldtable	= 'bme'
03:59:06 SQL> DEFINE scoretable = 'sme'
03:59:06 SQL> DEFINE case_id	= 'prdate'
03:59:06 SQL> -- Demo:
03:59:06 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:59:06 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:59:06 SQL> --
03:59:06 SQL> -- score.sql
03:59:06 SQL> --
03:59:06 SQL> 
03:59:06 SQL> -- usage: score.sql
03:59:06 SQL> 
03:59:06 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:59:06 SQL> 
03:59:06 SQL> -- DEFINE target	   = 'gatt'
03:59:06 SQL> -- DEFINE model_name = 'svmfx101'
03:59:06 SQL> -- DEFINE bldtable   = 'bme'
03:59:06 SQL> -- DEFINE scoretable = 'sme'
03:59:06 SQL> -- DEFINE case_id    = 'prdate'
03:59:06 SQL> 
03:59:06 SQL> DEFINE target	= '&1'
03:59:06 SQL> DEFINE model_name = '&2'
03:59:06 SQL> DEFINE bldtable	= '&3'
03:59:06 SQL> DEFINE scoretable = '&4'
03:59:06 SQL> DEFINE case_id	= '&5'
03:59:06 SQL> 
03:59:06 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:59:06 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:59:06 SQL> 
03:59:06 SQL> -- Builds an SVM model using pl/sql.
03:59:06 SQL> 
03:59:06 SQL> -----------------------------------------------------------------------
03:59:06 SQL> --			    BUILD THE MODEL
03:59:06 SQL> -----------------------------------------------------------------------
03:59:06 SQL> 
03:59:06 SQL> -- Cleanup old build data preparation objects for repeat runs
03:59:06 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:06 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:59:06 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:59:06 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:59:06 SQL> 
03:59:06 SQL> 
03:59:06 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:59:06 SQL> --
03:59:06 SQL> -- DROP	TABLE svmc_settings ;
03:59:06 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:59:06 SQL> -- DELETE svmc_settings;
03:59:06 SQL> 
03:59:06 SQL> -- The default classification algorithm is Naive Bayes. So override
03:59:06 SQL> -- this choice to SVM using a settings table.
03:59:06 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:59:06 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:59:06 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:59:06 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:59:06 SQL> -- models.
03:59:06 SQL> --
03:59:06 SQL> 
03:59:06 SQL> -- Do this once and then comment it out.
03:59:06 SQL> -- That makes script go faster.
03:59:06 SQL> -- BEGIN
03:59:06 SQL> -- -- Populate settings table
03:59:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:06 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:59:06 SQL> --
03:59:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:06 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:59:06 SQL> --
03:59:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:06 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:59:06 SQL> --   COMMIT;
03:59:06 SQL> -- END;
03:59:06 SQL> -- /
03:59:06 SQL> 
03:59:06 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:59:06 SQL> 
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:06 SQL> 
03:59:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:59:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:06 SQL> 
03:59:06 SQL> --------------------------------
03:59:06 SQL> -- PREPARE BUILD (TRAINING) DATA
03:59:06 SQL> --
03:59:06 SQL> 
03:59:06 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:06 SQL> -- 2. Outlier Treatment and
03:59:06 SQL> -- 3. Normalization are performed below.
03:59:06 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:59:06 SQL> --    normalized here.
03:59:06 SQL> 
03:59:06 SQL> BEGIN
03:59:06   2  	-- Perform missing value treatment for all predictors
03:59:06   3  	-- create miss tables
03:59:06   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:59:06   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:59:06   6  
03:59:06   7  	-- populate miss tables
03:59:06   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:59:06   9  	  miss_table_name => 'svmc_miss_num',
03:59:06  10  	  data_table_name => '&bldtable',
03:59:06  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:06  12  
03:59:06  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:59:06  14  	  miss_table_name => 'svmc_miss_cat',
03:59:06  15  	  data_table_name => '&bldtable',
03:59:06  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:06  17  
03:59:06  18  	-- xform input data to replace missing values
03:59:06  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:06  20  	  miss_table_name => 'svmc_miss_num',
03:59:06  21  	  data_table_name => '&bldtable',
03:59:06  22  	  xform_view_name => 'xformed_build_miss_num');
03:59:06  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:06  24  	  miss_table_name => 'svmc_miss_cat',
03:59:06  25  	  data_table_name => '&bldtable',
03:59:06  26  	  xform_view_name => 'xformed_build_miss_cat');
03:59:06  27  
03:59:06  28  	-- Perform outlier treatment.
03:59:06  29  	-- create clip table
03:59:06  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:59:06  31  
03:59:06  32  	-- populate clip table
03:59:06  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:59:06  34  	  clip_table_name => 'svmc_clip',
03:59:06  35  	  data_table_name => '&bldtable',
03:59:06  36  	  tail_frac	  => 0.025,
03:59:06  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:06  38  
03:59:06  39  	-- xform input data to winsorized data
03:59:06  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:59:06  41  	  clip_table_name => 'svmc_clip',
03:59:06  42  	  data_table_name => '&bldtable',
03:59:06  43  	  xform_view_name => 'svmc_winsor');
03:59:06  44  
03:59:06  45  	-- create normalization table
03:59:06  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:59:06  47  
03:59:06  48  	-- populate normalization table based on winsorized data
03:59:06  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:59:06  50  	  norm_table_name => 'svmc_norm',
03:59:06  51  	  data_table_name => 'svmc_winsor',
03:59:06  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:06  53  
03:59:06  54  	-- normalize the original data
03:59:06  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:06  56  	  norm_table_name => 'svmc_norm',
03:59:06  57  	  data_table_name => '&bldtable',
03:59:06  58  	  xform_view_name => 'svmc_build_prep');
03:59:06  59  END;
03:59:06  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.66
03:59:09 SQL> 
03:59:09 SQL> ---------------------
03:59:09 SQL> -- CREATE A NEW MODEL
03:59:09 SQL> --
03:59:09 SQL> -- Cleanup old model with the same name for repeat runs
03:59:09 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:59:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:09   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.51
03:59:10 SQL> 
03:59:10 SQL> -- Build a new SVM Model
03:59:10 SQL> BEGIN
03:59:10   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:59:10   3  	  model_name	      => '&model_name',
03:59:10   4  	  mining_function     => dbms_data_mining.classification,
03:59:10   5  	  data_table_name     => 'svmc_build_prep',
03:59:10   6  	  case_id_column_name => '&case_id',
03:59:10   7  	  target_column_name  => '&target',
03:59:10   8  	  settings_table_name => 'svmc_settings');
03:59:10   9  END;
03:59:10  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.46
03:59:16 SQL> 
03:59:16 SQL> -----------------------------------------------------------------------
03:59:16 SQL> --			       APPLY/score THE MODEL
03:59:16 SQL> -----------------------------------------------------------------------
03:59:16 SQL> 
03:59:16 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:59:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:59:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:59:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:59:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:16 SQL> -----------------------
03:59:16 SQL> -- PREPARE SCORING DATA
03:59:16 SQL> --
03:59:16 SQL> -- If the data for model creation has been prepared, then the data
03:59:16 SQL> -- to be scored using the model must be prepared in the same manner
03:59:16 SQL> -- in order to obtain meaningful results.
03:59:16 SQL> --
03:59:16 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:16 SQL> -- 2. Normalization
03:59:16 SQL> -- No outlier treatment will be performed during test and apply. The
03:59:16 SQL> -- normalization step is sufficient, since the normalization parameters
03:59:16 SQL> -- already capture the effects of outlier treatment done with build data.
03:59:16 SQL> --
03:59:16 SQL> BEGIN
03:59:16   2  	-- Xform Test data to replace missing values
03:59:16   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:16   4  	  miss_table_name => 'svmc_miss_num',
03:59:16   5  	  data_table_name => '&scoretable',
03:59:16   6  	  xform_view_name => 'xformed_apply_miss_num');
03:59:16   7  
03:59:16   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:16   9  	  miss_table_name => 'svmc_miss_cat',
03:59:16  10  	  data_table_name => '&scoretable',
03:59:16  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:59:16  12  
03:59:16  13  	-- Normalize the data to be scored
03:59:16  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:16  15  	  norm_table_name => 'svmc_norm',
03:59:16  16  	  data_table_name => '&scoretable',
03:59:16  17  	  xform_view_name => 'svmc_apply_prep');
03:59:16  18  END;
03:59:16  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:59:16 SQL> 
03:59:16 SQL> -- Maybe I already collected a score for this prdate.
03:59:16 SQL> -- DELETE it if I did:
03:59:16 SQL> DELETE svm24scores
03:59:16   2  WHERE score > 0
03:59:16   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:59:16   4  -- I need to supply the target attribute name:
03:59:16   5  AND targ = '&1'
03:59:16   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:59:16 SQL> 
03:59:16 SQL> -- We do a drumroll here:
03:59:16 SQL> 
03:59:16 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:59:16   2  SELECT
03:59:16   3  prdate
03:59:16   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:59:16   5  ,sysdate
03:59:16   6  ,SUBSTR(prdate,1,7)pair
03:59:16   7  ,SUBSTR(prdate,-19)ydate
03:59:16   8  ,'&1'
03:59:16   9  FROM svmc_apply_prep
03:59:16  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:59:16 SQL> @score1_5min.sql	      2011-01-24 05:15:00 eur_usd
03:59:16 SQL> --
03:59:16 SQL> -- score1_5min.sql
03:59:16 SQL> --
03:59:16 SQL> 
03:59:16 SQL> -- Demo:
03:59:16 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
03:59:16 SQL> 
03:59:16 SQL> CREATE OR REPLACE VIEW sme AS
03:59:16   2  SELECT
03:59:16   3  prdate
03:59:16   4  ,NULL gatt
03:59:16   5  ,g00
03:59:16   6  ,g01
03:59:16   7  ,g02
03:59:16   8  ,g03
03:59:16   9  ,g04
03:59:16  10  ,g05
03:59:16  11  ,g06
03:59:16  12  ,g07
03:59:16  13  ,g08
03:59:16  14  ,g09
03:59:16  15  ,g10
03:59:16  16  ,g11
03:59:16  17  ,g12
03:59:16  18  ,g13
03:59:16  19  ,g14
03:59:16  20  ,g15
03:59:16  21  ,g16
03:59:16  22  ,g17
03:59:16  23  ,g18
03:59:16  24  ,g19
03:59:16  25  ,g20
03:59:16  26  ,g21
03:59:16  27  ,g22
03:59:16  28  ,g23
03:59:16  29  ,g24
03:59:16  30  ,g25
03:59:16  31  ,g26
03:59:16  32  ,g27
03:59:16  33  ,g28
03:59:16  34  ,g29
03:59:16  35  ,g30
03:59:16  36  ,g31
03:59:16  37  ,g32
03:59:16  38  ,g33
03:59:16  39  ,g34
03:59:16  40  ,g35
03:59:16  41  ,g36
03:59:16  42  ,g37
03:59:16  43  ,g38
03:59:16  44  ,g39
03:59:16  45  ,g40
03:59:16  46  ,g41
03:59:16  47  ,s.sc_corr
03:59:16  48  FROM modsrc24
03:59:16  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:59:16  50  WHERE ydate = '&1'||' '||'&2'
03:59:16  51  AND pair = '&3'
03:59:16  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-24'||' '||'05:15:00'AND ydate<'2011-01-24'||' '||'05:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-24'||' '||'05:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:59:16 SQL> 
03:59:16 SQL> -- rpt
03:59:16 SQL> -- We should see just 1 row:
03:59:16 SQL> 
03:59:16 SQL> SELECT COUNT(prdate) FROM sme
03:59:16   2  
03:59:16 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:59:16   2  
03:59:16 SQL> 
03:59:16 SQL> -- Build the model:
03:59:16 SQL> CREATE OR REPLACE VIEW bme AS
03:59:16   2  SELECT
03:59:16   3  prdate
03:59:16   4  ,gatt
03:59:16   5  ,g00
03:59:16   6  ,g01
03:59:16   7  ,g02
03:59:16   8  ,g03
03:59:16   9  ,g04
03:59:16  10  ,g05
03:59:16  11  ,g06
03:59:16  12  ,g07
03:59:16  13  ,g08
03:59:16  14  ,g09
03:59:16  15  ,g10
03:59:16  16  ,g11
03:59:16  17  ,g12
03:59:16  18  ,g13
03:59:16  19  ,g14
03:59:16  20  ,g15
03:59:16  21  ,g16
03:59:16  22  ,g17
03:59:16  23  ,g18
03:59:16  24  ,g19
03:59:16  25  ,g20
03:59:16  26  ,g21
03:59:16  27  ,g22
03:59:16  28  ,g23
03:59:16  29  ,g24
03:59:16  30  ,g25
03:59:16  31  ,g26
03:59:16  32  ,g27
03:59:16  33  ,g28
03:59:16  34  ,g29
03:59:16  35  ,g30
03:59:16  36  ,g31
03:59:16  37  ,g32
03:59:16  38  ,g33
03:59:16  39  ,g34
03:59:16  40  ,g35
03:59:16  41  ,g36
03:59:16  42  ,g37
03:59:16  43  ,g38
03:59:16  44  ,g39
03:59:16  45  ,g40
03:59:16  46  ,g41
03:59:16  47  ,sc_corr
03:59:16  48  FROM modsrc24
03:59:16  49  WHERE gatt IN('nup','up')
03:59:16  50  -- Use only rows which are older than 1 day:
03:59:16  51  AND 1+ydate < '&1'||' '||'&2'
03:59:16  52  AND pair = '&3'
03:59:16  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-24'||' '||'05:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:59:16 SQL> 
03:59:16 SQL> -- rpt
03:59:16 SQL> 
03:59:16 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
03:59:16   2  
03:59:16 SQL> SELECT MAX(prdate) FROM bme
03:59:16   2  
03:59:16 SQL> -- Now build model from bme and score sme
03:59:16 SQL> @score1.sql gatt
03:59:16 SQL> --
03:59:16 SQL> -- score1.sql
03:59:16 SQL> --
03:59:16 SQL> 
03:59:16 SQL> -- I use this script to send 5 params to score.sql
03:59:16 SQL> -- which does the heavy lifting of creating an SVM model.
03:59:16 SQL> -- Then at the very end of this script I use the model
03:59:16 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:59:16 SQL> 
03:59:16 SQL> -- I call this script from 2 other scripts:
03:59:16 SQL> -- score1_5min.sql
03:59:16 SQL> -- score1_5min_gattn.sql
03:59:16 SQL> 
03:59:16 SQL> -- The 1st param is the name of the target attribute.
03:59:16 SQL> -- I like to call my target attributes either gatt or gattn.
03:59:16 SQL> 
03:59:16 SQL> -- Demo:
03:59:16 SQL> -- @score1.sql 'gatt'
03:59:16 SQL> -- @score1.sql 'gattn'
03:59:16 SQL> 
03:59:16 SQL> -- Now, I fill up svmc_apply_prep.
03:59:16 SQL> -- I use same model_name used in score.sql
03:59:16 SQL> DEFINE model_name = 'svmfx101'
03:59:16 SQL> DEFINE bldtable	= 'bme'
03:59:16 SQL> DEFINE scoretable = 'sme'
03:59:16 SQL> DEFINE case_id	= 'prdate'
03:59:16 SQL> -- Demo:
03:59:16 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:59:16 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:59:16 SQL> --
03:59:16 SQL> -- score.sql
03:59:16 SQL> --
03:59:16 SQL> 
03:59:16 SQL> -- usage: score.sql
03:59:16 SQL> 
03:59:16 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:59:16 SQL> 
03:59:16 SQL> -- DEFINE target	   = 'gatt'
03:59:16 SQL> -- DEFINE model_name = 'svmfx101'
03:59:16 SQL> -- DEFINE bldtable   = 'bme'
03:59:16 SQL> -- DEFINE scoretable = 'sme'
03:59:16 SQL> -- DEFINE case_id    = 'prdate'
03:59:16 SQL> 
03:59:16 SQL> DEFINE target	= '&1'
03:59:16 SQL> DEFINE model_name = '&2'
03:59:16 SQL> DEFINE bldtable	= '&3'
03:59:16 SQL> DEFINE scoretable = '&4'
03:59:16 SQL> DEFINE case_id	= '&5'
03:59:16 SQL> 
03:59:16 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:59:16 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:59:16 SQL> 
03:59:16 SQL> -- Builds an SVM model using pl/sql.
03:59:16 SQL> 
03:59:16 SQL> -----------------------------------------------------------------------
03:59:16 SQL> --			    BUILD THE MODEL
03:59:16 SQL> -----------------------------------------------------------------------
03:59:16 SQL> 
03:59:16 SQL> -- Cleanup old build data preparation objects for repeat runs
03:59:16 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:59:16 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:59:16 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:16 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:59:16 SQL> 
03:59:16 SQL> 
03:59:16 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:59:16 SQL> --
03:59:16 SQL> -- DROP	TABLE svmc_settings ;
03:59:16 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:59:16 SQL> -- DELETE svmc_settings;
03:59:16 SQL> 
03:59:16 SQL> -- The default classification algorithm is Naive Bayes. So override
03:59:16 SQL> -- this choice to SVM using a settings table.
03:59:16 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:59:16 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:59:16 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:59:16 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:59:16 SQL> -- models.
03:59:16 SQL> --
03:59:16 SQL> 
03:59:16 SQL> -- Do this once and then comment it out.
03:59:16 SQL> -- That makes script go faster.
03:59:16 SQL> -- BEGIN
03:59:16 SQL> -- -- Populate settings table
03:59:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:16 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:59:16 SQL> --
03:59:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:16 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:59:16 SQL> --
03:59:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:16 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:59:16 SQL> --   COMMIT;
03:59:16 SQL> -- END;
03:59:16 SQL> -- /
03:59:16 SQL> 
03:59:16 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:59:16 SQL> 
03:59:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:59:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:59:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:59:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:59:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:17 SQL> 
03:59:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:59:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:17 SQL> 
03:59:17 SQL> --------------------------------
03:59:17 SQL> -- PREPARE BUILD (TRAINING) DATA
03:59:17 SQL> --
03:59:17 SQL> 
03:59:17 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:17 SQL> -- 2. Outlier Treatment and
03:59:17 SQL> -- 3. Normalization are performed below.
03:59:17 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:59:17 SQL> --    normalized here.
03:59:17 SQL> 
03:59:17 SQL> BEGIN
03:59:17   2  	-- Perform missing value treatment for all predictors
03:59:17   3  	-- create miss tables
03:59:17   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:59:17   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:59:17   6  
03:59:17   7  	-- populate miss tables
03:59:17   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:59:17   9  	  miss_table_name => 'svmc_miss_num',
03:59:17  10  	  data_table_name => '&bldtable',
03:59:17  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:17  12  
03:59:17  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:59:17  14  	  miss_table_name => 'svmc_miss_cat',
03:59:17  15  	  data_table_name => '&bldtable',
03:59:17  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:17  17  
03:59:17  18  	-- xform input data to replace missing values
03:59:17  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:17  20  	  miss_table_name => 'svmc_miss_num',
03:59:17  21  	  data_table_name => '&bldtable',
03:59:17  22  	  xform_view_name => 'xformed_build_miss_num');
03:59:17  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:17  24  	  miss_table_name => 'svmc_miss_cat',
03:59:17  25  	  data_table_name => '&bldtable',
03:59:17  26  	  xform_view_name => 'xformed_build_miss_cat');
03:59:17  27  
03:59:17  28  	-- Perform outlier treatment.
03:59:17  29  	-- create clip table
03:59:17  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:59:17  31  
03:59:17  32  	-- populate clip table
03:59:17  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:59:17  34  	  clip_table_name => 'svmc_clip',
03:59:17  35  	  data_table_name => '&bldtable',
03:59:17  36  	  tail_frac	  => 0.025,
03:59:17  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:17  38  
03:59:17  39  	-- xform input data to winsorized data
03:59:17  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:59:17  41  	  clip_table_name => 'svmc_clip',
03:59:17  42  	  data_table_name => '&bldtable',
03:59:17  43  	  xform_view_name => 'svmc_winsor');
03:59:17  44  
03:59:17  45  	-- create normalization table
03:59:17  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:59:17  47  
03:59:17  48  	-- populate normalization table based on winsorized data
03:59:17  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:59:17  50  	  norm_table_name => 'svmc_norm',
03:59:17  51  	  data_table_name => 'svmc_winsor',
03:59:17  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:17  53  
03:59:17  54  	-- normalize the original data
03:59:17  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:17  56  	  norm_table_name => 'svmc_norm',
03:59:17  57  	  data_table_name => '&bldtable',
03:59:17  58  	  xform_view_name => 'svmc_build_prep');
03:59:17  59  END;
03:59:17  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.64
03:59:20 SQL> 
03:59:20 SQL> ---------------------
03:59:20 SQL> -- CREATE A NEW MODEL
03:59:20 SQL> --
03:59:20 SQL> -- Cleanup old model with the same name for repeat runs
03:59:20 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:59:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:20   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.27
03:59:21 SQL> 
03:59:21 SQL> -- Build a new SVM Model
03:59:21 SQL> BEGIN
03:59:21   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:59:21   3  	  model_name	      => '&model_name',
03:59:21   4  	  mining_function     => dbms_data_mining.classification,
03:59:21   5  	  data_table_name     => 'svmc_build_prep',
03:59:21   6  	  case_id_column_name => '&case_id',
03:59:21   7  	  target_column_name  => '&target',
03:59:21   8  	  settings_table_name => 'svmc_settings');
03:59:21   9  END;
03:59:21  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.04
03:59:27 SQL> 
03:59:27 SQL> -----------------------------------------------------------------------
03:59:27 SQL> --			       APPLY/score THE MODEL
03:59:27 SQL> -----------------------------------------------------------------------
03:59:27 SQL> 
03:59:27 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:27 SQL> -----------------------
03:59:27 SQL> -- PREPARE SCORING DATA
03:59:27 SQL> --
03:59:27 SQL> -- If the data for model creation has been prepared, then the data
03:59:27 SQL> -- to be scored using the model must be prepared in the same manner
03:59:27 SQL> -- in order to obtain meaningful results.
03:59:27 SQL> --
03:59:27 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:27 SQL> -- 2. Normalization
03:59:27 SQL> -- No outlier treatment will be performed during test and apply. The
03:59:27 SQL> -- normalization step is sufficient, since the normalization parameters
03:59:27 SQL> -- already capture the effects of outlier treatment done with build data.
03:59:27 SQL> --
03:59:27 SQL> BEGIN
03:59:27   2  	-- Xform Test data to replace missing values
03:59:27   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:27   4  	  miss_table_name => 'svmc_miss_num',
03:59:27   5  	  data_table_name => '&scoretable',
03:59:27   6  	  xform_view_name => 'xformed_apply_miss_num');
03:59:27   7  
03:59:27   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:27   9  	  miss_table_name => 'svmc_miss_cat',
03:59:27  10  	  data_table_name => '&scoretable',
03:59:27  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:59:27  12  
03:59:27  13  	-- Normalize the data to be scored
03:59:27  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:27  15  	  norm_table_name => 'svmc_norm',
03:59:27  16  	  data_table_name => '&scoretable',
03:59:27  17  	  xform_view_name => 'svmc_apply_prep');
03:59:27  18  END;
03:59:27  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:59:27 SQL> 
03:59:27 SQL> -- Maybe I already collected a score for this prdate.
03:59:27 SQL> -- DELETE it if I did:
03:59:27 SQL> DELETE svm24scores
03:59:27   2  WHERE score > 0
03:59:27   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:59:27   4  -- I need to supply the target attribute name:
03:59:27   5  AND targ = '&1'
03:59:27   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
03:59:27 SQL> 
03:59:27 SQL> -- We do a drumroll here:
03:59:27 SQL> 
03:59:27 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:59:27   2  SELECT
03:59:27   3  prdate
03:59:27   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:59:27   5  ,sysdate
03:59:27   6  ,SUBSTR(prdate,1,7)pair
03:59:27   7  ,SUBSTR(prdate,-19)ydate
03:59:27   8  ,'&1'
03:59:27   9  FROM svmc_apply_prep
03:59:27  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
03:59:27 SQL> @score1_5min_gattn.sql	2011-01-20 02:50:00 eur_usd
03:59:27 SQL> --
03:59:27 SQL> -- score1_5min_gattn.sql
03:59:27 SQL> --
03:59:27 SQL> 
03:59:27 SQL> -- Demo:
03:59:27 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:59:27 SQL> 
03:59:27 SQL> CREATE OR REPLACE VIEW sme AS
03:59:27   2  SELECT
03:59:27   3  prdate
03:59:27   4  ,NULL gattn
03:59:27   5  ,g00
03:59:27   6  ,g01
03:59:27   7  ,g02
03:59:27   8  ,g03
03:59:27   9  ,g04
03:59:27  10  ,g05
03:59:27  11  ,g06
03:59:27  12  ,g07
03:59:27  13  ,g08
03:59:27  14  ,g09
03:59:27  15  ,g10
03:59:27  16  ,g11
03:59:27  17  ,g12
03:59:27  18  ,g13
03:59:27  19  ,g14
03:59:27  20  ,g15
03:59:27  21  ,g16
03:59:27  22  ,g17
03:59:27  23  ,g18
03:59:27  24  ,g19
03:59:27  25  ,g20
03:59:27  26  ,g21
03:59:27  27  ,g22
03:59:27  28  ,g23
03:59:27  29  ,g24
03:59:27  30  ,g25
03:59:27  31  ,g26
03:59:27  32  ,g27
03:59:27  33  ,g28
03:59:27  34  ,g29
03:59:27  35  ,g30
03:59:27  36  ,g31
03:59:27  37  ,g32
03:59:27  38  ,g33
03:59:27  39  ,g34
03:59:27  40  ,g35
03:59:27  41  ,g36
03:59:27  42  ,g37
03:59:27  43  ,g38
03:59:27  44  ,g39
03:59:27  45  ,g40
03:59:27  46  ,g41
03:59:27  47  ,s.sc_corr
03:59:27  48  FROM modsrc24
03:59:27  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:59:27  50  WHERE ydate = '&1'||' '||'&2'
03:59:27  51  AND pair = '&3'
03:59:27  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'02:50:00'AND ydate<'2011-01-20'||' '||'02:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'02:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:59:27 SQL> 
03:59:27 SQL> -- rpt
03:59:27 SQL> -- We should see just 1 row:
03:59:27 SQL> 
03:59:27 SQL> SELECT COUNT(prdate) FROM sme
03:59:27   2  
03:59:27 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:59:27   2  
03:59:27 SQL> 
03:59:27 SQL> -- Build the model:
03:59:27 SQL> CREATE OR REPLACE VIEW bme AS
03:59:27   2  SELECT
03:59:27   3  prdate
03:59:27   4  ,gattn
03:59:27   5  ,g00
03:59:27   6  ,g01
03:59:27   7  ,g02
03:59:27   8  ,g03
03:59:27   9  ,g04
03:59:27  10  ,g05
03:59:27  11  ,g06
03:59:27  12  ,g07
03:59:27  13  ,g08
03:59:27  14  ,g09
03:59:27  15  ,g10
03:59:27  16  ,g11
03:59:27  17  ,g12
03:59:27  18  ,g13
03:59:27  19  ,g14
03:59:27  20  ,g15
03:59:27  21  ,g16
03:59:27  22  ,g17
03:59:27  23  ,g18
03:59:27  24  ,g19
03:59:27  25  ,g20
03:59:27  26  ,g21
03:59:27  27  ,g22
03:59:27  28  ,g23
03:59:27  29  ,g24
03:59:27  30  ,g25
03:59:27  31  ,g26
03:59:27  32  ,g27
03:59:27  33  ,g28
03:59:27  34  ,g29
03:59:27  35  ,g30
03:59:27  36  ,g31
03:59:27  37  ,g32
03:59:27  38  ,g33
03:59:27  39  ,g34
03:59:27  40  ,g35
03:59:27  41  ,g36
03:59:27  42  ,g37
03:59:27  43  ,g38
03:59:27  44  ,g39
03:59:27  45  ,g40
03:59:27  46  ,g41
03:59:27  47  ,sc_corr
03:59:27  48  FROM modsrc24
03:59:27  49  WHERE gattn IN('nup','up')
03:59:27  50  -- Use only rows which are older than 1 day:
03:59:27  51  AND 1+ydate < '&1'||' '||'&2'
03:59:27  52  AND pair = '&3'
03:59:27  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'02:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.13
03:59:27 SQL> 
03:59:27 SQL> -- rpt
03:59:27 SQL> 
03:59:27 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:59:27   2  
03:59:27 SQL> SELECT MAX(prdate) FROM bme
03:59:27   2  
03:59:27 SQL> -- Now build model from bme and score sme
03:59:27 SQL> @score1.sql gattn
03:59:27 SQL> --
03:59:27 SQL> -- score1.sql
03:59:27 SQL> --
03:59:27 SQL> 
03:59:27 SQL> -- I use this script to send 5 params to score.sql
03:59:27 SQL> -- which does the heavy lifting of creating an SVM model.
03:59:27 SQL> -- Then at the very end of this script I use the model
03:59:27 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:59:27 SQL> 
03:59:27 SQL> -- I call this script from 2 other scripts:
03:59:27 SQL> -- score1_5min.sql
03:59:27 SQL> -- score1_5min_gattn.sql
03:59:27 SQL> 
03:59:27 SQL> -- The 1st param is the name of the target attribute.
03:59:27 SQL> -- I like to call my target attributes either gatt or gattn.
03:59:27 SQL> 
03:59:27 SQL> -- Demo:
03:59:27 SQL> -- @score1.sql 'gatt'
03:59:27 SQL> -- @score1.sql 'gattn'
03:59:27 SQL> 
03:59:27 SQL> -- Now, I fill up svmc_apply_prep.
03:59:27 SQL> -- I use same model_name used in score.sql
03:59:27 SQL> DEFINE model_name = 'svmfx101'
03:59:27 SQL> DEFINE bldtable	= 'bme'
03:59:27 SQL> DEFINE scoretable = 'sme'
03:59:27 SQL> DEFINE case_id	= 'prdate'
03:59:27 SQL> -- Demo:
03:59:27 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:59:27 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:59:27 SQL> --
03:59:27 SQL> -- score.sql
03:59:27 SQL> --
03:59:27 SQL> 
03:59:27 SQL> -- usage: score.sql
03:59:27 SQL> 
03:59:27 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:59:27 SQL> 
03:59:27 SQL> -- DEFINE target	   = 'gatt'
03:59:27 SQL> -- DEFINE model_name = 'svmfx101'
03:59:27 SQL> -- DEFINE bldtable   = 'bme'
03:59:27 SQL> -- DEFINE scoretable = 'sme'
03:59:27 SQL> -- DEFINE case_id    = 'prdate'
03:59:27 SQL> 
03:59:27 SQL> DEFINE target	= '&1'
03:59:27 SQL> DEFINE model_name = '&2'
03:59:27 SQL> DEFINE bldtable	= '&3'
03:59:27 SQL> DEFINE scoretable = '&4'
03:59:27 SQL> DEFINE case_id	= '&5'
03:59:27 SQL> 
03:59:27 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:59:27 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:59:27 SQL> 
03:59:27 SQL> -- Builds an SVM model using pl/sql.
03:59:27 SQL> 
03:59:27 SQL> -----------------------------------------------------------------------
03:59:27 SQL> --			    BUILD THE MODEL
03:59:27 SQL> -----------------------------------------------------------------------
03:59:27 SQL> 
03:59:27 SQL> -- Cleanup old build data preparation objects for repeat runs
03:59:27 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:27 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:59:27 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:27 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:59:27 SQL> 
03:59:27 SQL> 
03:59:27 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:59:27 SQL> --
03:59:27 SQL> -- DROP	TABLE svmc_settings ;
03:59:27 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:59:27 SQL> -- DELETE svmc_settings;
03:59:27 SQL> 
03:59:27 SQL> -- The default classification algorithm is Naive Bayes. So override
03:59:27 SQL> -- this choice to SVM using a settings table.
03:59:27 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:59:27 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:59:27 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:59:27 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:59:27 SQL> -- models.
03:59:27 SQL> --
03:59:27 SQL> 
03:59:27 SQL> -- Do this once and then comment it out.
03:59:27 SQL> -- That makes script go faster.
03:59:27 SQL> -- BEGIN
03:59:27 SQL> -- -- Populate settings table
03:59:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:27 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:59:27 SQL> --
03:59:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:27 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:59:27 SQL> --
03:59:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:27 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:59:27 SQL> --   COMMIT;
03:59:27 SQL> -- END;
03:59:27 SQL> -- /
03:59:27 SQL> 
03:59:27 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
03:59:27 SQL> 
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:27 SQL> 
03:59:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:59:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:27 SQL> 
03:59:27 SQL> --------------------------------
03:59:27 SQL> -- PREPARE BUILD (TRAINING) DATA
03:59:27 SQL> --
03:59:27 SQL> 
03:59:27 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:27 SQL> -- 2. Outlier Treatment and
03:59:27 SQL> -- 3. Normalization are performed below.
03:59:27 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:59:27 SQL> --    normalized here.
03:59:27 SQL> 
03:59:27 SQL> BEGIN
03:59:27   2  	-- Perform missing value treatment for all predictors
03:59:27   3  	-- create miss tables
03:59:27   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:59:27   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:59:27   6  
03:59:27   7  	-- populate miss tables
03:59:27   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:59:27   9  	  miss_table_name => 'svmc_miss_num',
03:59:27  10  	  data_table_name => '&bldtable',
03:59:27  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:27  12  
03:59:27  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:59:27  14  	  miss_table_name => 'svmc_miss_cat',
03:59:27  15  	  data_table_name => '&bldtable',
03:59:27  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:27  17  
03:59:27  18  	-- xform input data to replace missing values
03:59:27  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:27  20  	  miss_table_name => 'svmc_miss_num',
03:59:27  21  	  data_table_name => '&bldtable',
03:59:27  22  	  xform_view_name => 'xformed_build_miss_num');
03:59:27  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:27  24  	  miss_table_name => 'svmc_miss_cat',
03:59:27  25  	  data_table_name => '&bldtable',
03:59:27  26  	  xform_view_name => 'xformed_build_miss_cat');
03:59:27  27  
03:59:27  28  	-- Perform outlier treatment.
03:59:27  29  	-- create clip table
03:59:27  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:59:27  31  
03:59:27  32  	-- populate clip table
03:59:27  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:59:27  34  	  clip_table_name => 'svmc_clip',
03:59:27  35  	  data_table_name => '&bldtable',
03:59:27  36  	  tail_frac	  => 0.025,
03:59:27  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:27  38  
03:59:27  39  	-- xform input data to winsorized data
03:59:27  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:59:27  41  	  clip_table_name => 'svmc_clip',
03:59:27  42  	  data_table_name => '&bldtable',
03:59:27  43  	  xform_view_name => 'svmc_winsor');
03:59:27  44  
03:59:27  45  	-- create normalization table
03:59:27  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:59:27  47  
03:59:27  48  	-- populate normalization table based on winsorized data
03:59:27  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:59:27  50  	  norm_table_name => 'svmc_norm',
03:59:27  51  	  data_table_name => 'svmc_winsor',
03:59:27  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:27  53  
03:59:27  54  	-- normalize the original data
03:59:27  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:27  56  	  norm_table_name => 'svmc_norm',
03:59:27  57  	  data_table_name => '&bldtable',
03:59:27  58  	  xform_view_name => 'svmc_build_prep');
03:59:27  59  END;
03:59:27  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
03:59:30 SQL> 
03:59:30 SQL> ---------------------
03:59:30 SQL> -- CREATE A NEW MODEL
03:59:30 SQL> --
03:59:30 SQL> -- Cleanup old model with the same name for repeat runs
03:59:30 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:59:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:30   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.45
03:59:31 SQL> 
03:59:31 SQL> -- Build a new SVM Model
03:59:31 SQL> BEGIN
03:59:31   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:59:31   3  	  model_name	      => '&model_name',
03:59:31   4  	  mining_function     => dbms_data_mining.classification,
03:59:31   5  	  data_table_name     => 'svmc_build_prep',
03:59:31   6  	  case_id_column_name => '&case_id',
03:59:31   7  	  target_column_name  => '&target',
03:59:31   8  	  settings_table_name => 'svmc_settings');
03:59:31   9  END;
03:59:31  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.19
03:59:35 SQL> 
03:59:35 SQL> -----------------------------------------------------------------------
03:59:35 SQL> --			       APPLY/score THE MODEL
03:59:35 SQL> -----------------------------------------------------------------------
03:59:35 SQL> 
03:59:35 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:59:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:59:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:59:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:59:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:36 SQL> -----------------------
03:59:36 SQL> -- PREPARE SCORING DATA
03:59:36 SQL> --
03:59:36 SQL> -- If the data for model creation has been prepared, then the data
03:59:36 SQL> -- to be scored using the model must be prepared in the same manner
03:59:36 SQL> -- in order to obtain meaningful results.
03:59:36 SQL> --
03:59:36 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:36 SQL> -- 2. Normalization
03:59:36 SQL> -- No outlier treatment will be performed during test and apply. The
03:59:36 SQL> -- normalization step is sufficient, since the normalization parameters
03:59:36 SQL> -- already capture the effects of outlier treatment done with build data.
03:59:36 SQL> --
03:59:36 SQL> BEGIN
03:59:36   2  	-- Xform Test data to replace missing values
03:59:36   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:36   4  	  miss_table_name => 'svmc_miss_num',
03:59:36   5  	  data_table_name => '&scoretable',
03:59:36   6  	  xform_view_name => 'xformed_apply_miss_num');
03:59:36   7  
03:59:36   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:36   9  	  miss_table_name => 'svmc_miss_cat',
03:59:36  10  	  data_table_name => '&scoretable',
03:59:36  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:59:36  12  
03:59:36  13  	-- Normalize the data to be scored
03:59:36  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:36  15  	  norm_table_name => 'svmc_norm',
03:59:36  16  	  data_table_name => '&scoretable',
03:59:36  17  	  xform_view_name => 'svmc_apply_prep');
03:59:36  18  END;
03:59:36  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:59:36 SQL> 
03:59:36 SQL> -- Maybe I already collected a score for this prdate.
03:59:36 SQL> -- DELETE it if I did:
03:59:36 SQL> DELETE svm24scores
03:59:36   2  WHERE score > 0
03:59:36   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:59:36   4  -- I need to supply the target attribute name:
03:59:36   5  AND targ = '&1'
03:59:36   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:59:36 SQL> 
03:59:36 SQL> -- We do a drumroll here:
03:59:36 SQL> 
03:59:36 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:59:36   2  SELECT
03:59:36   3  prdate
03:59:36   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:59:36   5  ,sysdate
03:59:36   6  ,SUBSTR(prdate,1,7)pair
03:59:36   7  ,SUBSTR(prdate,-19)ydate
03:59:36   8  ,'&1'
03:59:36   9  FROM svmc_apply_prep
03:59:36  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:59:36 SQL> @score1_5min_gattn.sql	2011-01-24 22:45:00 eur_usd
03:59:36 SQL> --
03:59:36 SQL> -- score1_5min_gattn.sql
03:59:36 SQL> --
03:59:36 SQL> 
03:59:36 SQL> -- Demo:
03:59:36 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:59:36 SQL> 
03:59:36 SQL> CREATE OR REPLACE VIEW sme AS
03:59:36   2  SELECT
03:59:36   3  prdate
03:59:36   4  ,NULL gattn
03:59:36   5  ,g00
03:59:36   6  ,g01
03:59:36   7  ,g02
03:59:36   8  ,g03
03:59:36   9  ,g04
03:59:36  10  ,g05
03:59:36  11  ,g06
03:59:36  12  ,g07
03:59:36  13  ,g08
03:59:36  14  ,g09
03:59:36  15  ,g10
03:59:36  16  ,g11
03:59:36  17  ,g12
03:59:36  18  ,g13
03:59:36  19  ,g14
03:59:36  20  ,g15
03:59:36  21  ,g16
03:59:36  22  ,g17
03:59:36  23  ,g18
03:59:36  24  ,g19
03:59:36  25  ,g20
03:59:36  26  ,g21
03:59:36  27  ,g22
03:59:36  28  ,g23
03:59:36  29  ,g24
03:59:36  30  ,g25
03:59:36  31  ,g26
03:59:36  32  ,g27
03:59:36  33  ,g28
03:59:36  34  ,g29
03:59:36  35  ,g30
03:59:36  36  ,g31
03:59:36  37  ,g32
03:59:36  38  ,g33
03:59:36  39  ,g34
03:59:36  40  ,g35
03:59:36  41  ,g36
03:59:36  42  ,g37
03:59:36  43  ,g38
03:59:36  44  ,g39
03:59:36  45  ,g40
03:59:36  46  ,g41
03:59:36  47  ,s.sc_corr
03:59:36  48  FROM modsrc24
03:59:36  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:59:36  50  WHERE ydate = '&1'||' '||'&2'
03:59:36  51  AND pair = '&3'
03:59:36  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-24'||' '||'22:45:00'AND ydate<'2011-01-24'||' '||'22:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-24'||' '||'22:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:59:36 SQL> 
03:59:36 SQL> -- rpt
03:59:36 SQL> -- We should see just 1 row:
03:59:36 SQL> 
03:59:36 SQL> SELECT COUNT(prdate) FROM sme
03:59:36   2  
03:59:36 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:59:36   2  
03:59:36 SQL> 
03:59:36 SQL> -- Build the model:
03:59:36 SQL> CREATE OR REPLACE VIEW bme AS
03:59:36   2  SELECT
03:59:36   3  prdate
03:59:36   4  ,gattn
03:59:36   5  ,g00
03:59:36   6  ,g01
03:59:36   7  ,g02
03:59:36   8  ,g03
03:59:36   9  ,g04
03:59:36  10  ,g05
03:59:36  11  ,g06
03:59:36  12  ,g07
03:59:36  13  ,g08
03:59:36  14  ,g09
03:59:36  15  ,g10
03:59:36  16  ,g11
03:59:36  17  ,g12
03:59:36  18  ,g13
03:59:36  19  ,g14
03:59:36  20  ,g15
03:59:36  21  ,g16
03:59:36  22  ,g17
03:59:36  23  ,g18
03:59:36  24  ,g19
03:59:36  25  ,g20
03:59:36  26  ,g21
03:59:36  27  ,g22
03:59:36  28  ,g23
03:59:36  29  ,g24
03:59:36  30  ,g25
03:59:36  31  ,g26
03:59:36  32  ,g27
03:59:36  33  ,g28
03:59:36  34  ,g29
03:59:36  35  ,g30
03:59:36  36  ,g31
03:59:36  37  ,g32
03:59:36  38  ,g33
03:59:36  39  ,g34
03:59:36  40  ,g35
03:59:36  41  ,g36
03:59:36  42  ,g37
03:59:36  43  ,g38
03:59:36  44  ,g39
03:59:36  45  ,g40
03:59:36  46  ,g41
03:59:36  47  ,sc_corr
03:59:36  48  FROM modsrc24
03:59:36  49  WHERE gattn IN('nup','up')
03:59:36  50  -- Use only rows which are older than 1 day:
03:59:36  51  AND 1+ydate < '&1'||' '||'&2'
03:59:36  52  AND pair = '&3'
03:59:36  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-24'||' '||'22:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:59:36 SQL> 
03:59:36 SQL> -- rpt
03:59:36 SQL> 
03:59:36 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:59:36   2  
03:59:36 SQL> SELECT MAX(prdate) FROM bme
03:59:36   2  
03:59:36 SQL> -- Now build model from bme and score sme
03:59:36 SQL> @score1.sql gattn
03:59:36 SQL> --
03:59:36 SQL> -- score1.sql
03:59:36 SQL> --
03:59:36 SQL> 
03:59:36 SQL> -- I use this script to send 5 params to score.sql
03:59:36 SQL> -- which does the heavy lifting of creating an SVM model.
03:59:36 SQL> -- Then at the very end of this script I use the model
03:59:36 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:59:36 SQL> 
03:59:36 SQL> -- I call this script from 2 other scripts:
03:59:36 SQL> -- score1_5min.sql
03:59:36 SQL> -- score1_5min_gattn.sql
03:59:36 SQL> 
03:59:36 SQL> -- The 1st param is the name of the target attribute.
03:59:36 SQL> -- I like to call my target attributes either gatt or gattn.
03:59:36 SQL> 
03:59:36 SQL> -- Demo:
03:59:36 SQL> -- @score1.sql 'gatt'
03:59:36 SQL> -- @score1.sql 'gattn'
03:59:36 SQL> 
03:59:36 SQL> -- Now, I fill up svmc_apply_prep.
03:59:36 SQL> -- I use same model_name used in score.sql
03:59:36 SQL> DEFINE model_name = 'svmfx101'
03:59:36 SQL> DEFINE bldtable	= 'bme'
03:59:36 SQL> DEFINE scoretable = 'sme'
03:59:36 SQL> DEFINE case_id	= 'prdate'
03:59:36 SQL> -- Demo:
03:59:36 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:59:36 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:59:36 SQL> --
03:59:36 SQL> -- score.sql
03:59:36 SQL> --
03:59:36 SQL> 
03:59:36 SQL> -- usage: score.sql
03:59:36 SQL> 
03:59:36 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:59:36 SQL> 
03:59:36 SQL> -- DEFINE target	   = 'gatt'
03:59:36 SQL> -- DEFINE model_name = 'svmfx101'
03:59:36 SQL> -- DEFINE bldtable   = 'bme'
03:59:36 SQL> -- DEFINE scoretable = 'sme'
03:59:36 SQL> -- DEFINE case_id    = 'prdate'
03:59:36 SQL> 
03:59:36 SQL> DEFINE target	= '&1'
03:59:36 SQL> DEFINE model_name = '&2'
03:59:36 SQL> DEFINE bldtable	= '&3'
03:59:36 SQL> DEFINE scoretable = '&4'
03:59:36 SQL> DEFINE case_id	= '&5'
03:59:36 SQL> 
03:59:36 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:59:36 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:59:36 SQL> 
03:59:36 SQL> -- Builds an SVM model using pl/sql.
03:59:36 SQL> 
03:59:36 SQL> -----------------------------------------------------------------------
03:59:36 SQL> --			    BUILD THE MODEL
03:59:36 SQL> -----------------------------------------------------------------------
03:59:36 SQL> 
03:59:36 SQL> -- Cleanup old build data preparation objects for repeat runs
03:59:36 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:36 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:59:36 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:36 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:59:36 SQL> 
03:59:36 SQL> 
03:59:36 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:59:36 SQL> --
03:59:36 SQL> -- DROP	TABLE svmc_settings ;
03:59:36 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:59:36 SQL> -- DELETE svmc_settings;
03:59:36 SQL> 
03:59:36 SQL> -- The default classification algorithm is Naive Bayes. So override
03:59:36 SQL> -- this choice to SVM using a settings table.
03:59:36 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:59:36 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:59:36 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:59:36 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:59:36 SQL> -- models.
03:59:36 SQL> --
03:59:36 SQL> 
03:59:36 SQL> -- Do this once and then comment it out.
03:59:36 SQL> -- That makes script go faster.
03:59:36 SQL> -- BEGIN
03:59:36 SQL> -- -- Populate settings table
03:59:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:36 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:59:36 SQL> --
03:59:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:36 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:59:36 SQL> --
03:59:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:36 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:59:36 SQL> --   COMMIT;
03:59:36 SQL> -- END;
03:59:36 SQL> -- /
03:59:36 SQL> 
03:59:36 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:59:36 SQL> 
03:59:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:59:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:59:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:59:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:36 SQL> 
03:59:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:59:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:36 SQL> 
03:59:36 SQL> --------------------------------
03:59:36 SQL> -- PREPARE BUILD (TRAINING) DATA
03:59:36 SQL> --
03:59:36 SQL> 
03:59:36 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:36 SQL> -- 2. Outlier Treatment and
03:59:36 SQL> -- 3. Normalization are performed below.
03:59:36 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:59:36 SQL> --    normalized here.
03:59:36 SQL> 
03:59:36 SQL> BEGIN
03:59:36   2  	-- Perform missing value treatment for all predictors
03:59:36   3  	-- create miss tables
03:59:36   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:59:36   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:59:36   6  
03:59:36   7  	-- populate miss tables
03:59:36   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:59:36   9  	  miss_table_name => 'svmc_miss_num',
03:59:36  10  	  data_table_name => '&bldtable',
03:59:36  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:36  12  
03:59:36  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:59:36  14  	  miss_table_name => 'svmc_miss_cat',
03:59:36  15  	  data_table_name => '&bldtable',
03:59:36  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:36  17  
03:59:36  18  	-- xform input data to replace missing values
03:59:36  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:36  20  	  miss_table_name => 'svmc_miss_num',
03:59:36  21  	  data_table_name => '&bldtable',
03:59:36  22  	  xform_view_name => 'xformed_build_miss_num');
03:59:36  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:36  24  	  miss_table_name => 'svmc_miss_cat',
03:59:36  25  	  data_table_name => '&bldtable',
03:59:36  26  	  xform_view_name => 'xformed_build_miss_cat');
03:59:36  27  
03:59:36  28  	-- Perform outlier treatment.
03:59:36  29  	-- create clip table
03:59:36  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:59:36  31  
03:59:36  32  	-- populate clip table
03:59:36  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:59:36  34  	  clip_table_name => 'svmc_clip',
03:59:36  35  	  data_table_name => '&bldtable',
03:59:36  36  	  tail_frac	  => 0.025,
03:59:36  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:36  38  
03:59:36  39  	-- xform input data to winsorized data
03:59:36  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:59:36  41  	  clip_table_name => 'svmc_clip',
03:59:36  42  	  data_table_name => '&bldtable',
03:59:36  43  	  xform_view_name => 'svmc_winsor');
03:59:36  44  
03:59:36  45  	-- create normalization table
03:59:36  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:59:36  47  
03:59:36  48  	-- populate normalization table based on winsorized data
03:59:36  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:59:36  50  	  norm_table_name => 'svmc_norm',
03:59:36  51  	  data_table_name => 'svmc_winsor',
03:59:36  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:36  53  
03:59:36  54  	-- normalize the original data
03:59:36  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:36  56  	  norm_table_name => 'svmc_norm',
03:59:36  57  	  data_table_name => '&bldtable',
03:59:36  58  	  xform_view_name => 'svmc_build_prep');
03:59:36  59  END;
03:59:36  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.62
03:59:39 SQL> 
03:59:39 SQL> ---------------------
03:59:39 SQL> -- CREATE A NEW MODEL
03:59:39 SQL> --
03:59:39 SQL> -- Cleanup old model with the same name for repeat runs
03:59:39 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:59:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:39   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.65
03:59:40 SQL> 
03:59:40 SQL> -- Build a new SVM Model
03:59:40 SQL> BEGIN
03:59:40   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:59:40   3  	  model_name	      => '&model_name',
03:59:40   4  	  mining_function     => dbms_data_mining.classification,
03:59:40   5  	  data_table_name     => 'svmc_build_prep',
03:59:40   6  	  case_id_column_name => '&case_id',
03:59:40   7  	  target_column_name  => '&target',
03:59:40   8  	  settings_table_name => 'svmc_settings');
03:59:40   9  END;
03:59:40  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.76
03:59:47 SQL> 
03:59:47 SQL> -----------------------------------------------------------------------
03:59:47 SQL> --			       APPLY/score THE MODEL
03:59:47 SQL> -----------------------------------------------------------------------
03:59:47 SQL> 
03:59:47 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:59:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:59:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:59:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:59:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:47 SQL> -----------------------
03:59:47 SQL> -- PREPARE SCORING DATA
03:59:47 SQL> --
03:59:47 SQL> -- If the data for model creation has been prepared, then the data
03:59:47 SQL> -- to be scored using the model must be prepared in the same manner
03:59:47 SQL> -- in order to obtain meaningful results.
03:59:47 SQL> --
03:59:47 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:47 SQL> -- 2. Normalization
03:59:47 SQL> -- No outlier treatment will be performed during test and apply. The
03:59:47 SQL> -- normalization step is sufficient, since the normalization parameters
03:59:47 SQL> -- already capture the effects of outlier treatment done with build data.
03:59:47 SQL> --
03:59:47 SQL> BEGIN
03:59:47   2  	-- Xform Test data to replace missing values
03:59:47   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:47   4  	  miss_table_name => 'svmc_miss_num',
03:59:47   5  	  data_table_name => '&scoretable',
03:59:47   6  	  xform_view_name => 'xformed_apply_miss_num');
03:59:47   7  
03:59:47   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:47   9  	  miss_table_name => 'svmc_miss_cat',
03:59:47  10  	  data_table_name => '&scoretable',
03:59:47  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:59:47  12  
03:59:47  13  	-- Normalize the data to be scored
03:59:47  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:47  15  	  norm_table_name => 'svmc_norm',
03:59:47  16  	  data_table_name => '&scoretable',
03:59:47  17  	  xform_view_name => 'svmc_apply_prep');
03:59:47  18  END;
03:59:47  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
03:59:47 SQL> 
03:59:47 SQL> -- Maybe I already collected a score for this prdate.
03:59:47 SQL> -- DELETE it if I did:
03:59:47 SQL> DELETE svm24scores
03:59:47   2  WHERE score > 0
03:59:47   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:59:47   4  -- I need to supply the target attribute name:
03:59:47   5  AND targ = '&1'
03:59:47   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
03:59:47 SQL> 
03:59:47 SQL> -- We do a drumroll here:
03:59:47 SQL> 
03:59:47 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:59:47   2  SELECT
03:59:47   3  prdate
03:59:47   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:59:47   5  ,sysdate
03:59:47   6  ,SUBSTR(prdate,1,7)pair
03:59:47   7  ,SUBSTR(prdate,-19)ydate
03:59:47   8  ,'&1'
03:59:47   9  FROM svmc_apply_prep
03:59:47  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
03:59:48 SQL> @score1_5min_gattn.sql	2011-01-21 06:40:00 eur_usd
03:59:48 SQL> --
03:59:48 SQL> -- score1_5min_gattn.sql
03:59:48 SQL> --
03:59:48 SQL> 
03:59:48 SQL> -- Demo:
03:59:48 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:59:48 SQL> 
03:59:48 SQL> CREATE OR REPLACE VIEW sme AS
03:59:48   2  SELECT
03:59:48   3  prdate
03:59:48   4  ,NULL gattn
03:59:48   5  ,g00
03:59:48   6  ,g01
03:59:48   7  ,g02
03:59:48   8  ,g03
03:59:48   9  ,g04
03:59:48  10  ,g05
03:59:48  11  ,g06
03:59:48  12  ,g07
03:59:48  13  ,g08
03:59:48  14  ,g09
03:59:48  15  ,g10
03:59:48  16  ,g11
03:59:48  17  ,g12
03:59:48  18  ,g13
03:59:48  19  ,g14
03:59:48  20  ,g15
03:59:48  21  ,g16
03:59:48  22  ,g17
03:59:48  23  ,g18
03:59:48  24  ,g19
03:59:48  25  ,g20
03:59:48  26  ,g21
03:59:48  27  ,g22
03:59:48  28  ,g23
03:59:48  29  ,g24
03:59:48  30  ,g25
03:59:48  31  ,g26
03:59:48  32  ,g27
03:59:48  33  ,g28
03:59:48  34  ,g29
03:59:48  35  ,g30
03:59:48  36  ,g31
03:59:48  37  ,g32
03:59:48  38  ,g33
03:59:48  39  ,g34
03:59:48  40  ,g35
03:59:48  41  ,g36
03:59:48  42  ,g37
03:59:48  43  ,g38
03:59:48  44  ,g39
03:59:48  45  ,g40
03:59:48  46  ,g41
03:59:48  47  ,s.sc_corr
03:59:48  48  FROM modsrc24
03:59:48  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:59:48  50  WHERE ydate = '&1'||' '||'&2'
03:59:48  51  AND pair = '&3'
03:59:48  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'06:40:00'AND ydate<'2011-01-21'||' '||'06:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'06:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:59:48 SQL> 
03:59:48 SQL> -- rpt
03:59:48 SQL> -- We should see just 1 row:
03:59:48 SQL> 
03:59:48 SQL> SELECT COUNT(prdate) FROM sme
03:59:48   2  
03:59:48 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:59:48   2  
03:59:48 SQL> 
03:59:48 SQL> -- Build the model:
03:59:48 SQL> CREATE OR REPLACE VIEW bme AS
03:59:48   2  SELECT
03:59:48   3  prdate
03:59:48   4  ,gattn
03:59:48   5  ,g00
03:59:48   6  ,g01
03:59:48   7  ,g02
03:59:48   8  ,g03
03:59:48   9  ,g04
03:59:48  10  ,g05
03:59:48  11  ,g06
03:59:48  12  ,g07
03:59:48  13  ,g08
03:59:48  14  ,g09
03:59:48  15  ,g10
03:59:48  16  ,g11
03:59:48  17  ,g12
03:59:48  18  ,g13
03:59:48  19  ,g14
03:59:48  20  ,g15
03:59:48  21  ,g16
03:59:48  22  ,g17
03:59:48  23  ,g18
03:59:48  24  ,g19
03:59:48  25  ,g20
03:59:48  26  ,g21
03:59:48  27  ,g22
03:59:48  28  ,g23
03:59:48  29  ,g24
03:59:48  30  ,g25
03:59:48  31  ,g26
03:59:48  32  ,g27
03:59:48  33  ,g28
03:59:48  34  ,g29
03:59:48  35  ,g30
03:59:48  36  ,g31
03:59:48  37  ,g32
03:59:48  38  ,g33
03:59:48  39  ,g34
03:59:48  40  ,g35
03:59:48  41  ,g36
03:59:48  42  ,g37
03:59:48  43  ,g38
03:59:48  44  ,g39
03:59:48  45  ,g40
03:59:48  46  ,g41
03:59:48  47  ,sc_corr
03:59:48  48  FROM modsrc24
03:59:48  49  WHERE gattn IN('nup','up')
03:59:48  50  -- Use only rows which are older than 1 day:
03:59:48  51  AND 1+ydate < '&1'||' '||'&2'
03:59:48  52  AND pair = '&3'
03:59:48  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'06:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
03:59:48 SQL> 
03:59:48 SQL> -- rpt
03:59:48 SQL> 
03:59:48 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:59:48   2  
03:59:48 SQL> SELECT MAX(prdate) FROM bme
03:59:48   2  
03:59:48 SQL> -- Now build model from bme and score sme
03:59:48 SQL> @score1.sql gattn
03:59:48 SQL> --
03:59:48 SQL> -- score1.sql
03:59:48 SQL> --
03:59:48 SQL> 
03:59:48 SQL> -- I use this script to send 5 params to score.sql
03:59:48 SQL> -- which does the heavy lifting of creating an SVM model.
03:59:48 SQL> -- Then at the very end of this script I use the model
03:59:48 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:59:48 SQL> 
03:59:48 SQL> -- I call this script from 2 other scripts:
03:59:48 SQL> -- score1_5min.sql
03:59:48 SQL> -- score1_5min_gattn.sql
03:59:48 SQL> 
03:59:48 SQL> -- The 1st param is the name of the target attribute.
03:59:48 SQL> -- I like to call my target attributes either gatt or gattn.
03:59:48 SQL> 
03:59:48 SQL> -- Demo:
03:59:48 SQL> -- @score1.sql 'gatt'
03:59:48 SQL> -- @score1.sql 'gattn'
03:59:48 SQL> 
03:59:48 SQL> -- Now, I fill up svmc_apply_prep.
03:59:48 SQL> -- I use same model_name used in score.sql
03:59:48 SQL> DEFINE model_name = 'svmfx101'
03:59:48 SQL> DEFINE bldtable	= 'bme'
03:59:48 SQL> DEFINE scoretable = 'sme'
03:59:48 SQL> DEFINE case_id	= 'prdate'
03:59:48 SQL> -- Demo:
03:59:48 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:59:48 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:59:48 SQL> --
03:59:48 SQL> -- score.sql
03:59:48 SQL> --
03:59:48 SQL> 
03:59:48 SQL> -- usage: score.sql
03:59:48 SQL> 
03:59:48 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:59:48 SQL> 
03:59:48 SQL> -- DEFINE target	   = 'gatt'
03:59:48 SQL> -- DEFINE model_name = 'svmfx101'
03:59:48 SQL> -- DEFINE bldtable   = 'bme'
03:59:48 SQL> -- DEFINE scoretable = 'sme'
03:59:48 SQL> -- DEFINE case_id    = 'prdate'
03:59:48 SQL> 
03:59:48 SQL> DEFINE target	= '&1'
03:59:48 SQL> DEFINE model_name = '&2'
03:59:48 SQL> DEFINE bldtable	= '&3'
03:59:48 SQL> DEFINE scoretable = '&4'
03:59:48 SQL> DEFINE case_id	= '&5'
03:59:48 SQL> 
03:59:48 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:59:48 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:59:48 SQL> 
03:59:48 SQL> -- Builds an SVM model using pl/sql.
03:59:48 SQL> 
03:59:48 SQL> -----------------------------------------------------------------------
03:59:48 SQL> --			    BUILD THE MODEL
03:59:48 SQL> -----------------------------------------------------------------------
03:59:48 SQL> 
03:59:48 SQL> -- Cleanup old build data preparation objects for repeat runs
03:59:48 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
03:59:48 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:59:48 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:48 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
03:59:48 SQL> 
03:59:48 SQL> 
03:59:48 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:59:48 SQL> --
03:59:48 SQL> -- DROP	TABLE svmc_settings ;
03:59:48 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:59:48 SQL> -- DELETE svmc_settings;
03:59:48 SQL> 
03:59:48 SQL> -- The default classification algorithm is Naive Bayes. So override
03:59:48 SQL> -- this choice to SVM using a settings table.
03:59:48 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:59:48 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:59:48 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:59:48 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:59:48 SQL> -- models.
03:59:48 SQL> --
03:59:48 SQL> 
03:59:48 SQL> -- Do this once and then comment it out.
03:59:48 SQL> -- That makes script go faster.
03:59:48 SQL> -- BEGIN
03:59:48 SQL> -- -- Populate settings table
03:59:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:48 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:59:48 SQL> --
03:59:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:48 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:59:48 SQL> --
03:59:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:48 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:59:48 SQL> --   COMMIT;
03:59:48 SQL> -- END;
03:59:48 SQL> -- /
03:59:48 SQL> 
03:59:48 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:59:48 SQL> 
03:59:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:59:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:59:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:59:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:48 SQL> 
03:59:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:59:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:48 SQL> 
03:59:48 SQL> --------------------------------
03:59:48 SQL> -- PREPARE BUILD (TRAINING) DATA
03:59:48 SQL> --
03:59:48 SQL> 
03:59:48 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:48 SQL> -- 2. Outlier Treatment and
03:59:48 SQL> -- 3. Normalization are performed below.
03:59:48 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:59:48 SQL> --    normalized here.
03:59:48 SQL> 
03:59:48 SQL> BEGIN
03:59:48   2  	-- Perform missing value treatment for all predictors
03:59:48   3  	-- create miss tables
03:59:48   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:59:48   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:59:48   6  
03:59:48   7  	-- populate miss tables
03:59:48   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:59:48   9  	  miss_table_name => 'svmc_miss_num',
03:59:48  10  	  data_table_name => '&bldtable',
03:59:48  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:48  12  
03:59:48  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:59:48  14  	  miss_table_name => 'svmc_miss_cat',
03:59:48  15  	  data_table_name => '&bldtable',
03:59:48  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:48  17  
03:59:48  18  	-- xform input data to replace missing values
03:59:48  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:48  20  	  miss_table_name => 'svmc_miss_num',
03:59:48  21  	  data_table_name => '&bldtable',
03:59:48  22  	  xform_view_name => 'xformed_build_miss_num');
03:59:48  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:48  24  	  miss_table_name => 'svmc_miss_cat',
03:59:48  25  	  data_table_name => '&bldtable',
03:59:48  26  	  xform_view_name => 'xformed_build_miss_cat');
03:59:48  27  
03:59:48  28  	-- Perform outlier treatment.
03:59:48  29  	-- create clip table
03:59:48  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:59:48  31  
03:59:48  32  	-- populate clip table
03:59:48  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:59:48  34  	  clip_table_name => 'svmc_clip',
03:59:48  35  	  data_table_name => '&bldtable',
03:59:48  36  	  tail_frac	  => 0.025,
03:59:48  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:48  38  
03:59:48  39  	-- xform input data to winsorized data
03:59:48  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:59:48  41  	  clip_table_name => 'svmc_clip',
03:59:48  42  	  data_table_name => '&bldtable',
03:59:48  43  	  xform_view_name => 'svmc_winsor');
03:59:48  44  
03:59:48  45  	-- create normalization table
03:59:48  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:59:48  47  
03:59:48  48  	-- populate normalization table based on winsorized data
03:59:48  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:59:48  50  	  norm_table_name => 'svmc_norm',
03:59:48  51  	  data_table_name => 'svmc_winsor',
03:59:48  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:48  53  
03:59:48  54  	-- normalize the original data
03:59:48  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:48  56  	  norm_table_name => 'svmc_norm',
03:59:48  57  	  data_table_name => '&bldtable',
03:59:48  58  	  xform_view_name => 'svmc_build_prep');
03:59:48  59  END;
03:59:48  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
03:59:50 SQL> 
03:59:50 SQL> ---------------------
03:59:50 SQL> -- CREATE A NEW MODEL
03:59:50 SQL> --
03:59:50 SQL> -- Cleanup old model with the same name for repeat runs
03:59:50 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
03:59:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:50   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.41
03:59:52 SQL> 
03:59:52 SQL> -- Build a new SVM Model
03:59:52 SQL> BEGIN
03:59:52   2  	DBMS_DATA_MINING.CREATE_MODEL(
03:59:52   3  	  model_name	      => '&model_name',
03:59:52   4  	  mining_function     => dbms_data_mining.classification,
03:59:52   5  	  data_table_name     => 'svmc_build_prep',
03:59:52   6  	  case_id_column_name => '&case_id',
03:59:52   7  	  target_column_name  => '&target',
03:59:52   8  	  settings_table_name => 'svmc_settings');
03:59:52   9  END;
03:59:52  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.36
03:59:57 SQL> 
03:59:57 SQL> -----------------------------------------------------------------------
03:59:57 SQL> --			       APPLY/score THE MODEL
03:59:57 SQL> -----------------------------------------------------------------------
03:59:57 SQL> 
03:59:57 SQL> -- Cleanup old scoring data preparation objects for repeat runs
03:59:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
03:59:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
03:59:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
03:59:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
03:59:57 SQL> -----------------------
03:59:57 SQL> -- PREPARE SCORING DATA
03:59:57 SQL> --
03:59:57 SQL> -- If the data for model creation has been prepared, then the data
03:59:57 SQL> -- to be scored using the model must be prepared in the same manner
03:59:57 SQL> -- in order to obtain meaningful results.
03:59:57 SQL> --
03:59:57 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:57 SQL> -- 2. Normalization
03:59:57 SQL> -- No outlier treatment will be performed during test and apply. The
03:59:57 SQL> -- normalization step is sufficient, since the normalization parameters
03:59:57 SQL> -- already capture the effects of outlier treatment done with build data.
03:59:57 SQL> --
03:59:57 SQL> BEGIN
03:59:57   2  	-- Xform Test data to replace missing values
03:59:57   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:57   4  	  miss_table_name => 'svmc_miss_num',
03:59:57   5  	  data_table_name => '&scoretable',
03:59:57   6  	  xform_view_name => 'xformed_apply_miss_num');
03:59:57   7  
03:59:57   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:57   9  	  miss_table_name => 'svmc_miss_cat',
03:59:57  10  	  data_table_name => '&scoretable',
03:59:57  11  	  xform_view_name => 'xformed_apply_miss_cat');
03:59:57  12  
03:59:57  13  	-- Normalize the data to be scored
03:59:57  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:57  15  	  norm_table_name => 'svmc_norm',
03:59:57  16  	  data_table_name => '&scoretable',
03:59:57  17  	  xform_view_name => 'svmc_apply_prep');
03:59:57  18  END;
03:59:57  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
03:59:57 SQL> 
03:59:57 SQL> -- Maybe I already collected a score for this prdate.
03:59:57 SQL> -- DELETE it if I did:
03:59:57 SQL> DELETE svm24scores
03:59:57   2  WHERE score > 0
03:59:57   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
03:59:57   4  -- I need to supply the target attribute name:
03:59:57   5  AND targ = '&1'
03:59:57   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
03:59:57 SQL> 
03:59:57 SQL> -- We do a drumroll here:
03:59:57 SQL> 
03:59:57 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
03:59:57   2  SELECT
03:59:57   3  prdate
03:59:57   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
03:59:57   5  ,sysdate
03:59:57   6  ,SUBSTR(prdate,1,7)pair
03:59:57   7  ,SUBSTR(prdate,-19)ydate
03:59:57   8  ,'&1'
03:59:57   9  FROM svmc_apply_prep
03:59:57  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
03:59:57 SQL> @score1_5min_gattn.sql	2011-01-25 20:10:00 eur_usd
03:59:57 SQL> --
03:59:57 SQL> -- score1_5min_gattn.sql
03:59:57 SQL> --
03:59:57 SQL> 
03:59:57 SQL> -- Demo:
03:59:57 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
03:59:57 SQL> 
03:59:57 SQL> CREATE OR REPLACE VIEW sme AS
03:59:57   2  SELECT
03:59:57   3  prdate
03:59:57   4  ,NULL gattn
03:59:57   5  ,g00
03:59:57   6  ,g01
03:59:57   7  ,g02
03:59:57   8  ,g03
03:59:57   9  ,g04
03:59:57  10  ,g05
03:59:57  11  ,g06
03:59:57  12  ,g07
03:59:57  13  ,g08
03:59:57  14  ,g09
03:59:57  15  ,g10
03:59:57  16  ,g11
03:59:57  17  ,g12
03:59:57  18  ,g13
03:59:57  19  ,g14
03:59:57  20  ,g15
03:59:57  21  ,g16
03:59:57  22  ,g17
03:59:57  23  ,g18
03:59:57  24  ,g19
03:59:57  25  ,g20
03:59:57  26  ,g21
03:59:57  27  ,g22
03:59:57  28  ,g23
03:59:57  29  ,g24
03:59:57  30  ,g25
03:59:57  31  ,g26
03:59:57  32  ,g27
03:59:57  33  ,g28
03:59:57  34  ,g29
03:59:57  35  ,g30
03:59:57  36  ,g31
03:59:57  37  ,g32
03:59:57  38  ,g33
03:59:57  39  ,g34
03:59:57  40  ,g35
03:59:57  41  ,g36
03:59:57  42  ,g37
03:59:57  43  ,g38
03:59:57  44  ,g39
03:59:57  45  ,g40
03:59:57  46  ,g41
03:59:57  47  ,s.sc_corr
03:59:57  48  FROM modsrc24
03:59:57  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
03:59:57  50  WHERE ydate = '&1'||' '||'&2'
03:59:57  51  AND pair = '&3'
03:59:57  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'20:10:00'AND ydate<'2011-01-25'||' '||'20:10:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'20:10:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
03:59:58 SQL> 
03:59:58 SQL> -- rpt
03:59:58 SQL> -- We should see just 1 row:
03:59:58 SQL> 
03:59:58 SQL> SELECT COUNT(prdate) FROM sme
03:59:58   2  
03:59:58 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
03:59:58   2  
03:59:58 SQL> 
03:59:58 SQL> -- Build the model:
03:59:58 SQL> CREATE OR REPLACE VIEW bme AS
03:59:58   2  SELECT
03:59:58   3  prdate
03:59:58   4  ,gattn
03:59:58   5  ,g00
03:59:58   6  ,g01
03:59:58   7  ,g02
03:59:58   8  ,g03
03:59:58   9  ,g04
03:59:58  10  ,g05
03:59:58  11  ,g06
03:59:58  12  ,g07
03:59:58  13  ,g08
03:59:58  14  ,g09
03:59:58  15  ,g10
03:59:58  16  ,g11
03:59:58  17  ,g12
03:59:58  18  ,g13
03:59:58  19  ,g14
03:59:58  20  ,g15
03:59:58  21  ,g16
03:59:58  22  ,g17
03:59:58  23  ,g18
03:59:58  24  ,g19
03:59:58  25  ,g20
03:59:58  26  ,g21
03:59:58  27  ,g22
03:59:58  28  ,g23
03:59:58  29  ,g24
03:59:58  30  ,g25
03:59:58  31  ,g26
03:59:58  32  ,g27
03:59:58  33  ,g28
03:59:58  34  ,g29
03:59:58  35  ,g30
03:59:58  36  ,g31
03:59:58  37  ,g32
03:59:58  38  ,g33
03:59:58  39  ,g34
03:59:58  40  ,g35
03:59:58  41  ,g36
03:59:58  42  ,g37
03:59:58  43  ,g38
03:59:58  44  ,g39
03:59:58  45  ,g40
03:59:58  46  ,g41
03:59:58  47  ,sc_corr
03:59:58  48  FROM modsrc24
03:59:58  49  WHERE gattn IN('nup','up')
03:59:58  50  -- Use only rows which are older than 1 day:
03:59:58  51  AND 1+ydate < '&1'||' '||'&2'
03:59:58  52  AND pair = '&3'
03:59:58  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'20:10:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
03:59:58 SQL> 
03:59:58 SQL> -- rpt
03:59:58 SQL> 
03:59:58 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
03:59:58   2  
03:59:58 SQL> SELECT MAX(prdate) FROM bme
03:59:58   2  
03:59:58 SQL> -- Now build model from bme and score sme
03:59:58 SQL> @score1.sql gattn
03:59:58 SQL> --
03:59:58 SQL> -- score1.sql
03:59:58 SQL> --
03:59:58 SQL> 
03:59:58 SQL> -- I use this script to send 5 params to score.sql
03:59:58 SQL> -- which does the heavy lifting of creating an SVM model.
03:59:58 SQL> -- Then at the very end of this script I use the model
03:59:58 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
03:59:58 SQL> 
03:59:58 SQL> -- I call this script from 2 other scripts:
03:59:58 SQL> -- score1_5min.sql
03:59:58 SQL> -- score1_5min_gattn.sql
03:59:58 SQL> 
03:59:58 SQL> -- The 1st param is the name of the target attribute.
03:59:58 SQL> -- I like to call my target attributes either gatt or gattn.
03:59:58 SQL> 
03:59:58 SQL> -- Demo:
03:59:58 SQL> -- @score1.sql 'gatt'
03:59:58 SQL> -- @score1.sql 'gattn'
03:59:58 SQL> 
03:59:58 SQL> -- Now, I fill up svmc_apply_prep.
03:59:58 SQL> -- I use same model_name used in score.sql
03:59:58 SQL> DEFINE model_name = 'svmfx101'
03:59:58 SQL> DEFINE bldtable	= 'bme'
03:59:58 SQL> DEFINE scoretable = 'sme'
03:59:58 SQL> DEFINE case_id	= 'prdate'
03:59:58 SQL> -- Demo:
03:59:58 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
03:59:58 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
03:59:58 SQL> --
03:59:58 SQL> -- score.sql
03:59:58 SQL> --
03:59:58 SQL> 
03:59:58 SQL> -- usage: score.sql
03:59:58 SQL> 
03:59:58 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
03:59:58 SQL> 
03:59:58 SQL> -- DEFINE target	   = 'gatt'
03:59:58 SQL> -- DEFINE model_name = 'svmfx101'
03:59:58 SQL> -- DEFINE bldtable   = 'bme'
03:59:58 SQL> -- DEFINE scoretable = 'sme'
03:59:58 SQL> -- DEFINE case_id    = 'prdate'
03:59:58 SQL> 
03:59:58 SQL> DEFINE target	= '&1'
03:59:58 SQL> DEFINE model_name = '&2'
03:59:58 SQL> DEFINE bldtable	= '&3'
03:59:58 SQL> DEFINE scoretable = '&4'
03:59:58 SQL> DEFINE case_id	= '&5'
03:59:58 SQL> 
03:59:58 SQL> -- Define a variable to help me exclude some columns from some data mining calls
03:59:58 SQL> DEFINE exclude1 = "'&target','&case_id'"
03:59:58 SQL> 
03:59:58 SQL> -- Builds an SVM model using pl/sql.
03:59:58 SQL> 
03:59:58 SQL> -----------------------------------------------------------------------
03:59:58 SQL> --			    BUILD THE MODEL
03:59:58 SQL> -----------------------------------------------------------------------
03:59:58 SQL> 
03:59:58 SQL> -- Cleanup old build data preparation objects for repeat runs
03:59:58 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
03:59:58 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
03:59:58 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
03:59:58 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
03:59:58 SQL> 
03:59:58 SQL> 
03:59:58 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
03:59:58 SQL> --
03:59:58 SQL> -- DROP	TABLE svmc_settings ;
03:59:58 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
03:59:58 SQL> -- DELETE svmc_settings;
03:59:58 SQL> 
03:59:58 SQL> -- The default classification algorithm is Naive Bayes. So override
03:59:58 SQL> -- this choice to SVM using a settings table.
03:59:58 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
03:59:58 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
03:59:58 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
03:59:58 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
03:59:58 SQL> -- models.
03:59:58 SQL> --
03:59:58 SQL> 
03:59:58 SQL> -- Do this once and then comment it out.
03:59:58 SQL> -- That makes script go faster.
03:59:58 SQL> -- BEGIN
03:59:58 SQL> -- -- Populate settings table
03:59:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:58 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
03:59:58 SQL> --
03:59:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:58 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
03:59:58 SQL> --
03:59:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
03:59:58 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
03:59:58 SQL> --   COMMIT;
03:59:58 SQL> -- END;
03:59:58 SQL> -- /
03:59:58 SQL> 
03:59:58 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
03:59:58 SQL> 
03:59:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
03:59:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
03:59:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
03:59:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
03:59:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
03:59:58 SQL> 
03:59:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
03:59:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
03:59:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
03:59:58 SQL> 
03:59:58 SQL> --------------------------------
03:59:58 SQL> -- PREPARE BUILD (TRAINING) DATA
03:59:58 SQL> --
03:59:58 SQL> 
03:59:58 SQL> -- 1. Missing Value treatment for all Predictors and
03:59:58 SQL> -- 2. Outlier Treatment and
03:59:58 SQL> -- 3. Normalization are performed below.
03:59:58 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
03:59:58 SQL> --    normalized here.
03:59:58 SQL> 
03:59:58 SQL> BEGIN
03:59:58   2  	-- Perform missing value treatment for all predictors
03:59:58   3  	-- create miss tables
03:59:58   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
03:59:58   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
03:59:58   6  
03:59:58   7  	-- populate miss tables
03:59:58   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
03:59:58   9  	  miss_table_name => 'svmc_miss_num',
03:59:58  10  	  data_table_name => '&bldtable',
03:59:58  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:58  12  
03:59:58  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
03:59:58  14  	  miss_table_name => 'svmc_miss_cat',
03:59:58  15  	  data_table_name => '&bldtable',
03:59:58  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:58  17  
03:59:58  18  	-- xform input data to replace missing values
03:59:58  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
03:59:58  20  	  miss_table_name => 'svmc_miss_num',
03:59:58  21  	  data_table_name => '&bldtable',
03:59:58  22  	  xform_view_name => 'xformed_build_miss_num');
03:59:58  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
03:59:58  24  	  miss_table_name => 'svmc_miss_cat',
03:59:58  25  	  data_table_name => '&bldtable',
03:59:58  26  	  xform_view_name => 'xformed_build_miss_cat');
03:59:58  27  
03:59:58  28  	-- Perform outlier treatment.
03:59:58  29  	-- create clip table
03:59:58  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
03:59:58  31  
03:59:58  32  	-- populate clip table
03:59:58  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
03:59:58  34  	  clip_table_name => 'svmc_clip',
03:59:58  35  	  data_table_name => '&bldtable',
03:59:58  36  	  tail_frac	  => 0.025,
03:59:58  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:58  38  
03:59:58  39  	-- xform input data to winsorized data
03:59:58  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
03:59:58  41  	  clip_table_name => 'svmc_clip',
03:59:58  42  	  data_table_name => '&bldtable',
03:59:58  43  	  xform_view_name => 'svmc_winsor');
03:59:58  44  
03:59:58  45  	-- create normalization table
03:59:58  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
03:59:58  47  
03:59:58  48  	-- populate normalization table based on winsorized data
03:59:58  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
03:59:58  50  	  norm_table_name => 'svmc_norm',
03:59:58  51  	  data_table_name => 'svmc_winsor',
03:59:58  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
03:59:58  53  
03:59:58  54  	-- normalize the original data
03:59:58  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
03:59:58  56  	  norm_table_name => 'svmc_norm',
03:59:58  57  	  data_table_name => '&bldtable',
03:59:58  58  	  xform_view_name => 'svmc_build_prep');
03:59:58  59  END;
03:59:58  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.64
04:00:00 SQL> 
04:00:00 SQL> ---------------------
04:00:00 SQL> -- CREATE A NEW MODEL
04:00:00 SQL> --
04:00:00 SQL> -- Cleanup old model with the same name for repeat runs
04:00:00 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:00:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:00   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.38
04:00:02 SQL> 
04:00:02 SQL> -- Build a new SVM Model
04:00:02 SQL> BEGIN
04:00:02   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:00:02   3  	  model_name	      => '&model_name',
04:00:02   4  	  mining_function     => dbms_data_mining.classification,
04:00:02   5  	  data_table_name     => 'svmc_build_prep',
04:00:02   6  	  case_id_column_name => '&case_id',
04:00:02   7  	  target_column_name  => '&target',
04:00:02   8  	  settings_table_name => 'svmc_settings');
04:00:02   9  END;
04:00:02  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.14
04:00:08 SQL> 
04:00:08 SQL> -----------------------------------------------------------------------
04:00:08 SQL> --			       APPLY/score THE MODEL
04:00:08 SQL> -----------------------------------------------------------------------
04:00:08 SQL> 
04:00:08 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:00:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:00:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:00:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:00:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:08 SQL> -----------------------
04:00:08 SQL> -- PREPARE SCORING DATA
04:00:08 SQL> --
04:00:08 SQL> -- If the data for model creation has been prepared, then the data
04:00:08 SQL> -- to be scored using the model must be prepared in the same manner
04:00:08 SQL> -- in order to obtain meaningful results.
04:00:08 SQL> --
04:00:08 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:08 SQL> -- 2. Normalization
04:00:08 SQL> -- No outlier treatment will be performed during test and apply. The
04:00:08 SQL> -- normalization step is sufficient, since the normalization parameters
04:00:08 SQL> -- already capture the effects of outlier treatment done with build data.
04:00:08 SQL> --
04:00:08 SQL> BEGIN
04:00:08   2  	-- Xform Test data to replace missing values
04:00:08   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:08   4  	  miss_table_name => 'svmc_miss_num',
04:00:08   5  	  data_table_name => '&scoretable',
04:00:08   6  	  xform_view_name => 'xformed_apply_miss_num');
04:00:08   7  
04:00:08   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:08   9  	  miss_table_name => 'svmc_miss_cat',
04:00:08  10  	  data_table_name => '&scoretable',
04:00:08  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:00:08  12  
04:00:08  13  	-- Normalize the data to be scored
04:00:08  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:08  15  	  norm_table_name => 'svmc_norm',
04:00:08  16  	  data_table_name => '&scoretable',
04:00:08  17  	  xform_view_name => 'svmc_apply_prep');
04:00:08  18  END;
04:00:08  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.23
04:00:08 SQL> 
04:00:08 SQL> -- Maybe I already collected a score for this prdate.
04:00:08 SQL> -- DELETE it if I did:
04:00:08 SQL> DELETE svm24scores
04:00:08   2  WHERE score > 0
04:00:08   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:00:08   4  -- I need to supply the target attribute name:
04:00:08   5  AND targ = '&1'
04:00:08   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:00:08 SQL> 
04:00:08 SQL> -- We do a drumroll here:
04:00:08 SQL> 
04:00:08 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:00:08   2  SELECT
04:00:08   3  prdate
04:00:08   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:00:08   5  ,sysdate
04:00:08   6  ,SUBSTR(prdate,1,7)pair
04:00:08   7  ,SUBSTR(prdate,-19)ydate
04:00:08   8  ,'&1'
04:00:08   9  FROM svmc_apply_prep
04:00:08  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
04:00:08 SQL> @score1_5min.sql	      2011-01-25 10:20:00 eur_usd
04:00:08 SQL> --
04:00:08 SQL> -- score1_5min.sql
04:00:08 SQL> --
04:00:08 SQL> 
04:00:08 SQL> -- Demo:
04:00:08 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
04:00:08 SQL> 
04:00:08 SQL> CREATE OR REPLACE VIEW sme AS
04:00:08   2  SELECT
04:00:08   3  prdate
04:00:08   4  ,NULL gatt
04:00:08   5  ,g00
04:00:08   6  ,g01
04:00:08   7  ,g02
04:00:08   8  ,g03
04:00:08   9  ,g04
04:00:08  10  ,g05
04:00:08  11  ,g06
04:00:08  12  ,g07
04:00:08  13  ,g08
04:00:08  14  ,g09
04:00:08  15  ,g10
04:00:08  16  ,g11
04:00:08  17  ,g12
04:00:08  18  ,g13
04:00:08  19  ,g14
04:00:08  20  ,g15
04:00:08  21  ,g16
04:00:08  22  ,g17
04:00:08  23  ,g18
04:00:08  24  ,g19
04:00:08  25  ,g20
04:00:08  26  ,g21
04:00:08  27  ,g22
04:00:08  28  ,g23
04:00:08  29  ,g24
04:00:08  30  ,g25
04:00:08  31  ,g26
04:00:08  32  ,g27
04:00:08  33  ,g28
04:00:08  34  ,g29
04:00:08  35  ,g30
04:00:08  36  ,g31
04:00:08  37  ,g32
04:00:08  38  ,g33
04:00:08  39  ,g34
04:00:08  40  ,g35
04:00:08  41  ,g36
04:00:08  42  ,g37
04:00:08  43  ,g38
04:00:08  44  ,g39
04:00:08  45  ,g40
04:00:08  46  ,g41
04:00:08  47  ,s.sc_corr
04:00:08  48  FROM modsrc24
04:00:08  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:00:08  50  WHERE ydate = '&1'||' '||'&2'
04:00:08  51  AND pair = '&3'
04:00:08  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'10:20:00'AND ydate<'2011-01-25'||' '||'10:20:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'10:20:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:00:08 SQL> 
04:00:08 SQL> -- rpt
04:00:08 SQL> -- We should see just 1 row:
04:00:08 SQL> 
04:00:08 SQL> SELECT COUNT(prdate) FROM sme
04:00:08   2  
04:00:08 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:00:08   2  
04:00:08 SQL> 
04:00:08 SQL> -- Build the model:
04:00:08 SQL> CREATE OR REPLACE VIEW bme AS
04:00:08   2  SELECT
04:00:08   3  prdate
04:00:08   4  ,gatt
04:00:08   5  ,g00
04:00:08   6  ,g01
04:00:08   7  ,g02
04:00:08   8  ,g03
04:00:08   9  ,g04
04:00:08  10  ,g05
04:00:08  11  ,g06
04:00:08  12  ,g07
04:00:08  13  ,g08
04:00:08  14  ,g09
04:00:08  15  ,g10
04:00:08  16  ,g11
04:00:08  17  ,g12
04:00:08  18  ,g13
04:00:08  19  ,g14
04:00:08  20  ,g15
04:00:08  21  ,g16
04:00:08  22  ,g17
04:00:08  23  ,g18
04:00:08  24  ,g19
04:00:08  25  ,g20
04:00:08  26  ,g21
04:00:08  27  ,g22
04:00:08  28  ,g23
04:00:08  29  ,g24
04:00:08  30  ,g25
04:00:08  31  ,g26
04:00:08  32  ,g27
04:00:08  33  ,g28
04:00:08  34  ,g29
04:00:08  35  ,g30
04:00:08  36  ,g31
04:00:08  37  ,g32
04:00:08  38  ,g33
04:00:08  39  ,g34
04:00:08  40  ,g35
04:00:08  41  ,g36
04:00:08  42  ,g37
04:00:08  43  ,g38
04:00:08  44  ,g39
04:00:08  45  ,g40
04:00:08  46  ,g41
04:00:08  47  ,sc_corr
04:00:08  48  FROM modsrc24
04:00:08  49  WHERE gatt IN('nup','up')
04:00:08  50  -- Use only rows which are older than 1 day:
04:00:08  51  AND 1+ydate < '&1'||' '||'&2'
04:00:08  52  AND pair = '&3'
04:00:08  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'10:20:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:00:08 SQL> 
04:00:08 SQL> -- rpt
04:00:08 SQL> 
04:00:08 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
04:00:08   2  
04:00:08 SQL> SELECT MAX(prdate) FROM bme
04:00:08   2  
04:00:08 SQL> -- Now build model from bme and score sme
04:00:08 SQL> @score1.sql gatt
04:00:08 SQL> --
04:00:08 SQL> -- score1.sql
04:00:08 SQL> --
04:00:08 SQL> 
04:00:08 SQL> -- I use this script to send 5 params to score.sql
04:00:08 SQL> -- which does the heavy lifting of creating an SVM model.
04:00:08 SQL> -- Then at the very end of this script I use the model
04:00:08 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:00:08 SQL> 
04:00:08 SQL> -- I call this script from 2 other scripts:
04:00:08 SQL> -- score1_5min.sql
04:00:08 SQL> -- score1_5min_gattn.sql
04:00:08 SQL> 
04:00:08 SQL> -- The 1st param is the name of the target attribute.
04:00:08 SQL> -- I like to call my target attributes either gatt or gattn.
04:00:08 SQL> 
04:00:08 SQL> -- Demo:
04:00:08 SQL> -- @score1.sql 'gatt'
04:00:08 SQL> -- @score1.sql 'gattn'
04:00:08 SQL> 
04:00:08 SQL> -- Now, I fill up svmc_apply_prep.
04:00:08 SQL> -- I use same model_name used in score.sql
04:00:08 SQL> DEFINE model_name = 'svmfx101'
04:00:08 SQL> DEFINE bldtable	= 'bme'
04:00:08 SQL> DEFINE scoretable = 'sme'
04:00:08 SQL> DEFINE case_id	= 'prdate'
04:00:08 SQL> -- Demo:
04:00:08 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:00:08 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:00:08 SQL> --
04:00:08 SQL> -- score.sql
04:00:08 SQL> --
04:00:08 SQL> 
04:00:08 SQL> -- usage: score.sql
04:00:08 SQL> 
04:00:08 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:00:08 SQL> 
04:00:08 SQL> -- DEFINE target	   = 'gatt'
04:00:08 SQL> -- DEFINE model_name = 'svmfx101'
04:00:08 SQL> -- DEFINE bldtable   = 'bme'
04:00:08 SQL> -- DEFINE scoretable = 'sme'
04:00:08 SQL> -- DEFINE case_id    = 'prdate'
04:00:08 SQL> 
04:00:08 SQL> DEFINE target	= '&1'
04:00:08 SQL> DEFINE model_name = '&2'
04:00:08 SQL> DEFINE bldtable	= '&3'
04:00:08 SQL> DEFINE scoretable = '&4'
04:00:08 SQL> DEFINE case_id	= '&5'
04:00:08 SQL> 
04:00:08 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:00:08 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:00:08 SQL> 
04:00:08 SQL> -- Builds an SVM model using pl/sql.
04:00:08 SQL> 
04:00:08 SQL> -----------------------------------------------------------------------
04:00:08 SQL> --			    BUILD THE MODEL
04:00:08 SQL> -----------------------------------------------------------------------
04:00:08 SQL> 
04:00:08 SQL> -- Cleanup old build data preparation objects for repeat runs
04:00:08 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:08 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
04:00:08 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:08 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:00:08 SQL> 
04:00:08 SQL> 
04:00:08 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:00:08 SQL> --
04:00:08 SQL> -- DROP	TABLE svmc_settings ;
04:00:08 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:00:08 SQL> -- DELETE svmc_settings;
04:00:08 SQL> 
04:00:08 SQL> -- The default classification algorithm is Naive Bayes. So override
04:00:08 SQL> -- this choice to SVM using a settings table.
04:00:08 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:00:08 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:00:08 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:00:08 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:00:08 SQL> -- models.
04:00:08 SQL> --
04:00:08 SQL> 
04:00:08 SQL> -- Do this once and then comment it out.
04:00:08 SQL> -- That makes script go faster.
04:00:08 SQL> -- BEGIN
04:00:08 SQL> -- -- Populate settings table
04:00:08 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:08 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:00:08 SQL> --
04:00:08 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:08 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:00:08 SQL> --
04:00:08 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:08 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:00:08 SQL> --   COMMIT;
04:00:08 SQL> -- END;
04:00:08 SQL> -- /
04:00:08 SQL> 
04:00:08 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:00:08 SQL> 
04:00:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:00:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.10
04:00:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:00:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:00:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:09 SQL> 
04:00:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:00:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:09 SQL> 
04:00:09 SQL> --------------------------------
04:00:09 SQL> -- PREPARE BUILD (TRAINING) DATA
04:00:09 SQL> --
04:00:09 SQL> 
04:00:09 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:09 SQL> -- 2. Outlier Treatment and
04:00:09 SQL> -- 3. Normalization are performed below.
04:00:09 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:00:09 SQL> --    normalized here.
04:00:09 SQL> 
04:00:09 SQL> BEGIN
04:00:09   2  	-- Perform missing value treatment for all predictors
04:00:09   3  	-- create miss tables
04:00:09   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:00:09   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:00:09   6  
04:00:09   7  	-- populate miss tables
04:00:09   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:00:09   9  	  miss_table_name => 'svmc_miss_num',
04:00:09  10  	  data_table_name => '&bldtable',
04:00:09  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:09  12  
04:00:09  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:00:09  14  	  miss_table_name => 'svmc_miss_cat',
04:00:09  15  	  data_table_name => '&bldtable',
04:00:09  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:09  17  
04:00:09  18  	-- xform input data to replace missing values
04:00:09  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:09  20  	  miss_table_name => 'svmc_miss_num',
04:00:09  21  	  data_table_name => '&bldtable',
04:00:09  22  	  xform_view_name => 'xformed_build_miss_num');
04:00:09  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:09  24  	  miss_table_name => 'svmc_miss_cat',
04:00:09  25  	  data_table_name => '&bldtable',
04:00:09  26  	  xform_view_name => 'xformed_build_miss_cat');
04:00:09  27  
04:00:09  28  	-- Perform outlier treatment.
04:00:09  29  	-- create clip table
04:00:09  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:00:09  31  
04:00:09  32  	-- populate clip table
04:00:09  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:00:09  34  	  clip_table_name => 'svmc_clip',
04:00:09  35  	  data_table_name => '&bldtable',
04:00:09  36  	  tail_frac	  => 0.025,
04:00:09  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:09  38  
04:00:09  39  	-- xform input data to winsorized data
04:00:09  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:00:09  41  	  clip_table_name => 'svmc_clip',
04:00:09  42  	  data_table_name => '&bldtable',
04:00:09  43  	  xform_view_name => 'svmc_winsor');
04:00:09  44  
04:00:09  45  	-- create normalization table
04:00:09  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:00:09  47  
04:00:09  48  	-- populate normalization table based on winsorized data
04:00:09  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:00:09  50  	  norm_table_name => 'svmc_norm',
04:00:09  51  	  data_table_name => 'svmc_winsor',
04:00:09  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:09  53  
04:00:09  54  	-- normalize the original data
04:00:09  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:09  56  	  norm_table_name => 'svmc_norm',
04:00:09  57  	  data_table_name => '&bldtable',
04:00:09  58  	  xform_view_name => 'svmc_build_prep');
04:00:09  59  END;
04:00:09  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.65
04:00:11 SQL> 
04:00:11 SQL> ---------------------
04:00:11 SQL> -- CREATE A NEW MODEL
04:00:11 SQL> --
04:00:11 SQL> -- Cleanup old model with the same name for repeat runs
04:00:11 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:00:11   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:11   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.44
04:00:13 SQL> 
04:00:13 SQL> -- Build a new SVM Model
04:00:13 SQL> BEGIN
04:00:13   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:00:13   3  	  model_name	      => '&model_name',
04:00:13   4  	  mining_function     => dbms_data_mining.classification,
04:00:13   5  	  data_table_name     => 'svmc_build_prep',
04:00:13   6  	  case_id_column_name => '&case_id',
04:00:13   7  	  target_column_name  => '&target',
04:00:13   8  	  settings_table_name => 'svmc_settings');
04:00:13   9  END;
04:00:13  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.05
04:00:18 SQL> 
04:00:18 SQL> -----------------------------------------------------------------------
04:00:18 SQL> --			       APPLY/score THE MODEL
04:00:18 SQL> -----------------------------------------------------------------------
04:00:18 SQL> 
04:00:18 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:18 SQL> -----------------------
04:00:18 SQL> -- PREPARE SCORING DATA
04:00:18 SQL> --
04:00:18 SQL> -- If the data for model creation has been prepared, then the data
04:00:18 SQL> -- to be scored using the model must be prepared in the same manner
04:00:18 SQL> -- in order to obtain meaningful results.
04:00:18 SQL> --
04:00:18 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:18 SQL> -- 2. Normalization
04:00:18 SQL> -- No outlier treatment will be performed during test and apply. The
04:00:18 SQL> -- normalization step is sufficient, since the normalization parameters
04:00:18 SQL> -- already capture the effects of outlier treatment done with build data.
04:00:18 SQL> --
04:00:18 SQL> BEGIN
04:00:18   2  	-- Xform Test data to replace missing values
04:00:18   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:18   4  	  miss_table_name => 'svmc_miss_num',
04:00:18   5  	  data_table_name => '&scoretable',
04:00:18   6  	  xform_view_name => 'xformed_apply_miss_num');
04:00:18   7  
04:00:18   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:18   9  	  miss_table_name => 'svmc_miss_cat',
04:00:18  10  	  data_table_name => '&scoretable',
04:00:18  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:00:18  12  
04:00:18  13  	-- Normalize the data to be scored
04:00:18  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:18  15  	  norm_table_name => 'svmc_norm',
04:00:18  16  	  data_table_name => '&scoretable',
04:00:18  17  	  xform_view_name => 'svmc_apply_prep');
04:00:18  18  END;
04:00:18  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
04:00:18 SQL> 
04:00:18 SQL> -- Maybe I already collected a score for this prdate.
04:00:18 SQL> -- DELETE it if I did:
04:00:18 SQL> DELETE svm24scores
04:00:18   2  WHERE score > 0
04:00:18   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:00:18   4  -- I need to supply the target attribute name:
04:00:18   5  AND targ = '&1'
04:00:18   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
04:00:18 SQL> 
04:00:18 SQL> -- We do a drumroll here:
04:00:18 SQL> 
04:00:18 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:00:18   2  SELECT
04:00:18   3  prdate
04:00:18   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:00:18   5  ,sysdate
04:00:18   6  ,SUBSTR(prdate,1,7)pair
04:00:18   7  ,SUBSTR(prdate,-19)ydate
04:00:18   8  ,'&1'
04:00:18   9  FROM svmc_apply_prep
04:00:18  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
04:00:18 SQL> @score1_5min.sql	      2011-01-25 23:10:00 eur_usd
04:00:18 SQL> --
04:00:18 SQL> -- score1_5min.sql
04:00:18 SQL> --
04:00:18 SQL> 
04:00:18 SQL> -- Demo:
04:00:18 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
04:00:18 SQL> 
04:00:18 SQL> CREATE OR REPLACE VIEW sme AS
04:00:18   2  SELECT
04:00:18   3  prdate
04:00:18   4  ,NULL gatt
04:00:18   5  ,g00
04:00:18   6  ,g01
04:00:18   7  ,g02
04:00:18   8  ,g03
04:00:18   9  ,g04
04:00:18  10  ,g05
04:00:18  11  ,g06
04:00:18  12  ,g07
04:00:18  13  ,g08
04:00:18  14  ,g09
04:00:18  15  ,g10
04:00:18  16  ,g11
04:00:18  17  ,g12
04:00:18  18  ,g13
04:00:18  19  ,g14
04:00:18  20  ,g15
04:00:18  21  ,g16
04:00:18  22  ,g17
04:00:18  23  ,g18
04:00:18  24  ,g19
04:00:18  25  ,g20
04:00:18  26  ,g21
04:00:18  27  ,g22
04:00:18  28  ,g23
04:00:18  29  ,g24
04:00:18  30  ,g25
04:00:18  31  ,g26
04:00:18  32  ,g27
04:00:18  33  ,g28
04:00:18  34  ,g29
04:00:18  35  ,g30
04:00:18  36  ,g31
04:00:18  37  ,g32
04:00:18  38  ,g33
04:00:18  39  ,g34
04:00:18  40  ,g35
04:00:18  41  ,g36
04:00:18  42  ,g37
04:00:18  43  ,g38
04:00:18  44  ,g39
04:00:18  45  ,g40
04:00:18  46  ,g41
04:00:18  47  ,s.sc_corr
04:00:18  48  FROM modsrc24
04:00:18  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:00:18  50  WHERE ydate = '&1'||' '||'&2'
04:00:18  51  AND pair = '&3'
04:00:18  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'23:10:00'AND ydate<'2011-01-25'||' '||'23:10:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'23:10:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
04:00:18 SQL> 
04:00:18 SQL> -- rpt
04:00:18 SQL> -- We should see just 1 row:
04:00:18 SQL> 
04:00:18 SQL> SELECT COUNT(prdate) FROM sme
04:00:18   2  
04:00:18 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:00:18   2  
04:00:18 SQL> 
04:00:18 SQL> -- Build the model:
04:00:18 SQL> CREATE OR REPLACE VIEW bme AS
04:00:18   2  SELECT
04:00:18   3  prdate
04:00:18   4  ,gatt
04:00:18   5  ,g00
04:00:18   6  ,g01
04:00:18   7  ,g02
04:00:18   8  ,g03
04:00:18   9  ,g04
04:00:18  10  ,g05
04:00:18  11  ,g06
04:00:18  12  ,g07
04:00:18  13  ,g08
04:00:18  14  ,g09
04:00:18  15  ,g10
04:00:18  16  ,g11
04:00:18  17  ,g12
04:00:18  18  ,g13
04:00:18  19  ,g14
04:00:18  20  ,g15
04:00:18  21  ,g16
04:00:18  22  ,g17
04:00:18  23  ,g18
04:00:18  24  ,g19
04:00:18  25  ,g20
04:00:18  26  ,g21
04:00:18  27  ,g22
04:00:18  28  ,g23
04:00:18  29  ,g24
04:00:18  30  ,g25
04:00:18  31  ,g26
04:00:18  32  ,g27
04:00:18  33  ,g28
04:00:18  34  ,g29
04:00:18  35  ,g30
04:00:18  36  ,g31
04:00:18  37  ,g32
04:00:18  38  ,g33
04:00:18  39  ,g34
04:00:18  40  ,g35
04:00:18  41  ,g36
04:00:18  42  ,g37
04:00:18  43  ,g38
04:00:18  44  ,g39
04:00:18  45  ,g40
04:00:18  46  ,g41
04:00:18  47  ,sc_corr
04:00:18  48  FROM modsrc24
04:00:18  49  WHERE gatt IN('nup','up')
04:00:18  50  -- Use only rows which are older than 1 day:
04:00:18  51  AND 1+ydate < '&1'||' '||'&2'
04:00:18  52  AND pair = '&3'
04:00:18  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'23:10:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
04:00:18 SQL> 
04:00:18 SQL> -- rpt
04:00:18 SQL> 
04:00:18 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
04:00:18   2  
04:00:18 SQL> SELECT MAX(prdate) FROM bme
04:00:18   2  
04:00:18 SQL> -- Now build model from bme and score sme
04:00:18 SQL> @score1.sql gatt
04:00:18 SQL> --
04:00:18 SQL> -- score1.sql
04:00:18 SQL> --
04:00:18 SQL> 
04:00:18 SQL> -- I use this script to send 5 params to score.sql
04:00:18 SQL> -- which does the heavy lifting of creating an SVM model.
04:00:18 SQL> -- Then at the very end of this script I use the model
04:00:18 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:00:18 SQL> 
04:00:18 SQL> -- I call this script from 2 other scripts:
04:00:18 SQL> -- score1_5min.sql
04:00:18 SQL> -- score1_5min_gattn.sql
04:00:18 SQL> 
04:00:18 SQL> -- The 1st param is the name of the target attribute.
04:00:18 SQL> -- I like to call my target attributes either gatt or gattn.
04:00:18 SQL> 
04:00:18 SQL> -- Demo:
04:00:18 SQL> -- @score1.sql 'gatt'
04:00:18 SQL> -- @score1.sql 'gattn'
04:00:18 SQL> 
04:00:18 SQL> -- Now, I fill up svmc_apply_prep.
04:00:18 SQL> -- I use same model_name used in score.sql
04:00:18 SQL> DEFINE model_name = 'svmfx101'
04:00:18 SQL> DEFINE bldtable	= 'bme'
04:00:18 SQL> DEFINE scoretable = 'sme'
04:00:18 SQL> DEFINE case_id	= 'prdate'
04:00:18 SQL> -- Demo:
04:00:18 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:00:18 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:00:18 SQL> --
04:00:18 SQL> -- score.sql
04:00:18 SQL> --
04:00:18 SQL> 
04:00:18 SQL> -- usage: score.sql
04:00:18 SQL> 
04:00:18 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:00:18 SQL> 
04:00:18 SQL> -- DEFINE target	   = 'gatt'
04:00:18 SQL> -- DEFINE model_name = 'svmfx101'
04:00:18 SQL> -- DEFINE bldtable   = 'bme'
04:00:18 SQL> -- DEFINE scoretable = 'sme'
04:00:18 SQL> -- DEFINE case_id    = 'prdate'
04:00:18 SQL> 
04:00:18 SQL> DEFINE target	= '&1'
04:00:18 SQL> DEFINE model_name = '&2'
04:00:18 SQL> DEFINE bldtable	= '&3'
04:00:18 SQL> DEFINE scoretable = '&4'
04:00:18 SQL> DEFINE case_id	= '&5'
04:00:18 SQL> 
04:00:18 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:00:18 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:00:18 SQL> 
04:00:18 SQL> -- Builds an SVM model using pl/sql.
04:00:18 SQL> 
04:00:18 SQL> -----------------------------------------------------------------------
04:00:18 SQL> --			    BUILD THE MODEL
04:00:18 SQL> -----------------------------------------------------------------------
04:00:18 SQL> 
04:00:18 SQL> -- Cleanup old build data preparation objects for repeat runs
04:00:18 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:18 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
04:00:18 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:18 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:00:18 SQL> 
04:00:18 SQL> 
04:00:18 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:00:18 SQL> --
04:00:18 SQL> -- DROP	TABLE svmc_settings ;
04:00:18 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:00:18 SQL> -- DELETE svmc_settings;
04:00:18 SQL> 
04:00:18 SQL> -- The default classification algorithm is Naive Bayes. So override
04:00:18 SQL> -- this choice to SVM using a settings table.
04:00:18 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:00:18 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:00:18 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:00:18 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:00:18 SQL> -- models.
04:00:18 SQL> --
04:00:18 SQL> 
04:00:18 SQL> -- Do this once and then comment it out.
04:00:18 SQL> -- That makes script go faster.
04:00:18 SQL> -- BEGIN
04:00:18 SQL> -- -- Populate settings table
04:00:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:18 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:00:18 SQL> --
04:00:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:18 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:00:18 SQL> --
04:00:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:18 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:00:18 SQL> --   COMMIT;
04:00:18 SQL> -- END;
04:00:18 SQL> -- /
04:00:18 SQL> 
04:00:18 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:00:18 SQL> 
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:18 SQL> 
04:00:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:00:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:19 SQL> 
04:00:19 SQL> --------------------------------
04:00:19 SQL> -- PREPARE BUILD (TRAINING) DATA
04:00:19 SQL> --
04:00:19 SQL> 
04:00:19 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:19 SQL> -- 2. Outlier Treatment and
04:00:19 SQL> -- 3. Normalization are performed below.
04:00:19 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:00:19 SQL> --    normalized here.
04:00:19 SQL> 
04:00:19 SQL> BEGIN
04:00:19   2  	-- Perform missing value treatment for all predictors
04:00:19   3  	-- create miss tables
04:00:19   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:00:19   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:00:19   6  
04:00:19   7  	-- populate miss tables
04:00:19   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:00:19   9  	  miss_table_name => 'svmc_miss_num',
04:00:19  10  	  data_table_name => '&bldtable',
04:00:19  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:19  12  
04:00:19  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:00:19  14  	  miss_table_name => 'svmc_miss_cat',
04:00:19  15  	  data_table_name => '&bldtable',
04:00:19  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:19  17  
04:00:19  18  	-- xform input data to replace missing values
04:00:19  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:19  20  	  miss_table_name => 'svmc_miss_num',
04:00:19  21  	  data_table_name => '&bldtable',
04:00:19  22  	  xform_view_name => 'xformed_build_miss_num');
04:00:19  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:19  24  	  miss_table_name => 'svmc_miss_cat',
04:00:19  25  	  data_table_name => '&bldtable',
04:00:19  26  	  xform_view_name => 'xformed_build_miss_cat');
04:00:19  27  
04:00:19  28  	-- Perform outlier treatment.
04:00:19  29  	-- create clip table
04:00:19  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:00:19  31  
04:00:19  32  	-- populate clip table
04:00:19  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:00:19  34  	  clip_table_name => 'svmc_clip',
04:00:19  35  	  data_table_name => '&bldtable',
04:00:19  36  	  tail_frac	  => 0.025,
04:00:19  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:19  38  
04:00:19  39  	-- xform input data to winsorized data
04:00:19  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:00:19  41  	  clip_table_name => 'svmc_clip',
04:00:19  42  	  data_table_name => '&bldtable',
04:00:19  43  	  xform_view_name => 'svmc_winsor');
04:00:19  44  
04:00:19  45  	-- create normalization table
04:00:19  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:00:19  47  
04:00:19  48  	-- populate normalization table based on winsorized data
04:00:19  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:00:19  50  	  norm_table_name => 'svmc_norm',
04:00:19  51  	  data_table_name => 'svmc_winsor',
04:00:19  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:19  53  
04:00:19  54  	-- normalize the original data
04:00:19  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:19  56  	  norm_table_name => 'svmc_norm',
04:00:19  57  	  data_table_name => '&bldtable',
04:00:19  58  	  xform_view_name => 'svmc_build_prep');
04:00:19  59  END;
04:00:19  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.62
04:00:21 SQL> 
04:00:21 SQL> ---------------------
04:00:21 SQL> -- CREATE A NEW MODEL
04:00:21 SQL> --
04:00:21 SQL> -- Cleanup old model with the same name for repeat runs
04:00:21 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:00:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:21   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.64
04:00:23 SQL> 
04:00:23 SQL> -- Build a new SVM Model
04:00:23 SQL> BEGIN
04:00:23   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:00:23   3  	  model_name	      => '&model_name',
04:00:23   4  	  mining_function     => dbms_data_mining.classification,
04:00:23   5  	  data_table_name     => 'svmc_build_prep',
04:00:23   6  	  case_id_column_name => '&case_id',
04:00:23   7  	  target_column_name  => '&target',
04:00:23   8  	  settings_table_name => 'svmc_settings');
04:00:23   9  END;
04:00:23  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.21
04:00:28 SQL> 
04:00:28 SQL> -----------------------------------------------------------------------
04:00:28 SQL> --			       APPLY/score THE MODEL
04:00:28 SQL> -----------------------------------------------------------------------
04:00:28 SQL> 
04:00:28 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:00:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:00:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:00:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:00:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:28 SQL> -----------------------
04:00:28 SQL> -- PREPARE SCORING DATA
04:00:28 SQL> --
04:00:28 SQL> -- If the data for model creation has been prepared, then the data
04:00:28 SQL> -- to be scored using the model must be prepared in the same manner
04:00:28 SQL> -- in order to obtain meaningful results.
04:00:28 SQL> --
04:00:28 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:28 SQL> -- 2. Normalization
04:00:28 SQL> -- No outlier treatment will be performed during test and apply. The
04:00:28 SQL> -- normalization step is sufficient, since the normalization parameters
04:00:28 SQL> -- already capture the effects of outlier treatment done with build data.
04:00:28 SQL> --
04:00:28 SQL> BEGIN
04:00:28   2  	-- Xform Test data to replace missing values
04:00:28   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:28   4  	  miss_table_name => 'svmc_miss_num',
04:00:28   5  	  data_table_name => '&scoretable',
04:00:28   6  	  xform_view_name => 'xformed_apply_miss_num');
04:00:28   7  
04:00:28   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:28   9  	  miss_table_name => 'svmc_miss_cat',
04:00:28  10  	  data_table_name => '&scoretable',
04:00:28  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:00:28  12  
04:00:28  13  	-- Normalize the data to be scored
04:00:28  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:28  15  	  norm_table_name => 'svmc_norm',
04:00:28  16  	  data_table_name => '&scoretable',
04:00:28  17  	  xform_view_name => 'svmc_apply_prep');
04:00:28  18  END;
04:00:28  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:00:28 SQL> 
04:00:28 SQL> -- Maybe I already collected a score for this prdate.
04:00:28 SQL> -- DELETE it if I did:
04:00:28 SQL> DELETE svm24scores
04:00:28   2  WHERE score > 0
04:00:28   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:00:28   4  -- I need to supply the target attribute name:
04:00:28   5  AND targ = '&1'
04:00:28   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
04:00:28 SQL> 
04:00:28 SQL> -- We do a drumroll here:
04:00:28 SQL> 
04:00:28 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:00:28   2  SELECT
04:00:28   3  prdate
04:00:28   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:00:28   5  ,sysdate
04:00:28   6  ,SUBSTR(prdate,1,7)pair
04:00:28   7  ,SUBSTR(prdate,-19)ydate
04:00:28   8  ,'&1'
04:00:28   9  FROM svmc_apply_prep
04:00:28  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.07
04:00:28 SQL> @score1_5min_gattn.sql	2011-01-20 11:05:00 eur_usd
04:00:28 SQL> --
04:00:28 SQL> -- score1_5min_gattn.sql
04:00:28 SQL> --
04:00:28 SQL> 
04:00:28 SQL> -- Demo:
04:00:28 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:00:28 SQL> 
04:00:28 SQL> CREATE OR REPLACE VIEW sme AS
04:00:28   2  SELECT
04:00:28   3  prdate
04:00:28   4  ,NULL gattn
04:00:28   5  ,g00
04:00:28   6  ,g01
04:00:28   7  ,g02
04:00:28   8  ,g03
04:00:28   9  ,g04
04:00:28  10  ,g05
04:00:28  11  ,g06
04:00:28  12  ,g07
04:00:28  13  ,g08
04:00:28  14  ,g09
04:00:28  15  ,g10
04:00:28  16  ,g11
04:00:28  17  ,g12
04:00:28  18  ,g13
04:00:28  19  ,g14
04:00:28  20  ,g15
04:00:28  21  ,g16
04:00:28  22  ,g17
04:00:28  23  ,g18
04:00:28  24  ,g19
04:00:28  25  ,g20
04:00:28  26  ,g21
04:00:28  27  ,g22
04:00:28  28  ,g23
04:00:28  29  ,g24
04:00:28  30  ,g25
04:00:28  31  ,g26
04:00:28  32  ,g27
04:00:28  33  ,g28
04:00:28  34  ,g29
04:00:28  35  ,g30
04:00:28  36  ,g31
04:00:28  37  ,g32
04:00:28  38  ,g33
04:00:28  39  ,g34
04:00:28  40  ,g35
04:00:28  41  ,g36
04:00:28  42  ,g37
04:00:28  43  ,g38
04:00:28  44  ,g39
04:00:28  45  ,g40
04:00:28  46  ,g41
04:00:28  47  ,s.sc_corr
04:00:28  48  FROM modsrc24
04:00:28  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:00:28  50  WHERE ydate = '&1'||' '||'&2'
04:00:28  51  AND pair = '&3'
04:00:28  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'11:05:00'AND ydate<'2011-01-20'||' '||'11:05:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'11:05:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:00:28 SQL> 
04:00:28 SQL> -- rpt
04:00:28 SQL> -- We should see just 1 row:
04:00:28 SQL> 
04:00:28 SQL> SELECT COUNT(prdate) FROM sme
04:00:28   2  
04:00:28 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:00:28   2  
04:00:28 SQL> 
04:00:28 SQL> -- Build the model:
04:00:28 SQL> CREATE OR REPLACE VIEW bme AS
04:00:28   2  SELECT
04:00:28   3  prdate
04:00:28   4  ,gattn
04:00:28   5  ,g00
04:00:28   6  ,g01
04:00:28   7  ,g02
04:00:28   8  ,g03
04:00:28   9  ,g04
04:00:28  10  ,g05
04:00:28  11  ,g06
04:00:28  12  ,g07
04:00:28  13  ,g08
04:00:28  14  ,g09
04:00:28  15  ,g10
04:00:28  16  ,g11
04:00:28  17  ,g12
04:00:28  18  ,g13
04:00:28  19  ,g14
04:00:28  20  ,g15
04:00:28  21  ,g16
04:00:28  22  ,g17
04:00:28  23  ,g18
04:00:28  24  ,g19
04:00:28  25  ,g20
04:00:28  26  ,g21
04:00:28  27  ,g22
04:00:28  28  ,g23
04:00:28  29  ,g24
04:00:28  30  ,g25
04:00:28  31  ,g26
04:00:28  32  ,g27
04:00:28  33  ,g28
04:00:28  34  ,g29
04:00:28  35  ,g30
04:00:28  36  ,g31
04:00:28  37  ,g32
04:00:28  38  ,g33
04:00:28  39  ,g34
04:00:28  40  ,g35
04:00:28  41  ,g36
04:00:28  42  ,g37
04:00:28  43  ,g38
04:00:28  44  ,g39
04:00:28  45  ,g40
04:00:28  46  ,g41
04:00:28  47  ,sc_corr
04:00:28  48  FROM modsrc24
04:00:28  49  WHERE gattn IN('nup','up')
04:00:28  50  -- Use only rows which are older than 1 day:
04:00:28  51  AND 1+ydate < '&1'||' '||'&2'
04:00:28  52  AND pair = '&3'
04:00:28  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'11:05:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:00:29 SQL> 
04:00:29 SQL> -- rpt
04:00:29 SQL> 
04:00:29 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:00:29   2  
04:00:29 SQL> SELECT MAX(prdate) FROM bme
04:00:29   2  
04:00:29 SQL> -- Now build model from bme and score sme
04:00:29 SQL> @score1.sql gattn
04:00:29 SQL> --
04:00:29 SQL> -- score1.sql
04:00:29 SQL> --
04:00:29 SQL> 
04:00:29 SQL> -- I use this script to send 5 params to score.sql
04:00:29 SQL> -- which does the heavy lifting of creating an SVM model.
04:00:29 SQL> -- Then at the very end of this script I use the model
04:00:29 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:00:29 SQL> 
04:00:29 SQL> -- I call this script from 2 other scripts:
04:00:29 SQL> -- score1_5min.sql
04:00:29 SQL> -- score1_5min_gattn.sql
04:00:29 SQL> 
04:00:29 SQL> -- The 1st param is the name of the target attribute.
04:00:29 SQL> -- I like to call my target attributes either gatt or gattn.
04:00:29 SQL> 
04:00:29 SQL> -- Demo:
04:00:29 SQL> -- @score1.sql 'gatt'
04:00:29 SQL> -- @score1.sql 'gattn'
04:00:29 SQL> 
04:00:29 SQL> -- Now, I fill up svmc_apply_prep.
04:00:29 SQL> -- I use same model_name used in score.sql
04:00:29 SQL> DEFINE model_name = 'svmfx101'
04:00:29 SQL> DEFINE bldtable	= 'bme'
04:00:29 SQL> DEFINE scoretable = 'sme'
04:00:29 SQL> DEFINE case_id	= 'prdate'
04:00:29 SQL> -- Demo:
04:00:29 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:00:29 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:00:29 SQL> --
04:00:29 SQL> -- score.sql
04:00:29 SQL> --
04:00:29 SQL> 
04:00:29 SQL> -- usage: score.sql
04:00:29 SQL> 
04:00:29 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:00:29 SQL> 
04:00:29 SQL> -- DEFINE target	   = 'gatt'
04:00:29 SQL> -- DEFINE model_name = 'svmfx101'
04:00:29 SQL> -- DEFINE bldtable   = 'bme'
04:00:29 SQL> -- DEFINE scoretable = 'sme'
04:00:29 SQL> -- DEFINE case_id    = 'prdate'
04:00:29 SQL> 
04:00:29 SQL> DEFINE target	= '&1'
04:00:29 SQL> DEFINE model_name = '&2'
04:00:29 SQL> DEFINE bldtable	= '&3'
04:00:29 SQL> DEFINE scoretable = '&4'
04:00:29 SQL> DEFINE case_id	= '&5'
04:00:29 SQL> 
04:00:29 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:00:29 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:00:29 SQL> 
04:00:29 SQL> -- Builds an SVM model using pl/sql.
04:00:29 SQL> 
04:00:29 SQL> -----------------------------------------------------------------------
04:00:29 SQL> --			    BUILD THE MODEL
04:00:29 SQL> -----------------------------------------------------------------------
04:00:29 SQL> 
04:00:29 SQL> -- Cleanup old build data preparation objects for repeat runs
04:00:29 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:29 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:00:29 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:00:29 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:00:29 SQL> 
04:00:29 SQL> 
04:00:29 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:00:29 SQL> --
04:00:29 SQL> -- DROP	TABLE svmc_settings ;
04:00:29 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:00:29 SQL> -- DELETE svmc_settings;
04:00:29 SQL> 
04:00:29 SQL> -- The default classification algorithm is Naive Bayes. So override
04:00:29 SQL> -- this choice to SVM using a settings table.
04:00:29 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:00:29 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:00:29 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:00:29 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:00:29 SQL> -- models.
04:00:29 SQL> --
04:00:29 SQL> 
04:00:29 SQL> -- Do this once and then comment it out.
04:00:29 SQL> -- That makes script go faster.
04:00:29 SQL> -- BEGIN
04:00:29 SQL> -- -- Populate settings table
04:00:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:29 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:00:29 SQL> --
04:00:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:29 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:00:29 SQL> --
04:00:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:29 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:00:29 SQL> --   COMMIT;
04:00:29 SQL> -- END;
04:00:29 SQL> -- /
04:00:29 SQL> 
04:00:29 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:00:29 SQL> 
04:00:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:00:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:00:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:00:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:29 SQL> 
04:00:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:00:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:29 SQL> 
04:00:29 SQL> --------------------------------
04:00:29 SQL> -- PREPARE BUILD (TRAINING) DATA
04:00:29 SQL> --
04:00:29 SQL> 
04:00:29 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:29 SQL> -- 2. Outlier Treatment and
04:00:29 SQL> -- 3. Normalization are performed below.
04:00:29 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:00:29 SQL> --    normalized here.
04:00:29 SQL> 
04:00:29 SQL> BEGIN
04:00:29   2  	-- Perform missing value treatment for all predictors
04:00:29   3  	-- create miss tables
04:00:29   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:00:29   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:00:29   6  
04:00:29   7  	-- populate miss tables
04:00:29   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:00:29   9  	  miss_table_name => 'svmc_miss_num',
04:00:29  10  	  data_table_name => '&bldtable',
04:00:29  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:29  12  
04:00:29  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:00:29  14  	  miss_table_name => 'svmc_miss_cat',
04:00:29  15  	  data_table_name => '&bldtable',
04:00:29  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:29  17  
04:00:29  18  	-- xform input data to replace missing values
04:00:29  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:29  20  	  miss_table_name => 'svmc_miss_num',
04:00:29  21  	  data_table_name => '&bldtable',
04:00:29  22  	  xform_view_name => 'xformed_build_miss_num');
04:00:29  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:29  24  	  miss_table_name => 'svmc_miss_cat',
04:00:29  25  	  data_table_name => '&bldtable',
04:00:29  26  	  xform_view_name => 'xformed_build_miss_cat');
04:00:29  27  
04:00:29  28  	-- Perform outlier treatment.
04:00:29  29  	-- create clip table
04:00:29  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:00:29  31  
04:00:29  32  	-- populate clip table
04:00:29  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:00:29  34  	  clip_table_name => 'svmc_clip',
04:00:29  35  	  data_table_name => '&bldtable',
04:00:29  36  	  tail_frac	  => 0.025,
04:00:29  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:29  38  
04:00:29  39  	-- xform input data to winsorized data
04:00:29  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:00:29  41  	  clip_table_name => 'svmc_clip',
04:00:29  42  	  data_table_name => '&bldtable',
04:00:29  43  	  xform_view_name => 'svmc_winsor');
04:00:29  44  
04:00:29  45  	-- create normalization table
04:00:29  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:00:29  47  
04:00:29  48  	-- populate normalization table based on winsorized data
04:00:29  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:00:29  50  	  norm_table_name => 'svmc_norm',
04:00:29  51  	  data_table_name => 'svmc_winsor',
04:00:29  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:29  53  
04:00:29  54  	-- normalize the original data
04:00:29  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:29  56  	  norm_table_name => 'svmc_norm',
04:00:29  57  	  data_table_name => '&bldtable',
04:00:29  58  	  xform_view_name => 'svmc_build_prep');
04:00:29  59  END;
04:00:29  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
04:00:31 SQL> 
04:00:31 SQL> ---------------------
04:00:31 SQL> -- CREATE A NEW MODEL
04:00:31 SQL> --
04:00:31 SQL> -- Cleanup old model with the same name for repeat runs
04:00:31 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:00:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:31   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.48
04:00:33 SQL> 
04:00:33 SQL> -- Build a new SVM Model
04:00:33 SQL> BEGIN
04:00:33   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:00:33   3  	  model_name	      => '&model_name',
04:00:33   4  	  mining_function     => dbms_data_mining.classification,
04:00:33   5  	  data_table_name     => 'svmc_build_prep',
04:00:33   6  	  case_id_column_name => '&case_id',
04:00:33   7  	  target_column_name  => '&target',
04:00:33   8  	  settings_table_name => 'svmc_settings');
04:00:33   9  END;
04:00:33  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.45
04:00:38 SQL> 
04:00:38 SQL> -----------------------------------------------------------------------
04:00:38 SQL> --			       APPLY/score THE MODEL
04:00:38 SQL> -----------------------------------------------------------------------
04:00:38 SQL> 
04:00:38 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:00:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:00:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:00:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:00:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:38 SQL> -----------------------
04:00:38 SQL> -- PREPARE SCORING DATA
04:00:38 SQL> --
04:00:38 SQL> -- If the data for model creation has been prepared, then the data
04:00:38 SQL> -- to be scored using the model must be prepared in the same manner
04:00:38 SQL> -- in order to obtain meaningful results.
04:00:38 SQL> --
04:00:38 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:38 SQL> -- 2. Normalization
04:00:38 SQL> -- No outlier treatment will be performed during test and apply. The
04:00:38 SQL> -- normalization step is sufficient, since the normalization parameters
04:00:38 SQL> -- already capture the effects of outlier treatment done with build data.
04:00:38 SQL> --
04:00:38 SQL> BEGIN
04:00:38   2  	-- Xform Test data to replace missing values
04:00:38   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:38   4  	  miss_table_name => 'svmc_miss_num',
04:00:38   5  	  data_table_name => '&scoretable',
04:00:38   6  	  xform_view_name => 'xformed_apply_miss_num');
04:00:38   7  
04:00:38   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:38   9  	  miss_table_name => 'svmc_miss_cat',
04:00:38  10  	  data_table_name => '&scoretable',
04:00:38  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:00:38  12  
04:00:38  13  	-- Normalize the data to be scored
04:00:38  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:38  15  	  norm_table_name => 'svmc_norm',
04:00:38  16  	  data_table_name => '&scoretable',
04:00:38  17  	  xform_view_name => 'svmc_apply_prep');
04:00:38  18  END;
04:00:38  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:00:38 SQL> 
04:00:38 SQL> -- Maybe I already collected a score for this prdate.
04:00:38 SQL> -- DELETE it if I did:
04:00:38 SQL> DELETE svm24scores
04:00:38   2  WHERE score > 0
04:00:38   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:00:38   4  -- I need to supply the target attribute name:
04:00:38   5  AND targ = '&1'
04:00:38   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:00:39 SQL> 
04:00:39 SQL> -- We do a drumroll here:
04:00:39 SQL> 
04:00:39 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:00:39   2  SELECT
04:00:39   3  prdate
04:00:39   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:00:39   5  ,sysdate
04:00:39   6  ,SUBSTR(prdate,1,7)pair
04:00:39   7  ,SUBSTR(prdate,-19)ydate
04:00:39   8  ,'&1'
04:00:39   9  FROM svmc_apply_prep
04:00:39  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:00:39 SQL> @score1_5min_gattn.sql	2011-01-19 22:40:00 eur_usd
04:00:39 SQL> --
04:00:39 SQL> -- score1_5min_gattn.sql
04:00:39 SQL> --
04:00:39 SQL> 
04:00:39 SQL> -- Demo:
04:00:39 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:00:39 SQL> 
04:00:39 SQL> CREATE OR REPLACE VIEW sme AS
04:00:39   2  SELECT
04:00:39   3  prdate
04:00:39   4  ,NULL gattn
04:00:39   5  ,g00
04:00:39   6  ,g01
04:00:39   7  ,g02
04:00:39   8  ,g03
04:00:39   9  ,g04
04:00:39  10  ,g05
04:00:39  11  ,g06
04:00:39  12  ,g07
04:00:39  13  ,g08
04:00:39  14  ,g09
04:00:39  15  ,g10
04:00:39  16  ,g11
04:00:39  17  ,g12
04:00:39  18  ,g13
04:00:39  19  ,g14
04:00:39  20  ,g15
04:00:39  21  ,g16
04:00:39  22  ,g17
04:00:39  23  ,g18
04:00:39  24  ,g19
04:00:39  25  ,g20
04:00:39  26  ,g21
04:00:39  27  ,g22
04:00:39  28  ,g23
04:00:39  29  ,g24
04:00:39  30  ,g25
04:00:39  31  ,g26
04:00:39  32  ,g27
04:00:39  33  ,g28
04:00:39  34  ,g29
04:00:39  35  ,g30
04:00:39  36  ,g31
04:00:39  37  ,g32
04:00:39  38  ,g33
04:00:39  39  ,g34
04:00:39  40  ,g35
04:00:39  41  ,g36
04:00:39  42  ,g37
04:00:39  43  ,g38
04:00:39  44  ,g39
04:00:39  45  ,g40
04:00:39  46  ,g41
04:00:39  47  ,s.sc_corr
04:00:39  48  FROM modsrc24
04:00:39  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:00:39  50  WHERE ydate = '&1'||' '||'&2'
04:00:39  51  AND pair = '&3'
04:00:39  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-19'||' '||'22:40:00'AND ydate<'2011-01-19'||' '||'22:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-19'||' '||'22:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:00:39 SQL> 
04:00:39 SQL> -- rpt
04:00:39 SQL> -- We should see just 1 row:
04:00:39 SQL> 
04:00:39 SQL> SELECT COUNT(prdate) FROM sme
04:00:39   2  
04:00:39 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:00:39   2  
04:00:39 SQL> 
04:00:39 SQL> -- Build the model:
04:00:39 SQL> CREATE OR REPLACE VIEW bme AS
04:00:39   2  SELECT
04:00:39   3  prdate
04:00:39   4  ,gattn
04:00:39   5  ,g00
04:00:39   6  ,g01
04:00:39   7  ,g02
04:00:39   8  ,g03
04:00:39   9  ,g04
04:00:39  10  ,g05
04:00:39  11  ,g06
04:00:39  12  ,g07
04:00:39  13  ,g08
04:00:39  14  ,g09
04:00:39  15  ,g10
04:00:39  16  ,g11
04:00:39  17  ,g12
04:00:39  18  ,g13
04:00:39  19  ,g14
04:00:39  20  ,g15
04:00:39  21  ,g16
04:00:39  22  ,g17
04:00:39  23  ,g18
04:00:39  24  ,g19
04:00:39  25  ,g20
04:00:39  26  ,g21
04:00:39  27  ,g22
04:00:39  28  ,g23
04:00:39  29  ,g24
04:00:39  30  ,g25
04:00:39  31  ,g26
04:00:39  32  ,g27
04:00:39  33  ,g28
04:00:39  34  ,g29
04:00:39  35  ,g30
04:00:39  36  ,g31
04:00:39  37  ,g32
04:00:39  38  ,g33
04:00:39  39  ,g34
04:00:39  40  ,g35
04:00:39  41  ,g36
04:00:39  42  ,g37
04:00:39  43  ,g38
04:00:39  44  ,g39
04:00:39  45  ,g40
04:00:39  46  ,g41
04:00:39  47  ,sc_corr
04:00:39  48  FROM modsrc24
04:00:39  49  WHERE gattn IN('nup','up')
04:00:39  50  -- Use only rows which are older than 1 day:
04:00:39  51  AND 1+ydate < '&1'||' '||'&2'
04:00:39  52  AND pair = '&3'
04:00:39  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-19'||' '||'22:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
04:00:39 SQL> 
04:00:39 SQL> -- rpt
04:00:39 SQL> 
04:00:39 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:00:39   2  
04:00:39 SQL> SELECT MAX(prdate) FROM bme
04:00:39   2  
04:00:39 SQL> -- Now build model from bme and score sme
04:00:39 SQL> @score1.sql gattn
04:00:39 SQL> --
04:00:39 SQL> -- score1.sql
04:00:39 SQL> --
04:00:39 SQL> 
04:00:39 SQL> -- I use this script to send 5 params to score.sql
04:00:39 SQL> -- which does the heavy lifting of creating an SVM model.
04:00:39 SQL> -- Then at the very end of this script I use the model
04:00:39 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:00:39 SQL> 
04:00:39 SQL> -- I call this script from 2 other scripts:
04:00:39 SQL> -- score1_5min.sql
04:00:39 SQL> -- score1_5min_gattn.sql
04:00:39 SQL> 
04:00:39 SQL> -- The 1st param is the name of the target attribute.
04:00:39 SQL> -- I like to call my target attributes either gatt or gattn.
04:00:39 SQL> 
04:00:39 SQL> -- Demo:
04:00:39 SQL> -- @score1.sql 'gatt'
04:00:39 SQL> -- @score1.sql 'gattn'
04:00:39 SQL> 
04:00:39 SQL> -- Now, I fill up svmc_apply_prep.
04:00:39 SQL> -- I use same model_name used in score.sql
04:00:39 SQL> DEFINE model_name = 'svmfx101'
04:00:39 SQL> DEFINE bldtable	= 'bme'
04:00:39 SQL> DEFINE scoretable = 'sme'
04:00:39 SQL> DEFINE case_id	= 'prdate'
04:00:39 SQL> -- Demo:
04:00:39 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:00:39 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:00:39 SQL> --
04:00:39 SQL> -- score.sql
04:00:39 SQL> --
04:00:39 SQL> 
04:00:39 SQL> -- usage: score.sql
04:00:39 SQL> 
04:00:39 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:00:39 SQL> 
04:00:39 SQL> -- DEFINE target	   = 'gatt'
04:00:39 SQL> -- DEFINE model_name = 'svmfx101'
04:00:39 SQL> -- DEFINE bldtable   = 'bme'
04:00:39 SQL> -- DEFINE scoretable = 'sme'
04:00:39 SQL> -- DEFINE case_id    = 'prdate'
04:00:39 SQL> 
04:00:39 SQL> DEFINE target	= '&1'
04:00:39 SQL> DEFINE model_name = '&2'
04:00:39 SQL> DEFINE bldtable	= '&3'
04:00:39 SQL> DEFINE scoretable = '&4'
04:00:39 SQL> DEFINE case_id	= '&5'
04:00:39 SQL> 
04:00:39 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:00:39 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:00:39 SQL> 
04:00:39 SQL> -- Builds an SVM model using pl/sql.
04:00:39 SQL> 
04:00:39 SQL> -----------------------------------------------------------------------
04:00:39 SQL> --			    BUILD THE MODEL
04:00:39 SQL> -----------------------------------------------------------------------
04:00:39 SQL> 
04:00:39 SQL> -- Cleanup old build data preparation objects for repeat runs
04:00:39 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:39 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
04:00:39 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:39 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:00:39 SQL> 
04:00:39 SQL> 
04:00:39 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:00:39 SQL> --
04:00:39 SQL> -- DROP	TABLE svmc_settings ;
04:00:39 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:00:39 SQL> -- DELETE svmc_settings;
04:00:39 SQL> 
04:00:39 SQL> -- The default classification algorithm is Naive Bayes. So override
04:00:39 SQL> -- this choice to SVM using a settings table.
04:00:39 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:00:39 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:00:39 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:00:39 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:00:39 SQL> -- models.
04:00:39 SQL> --
04:00:39 SQL> 
04:00:39 SQL> -- Do this once and then comment it out.
04:00:39 SQL> -- That makes script go faster.
04:00:39 SQL> -- BEGIN
04:00:39 SQL> -- -- Populate settings table
04:00:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:39 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:00:39 SQL> --
04:00:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:39 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:00:39 SQL> --
04:00:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:39 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:00:39 SQL> --   COMMIT;
04:00:39 SQL> -- END;
04:00:39 SQL> -- /
04:00:39 SQL> 
04:00:39 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:00:39 SQL> 
04:00:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:00:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:00:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:00:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:39 SQL> 
04:00:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:00:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:39 SQL> 
04:00:39 SQL> --------------------------------
04:00:39 SQL> -- PREPARE BUILD (TRAINING) DATA
04:00:39 SQL> --
04:00:39 SQL> 
04:00:39 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:39 SQL> -- 2. Outlier Treatment and
04:00:39 SQL> -- 3. Normalization are performed below.
04:00:39 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:00:39 SQL> --    normalized here.
04:00:39 SQL> 
04:00:39 SQL> BEGIN
04:00:39   2  	-- Perform missing value treatment for all predictors
04:00:39   3  	-- create miss tables
04:00:39   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:00:39   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:00:39   6  
04:00:39   7  	-- populate miss tables
04:00:39   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:00:39   9  	  miss_table_name => 'svmc_miss_num',
04:00:39  10  	  data_table_name => '&bldtable',
04:00:39  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:39  12  
04:00:39  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:00:39  14  	  miss_table_name => 'svmc_miss_cat',
04:00:39  15  	  data_table_name => '&bldtable',
04:00:39  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:39  17  
04:00:39  18  	-- xform input data to replace missing values
04:00:39  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:39  20  	  miss_table_name => 'svmc_miss_num',
04:00:39  21  	  data_table_name => '&bldtable',
04:00:39  22  	  xform_view_name => 'xformed_build_miss_num');
04:00:39  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:39  24  	  miss_table_name => 'svmc_miss_cat',
04:00:39  25  	  data_table_name => '&bldtable',
04:00:39  26  	  xform_view_name => 'xformed_build_miss_cat');
04:00:39  27  
04:00:39  28  	-- Perform outlier treatment.
04:00:39  29  	-- create clip table
04:00:39  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:00:39  31  
04:00:39  32  	-- populate clip table
04:00:39  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:00:39  34  	  clip_table_name => 'svmc_clip',
04:00:39  35  	  data_table_name => '&bldtable',
04:00:39  36  	  tail_frac	  => 0.025,
04:00:39  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:39  38  
04:00:39  39  	-- xform input data to winsorized data
04:00:39  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:00:39  41  	  clip_table_name => 'svmc_clip',
04:00:39  42  	  data_table_name => '&bldtable',
04:00:39  43  	  xform_view_name => 'svmc_winsor');
04:00:39  44  
04:00:39  45  	-- create normalization table
04:00:39  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:00:39  47  
04:00:39  48  	-- populate normalization table based on winsorized data
04:00:39  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:00:39  50  	  norm_table_name => 'svmc_norm',
04:00:39  51  	  data_table_name => 'svmc_winsor',
04:00:39  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:39  53  
04:00:39  54  	-- normalize the original data
04:00:39  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:39  56  	  norm_table_name => 'svmc_norm',
04:00:39  57  	  data_table_name => '&bldtable',
04:00:39  58  	  xform_view_name => 'svmc_build_prep');
04:00:39  59  END;
04:00:39  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.54
04:00:41 SQL> 
04:00:41 SQL> ---------------------
04:00:41 SQL> -- CREATE A NEW MODEL
04:00:41 SQL> --
04:00:41 SQL> -- Cleanup old model with the same name for repeat runs
04:00:41 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:00:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:41   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.49
04:00:43 SQL> 
04:00:43 SQL> -- Build a new SVM Model
04:00:43 SQL> BEGIN
04:00:43   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:00:43   3  	  model_name	      => '&model_name',
04:00:43   4  	  mining_function     => dbms_data_mining.classification,
04:00:43   5  	  data_table_name     => 'svmc_build_prep',
04:00:43   6  	  case_id_column_name => '&case_id',
04:00:43   7  	  target_column_name  => '&target',
04:00:43   8  	  settings_table_name => 'svmc_settings');
04:00:43   9  END;
04:00:43  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.94
04:00:48 SQL> 
04:00:48 SQL> -----------------------------------------------------------------------
04:00:48 SQL> --			       APPLY/score THE MODEL
04:00:48 SQL> -----------------------------------------------------------------------
04:00:48 SQL> 
04:00:48 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:48 SQL> -----------------------
04:00:48 SQL> -- PREPARE SCORING DATA
04:00:48 SQL> --
04:00:48 SQL> -- If the data for model creation has been prepared, then the data
04:00:48 SQL> -- to be scored using the model must be prepared in the same manner
04:00:48 SQL> -- in order to obtain meaningful results.
04:00:48 SQL> --
04:00:48 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:48 SQL> -- 2. Normalization
04:00:48 SQL> -- No outlier treatment will be performed during test and apply. The
04:00:48 SQL> -- normalization step is sufficient, since the normalization parameters
04:00:48 SQL> -- already capture the effects of outlier treatment done with build data.
04:00:48 SQL> --
04:00:48 SQL> BEGIN
04:00:48   2  	-- Xform Test data to replace missing values
04:00:48   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:48   4  	  miss_table_name => 'svmc_miss_num',
04:00:48   5  	  data_table_name => '&scoretable',
04:00:48   6  	  xform_view_name => 'xformed_apply_miss_num');
04:00:48   7  
04:00:48   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:48   9  	  miss_table_name => 'svmc_miss_cat',
04:00:48  10  	  data_table_name => '&scoretable',
04:00:48  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:00:48  12  
04:00:48  13  	-- Normalize the data to be scored
04:00:48  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:48  15  	  norm_table_name => 'svmc_norm',
04:00:48  16  	  data_table_name => '&scoretable',
04:00:48  17  	  xform_view_name => 'svmc_apply_prep');
04:00:48  18  END;
04:00:48  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
04:00:48 SQL> 
04:00:48 SQL> -- Maybe I already collected a score for this prdate.
04:00:48 SQL> -- DELETE it if I did:
04:00:48 SQL> DELETE svm24scores
04:00:48   2  WHERE score > 0
04:00:48   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:00:48   4  -- I need to supply the target attribute name:
04:00:48   5  AND targ = '&1'
04:00:48   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
04:00:48 SQL> 
04:00:48 SQL> -- We do a drumroll here:
04:00:48 SQL> 
04:00:48 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:00:48   2  SELECT
04:00:48   3  prdate
04:00:48   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:00:48   5  ,sysdate
04:00:48   6  ,SUBSTR(prdate,1,7)pair
04:00:48   7  ,SUBSTR(prdate,-19)ydate
04:00:48   8  ,'&1'
04:00:48   9  FROM svmc_apply_prep
04:00:48  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:00:48 SQL> @score1_5min_gattn.sql	2011-01-24 16:00:00 eur_usd
04:00:48 SQL> --
04:00:48 SQL> -- score1_5min_gattn.sql
04:00:48 SQL> --
04:00:48 SQL> 
04:00:48 SQL> -- Demo:
04:00:48 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:00:48 SQL> 
04:00:48 SQL> CREATE OR REPLACE VIEW sme AS
04:00:48   2  SELECT
04:00:48   3  prdate
04:00:48   4  ,NULL gattn
04:00:48   5  ,g00
04:00:48   6  ,g01
04:00:48   7  ,g02
04:00:48   8  ,g03
04:00:48   9  ,g04
04:00:48  10  ,g05
04:00:48  11  ,g06
04:00:48  12  ,g07
04:00:48  13  ,g08
04:00:48  14  ,g09
04:00:48  15  ,g10
04:00:48  16  ,g11
04:00:48  17  ,g12
04:00:48  18  ,g13
04:00:48  19  ,g14
04:00:48  20  ,g15
04:00:48  21  ,g16
04:00:48  22  ,g17
04:00:48  23  ,g18
04:00:48  24  ,g19
04:00:48  25  ,g20
04:00:48  26  ,g21
04:00:48  27  ,g22
04:00:48  28  ,g23
04:00:48  29  ,g24
04:00:48  30  ,g25
04:00:48  31  ,g26
04:00:48  32  ,g27
04:00:48  33  ,g28
04:00:48  34  ,g29
04:00:48  35  ,g30
04:00:48  36  ,g31
04:00:48  37  ,g32
04:00:48  38  ,g33
04:00:48  39  ,g34
04:00:48  40  ,g35
04:00:48  41  ,g36
04:00:48  42  ,g37
04:00:48  43  ,g38
04:00:48  44  ,g39
04:00:48  45  ,g40
04:00:48  46  ,g41
04:00:48  47  ,s.sc_corr
04:00:48  48  FROM modsrc24
04:00:48  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:00:48  50  WHERE ydate = '&1'||' '||'&2'
04:00:48  51  AND pair = '&3'
04:00:48  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-24'||' '||'16:00:00'AND ydate<'2011-01-24'||' '||'16:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-24'||' '||'16:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:00:48 SQL> 
04:00:48 SQL> -- rpt
04:00:48 SQL> -- We should see just 1 row:
04:00:48 SQL> 
04:00:48 SQL> SELECT COUNT(prdate) FROM sme
04:00:48   2  
04:00:48 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:00:48   2  
04:00:48 SQL> 
04:00:48 SQL> -- Build the model:
04:00:48 SQL> CREATE OR REPLACE VIEW bme AS
04:00:48   2  SELECT
04:00:48   3  prdate
04:00:48   4  ,gattn
04:00:48   5  ,g00
04:00:48   6  ,g01
04:00:48   7  ,g02
04:00:48   8  ,g03
04:00:48   9  ,g04
04:00:48  10  ,g05
04:00:48  11  ,g06
04:00:48  12  ,g07
04:00:48  13  ,g08
04:00:48  14  ,g09
04:00:48  15  ,g10
04:00:48  16  ,g11
04:00:48  17  ,g12
04:00:48  18  ,g13
04:00:48  19  ,g14
04:00:48  20  ,g15
04:00:48  21  ,g16
04:00:48  22  ,g17
04:00:48  23  ,g18
04:00:48  24  ,g19
04:00:48  25  ,g20
04:00:48  26  ,g21
04:00:48  27  ,g22
04:00:48  28  ,g23
04:00:48  29  ,g24
04:00:48  30  ,g25
04:00:48  31  ,g26
04:00:48  32  ,g27
04:00:48  33  ,g28
04:00:48  34  ,g29
04:00:48  35  ,g30
04:00:48  36  ,g31
04:00:48  37  ,g32
04:00:48  38  ,g33
04:00:48  39  ,g34
04:00:48  40  ,g35
04:00:48  41  ,g36
04:00:48  42  ,g37
04:00:48  43  ,g38
04:00:48  44  ,g39
04:00:48  45  ,g40
04:00:48  46  ,g41
04:00:48  47  ,sc_corr
04:00:48  48  FROM modsrc24
04:00:48  49  WHERE gattn IN('nup','up')
04:00:48  50  -- Use only rows which are older than 1 day:
04:00:48  51  AND 1+ydate < '&1'||' '||'&2'
04:00:48  52  AND pair = '&3'
04:00:48  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-24'||' '||'16:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:00:48 SQL> 
04:00:48 SQL> -- rpt
04:00:48 SQL> 
04:00:48 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:00:48   2  
04:00:48 SQL> SELECT MAX(prdate) FROM bme
04:00:48   2  
04:00:48 SQL> -- Now build model from bme and score sme
04:00:48 SQL> @score1.sql gattn
04:00:48 SQL> --
04:00:48 SQL> -- score1.sql
04:00:48 SQL> --
04:00:48 SQL> 
04:00:48 SQL> -- I use this script to send 5 params to score.sql
04:00:48 SQL> -- which does the heavy lifting of creating an SVM model.
04:00:48 SQL> -- Then at the very end of this script I use the model
04:00:48 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:00:48 SQL> 
04:00:48 SQL> -- I call this script from 2 other scripts:
04:00:48 SQL> -- score1_5min.sql
04:00:48 SQL> -- score1_5min_gattn.sql
04:00:48 SQL> 
04:00:48 SQL> -- The 1st param is the name of the target attribute.
04:00:48 SQL> -- I like to call my target attributes either gatt or gattn.
04:00:48 SQL> 
04:00:48 SQL> -- Demo:
04:00:48 SQL> -- @score1.sql 'gatt'
04:00:48 SQL> -- @score1.sql 'gattn'
04:00:48 SQL> 
04:00:48 SQL> -- Now, I fill up svmc_apply_prep.
04:00:48 SQL> -- I use same model_name used in score.sql
04:00:48 SQL> DEFINE model_name = 'svmfx101'
04:00:48 SQL> DEFINE bldtable	= 'bme'
04:00:48 SQL> DEFINE scoretable = 'sme'
04:00:48 SQL> DEFINE case_id	= 'prdate'
04:00:48 SQL> -- Demo:
04:00:48 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:00:48 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:00:48 SQL> --
04:00:48 SQL> -- score.sql
04:00:48 SQL> --
04:00:48 SQL> 
04:00:48 SQL> -- usage: score.sql
04:00:48 SQL> 
04:00:48 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:00:48 SQL> 
04:00:48 SQL> -- DEFINE target	   = 'gatt'
04:00:48 SQL> -- DEFINE model_name = 'svmfx101'
04:00:48 SQL> -- DEFINE bldtable   = 'bme'
04:00:48 SQL> -- DEFINE scoretable = 'sme'
04:00:48 SQL> -- DEFINE case_id    = 'prdate'
04:00:48 SQL> 
04:00:48 SQL> DEFINE target	= '&1'
04:00:48 SQL> DEFINE model_name = '&2'
04:00:48 SQL> DEFINE bldtable	= '&3'
04:00:48 SQL> DEFINE scoretable = '&4'
04:00:48 SQL> DEFINE case_id	= '&5'
04:00:48 SQL> 
04:00:48 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:00:48 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:00:48 SQL> 
04:00:48 SQL> -- Builds an SVM model using pl/sql.
04:00:48 SQL> 
04:00:48 SQL> -----------------------------------------------------------------------
04:00:48 SQL> --			    BUILD THE MODEL
04:00:48 SQL> -----------------------------------------------------------------------
04:00:48 SQL> 
04:00:48 SQL> -- Cleanup old build data preparation objects for repeat runs
04:00:48 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
04:00:48 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:00:48 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:48 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:00:48 SQL> 
04:00:48 SQL> 
04:00:48 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:00:48 SQL> --
04:00:48 SQL> -- DROP	TABLE svmc_settings ;
04:00:48 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:00:48 SQL> -- DELETE svmc_settings;
04:00:48 SQL> 
04:00:48 SQL> -- The default classification algorithm is Naive Bayes. So override
04:00:48 SQL> -- this choice to SVM using a settings table.
04:00:48 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:00:48 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:00:48 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:00:48 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:00:48 SQL> -- models.
04:00:48 SQL> --
04:00:48 SQL> 
04:00:48 SQL> -- Do this once and then comment it out.
04:00:48 SQL> -- That makes script go faster.
04:00:48 SQL> -- BEGIN
04:00:48 SQL> -- -- Populate settings table
04:00:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:48 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:00:48 SQL> --
04:00:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:48 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:00:48 SQL> --
04:00:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:48 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:00:48 SQL> --   COMMIT;
04:00:48 SQL> -- END;
04:00:48 SQL> -- /
04:00:48 SQL> 
04:00:48 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:00:48 SQL> 
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:48 SQL> 
04:00:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:00:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:48 SQL> 
04:00:48 SQL> --------------------------------
04:00:48 SQL> -- PREPARE BUILD (TRAINING) DATA
04:00:48 SQL> --
04:00:48 SQL> 
04:00:48 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:48 SQL> -- 2. Outlier Treatment and
04:00:48 SQL> -- 3. Normalization are performed below.
04:00:48 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:00:48 SQL> --    normalized here.
04:00:48 SQL> 
04:00:48 SQL> BEGIN
04:00:48   2  	-- Perform missing value treatment for all predictors
04:00:48   3  	-- create miss tables
04:00:48   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:00:48   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:00:48   6  
04:00:48   7  	-- populate miss tables
04:00:48   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:00:48   9  	  miss_table_name => 'svmc_miss_num',
04:00:48  10  	  data_table_name => '&bldtable',
04:00:48  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:48  12  
04:00:48  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:00:48  14  	  miss_table_name => 'svmc_miss_cat',
04:00:48  15  	  data_table_name => '&bldtable',
04:00:48  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:48  17  
04:00:48  18  	-- xform input data to replace missing values
04:00:48  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:48  20  	  miss_table_name => 'svmc_miss_num',
04:00:48  21  	  data_table_name => '&bldtable',
04:00:48  22  	  xform_view_name => 'xformed_build_miss_num');
04:00:48  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:48  24  	  miss_table_name => 'svmc_miss_cat',
04:00:48  25  	  data_table_name => '&bldtable',
04:00:48  26  	  xform_view_name => 'xformed_build_miss_cat');
04:00:48  27  
04:00:48  28  	-- Perform outlier treatment.
04:00:48  29  	-- create clip table
04:00:48  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:00:48  31  
04:00:48  32  	-- populate clip table
04:00:48  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:00:48  34  	  clip_table_name => 'svmc_clip',
04:00:48  35  	  data_table_name => '&bldtable',
04:00:48  36  	  tail_frac	  => 0.025,
04:00:48  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:48  38  
04:00:48  39  	-- xform input data to winsorized data
04:00:48  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:00:48  41  	  clip_table_name => 'svmc_clip',
04:00:48  42  	  data_table_name => '&bldtable',
04:00:48  43  	  xform_view_name => 'svmc_winsor');
04:00:48  44  
04:00:48  45  	-- create normalization table
04:00:48  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:00:48  47  
04:00:48  48  	-- populate normalization table based on winsorized data
04:00:48  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:00:48  50  	  norm_table_name => 'svmc_norm',
04:00:48  51  	  data_table_name => 'svmc_winsor',
04:00:48  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:48  53  
04:00:48  54  	-- normalize the original data
04:00:48  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:48  56  	  norm_table_name => 'svmc_norm',
04:00:48  57  	  data_table_name => '&bldtable',
04:00:48  58  	  xform_view_name => 'svmc_build_prep');
04:00:48  59  END;
04:00:48  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.60
04:00:51 SQL> 
04:00:51 SQL> ---------------------
04:00:51 SQL> -- CREATE A NEW MODEL
04:00:51 SQL> --
04:00:51 SQL> -- Cleanup old model with the same name for repeat runs
04:00:51 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:00:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:51   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.53
04:00:53 SQL> 
04:00:53 SQL> -- Build a new SVM Model
04:00:53 SQL> BEGIN
04:00:53   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:00:53   3  	  model_name	      => '&model_name',
04:00:53   4  	  mining_function     => dbms_data_mining.classification,
04:00:53   5  	  data_table_name     => 'svmc_build_prep',
04:00:53   6  	  case_id_column_name => '&case_id',
04:00:53   7  	  target_column_name  => '&target',
04:00:53   8  	  settings_table_name => 'svmc_settings');
04:00:53   9  END;
04:00:53  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.47
04:00:58 SQL> 
04:00:58 SQL> -----------------------------------------------------------------------
04:00:58 SQL> --			       APPLY/score THE MODEL
04:00:58 SQL> -----------------------------------------------------------------------
04:00:58 SQL> 
04:00:58 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:00:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:00:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:00:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:00:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:00:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:58 SQL> -----------------------
04:00:58 SQL> -- PREPARE SCORING DATA
04:00:58 SQL> --
04:00:58 SQL> -- If the data for model creation has been prepared, then the data
04:00:58 SQL> -- to be scored using the model must be prepared in the same manner
04:00:58 SQL> -- in order to obtain meaningful results.
04:00:58 SQL> --
04:00:58 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:58 SQL> -- 2. Normalization
04:00:58 SQL> -- No outlier treatment will be performed during test and apply. The
04:00:58 SQL> -- normalization step is sufficient, since the normalization parameters
04:00:58 SQL> -- already capture the effects of outlier treatment done with build data.
04:00:58 SQL> --
04:00:58 SQL> BEGIN
04:00:58   2  	-- Xform Test data to replace missing values
04:00:58   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:58   4  	  miss_table_name => 'svmc_miss_num',
04:00:58   5  	  data_table_name => '&scoretable',
04:00:58   6  	  xform_view_name => 'xformed_apply_miss_num');
04:00:58   7  
04:00:58   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:58   9  	  miss_table_name => 'svmc_miss_cat',
04:00:58  10  	  data_table_name => '&scoretable',
04:00:58  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:00:58  12  
04:00:58  13  	-- Normalize the data to be scored
04:00:58  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:58  15  	  norm_table_name => 'svmc_norm',
04:00:58  16  	  data_table_name => '&scoretable',
04:00:58  17  	  xform_view_name => 'svmc_apply_prep');
04:00:58  18  END;
04:00:58  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:00:58 SQL> 
04:00:58 SQL> -- Maybe I already collected a score for this prdate.
04:00:58 SQL> -- DELETE it if I did:
04:00:58 SQL> DELETE svm24scores
04:00:58   2  WHERE score > 0
04:00:58   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:00:58   4  -- I need to supply the target attribute name:
04:00:58   5  AND targ = '&1'
04:00:58   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
04:00:58 SQL> 
04:00:58 SQL> -- We do a drumroll here:
04:00:58 SQL> 
04:00:58 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:00:58   2  SELECT
04:00:58   3  prdate
04:00:58   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:00:58   5  ,sysdate
04:00:58   6  ,SUBSTR(prdate,1,7)pair
04:00:58   7  ,SUBSTR(prdate,-19)ydate
04:00:58   8  ,'&1'
04:00:58   9  FROM svmc_apply_prep
04:00:58  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:00:58 SQL> @score1_5min_gattn.sql	2011-01-20 13:30:00 eur_usd
04:00:58 SQL> --
04:00:58 SQL> -- score1_5min_gattn.sql
04:00:58 SQL> --
04:00:58 SQL> 
04:00:58 SQL> -- Demo:
04:00:58 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:00:58 SQL> 
04:00:58 SQL> CREATE OR REPLACE VIEW sme AS
04:00:58   2  SELECT
04:00:58   3  prdate
04:00:58   4  ,NULL gattn
04:00:58   5  ,g00
04:00:58   6  ,g01
04:00:58   7  ,g02
04:00:58   8  ,g03
04:00:58   9  ,g04
04:00:58  10  ,g05
04:00:58  11  ,g06
04:00:58  12  ,g07
04:00:58  13  ,g08
04:00:58  14  ,g09
04:00:58  15  ,g10
04:00:58  16  ,g11
04:00:58  17  ,g12
04:00:58  18  ,g13
04:00:58  19  ,g14
04:00:58  20  ,g15
04:00:58  21  ,g16
04:00:58  22  ,g17
04:00:58  23  ,g18
04:00:58  24  ,g19
04:00:58  25  ,g20
04:00:58  26  ,g21
04:00:58  27  ,g22
04:00:58  28  ,g23
04:00:58  29  ,g24
04:00:58  30  ,g25
04:00:58  31  ,g26
04:00:58  32  ,g27
04:00:58  33  ,g28
04:00:58  34  ,g29
04:00:58  35  ,g30
04:00:58  36  ,g31
04:00:58  37  ,g32
04:00:58  38  ,g33
04:00:58  39  ,g34
04:00:58  40  ,g35
04:00:58  41  ,g36
04:00:58  42  ,g37
04:00:58  43  ,g38
04:00:58  44  ,g39
04:00:58  45  ,g40
04:00:58  46  ,g41
04:00:58  47  ,s.sc_corr
04:00:58  48  FROM modsrc24
04:00:58  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:00:58  50  WHERE ydate = '&1'||' '||'&2'
04:00:58  51  AND pair = '&3'
04:00:58  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'13:30:00'AND ydate<'2011-01-20'||' '||'13:30:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'13:30:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
04:00:58 SQL> 
04:00:58 SQL> -- rpt
04:00:58 SQL> -- We should see just 1 row:
04:00:58 SQL> 
04:00:58 SQL> SELECT COUNT(prdate) FROM sme
04:00:58   2  
04:00:58 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:00:58   2  
04:00:58 SQL> 
04:00:58 SQL> -- Build the model:
04:00:58 SQL> CREATE OR REPLACE VIEW bme AS
04:00:58   2  SELECT
04:00:58   3  prdate
04:00:58   4  ,gattn
04:00:58   5  ,g00
04:00:58   6  ,g01
04:00:58   7  ,g02
04:00:58   8  ,g03
04:00:58   9  ,g04
04:00:58  10  ,g05
04:00:58  11  ,g06
04:00:58  12  ,g07
04:00:58  13  ,g08
04:00:58  14  ,g09
04:00:58  15  ,g10
04:00:58  16  ,g11
04:00:58  17  ,g12
04:00:58  18  ,g13
04:00:58  19  ,g14
04:00:58  20  ,g15
04:00:58  21  ,g16
04:00:58  22  ,g17
04:00:58  23  ,g18
04:00:58  24  ,g19
04:00:58  25  ,g20
04:00:58  26  ,g21
04:00:58  27  ,g22
04:00:58  28  ,g23
04:00:58  29  ,g24
04:00:58  30  ,g25
04:00:58  31  ,g26
04:00:58  32  ,g27
04:00:58  33  ,g28
04:00:58  34  ,g29
04:00:58  35  ,g30
04:00:58  36  ,g31
04:00:58  37  ,g32
04:00:58  38  ,g33
04:00:58  39  ,g34
04:00:58  40  ,g35
04:00:58  41  ,g36
04:00:58  42  ,g37
04:00:58  43  ,g38
04:00:58  44  ,g39
04:00:58  45  ,g40
04:00:58  46  ,g41
04:00:58  47  ,sc_corr
04:00:58  48  FROM modsrc24
04:00:58  49  WHERE gattn IN('nup','up')
04:00:58  50  -- Use only rows which are older than 1 day:
04:00:58  51  AND 1+ydate < '&1'||' '||'&2'
04:00:58  52  AND pair = '&3'
04:00:58  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'13:30:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:00:59 SQL> 
04:00:59 SQL> -- rpt
04:00:59 SQL> 
04:00:59 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:00:59   2  
04:00:59 SQL> SELECT MAX(prdate) FROM bme
04:00:59   2  
04:00:59 SQL> -- Now build model from bme and score sme
04:00:59 SQL> @score1.sql gattn
04:00:59 SQL> --
04:00:59 SQL> -- score1.sql
04:00:59 SQL> --
04:00:59 SQL> 
04:00:59 SQL> -- I use this script to send 5 params to score.sql
04:00:59 SQL> -- which does the heavy lifting of creating an SVM model.
04:00:59 SQL> -- Then at the very end of this script I use the model
04:00:59 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:00:59 SQL> 
04:00:59 SQL> -- I call this script from 2 other scripts:
04:00:59 SQL> -- score1_5min.sql
04:00:59 SQL> -- score1_5min_gattn.sql
04:00:59 SQL> 
04:00:59 SQL> -- The 1st param is the name of the target attribute.
04:00:59 SQL> -- I like to call my target attributes either gatt or gattn.
04:00:59 SQL> 
04:00:59 SQL> -- Demo:
04:00:59 SQL> -- @score1.sql 'gatt'
04:00:59 SQL> -- @score1.sql 'gattn'
04:00:59 SQL> 
04:00:59 SQL> -- Now, I fill up svmc_apply_prep.
04:00:59 SQL> -- I use same model_name used in score.sql
04:00:59 SQL> DEFINE model_name = 'svmfx101'
04:00:59 SQL> DEFINE bldtable	= 'bme'
04:00:59 SQL> DEFINE scoretable = 'sme'
04:00:59 SQL> DEFINE case_id	= 'prdate'
04:00:59 SQL> -- Demo:
04:00:59 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:00:59 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:00:59 SQL> --
04:00:59 SQL> -- score.sql
04:00:59 SQL> --
04:00:59 SQL> 
04:00:59 SQL> -- usage: score.sql
04:00:59 SQL> 
04:00:59 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:00:59 SQL> 
04:00:59 SQL> -- DEFINE target	   = 'gatt'
04:00:59 SQL> -- DEFINE model_name = 'svmfx101'
04:00:59 SQL> -- DEFINE bldtable   = 'bme'
04:00:59 SQL> -- DEFINE scoretable = 'sme'
04:00:59 SQL> -- DEFINE case_id    = 'prdate'
04:00:59 SQL> 
04:00:59 SQL> DEFINE target	= '&1'
04:00:59 SQL> DEFINE model_name = '&2'
04:00:59 SQL> DEFINE bldtable	= '&3'
04:00:59 SQL> DEFINE scoretable = '&4'
04:00:59 SQL> DEFINE case_id	= '&5'
04:00:59 SQL> 
04:00:59 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:00:59 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:00:59 SQL> 
04:00:59 SQL> -- Builds an SVM model using pl/sql.
04:00:59 SQL> 
04:00:59 SQL> -----------------------------------------------------------------------
04:00:59 SQL> --			    BUILD THE MODEL
04:00:59 SQL> -----------------------------------------------------------------------
04:00:59 SQL> 
04:00:59 SQL> -- Cleanup old build data preparation objects for repeat runs
04:00:59 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:00:59 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:00:59 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:00:59 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:00:59 SQL> 
04:00:59 SQL> 
04:00:59 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:00:59 SQL> --
04:00:59 SQL> -- DROP	TABLE svmc_settings ;
04:00:59 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:00:59 SQL> -- DELETE svmc_settings;
04:00:59 SQL> 
04:00:59 SQL> -- The default classification algorithm is Naive Bayes. So override
04:00:59 SQL> -- this choice to SVM using a settings table.
04:00:59 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:00:59 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:00:59 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:00:59 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:00:59 SQL> -- models.
04:00:59 SQL> --
04:00:59 SQL> 
04:00:59 SQL> -- Do this once and then comment it out.
04:00:59 SQL> -- That makes script go faster.
04:00:59 SQL> -- BEGIN
04:00:59 SQL> -- -- Populate settings table
04:00:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:59 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:00:59 SQL> --
04:00:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:59 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:00:59 SQL> --
04:00:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:00:59 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:00:59 SQL> --   COMMIT;
04:00:59 SQL> -- END;
04:00:59 SQL> -- /
04:00:59 SQL> 
04:00:59 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:00:59 SQL> 
04:00:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:00:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:00:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:00:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:00:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:59 SQL> 
04:00:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:00:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:00:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:00:59 SQL> 
04:00:59 SQL> --------------------------------
04:00:59 SQL> -- PREPARE BUILD (TRAINING) DATA
04:00:59 SQL> --
04:00:59 SQL> 
04:00:59 SQL> -- 1. Missing Value treatment for all Predictors and
04:00:59 SQL> -- 2. Outlier Treatment and
04:00:59 SQL> -- 3. Normalization are performed below.
04:00:59 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:00:59 SQL> --    normalized here.
04:00:59 SQL> 
04:00:59 SQL> BEGIN
04:00:59   2  	-- Perform missing value treatment for all predictors
04:00:59   3  	-- create miss tables
04:00:59   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:00:59   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:00:59   6  
04:00:59   7  	-- populate miss tables
04:00:59   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:00:59   9  	  miss_table_name => 'svmc_miss_num',
04:00:59  10  	  data_table_name => '&bldtable',
04:00:59  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:59  12  
04:00:59  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:00:59  14  	  miss_table_name => 'svmc_miss_cat',
04:00:59  15  	  data_table_name => '&bldtable',
04:00:59  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:59  17  
04:00:59  18  	-- xform input data to replace missing values
04:00:59  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:00:59  20  	  miss_table_name => 'svmc_miss_num',
04:00:59  21  	  data_table_name => '&bldtable',
04:00:59  22  	  xform_view_name => 'xformed_build_miss_num');
04:00:59  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:00:59  24  	  miss_table_name => 'svmc_miss_cat',
04:00:59  25  	  data_table_name => '&bldtable',
04:00:59  26  	  xform_view_name => 'xformed_build_miss_cat');
04:00:59  27  
04:00:59  28  	-- Perform outlier treatment.
04:00:59  29  	-- create clip table
04:00:59  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:00:59  31  
04:00:59  32  	-- populate clip table
04:00:59  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:00:59  34  	  clip_table_name => 'svmc_clip',
04:00:59  35  	  data_table_name => '&bldtable',
04:00:59  36  	  tail_frac	  => 0.025,
04:00:59  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:59  38  
04:00:59  39  	-- xform input data to winsorized data
04:00:59  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:00:59  41  	  clip_table_name => 'svmc_clip',
04:00:59  42  	  data_table_name => '&bldtable',
04:00:59  43  	  xform_view_name => 'svmc_winsor');
04:00:59  44  
04:00:59  45  	-- create normalization table
04:00:59  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:00:59  47  
04:00:59  48  	-- populate normalization table based on winsorized data
04:00:59  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:00:59  50  	  norm_table_name => 'svmc_norm',
04:00:59  51  	  data_table_name => 'svmc_winsor',
04:00:59  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:00:59  53  
04:00:59  54  	-- normalize the original data
04:00:59  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:00:59  56  	  norm_table_name => 'svmc_norm',
04:00:59  57  	  data_table_name => '&bldtable',
04:00:59  58  	  xform_view_name => 'svmc_build_prep');
04:00:59  59  END;
04:00:59  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.57
04:01:01 SQL> 
04:01:01 SQL> ---------------------
04:01:01 SQL> -- CREATE A NEW MODEL
04:01:01 SQL> --
04:01:01 SQL> -- Cleanup old model with the same name for repeat runs
04:01:01 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:01:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:01   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.36
04:01:03 SQL> 
04:01:03 SQL> -- Build a new SVM Model
04:01:03 SQL> BEGIN
04:01:03   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:01:03   3  	  model_name	      => '&model_name',
04:01:03   4  	  mining_function     => dbms_data_mining.classification,
04:01:03   5  	  data_table_name     => 'svmc_build_prep',
04:01:03   6  	  case_id_column_name => '&case_id',
04:01:03   7  	  target_column_name  => '&target',
04:01:03   8  	  settings_table_name => 'svmc_settings');
04:01:03   9  END;
04:01:03  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.76
04:01:08 SQL> 
04:01:08 SQL> -----------------------------------------------------------------------
04:01:08 SQL> --			       APPLY/score THE MODEL
04:01:08 SQL> -----------------------------------------------------------------------
04:01:08 SQL> 
04:01:08 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:01:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:01:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:01:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:01:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:08 SQL> -----------------------
04:01:08 SQL> -- PREPARE SCORING DATA
04:01:08 SQL> --
04:01:08 SQL> -- If the data for model creation has been prepared, then the data
04:01:08 SQL> -- to be scored using the model must be prepared in the same manner
04:01:08 SQL> -- in order to obtain meaningful results.
04:01:08 SQL> --
04:01:08 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:08 SQL> -- 2. Normalization
04:01:08 SQL> -- No outlier treatment will be performed during test and apply. The
04:01:08 SQL> -- normalization step is sufficient, since the normalization parameters
04:01:08 SQL> -- already capture the effects of outlier treatment done with build data.
04:01:08 SQL> --
04:01:08 SQL> BEGIN
04:01:08   2  	-- Xform Test data to replace missing values
04:01:08   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:08   4  	  miss_table_name => 'svmc_miss_num',
04:01:08   5  	  data_table_name => '&scoretable',
04:01:08   6  	  xform_view_name => 'xformed_apply_miss_num');
04:01:08   7  
04:01:08   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:08   9  	  miss_table_name => 'svmc_miss_cat',
04:01:08  10  	  data_table_name => '&scoretable',
04:01:08  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:01:08  12  
04:01:08  13  	-- Normalize the data to be scored
04:01:08  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:08  15  	  norm_table_name => 'svmc_norm',
04:01:08  16  	  data_table_name => '&scoretable',
04:01:08  17  	  xform_view_name => 'svmc_apply_prep');
04:01:08  18  END;
04:01:08  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.24
04:01:09 SQL> 
04:01:09 SQL> -- Maybe I already collected a score for this prdate.
04:01:09 SQL> -- DELETE it if I did:
04:01:09 SQL> DELETE svm24scores
04:01:09   2  WHERE score > 0
04:01:09   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:01:09   4  -- I need to supply the target attribute name:
04:01:09   5  AND targ = '&1'
04:01:09   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:01:09 SQL> 
04:01:09 SQL> -- We do a drumroll here:
04:01:09 SQL> 
04:01:09 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:01:09   2  SELECT
04:01:09   3  prdate
04:01:09   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:01:09   5  ,sysdate
04:01:09   6  ,SUBSTR(prdate,1,7)pair
04:01:09   7  ,SUBSTR(prdate,-19)ydate
04:01:09   8  ,'&1'
04:01:09   9  FROM svmc_apply_prep
04:01:09  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
04:01:09 SQL> @score1_5min_gattn.sql	2011-01-25 05:10:00 eur_usd
04:01:09 SQL> --
04:01:09 SQL> -- score1_5min_gattn.sql
04:01:09 SQL> --
04:01:09 SQL> 
04:01:09 SQL> -- Demo:
04:01:09 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:01:09 SQL> 
04:01:09 SQL> CREATE OR REPLACE VIEW sme AS
04:01:09   2  SELECT
04:01:09   3  prdate
04:01:09   4  ,NULL gattn
04:01:09   5  ,g00
04:01:09   6  ,g01
04:01:09   7  ,g02
04:01:09   8  ,g03
04:01:09   9  ,g04
04:01:09  10  ,g05
04:01:09  11  ,g06
04:01:09  12  ,g07
04:01:09  13  ,g08
04:01:09  14  ,g09
04:01:09  15  ,g10
04:01:09  16  ,g11
04:01:09  17  ,g12
04:01:09  18  ,g13
04:01:09  19  ,g14
04:01:09  20  ,g15
04:01:09  21  ,g16
04:01:09  22  ,g17
04:01:09  23  ,g18
04:01:09  24  ,g19
04:01:09  25  ,g20
04:01:09  26  ,g21
04:01:09  27  ,g22
04:01:09  28  ,g23
04:01:09  29  ,g24
04:01:09  30  ,g25
04:01:09  31  ,g26
04:01:09  32  ,g27
04:01:09  33  ,g28
04:01:09  34  ,g29
04:01:09  35  ,g30
04:01:09  36  ,g31
04:01:09  37  ,g32
04:01:09  38  ,g33
04:01:09  39  ,g34
04:01:09  40  ,g35
04:01:09  41  ,g36
04:01:09  42  ,g37
04:01:09  43  ,g38
04:01:09  44  ,g39
04:01:09  45  ,g40
04:01:09  46  ,g41
04:01:09  47  ,s.sc_corr
04:01:09  48  FROM modsrc24
04:01:09  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:01:09  50  WHERE ydate = '&1'||' '||'&2'
04:01:09  51  AND pair = '&3'
04:01:09  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'05:10:00'AND ydate<'2011-01-25'||' '||'05:10:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'05:10:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:01:09 SQL> 
04:01:09 SQL> -- rpt
04:01:09 SQL> -- We should see just 1 row:
04:01:09 SQL> 
04:01:09 SQL> SELECT COUNT(prdate) FROM sme
04:01:09   2  
04:01:09 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:01:09   2  
04:01:09 SQL> 
04:01:09 SQL> -- Build the model:
04:01:09 SQL> CREATE OR REPLACE VIEW bme AS
04:01:09   2  SELECT
04:01:09   3  prdate
04:01:09   4  ,gattn
04:01:09   5  ,g00
04:01:09   6  ,g01
04:01:09   7  ,g02
04:01:09   8  ,g03
04:01:09   9  ,g04
04:01:09  10  ,g05
04:01:09  11  ,g06
04:01:09  12  ,g07
04:01:09  13  ,g08
04:01:09  14  ,g09
04:01:09  15  ,g10
04:01:09  16  ,g11
04:01:09  17  ,g12
04:01:09  18  ,g13
04:01:09  19  ,g14
04:01:09  20  ,g15
04:01:09  21  ,g16
04:01:09  22  ,g17
04:01:09  23  ,g18
04:01:09  24  ,g19
04:01:09  25  ,g20
04:01:09  26  ,g21
04:01:09  27  ,g22
04:01:09  28  ,g23
04:01:09  29  ,g24
04:01:09  30  ,g25
04:01:09  31  ,g26
04:01:09  32  ,g27
04:01:09  33  ,g28
04:01:09  34  ,g29
04:01:09  35  ,g30
04:01:09  36  ,g31
04:01:09  37  ,g32
04:01:09  38  ,g33
04:01:09  39  ,g34
04:01:09  40  ,g35
04:01:09  41  ,g36
04:01:09  42  ,g37
04:01:09  43  ,g38
04:01:09  44  ,g39
04:01:09  45  ,g40
04:01:09  46  ,g41
04:01:09  47  ,sc_corr
04:01:09  48  FROM modsrc24
04:01:09  49  WHERE gattn IN('nup','up')
04:01:09  50  -- Use only rows which are older than 1 day:
04:01:09  51  AND 1+ydate < '&1'||' '||'&2'
04:01:09  52  AND pair = '&3'
04:01:09  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'05:10:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:01:09 SQL> 
04:01:09 SQL> -- rpt
04:01:09 SQL> 
04:01:09 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:01:09   2  
04:01:09 SQL> SELECT MAX(prdate) FROM bme
04:01:09   2  
04:01:09 SQL> -- Now build model from bme and score sme
04:01:09 SQL> @score1.sql gattn
04:01:09 SQL> --
04:01:09 SQL> -- score1.sql
04:01:09 SQL> --
04:01:09 SQL> 
04:01:09 SQL> -- I use this script to send 5 params to score.sql
04:01:09 SQL> -- which does the heavy lifting of creating an SVM model.
04:01:09 SQL> -- Then at the very end of this script I use the model
04:01:09 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:01:09 SQL> 
04:01:09 SQL> -- I call this script from 2 other scripts:
04:01:09 SQL> -- score1_5min.sql
04:01:09 SQL> -- score1_5min_gattn.sql
04:01:09 SQL> 
04:01:09 SQL> -- The 1st param is the name of the target attribute.
04:01:09 SQL> -- I like to call my target attributes either gatt or gattn.
04:01:09 SQL> 
04:01:09 SQL> -- Demo:
04:01:09 SQL> -- @score1.sql 'gatt'
04:01:09 SQL> -- @score1.sql 'gattn'
04:01:09 SQL> 
04:01:09 SQL> -- Now, I fill up svmc_apply_prep.
04:01:09 SQL> -- I use same model_name used in score.sql
04:01:09 SQL> DEFINE model_name = 'svmfx101'
04:01:09 SQL> DEFINE bldtable	= 'bme'
04:01:09 SQL> DEFINE scoretable = 'sme'
04:01:09 SQL> DEFINE case_id	= 'prdate'
04:01:09 SQL> -- Demo:
04:01:09 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:01:09 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:01:09 SQL> --
04:01:09 SQL> -- score.sql
04:01:09 SQL> --
04:01:09 SQL> 
04:01:09 SQL> -- usage: score.sql
04:01:09 SQL> 
04:01:09 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:01:09 SQL> 
04:01:09 SQL> -- DEFINE target	   = 'gatt'
04:01:09 SQL> -- DEFINE model_name = 'svmfx101'
04:01:09 SQL> -- DEFINE bldtable   = 'bme'
04:01:09 SQL> -- DEFINE scoretable = 'sme'
04:01:09 SQL> -- DEFINE case_id    = 'prdate'
04:01:09 SQL> 
04:01:09 SQL> DEFINE target	= '&1'
04:01:09 SQL> DEFINE model_name = '&2'
04:01:09 SQL> DEFINE bldtable	= '&3'
04:01:09 SQL> DEFINE scoretable = '&4'
04:01:09 SQL> DEFINE case_id	= '&5'
04:01:09 SQL> 
04:01:09 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:01:09 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:01:09 SQL> 
04:01:09 SQL> -- Builds an SVM model using pl/sql.
04:01:09 SQL> 
04:01:09 SQL> -----------------------------------------------------------------------
04:01:09 SQL> --			    BUILD THE MODEL
04:01:09 SQL> -----------------------------------------------------------------------
04:01:09 SQL> 
04:01:09 SQL> -- Cleanup old build data preparation objects for repeat runs
04:01:09 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:01:09 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
04:01:09 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:01:09 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:01:09 SQL> 
04:01:09 SQL> 
04:01:09 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:01:09 SQL> --
04:01:09 SQL> -- DROP	TABLE svmc_settings ;
04:01:09 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:01:09 SQL> -- DELETE svmc_settings;
04:01:09 SQL> 
04:01:09 SQL> -- The default classification algorithm is Naive Bayes. So override
04:01:09 SQL> -- this choice to SVM using a settings table.
04:01:09 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:01:09 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:01:09 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:01:09 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:01:09 SQL> -- models.
04:01:09 SQL> --
04:01:09 SQL> 
04:01:09 SQL> -- Do this once and then comment it out.
04:01:09 SQL> -- That makes script go faster.
04:01:09 SQL> -- BEGIN
04:01:09 SQL> -- -- Populate settings table
04:01:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:09 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:01:09 SQL> --
04:01:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:09 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:01:09 SQL> --
04:01:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:09 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:01:09 SQL> --   COMMIT;
04:01:09 SQL> -- END;
04:01:09 SQL> -- /
04:01:09 SQL> 
04:01:09 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:01:09 SQL> 
04:01:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:01:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:01:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:01:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:09 SQL> 
04:01:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:01:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
04:01:09 SQL> 
04:01:09 SQL> --------------------------------
04:01:09 SQL> -- PREPARE BUILD (TRAINING) DATA
04:01:09 SQL> --
04:01:09 SQL> 
04:01:09 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:09 SQL> -- 2. Outlier Treatment and
04:01:09 SQL> -- 3. Normalization are performed below.
04:01:09 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:01:09 SQL> --    normalized here.
04:01:09 SQL> 
04:01:09 SQL> BEGIN
04:01:09   2  	-- Perform missing value treatment for all predictors
04:01:09   3  	-- create miss tables
04:01:09   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:01:09   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:01:09   6  
04:01:09   7  	-- populate miss tables
04:01:09   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:01:09   9  	  miss_table_name => 'svmc_miss_num',
04:01:09  10  	  data_table_name => '&bldtable',
04:01:09  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:09  12  
04:01:09  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:01:09  14  	  miss_table_name => 'svmc_miss_cat',
04:01:09  15  	  data_table_name => '&bldtable',
04:01:09  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:09  17  
04:01:09  18  	-- xform input data to replace missing values
04:01:09  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:09  20  	  miss_table_name => 'svmc_miss_num',
04:01:09  21  	  data_table_name => '&bldtable',
04:01:09  22  	  xform_view_name => 'xformed_build_miss_num');
04:01:09  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:09  24  	  miss_table_name => 'svmc_miss_cat',
04:01:09  25  	  data_table_name => '&bldtable',
04:01:09  26  	  xform_view_name => 'xformed_build_miss_cat');
04:01:09  27  
04:01:09  28  	-- Perform outlier treatment.
04:01:09  29  	-- create clip table
04:01:09  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:01:09  31  
04:01:09  32  	-- populate clip table
04:01:09  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:01:09  34  	  clip_table_name => 'svmc_clip',
04:01:09  35  	  data_table_name => '&bldtable',
04:01:09  36  	  tail_frac	  => 0.025,
04:01:09  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:09  38  
04:01:09  39  	-- xform input data to winsorized data
04:01:09  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:01:09  41  	  clip_table_name => 'svmc_clip',
04:01:09  42  	  data_table_name => '&bldtable',
04:01:09  43  	  xform_view_name => 'svmc_winsor');
04:01:09  44  
04:01:09  45  	-- create normalization table
04:01:09  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:01:09  47  
04:01:09  48  	-- populate normalization table based on winsorized data
04:01:09  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:01:09  50  	  norm_table_name => 'svmc_norm',
04:01:09  51  	  data_table_name => 'svmc_winsor',
04:01:09  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:09  53  
04:01:09  54  	-- normalize the original data
04:01:09  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:09  56  	  norm_table_name => 'svmc_norm',
04:01:09  57  	  data_table_name => '&bldtable',
04:01:09  58  	  xform_view_name => 'svmc_build_prep');
04:01:09  59  END;
04:01:09  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.78
04:01:12 SQL> 
04:01:12 SQL> ---------------------
04:01:12 SQL> -- CREATE A NEW MODEL
04:01:12 SQL> --
04:01:12 SQL> -- Cleanup old model with the same name for repeat runs
04:01:12 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:01:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:12   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.41
04:01:13 SQL> 
04:01:13 SQL> -- Build a new SVM Model
04:01:13 SQL> BEGIN
04:01:13   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:01:13   3  	  model_name	      => '&model_name',
04:01:13   4  	  mining_function     => dbms_data_mining.classification,
04:01:13   5  	  data_table_name     => 'svmc_build_prep',
04:01:13   6  	  case_id_column_name => '&case_id',
04:01:13   7  	  target_column_name  => '&target',
04:01:13   8  	  settings_table_name => 'svmc_settings');
04:01:13   9  END;
04:01:13  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.83
04:01:20 SQL> 
04:01:20 SQL> -----------------------------------------------------------------------
04:01:20 SQL> --			       APPLY/score THE MODEL
04:01:20 SQL> -----------------------------------------------------------------------
04:01:20 SQL> 
04:01:20 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:01:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:01:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:01:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:01:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:01:20 SQL> -----------------------
04:01:20 SQL> -- PREPARE SCORING DATA
04:01:20 SQL> --
04:01:20 SQL> -- If the data for model creation has been prepared, then the data
04:01:20 SQL> -- to be scored using the model must be prepared in the same manner
04:01:20 SQL> -- in order to obtain meaningful results.
04:01:20 SQL> --
04:01:20 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:20 SQL> -- 2. Normalization
04:01:20 SQL> -- No outlier treatment will be performed during test and apply. The
04:01:20 SQL> -- normalization step is sufficient, since the normalization parameters
04:01:20 SQL> -- already capture the effects of outlier treatment done with build data.
04:01:20 SQL> --
04:01:20 SQL> BEGIN
04:01:20   2  	-- Xform Test data to replace missing values
04:01:20   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:20   4  	  miss_table_name => 'svmc_miss_num',
04:01:20   5  	  data_table_name => '&scoretable',
04:01:20   6  	  xform_view_name => 'xformed_apply_miss_num');
04:01:20   7  
04:01:20   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:20   9  	  miss_table_name => 'svmc_miss_cat',
04:01:20  10  	  data_table_name => '&scoretable',
04:01:20  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:01:20  12  
04:01:20  13  	-- Normalize the data to be scored
04:01:20  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:20  15  	  norm_table_name => 'svmc_norm',
04:01:20  16  	  data_table_name => '&scoretable',
04:01:20  17  	  xform_view_name => 'svmc_apply_prep');
04:01:20  18  END;
04:01:20  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
04:01:20 SQL> 
04:01:20 SQL> -- Maybe I already collected a score for this prdate.
04:01:20 SQL> -- DELETE it if I did:
04:01:20 SQL> DELETE svm24scores
04:01:20   2  WHERE score > 0
04:01:20   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:01:20   4  -- I need to supply the target attribute name:
04:01:20   5  AND targ = '&1'
04:01:20   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:01:20 SQL> 
04:01:20 SQL> -- We do a drumroll here:
04:01:20 SQL> 
04:01:20 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:01:20   2  SELECT
04:01:20   3  prdate
04:01:20   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:01:20   5  ,sysdate
04:01:20   6  ,SUBSTR(prdate,1,7)pair
04:01:20   7  ,SUBSTR(prdate,-19)ydate
04:01:20   8  ,'&1'
04:01:20   9  FROM svmc_apply_prep
04:01:20  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:01:21 SQL> @score1_5min_gattn.sql	2011-01-25 03:45:00 eur_usd
04:01:21 SQL> --
04:01:21 SQL> -- score1_5min_gattn.sql
04:01:21 SQL> --
04:01:21 SQL> 
04:01:21 SQL> -- Demo:
04:01:21 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:01:21 SQL> 
04:01:21 SQL> CREATE OR REPLACE VIEW sme AS
04:01:21   2  SELECT
04:01:21   3  prdate
04:01:21   4  ,NULL gattn
04:01:21   5  ,g00
04:01:21   6  ,g01
04:01:21   7  ,g02
04:01:21   8  ,g03
04:01:21   9  ,g04
04:01:21  10  ,g05
04:01:21  11  ,g06
04:01:21  12  ,g07
04:01:21  13  ,g08
04:01:21  14  ,g09
04:01:21  15  ,g10
04:01:21  16  ,g11
04:01:21  17  ,g12
04:01:21  18  ,g13
04:01:21  19  ,g14
04:01:21  20  ,g15
04:01:21  21  ,g16
04:01:21  22  ,g17
04:01:21  23  ,g18
04:01:21  24  ,g19
04:01:21  25  ,g20
04:01:21  26  ,g21
04:01:21  27  ,g22
04:01:21  28  ,g23
04:01:21  29  ,g24
04:01:21  30  ,g25
04:01:21  31  ,g26
04:01:21  32  ,g27
04:01:21  33  ,g28
04:01:21  34  ,g29
04:01:21  35  ,g30
04:01:21  36  ,g31
04:01:21  37  ,g32
04:01:21  38  ,g33
04:01:21  39  ,g34
04:01:21  40  ,g35
04:01:21  41  ,g36
04:01:21  42  ,g37
04:01:21  43  ,g38
04:01:21  44  ,g39
04:01:21  45  ,g40
04:01:21  46  ,g41
04:01:21  47  ,s.sc_corr
04:01:21  48  FROM modsrc24
04:01:21  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:01:21  50  WHERE ydate = '&1'||' '||'&2'
04:01:21  51  AND pair = '&3'
04:01:21  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'03:45:00'AND ydate<'2011-01-25'||' '||'03:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'03:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:01:21 SQL> 
04:01:21 SQL> -- rpt
04:01:21 SQL> -- We should see just 1 row:
04:01:21 SQL> 
04:01:21 SQL> SELECT COUNT(prdate) FROM sme
04:01:21   2  
04:01:21 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:01:21   2  
04:01:21 SQL> 
04:01:21 SQL> -- Build the model:
04:01:21 SQL> CREATE OR REPLACE VIEW bme AS
04:01:21   2  SELECT
04:01:21   3  prdate
04:01:21   4  ,gattn
04:01:21   5  ,g00
04:01:21   6  ,g01
04:01:21   7  ,g02
04:01:21   8  ,g03
04:01:21   9  ,g04
04:01:21  10  ,g05
04:01:21  11  ,g06
04:01:21  12  ,g07
04:01:21  13  ,g08
04:01:21  14  ,g09
04:01:21  15  ,g10
04:01:21  16  ,g11
04:01:21  17  ,g12
04:01:21  18  ,g13
04:01:21  19  ,g14
04:01:21  20  ,g15
04:01:21  21  ,g16
04:01:21  22  ,g17
04:01:21  23  ,g18
04:01:21  24  ,g19
04:01:21  25  ,g20
04:01:21  26  ,g21
04:01:21  27  ,g22
04:01:21  28  ,g23
04:01:21  29  ,g24
04:01:21  30  ,g25
04:01:21  31  ,g26
04:01:21  32  ,g27
04:01:21  33  ,g28
04:01:21  34  ,g29
04:01:21  35  ,g30
04:01:21  36  ,g31
04:01:21  37  ,g32
04:01:21  38  ,g33
04:01:21  39  ,g34
04:01:21  40  ,g35
04:01:21  41  ,g36
04:01:21  42  ,g37
04:01:21  43  ,g38
04:01:21  44  ,g39
04:01:21  45  ,g40
04:01:21  46  ,g41
04:01:21  47  ,sc_corr
04:01:21  48  FROM modsrc24
04:01:21  49  WHERE gattn IN('nup','up')
04:01:21  50  -- Use only rows which are older than 1 day:
04:01:21  51  AND 1+ydate < '&1'||' '||'&2'
04:01:21  52  AND pair = '&3'
04:01:21  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'03:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:01:21 SQL> 
04:01:21 SQL> -- rpt
04:01:21 SQL> 
04:01:21 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:01:21   2  
04:01:21 SQL> SELECT MAX(prdate) FROM bme
04:01:21   2  
04:01:21 SQL> -- Now build model from bme and score sme
04:01:21 SQL> @score1.sql gattn
04:01:21 SQL> --
04:01:21 SQL> -- score1.sql
04:01:21 SQL> --
04:01:21 SQL> 
04:01:21 SQL> -- I use this script to send 5 params to score.sql
04:01:21 SQL> -- which does the heavy lifting of creating an SVM model.
04:01:21 SQL> -- Then at the very end of this script I use the model
04:01:21 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:01:21 SQL> 
04:01:21 SQL> -- I call this script from 2 other scripts:
04:01:21 SQL> -- score1_5min.sql
04:01:21 SQL> -- score1_5min_gattn.sql
04:01:21 SQL> 
04:01:21 SQL> -- The 1st param is the name of the target attribute.
04:01:21 SQL> -- I like to call my target attributes either gatt or gattn.
04:01:21 SQL> 
04:01:21 SQL> -- Demo:
04:01:21 SQL> -- @score1.sql 'gatt'
04:01:21 SQL> -- @score1.sql 'gattn'
04:01:21 SQL> 
04:01:21 SQL> -- Now, I fill up svmc_apply_prep.
04:01:21 SQL> -- I use same model_name used in score.sql
04:01:21 SQL> DEFINE model_name = 'svmfx101'
04:01:21 SQL> DEFINE bldtable	= 'bme'
04:01:21 SQL> DEFINE scoretable = 'sme'
04:01:21 SQL> DEFINE case_id	= 'prdate'
04:01:21 SQL> -- Demo:
04:01:21 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:01:21 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:01:21 SQL> --
04:01:21 SQL> -- score.sql
04:01:21 SQL> --
04:01:21 SQL> 
04:01:21 SQL> -- usage: score.sql
04:01:21 SQL> 
04:01:21 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:01:21 SQL> 
04:01:21 SQL> -- DEFINE target	   = 'gatt'
04:01:21 SQL> -- DEFINE model_name = 'svmfx101'
04:01:21 SQL> -- DEFINE bldtable   = 'bme'
04:01:21 SQL> -- DEFINE scoretable = 'sme'
04:01:21 SQL> -- DEFINE case_id    = 'prdate'
04:01:21 SQL> 
04:01:21 SQL> DEFINE target	= '&1'
04:01:21 SQL> DEFINE model_name = '&2'
04:01:21 SQL> DEFINE bldtable	= '&3'
04:01:21 SQL> DEFINE scoretable = '&4'
04:01:21 SQL> DEFINE case_id	= '&5'
04:01:21 SQL> 
04:01:21 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:01:21 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:01:21 SQL> 
04:01:21 SQL> -- Builds an SVM model using pl/sql.
04:01:21 SQL> 
04:01:21 SQL> -----------------------------------------------------------------------
04:01:21 SQL> --			    BUILD THE MODEL
04:01:21 SQL> -----------------------------------------------------------------------
04:01:21 SQL> 
04:01:21 SQL> -- Cleanup old build data preparation objects for repeat runs
04:01:21 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:01:21 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:01:21 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:01:21 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:01:21 SQL> 
04:01:21 SQL> 
04:01:21 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:01:21 SQL> --
04:01:21 SQL> -- DROP	TABLE svmc_settings ;
04:01:21 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:01:21 SQL> -- DELETE svmc_settings;
04:01:21 SQL> 
04:01:21 SQL> -- The default classification algorithm is Naive Bayes. So override
04:01:21 SQL> -- this choice to SVM using a settings table.
04:01:21 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:01:21 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:01:21 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:01:21 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:01:21 SQL> -- models.
04:01:21 SQL> --
04:01:21 SQL> 
04:01:21 SQL> -- Do this once and then comment it out.
04:01:21 SQL> -- That makes script go faster.
04:01:21 SQL> -- BEGIN
04:01:21 SQL> -- -- Populate settings table
04:01:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:21 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:01:21 SQL> --
04:01:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:21 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:01:21 SQL> --
04:01:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:21 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:01:21 SQL> --   COMMIT;
04:01:21 SQL> -- END;
04:01:21 SQL> -- /
04:01:21 SQL> 
04:01:21 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:01:21 SQL> 
04:01:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:01:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:01:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:01:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:21 SQL> 
04:01:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:01:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:21 SQL> 
04:01:21 SQL> --------------------------------
04:01:21 SQL> -- PREPARE BUILD (TRAINING) DATA
04:01:21 SQL> --
04:01:21 SQL> 
04:01:21 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:21 SQL> -- 2. Outlier Treatment and
04:01:21 SQL> -- 3. Normalization are performed below.
04:01:21 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:01:21 SQL> --    normalized here.
04:01:21 SQL> 
04:01:21 SQL> BEGIN
04:01:21   2  	-- Perform missing value treatment for all predictors
04:01:21   3  	-- create miss tables
04:01:21   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:01:21   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:01:21   6  
04:01:21   7  	-- populate miss tables
04:01:21   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:01:21   9  	  miss_table_name => 'svmc_miss_num',
04:01:21  10  	  data_table_name => '&bldtable',
04:01:21  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:21  12  
04:01:21  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:01:21  14  	  miss_table_name => 'svmc_miss_cat',
04:01:21  15  	  data_table_name => '&bldtable',
04:01:21  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:21  17  
04:01:21  18  	-- xform input data to replace missing values
04:01:21  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:21  20  	  miss_table_name => 'svmc_miss_num',
04:01:21  21  	  data_table_name => '&bldtable',
04:01:21  22  	  xform_view_name => 'xformed_build_miss_num');
04:01:21  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:21  24  	  miss_table_name => 'svmc_miss_cat',
04:01:21  25  	  data_table_name => '&bldtable',
04:01:21  26  	  xform_view_name => 'xformed_build_miss_cat');
04:01:21  27  
04:01:21  28  	-- Perform outlier treatment.
04:01:21  29  	-- create clip table
04:01:21  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:01:21  31  
04:01:21  32  	-- populate clip table
04:01:21  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:01:21  34  	  clip_table_name => 'svmc_clip',
04:01:21  35  	  data_table_name => '&bldtable',
04:01:21  36  	  tail_frac	  => 0.025,
04:01:21  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:21  38  
04:01:21  39  	-- xform input data to winsorized data
04:01:21  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:01:21  41  	  clip_table_name => 'svmc_clip',
04:01:21  42  	  data_table_name => '&bldtable',
04:01:21  43  	  xform_view_name => 'svmc_winsor');
04:01:21  44  
04:01:21  45  	-- create normalization table
04:01:21  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:01:21  47  
04:01:21  48  	-- populate normalization table based on winsorized data
04:01:21  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:01:21  50  	  norm_table_name => 'svmc_norm',
04:01:21  51  	  data_table_name => 'svmc_winsor',
04:01:21  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:21  53  
04:01:21  54  	-- normalize the original data
04:01:21  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:21  56  	  norm_table_name => 'svmc_norm',
04:01:21  57  	  data_table_name => '&bldtable',
04:01:21  58  	  xform_view_name => 'svmc_build_prep');
04:01:21  59  END;
04:01:21  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.68
04:01:23 SQL> 
04:01:23 SQL> ---------------------
04:01:23 SQL> -- CREATE A NEW MODEL
04:01:23 SQL> --
04:01:23 SQL> -- Cleanup old model with the same name for repeat runs
04:01:23 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:01:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:23   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
04:01:25 SQL> 
04:01:25 SQL> -- Build a new SVM Model
04:01:25 SQL> BEGIN
04:01:25   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:01:25   3  	  model_name	      => '&model_name',
04:01:25   4  	  mining_function     => dbms_data_mining.classification,
04:01:25   5  	  data_table_name     => 'svmc_build_prep',
04:01:25   6  	  case_id_column_name => '&case_id',
04:01:25   7  	  target_column_name  => '&target',
04:01:25   8  	  settings_table_name => 'svmc_settings');
04:01:25   9  END;
04:01:25  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.46
04:01:30 SQL> 
04:01:30 SQL> -----------------------------------------------------------------------
04:01:30 SQL> --			       APPLY/score THE MODEL
04:01:30 SQL> -----------------------------------------------------------------------
04:01:30 SQL> 
04:01:30 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:01:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:01:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:01:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:01:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:31 SQL> -----------------------
04:01:31 SQL> -- PREPARE SCORING DATA
04:01:31 SQL> --
04:01:31 SQL> -- If the data for model creation has been prepared, then the data
04:01:31 SQL> -- to be scored using the model must be prepared in the same manner
04:01:31 SQL> -- in order to obtain meaningful results.
04:01:31 SQL> --
04:01:31 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:31 SQL> -- 2. Normalization
04:01:31 SQL> -- No outlier treatment will be performed during test and apply. The
04:01:31 SQL> -- normalization step is sufficient, since the normalization parameters
04:01:31 SQL> -- already capture the effects of outlier treatment done with build data.
04:01:31 SQL> --
04:01:31 SQL> BEGIN
04:01:31   2  	-- Xform Test data to replace missing values
04:01:31   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:31   4  	  miss_table_name => 'svmc_miss_num',
04:01:31   5  	  data_table_name => '&scoretable',
04:01:31   6  	  xform_view_name => 'xformed_apply_miss_num');
04:01:31   7  
04:01:31   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:31   9  	  miss_table_name => 'svmc_miss_cat',
04:01:31  10  	  data_table_name => '&scoretable',
04:01:31  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:01:31  12  
04:01:31  13  	-- Normalize the data to be scored
04:01:31  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:31  15  	  norm_table_name => 'svmc_norm',
04:01:31  16  	  data_table_name => '&scoretable',
04:01:31  17  	  xform_view_name => 'svmc_apply_prep');
04:01:31  18  END;
04:01:31  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
04:01:31 SQL> 
04:01:31 SQL> -- Maybe I already collected a score for this prdate.
04:01:31 SQL> -- DELETE it if I did:
04:01:31 SQL> DELETE svm24scores
04:01:31   2  WHERE score > 0
04:01:31   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:01:31   4  -- I need to supply the target attribute name:
04:01:31   5  AND targ = '&1'
04:01:31   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:01:31 SQL> 
04:01:31 SQL> -- We do a drumroll here:
04:01:31 SQL> 
04:01:31 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:01:31   2  SELECT
04:01:31   3  prdate
04:01:31   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:01:31   5  ,sysdate
04:01:31   6  ,SUBSTR(prdate,1,7)pair
04:01:31   7  ,SUBSTR(prdate,-19)ydate
04:01:31   8  ,'&1'
04:01:31   9  FROM svmc_apply_prep
04:01:31  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:01:31 SQL> @score1_5min.sql	      2011-01-27 01:20:00 eur_usd
04:01:31 SQL> --
04:01:31 SQL> -- score1_5min.sql
04:01:31 SQL> --
04:01:31 SQL> 
04:01:31 SQL> -- Demo:
04:01:31 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
04:01:31 SQL> 
04:01:31 SQL> CREATE OR REPLACE VIEW sme AS
04:01:31   2  SELECT
04:01:31   3  prdate
04:01:31   4  ,NULL gatt
04:01:31   5  ,g00
04:01:31   6  ,g01
04:01:31   7  ,g02
04:01:31   8  ,g03
04:01:31   9  ,g04
04:01:31  10  ,g05
04:01:31  11  ,g06
04:01:31  12  ,g07
04:01:31  13  ,g08
04:01:31  14  ,g09
04:01:31  15  ,g10
04:01:31  16  ,g11
04:01:31  17  ,g12
04:01:31  18  ,g13
04:01:31  19  ,g14
04:01:31  20  ,g15
04:01:31  21  ,g16
04:01:31  22  ,g17
04:01:31  23  ,g18
04:01:31  24  ,g19
04:01:31  25  ,g20
04:01:31  26  ,g21
04:01:31  27  ,g22
04:01:31  28  ,g23
04:01:31  29  ,g24
04:01:31  30  ,g25
04:01:31  31  ,g26
04:01:31  32  ,g27
04:01:31  33  ,g28
04:01:31  34  ,g29
04:01:31  35  ,g30
04:01:31  36  ,g31
04:01:31  37  ,g32
04:01:31  38  ,g33
04:01:31  39  ,g34
04:01:31  40  ,g35
04:01:31  41  ,g36
04:01:31  42  ,g37
04:01:31  43  ,g38
04:01:31  44  ,g39
04:01:31  45  ,g40
04:01:31  46  ,g41
04:01:31  47  ,s.sc_corr
04:01:31  48  FROM modsrc24
04:01:31  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:01:31  50  WHERE ydate = '&1'||' '||'&2'
04:01:31  51  AND pair = '&3'
04:01:31  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'01:20:00'AND ydate<'2011-01-27'||' '||'01:20:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'01:20:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
04:01:31 SQL> 
04:01:31 SQL> -- rpt
04:01:31 SQL> -- We should see just 1 row:
04:01:31 SQL> 
04:01:31 SQL> SELECT COUNT(prdate) FROM sme
04:01:31   2  
04:01:31 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:01:31   2  
04:01:31 SQL> 
04:01:31 SQL> -- Build the model:
04:01:31 SQL> CREATE OR REPLACE VIEW bme AS
04:01:31   2  SELECT
04:01:31   3  prdate
04:01:31   4  ,gatt
04:01:31   5  ,g00
04:01:31   6  ,g01
04:01:31   7  ,g02
04:01:31   8  ,g03
04:01:31   9  ,g04
04:01:31  10  ,g05
04:01:31  11  ,g06
04:01:31  12  ,g07
04:01:31  13  ,g08
04:01:31  14  ,g09
04:01:31  15  ,g10
04:01:31  16  ,g11
04:01:31  17  ,g12
04:01:31  18  ,g13
04:01:31  19  ,g14
04:01:31  20  ,g15
04:01:31  21  ,g16
04:01:31  22  ,g17
04:01:31  23  ,g18
04:01:31  24  ,g19
04:01:31  25  ,g20
04:01:31  26  ,g21
04:01:31  27  ,g22
04:01:31  28  ,g23
04:01:31  29  ,g24
04:01:31  30  ,g25
04:01:31  31  ,g26
04:01:31  32  ,g27
04:01:31  33  ,g28
04:01:31  34  ,g29
04:01:31  35  ,g30
04:01:31  36  ,g31
04:01:31  37  ,g32
04:01:31  38  ,g33
04:01:31  39  ,g34
04:01:31  40  ,g35
04:01:31  41  ,g36
04:01:31  42  ,g37
04:01:31  43  ,g38
04:01:31  44  ,g39
04:01:31  45  ,g40
04:01:31  46  ,g41
04:01:31  47  ,sc_corr
04:01:31  48  FROM modsrc24
04:01:31  49  WHERE gatt IN('nup','up')
04:01:31  50  -- Use only rows which are older than 1 day:
04:01:31  51  AND 1+ydate < '&1'||' '||'&2'
04:01:31  52  AND pair = '&3'
04:01:31  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'01:20:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:01:31 SQL> 
04:01:31 SQL> -- rpt
04:01:31 SQL> 
04:01:31 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
04:01:31   2  
04:01:31 SQL> SELECT MAX(prdate) FROM bme
04:01:31   2  
04:01:31 SQL> -- Now build model from bme and score sme
04:01:31 SQL> @score1.sql gatt
04:01:31 SQL> --
04:01:31 SQL> -- score1.sql
04:01:31 SQL> --
04:01:31 SQL> 
04:01:31 SQL> -- I use this script to send 5 params to score.sql
04:01:31 SQL> -- which does the heavy lifting of creating an SVM model.
04:01:31 SQL> -- Then at the very end of this script I use the model
04:01:31 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:01:31 SQL> 
04:01:31 SQL> -- I call this script from 2 other scripts:
04:01:31 SQL> -- score1_5min.sql
04:01:31 SQL> -- score1_5min_gattn.sql
04:01:31 SQL> 
04:01:31 SQL> -- The 1st param is the name of the target attribute.
04:01:31 SQL> -- I like to call my target attributes either gatt or gattn.
04:01:31 SQL> 
04:01:31 SQL> -- Demo:
04:01:31 SQL> -- @score1.sql 'gatt'
04:01:31 SQL> -- @score1.sql 'gattn'
04:01:31 SQL> 
04:01:31 SQL> -- Now, I fill up svmc_apply_prep.
04:01:31 SQL> -- I use same model_name used in score.sql
04:01:31 SQL> DEFINE model_name = 'svmfx101'
04:01:31 SQL> DEFINE bldtable	= 'bme'
04:01:31 SQL> DEFINE scoretable = 'sme'
04:01:31 SQL> DEFINE case_id	= 'prdate'
04:01:31 SQL> -- Demo:
04:01:31 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:01:31 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:01:31 SQL> --
04:01:31 SQL> -- score.sql
04:01:31 SQL> --
04:01:31 SQL> 
04:01:31 SQL> -- usage: score.sql
04:01:31 SQL> 
04:01:31 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:01:31 SQL> 
04:01:31 SQL> -- DEFINE target	   = 'gatt'
04:01:31 SQL> -- DEFINE model_name = 'svmfx101'
04:01:31 SQL> -- DEFINE bldtable   = 'bme'
04:01:31 SQL> -- DEFINE scoretable = 'sme'
04:01:31 SQL> -- DEFINE case_id    = 'prdate'
04:01:31 SQL> 
04:01:31 SQL> DEFINE target	= '&1'
04:01:31 SQL> DEFINE model_name = '&2'
04:01:31 SQL> DEFINE bldtable	= '&3'
04:01:31 SQL> DEFINE scoretable = '&4'
04:01:31 SQL> DEFINE case_id	= '&5'
04:01:31 SQL> 
04:01:31 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:01:31 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:01:31 SQL> 
04:01:31 SQL> -- Builds an SVM model using pl/sql.
04:01:31 SQL> 
04:01:31 SQL> -----------------------------------------------------------------------
04:01:31 SQL> --			    BUILD THE MODEL
04:01:31 SQL> -----------------------------------------------------------------------
04:01:31 SQL> 
04:01:31 SQL> -- Cleanup old build data preparation objects for repeat runs
04:01:31 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:01:31 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:01:31 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:01:31 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:01:31 SQL> 
04:01:31 SQL> 
04:01:31 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:01:31 SQL> --
04:01:31 SQL> -- DROP	TABLE svmc_settings ;
04:01:31 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:01:31 SQL> -- DELETE svmc_settings;
04:01:31 SQL> 
04:01:31 SQL> -- The default classification algorithm is Naive Bayes. So override
04:01:31 SQL> -- this choice to SVM using a settings table.
04:01:31 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:01:31 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:01:31 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:01:31 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:01:31 SQL> -- models.
04:01:31 SQL> --
04:01:31 SQL> 
04:01:31 SQL> -- Do this once and then comment it out.
04:01:31 SQL> -- That makes script go faster.
04:01:31 SQL> -- BEGIN
04:01:31 SQL> -- -- Populate settings table
04:01:31 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:31 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:01:31 SQL> --
04:01:31 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:31 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:01:31 SQL> --
04:01:31 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:31 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:01:31 SQL> --   COMMIT;
04:01:31 SQL> -- END;
04:01:31 SQL> -- /
04:01:31 SQL> 
04:01:31 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:01:31 SQL> 
04:01:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:01:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
04:01:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:01:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:01:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:31 SQL> 
04:01:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:01:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:31 SQL> 
04:01:31 SQL> --------------------------------
04:01:31 SQL> -- PREPARE BUILD (TRAINING) DATA
04:01:31 SQL> --
04:01:31 SQL> 
04:01:31 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:31 SQL> -- 2. Outlier Treatment and
04:01:31 SQL> -- 3. Normalization are performed below.
04:01:31 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:01:31 SQL> --    normalized here.
04:01:31 SQL> 
04:01:31 SQL> BEGIN
04:01:31   2  	-- Perform missing value treatment for all predictors
04:01:31   3  	-- create miss tables
04:01:31   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:01:31   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:01:31   6  
04:01:31   7  	-- populate miss tables
04:01:31   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:01:31   9  	  miss_table_name => 'svmc_miss_num',
04:01:31  10  	  data_table_name => '&bldtable',
04:01:31  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:31  12  
04:01:31  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:01:31  14  	  miss_table_name => 'svmc_miss_cat',
04:01:31  15  	  data_table_name => '&bldtable',
04:01:31  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:31  17  
04:01:31  18  	-- xform input data to replace missing values
04:01:31  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:31  20  	  miss_table_name => 'svmc_miss_num',
04:01:31  21  	  data_table_name => '&bldtable',
04:01:31  22  	  xform_view_name => 'xformed_build_miss_num');
04:01:31  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:31  24  	  miss_table_name => 'svmc_miss_cat',
04:01:31  25  	  data_table_name => '&bldtable',
04:01:31  26  	  xform_view_name => 'xformed_build_miss_cat');
04:01:31  27  
04:01:31  28  	-- Perform outlier treatment.
04:01:31  29  	-- create clip table
04:01:31  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:01:31  31  
04:01:31  32  	-- populate clip table
04:01:31  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:01:31  34  	  clip_table_name => 'svmc_clip',
04:01:31  35  	  data_table_name => '&bldtable',
04:01:31  36  	  tail_frac	  => 0.025,
04:01:31  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:31  38  
04:01:31  39  	-- xform input data to winsorized data
04:01:31  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:01:31  41  	  clip_table_name => 'svmc_clip',
04:01:31  42  	  data_table_name => '&bldtable',
04:01:31  43  	  xform_view_name => 'svmc_winsor');
04:01:31  44  
04:01:31  45  	-- create normalization table
04:01:31  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:01:31  47  
04:01:31  48  	-- populate normalization table based on winsorized data
04:01:31  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:01:31  50  	  norm_table_name => 'svmc_norm',
04:01:31  51  	  data_table_name => 'svmc_winsor',
04:01:31  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:31  53  
04:01:31  54  	-- normalize the original data
04:01:31  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:31  56  	  norm_table_name => 'svmc_norm',
04:01:31  57  	  data_table_name => '&bldtable',
04:01:31  58  	  xform_view_name => 'svmc_build_prep');
04:01:31  59  END;
04:01:31  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.66
04:01:34 SQL> 
04:01:34 SQL> ---------------------
04:01:34 SQL> -- CREATE A NEW MODEL
04:01:34 SQL> --
04:01:34 SQL> -- Cleanup old model with the same name for repeat runs
04:01:34 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:01:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:34   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.55
04:01:35 SQL> 
04:01:35 SQL> -- Build a new SVM Model
04:01:35 SQL> BEGIN
04:01:35   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:01:35   3  	  model_name	      => '&model_name',
04:01:35   4  	  mining_function     => dbms_data_mining.classification,
04:01:35   5  	  data_table_name     => 'svmc_build_prep',
04:01:35   6  	  case_id_column_name => '&case_id',
04:01:35   7  	  target_column_name  => '&target',
04:01:35   8  	  settings_table_name => 'svmc_settings');
04:01:35   9  END;
04:01:35  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.19
04:01:40 SQL> 
04:01:40 SQL> -----------------------------------------------------------------------
04:01:40 SQL> --			       APPLY/score THE MODEL
04:01:40 SQL> -----------------------------------------------------------------------
04:01:40 SQL> 
04:01:40 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:01:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:01:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:01:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:01:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:01:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:41 SQL> -----------------------
04:01:41 SQL> -- PREPARE SCORING DATA
04:01:41 SQL> --
04:01:41 SQL> -- If the data for model creation has been prepared, then the data
04:01:41 SQL> -- to be scored using the model must be prepared in the same manner
04:01:41 SQL> -- in order to obtain meaningful results.
04:01:41 SQL> --
04:01:41 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:41 SQL> -- 2. Normalization
04:01:41 SQL> -- No outlier treatment will be performed during test and apply. The
04:01:41 SQL> -- normalization step is sufficient, since the normalization parameters
04:01:41 SQL> -- already capture the effects of outlier treatment done with build data.
04:01:41 SQL> --
04:01:41 SQL> BEGIN
04:01:41   2  	-- Xform Test data to replace missing values
04:01:41   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:41   4  	  miss_table_name => 'svmc_miss_num',
04:01:41   5  	  data_table_name => '&scoretable',
04:01:41   6  	  xform_view_name => 'xformed_apply_miss_num');
04:01:41   7  
04:01:41   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:41   9  	  miss_table_name => 'svmc_miss_cat',
04:01:41  10  	  data_table_name => '&scoretable',
04:01:41  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:01:41  12  
04:01:41  13  	-- Normalize the data to be scored
04:01:41  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:41  15  	  norm_table_name => 'svmc_norm',
04:01:41  16  	  data_table_name => '&scoretable',
04:01:41  17  	  xform_view_name => 'svmc_apply_prep');
04:01:41  18  END;
04:01:41  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:01:41 SQL> 
04:01:41 SQL> -- Maybe I already collected a score for this prdate.
04:01:41 SQL> -- DELETE it if I did:
04:01:41 SQL> DELETE svm24scores
04:01:41   2  WHERE score > 0
04:01:41   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:01:41   4  -- I need to supply the target attribute name:
04:01:41   5  AND targ = '&1'
04:01:41   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.03
04:01:41 SQL> 
04:01:41 SQL> -- We do a drumroll here:
04:01:41 SQL> 
04:01:41 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:01:41   2  SELECT
04:01:41   3  prdate
04:01:41   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:01:41   5  ,sysdate
04:01:41   6  ,SUBSTR(prdate,1,7)pair
04:01:41   7  ,SUBSTR(prdate,-19)ydate
04:01:41   8  ,'&1'
04:01:41   9  FROM svmc_apply_prep
04:01:41  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
04:01:41 SQL> @score1_5min.sql	      2011-01-28 13:15:00 eur_usd
04:01:41 SQL> --
04:01:41 SQL> -- score1_5min.sql
04:01:41 SQL> --
04:01:41 SQL> 
04:01:41 SQL> -- Demo:
04:01:41 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
04:01:41 SQL> 
04:01:41 SQL> CREATE OR REPLACE VIEW sme AS
04:01:41   2  SELECT
04:01:41   3  prdate
04:01:41   4  ,NULL gatt
04:01:41   5  ,g00
04:01:41   6  ,g01
04:01:41   7  ,g02
04:01:41   8  ,g03
04:01:41   9  ,g04
04:01:41  10  ,g05
04:01:41  11  ,g06
04:01:41  12  ,g07
04:01:41  13  ,g08
04:01:41  14  ,g09
04:01:41  15  ,g10
04:01:41  16  ,g11
04:01:41  17  ,g12
04:01:41  18  ,g13
04:01:41  19  ,g14
04:01:41  20  ,g15
04:01:41  21  ,g16
04:01:41  22  ,g17
04:01:41  23  ,g18
04:01:41  24  ,g19
04:01:41  25  ,g20
04:01:41  26  ,g21
04:01:41  27  ,g22
04:01:41  28  ,g23
04:01:41  29  ,g24
04:01:41  30  ,g25
04:01:41  31  ,g26
04:01:41  32  ,g27
04:01:41  33  ,g28
04:01:41  34  ,g29
04:01:41  35  ,g30
04:01:41  36  ,g31
04:01:41  37  ,g32
04:01:41  38  ,g33
04:01:41  39  ,g34
04:01:41  40  ,g35
04:01:41  41  ,g36
04:01:41  42  ,g37
04:01:41  43  ,g38
04:01:41  44  ,g39
04:01:41  45  ,g40
04:01:41  46  ,g41
04:01:41  47  ,s.sc_corr
04:01:41  48  FROM modsrc24
04:01:41  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:01:41  50  WHERE ydate = '&1'||' '||'&2'
04:01:41  51  AND pair = '&3'
04:01:41  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-28'||' '||'13:15:00'AND ydate<'2011-01-28'||' '||'13:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-28'||' '||'13:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.07
04:01:41 SQL> 
04:01:41 SQL> -- rpt
04:01:41 SQL> -- We should see just 1 row:
04:01:41 SQL> 
04:01:41 SQL> SELECT COUNT(prdate) FROM sme
04:01:41   2  
04:01:41 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:01:41   2  
04:01:41 SQL> 
04:01:41 SQL> -- Build the model:
04:01:41 SQL> CREATE OR REPLACE VIEW bme AS
04:01:41   2  SELECT
04:01:41   3  prdate
04:01:41   4  ,gatt
04:01:41   5  ,g00
04:01:41   6  ,g01
04:01:41   7  ,g02
04:01:41   8  ,g03
04:01:41   9  ,g04
04:01:41  10  ,g05
04:01:41  11  ,g06
04:01:41  12  ,g07
04:01:41  13  ,g08
04:01:41  14  ,g09
04:01:41  15  ,g10
04:01:41  16  ,g11
04:01:41  17  ,g12
04:01:41  18  ,g13
04:01:41  19  ,g14
04:01:41  20  ,g15
04:01:41  21  ,g16
04:01:41  22  ,g17
04:01:41  23  ,g18
04:01:41  24  ,g19
04:01:41  25  ,g20
04:01:41  26  ,g21
04:01:41  27  ,g22
04:01:41  28  ,g23
04:01:41  29  ,g24
04:01:41  30  ,g25
04:01:41  31  ,g26
04:01:41  32  ,g27
04:01:41  33  ,g28
04:01:41  34  ,g29
04:01:41  35  ,g30
04:01:41  36  ,g31
04:01:41  37  ,g32
04:01:41  38  ,g33
04:01:41  39  ,g34
04:01:41  40  ,g35
04:01:41  41  ,g36
04:01:41  42  ,g37
04:01:41  43  ,g38
04:01:41  44  ,g39
04:01:41  45  ,g40
04:01:41  46  ,g41
04:01:41  47  ,sc_corr
04:01:41  48  FROM modsrc24
04:01:41  49  WHERE gatt IN('nup','up')
04:01:41  50  -- Use only rows which are older than 1 day:
04:01:41  51  AND 1+ydate < '&1'||' '||'&2'
04:01:41  52  AND pair = '&3'
04:01:41  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-28'||' '||'13:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:01:41 SQL> 
04:01:41 SQL> -- rpt
04:01:41 SQL> 
04:01:41 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
04:01:41   2  
04:01:41 SQL> SELECT MAX(prdate) FROM bme
04:01:41   2  
04:01:41 SQL> -- Now build model from bme and score sme
04:01:41 SQL> @score1.sql gatt
04:01:41 SQL> --
04:01:41 SQL> -- score1.sql
04:01:41 SQL> --
04:01:41 SQL> 
04:01:41 SQL> -- I use this script to send 5 params to score.sql
04:01:41 SQL> -- which does the heavy lifting of creating an SVM model.
04:01:41 SQL> -- Then at the very end of this script I use the model
04:01:41 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:01:41 SQL> 
04:01:41 SQL> -- I call this script from 2 other scripts:
04:01:41 SQL> -- score1_5min.sql
04:01:41 SQL> -- score1_5min_gattn.sql
04:01:41 SQL> 
04:01:41 SQL> -- The 1st param is the name of the target attribute.
04:01:41 SQL> -- I like to call my target attributes either gatt or gattn.
04:01:41 SQL> 
04:01:41 SQL> -- Demo:
04:01:41 SQL> -- @score1.sql 'gatt'
04:01:41 SQL> -- @score1.sql 'gattn'
04:01:41 SQL> 
04:01:41 SQL> -- Now, I fill up svmc_apply_prep.
04:01:41 SQL> -- I use same model_name used in score.sql
04:01:41 SQL> DEFINE model_name = 'svmfx101'
04:01:41 SQL> DEFINE bldtable	= 'bme'
04:01:41 SQL> DEFINE scoretable = 'sme'
04:01:41 SQL> DEFINE case_id	= 'prdate'
04:01:41 SQL> -- Demo:
04:01:41 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:01:41 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:01:41 SQL> --
04:01:41 SQL> -- score.sql
04:01:41 SQL> --
04:01:41 SQL> 
04:01:41 SQL> -- usage: score.sql
04:01:41 SQL> 
04:01:41 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:01:41 SQL> 
04:01:41 SQL> -- DEFINE target	   = 'gatt'
04:01:41 SQL> -- DEFINE model_name = 'svmfx101'
04:01:41 SQL> -- DEFINE bldtable   = 'bme'
04:01:41 SQL> -- DEFINE scoretable = 'sme'
04:01:41 SQL> -- DEFINE case_id    = 'prdate'
04:01:41 SQL> 
04:01:41 SQL> DEFINE target	= '&1'
04:01:41 SQL> DEFINE model_name = '&2'
04:01:41 SQL> DEFINE bldtable	= '&3'
04:01:41 SQL> DEFINE scoretable = '&4'
04:01:41 SQL> DEFINE case_id	= '&5'
04:01:41 SQL> 
04:01:41 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:01:41 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:01:41 SQL> 
04:01:41 SQL> -- Builds an SVM model using pl/sql.
04:01:41 SQL> 
04:01:41 SQL> -----------------------------------------------------------------------
04:01:41 SQL> --			    BUILD THE MODEL
04:01:41 SQL> -----------------------------------------------------------------------
04:01:41 SQL> 
04:01:41 SQL> -- Cleanup old build data preparation objects for repeat runs
04:01:41 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
04:01:41 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:01:41 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:01:41 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
04:01:41 SQL> 
04:01:41 SQL> 
04:01:41 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:01:41 SQL> --
04:01:41 SQL> -- DROP	TABLE svmc_settings ;
04:01:41 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:01:41 SQL> -- DELETE svmc_settings;
04:01:41 SQL> 
04:01:41 SQL> -- The default classification algorithm is Naive Bayes. So override
04:01:41 SQL> -- this choice to SVM using a settings table.
04:01:41 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:01:41 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:01:41 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:01:41 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:01:41 SQL> -- models.
04:01:41 SQL> --
04:01:41 SQL> 
04:01:41 SQL> -- Do this once and then comment it out.
04:01:41 SQL> -- That makes script go faster.
04:01:41 SQL> -- BEGIN
04:01:41 SQL> -- -- Populate settings table
04:01:41 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:41 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:01:41 SQL> --
04:01:41 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:41 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:01:41 SQL> --
04:01:41 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:41 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:01:41 SQL> --   COMMIT;
04:01:41 SQL> -- END;
04:01:41 SQL> -- /
04:01:41 SQL> 
04:01:41 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:01:41 SQL> 
04:01:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:01:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:01:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:01:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.12
04:01:41 SQL> 
04:01:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:01:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
04:01:41 SQL> 
04:01:41 SQL> --------------------------------
04:01:41 SQL> -- PREPARE BUILD (TRAINING) DATA
04:01:41 SQL> --
04:01:41 SQL> 
04:01:41 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:41 SQL> -- 2. Outlier Treatment and
04:01:41 SQL> -- 3. Normalization are performed below.
04:01:41 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:01:41 SQL> --    normalized here.
04:01:41 SQL> 
04:01:41 SQL> BEGIN
04:01:41   2  	-- Perform missing value treatment for all predictors
04:01:41   3  	-- create miss tables
04:01:41   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:01:41   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:01:41   6  
04:01:41   7  	-- populate miss tables
04:01:41   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:01:41   9  	  miss_table_name => 'svmc_miss_num',
04:01:41  10  	  data_table_name => '&bldtable',
04:01:41  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:41  12  
04:01:41  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:01:41  14  	  miss_table_name => 'svmc_miss_cat',
04:01:41  15  	  data_table_name => '&bldtable',
04:01:41  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:41  17  
04:01:41  18  	-- xform input data to replace missing values
04:01:41  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:41  20  	  miss_table_name => 'svmc_miss_num',
04:01:41  21  	  data_table_name => '&bldtable',
04:01:41  22  	  xform_view_name => 'xformed_build_miss_num');
04:01:41  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:41  24  	  miss_table_name => 'svmc_miss_cat',
04:01:41  25  	  data_table_name => '&bldtable',
04:01:41  26  	  xform_view_name => 'xformed_build_miss_cat');
04:01:41  27  
04:01:41  28  	-- Perform outlier treatment.
04:01:41  29  	-- create clip table
04:01:41  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:01:41  31  
04:01:41  32  	-- populate clip table
04:01:41  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:01:41  34  	  clip_table_name => 'svmc_clip',
04:01:41  35  	  data_table_name => '&bldtable',
04:01:41  36  	  tail_frac	  => 0.025,
04:01:41  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:41  38  
04:01:41  39  	-- xform input data to winsorized data
04:01:41  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:01:41  41  	  clip_table_name => 'svmc_clip',
04:01:41  42  	  data_table_name => '&bldtable',
04:01:41  43  	  xform_view_name => 'svmc_winsor');
04:01:41  44  
04:01:41  45  	-- create normalization table
04:01:41  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:01:41  47  
04:01:41  48  	-- populate normalization table based on winsorized data
04:01:41  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:01:41  50  	  norm_table_name => 'svmc_norm',
04:01:41  51  	  data_table_name => 'svmc_winsor',
04:01:41  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:41  53  
04:01:41  54  	-- normalize the original data
04:01:41  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:41  56  	  norm_table_name => 'svmc_norm',
04:01:41  57  	  data_table_name => '&bldtable',
04:01:41  58  	  xform_view_name => 'svmc_build_prep');
04:01:41  59  END;
04:01:41  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.75
04:01:44 SQL> 
04:01:44 SQL> ---------------------
04:01:44 SQL> -- CREATE A NEW MODEL
04:01:44 SQL> --
04:01:44 SQL> -- Cleanup old model with the same name for repeat runs
04:01:44 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:01:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:44   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
04:01:46 SQL> 
04:01:46 SQL> -- Build a new SVM Model
04:01:46 SQL> BEGIN
04:01:46   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:01:46   3  	  model_name	      => '&model_name',
04:01:46   4  	  mining_function     => dbms_data_mining.classification,
04:01:46   5  	  data_table_name     => 'svmc_build_prep',
04:01:46   6  	  case_id_column_name => '&case_id',
04:01:46   7  	  target_column_name  => '&target',
04:01:46   8  	  settings_table_name => 'svmc_settings');
04:01:46   9  END;
04:01:46  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.31
04:01:51 SQL> 
04:01:51 SQL> -----------------------------------------------------------------------
04:01:51 SQL> --			       APPLY/score THE MODEL
04:01:51 SQL> -----------------------------------------------------------------------
04:01:51 SQL> 
04:01:51 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:51 SQL> -----------------------
04:01:51 SQL> -- PREPARE SCORING DATA
04:01:51 SQL> --
04:01:51 SQL> -- If the data for model creation has been prepared, then the data
04:01:51 SQL> -- to be scored using the model must be prepared in the same manner
04:01:51 SQL> -- in order to obtain meaningful results.
04:01:51 SQL> --
04:01:51 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:51 SQL> -- 2. Normalization
04:01:51 SQL> -- No outlier treatment will be performed during test and apply. The
04:01:51 SQL> -- normalization step is sufficient, since the normalization parameters
04:01:51 SQL> -- already capture the effects of outlier treatment done with build data.
04:01:51 SQL> --
04:01:51 SQL> BEGIN
04:01:51   2  	-- Xform Test data to replace missing values
04:01:51   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:51   4  	  miss_table_name => 'svmc_miss_num',
04:01:51   5  	  data_table_name => '&scoretable',
04:01:51   6  	  xform_view_name => 'xformed_apply_miss_num');
04:01:51   7  
04:01:51   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:51   9  	  miss_table_name => 'svmc_miss_cat',
04:01:51  10  	  data_table_name => '&scoretable',
04:01:51  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:01:51  12  
04:01:51  13  	-- Normalize the data to be scored
04:01:51  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:51  15  	  norm_table_name => 'svmc_norm',
04:01:51  16  	  data_table_name => '&scoretable',
04:01:51  17  	  xform_view_name => 'svmc_apply_prep');
04:01:51  18  END;
04:01:51  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:01:51 SQL> 
04:01:51 SQL> -- Maybe I already collected a score for this prdate.
04:01:51 SQL> -- DELETE it if I did:
04:01:51 SQL> DELETE svm24scores
04:01:51   2  WHERE score > 0
04:01:51   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:01:51   4  -- I need to supply the target attribute name:
04:01:51   5  AND targ = '&1'
04:01:51   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.04
04:01:51 SQL> 
04:01:51 SQL> -- We do a drumroll here:
04:01:51 SQL> 
04:01:51 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:01:51   2  SELECT
04:01:51   3  prdate
04:01:51   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:01:51   5  ,sysdate
04:01:51   6  ,SUBSTR(prdate,1,7)pair
04:01:51   7  ,SUBSTR(prdate,-19)ydate
04:01:51   8  ,'&1'
04:01:51   9  FROM svmc_apply_prep
04:01:51  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gatt'

1 row created.

Elapsed: 00:00:00.06
04:01:51 SQL> @score1_5min_gattn.sql	2011-01-25 00:40:00 eur_usd
04:01:51 SQL> --
04:01:51 SQL> -- score1_5min_gattn.sql
04:01:51 SQL> --
04:01:51 SQL> 
04:01:51 SQL> -- Demo:
04:01:51 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:01:51 SQL> 
04:01:51 SQL> CREATE OR REPLACE VIEW sme AS
04:01:51   2  SELECT
04:01:51   3  prdate
04:01:51   4  ,NULL gattn
04:01:51   5  ,g00
04:01:51   6  ,g01
04:01:51   7  ,g02
04:01:51   8  ,g03
04:01:51   9  ,g04
04:01:51  10  ,g05
04:01:51  11  ,g06
04:01:51  12  ,g07
04:01:51  13  ,g08
04:01:51  14  ,g09
04:01:51  15  ,g10
04:01:51  16  ,g11
04:01:51  17  ,g12
04:01:51  18  ,g13
04:01:51  19  ,g14
04:01:51  20  ,g15
04:01:51  21  ,g16
04:01:51  22  ,g17
04:01:51  23  ,g18
04:01:51  24  ,g19
04:01:51  25  ,g20
04:01:51  26  ,g21
04:01:51  27  ,g22
04:01:51  28  ,g23
04:01:51  29  ,g24
04:01:51  30  ,g25
04:01:51  31  ,g26
04:01:51  32  ,g27
04:01:51  33  ,g28
04:01:51  34  ,g29
04:01:51  35  ,g30
04:01:51  36  ,g31
04:01:51  37  ,g32
04:01:51  38  ,g33
04:01:51  39  ,g34
04:01:51  40  ,g35
04:01:51  41  ,g36
04:01:51  42  ,g37
04:01:51  43  ,g38
04:01:51  44  ,g39
04:01:51  45  ,g40
04:01:51  46  ,g41
04:01:51  47  ,s.sc_corr
04:01:51  48  FROM modsrc24
04:01:51  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:01:51  50  WHERE ydate = '&1'||' '||'&2'
04:01:51  51  AND pair = '&3'
04:01:51  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'00:40:00'AND ydate<'2011-01-25'||' '||'00:40:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'00:40:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.03
04:01:51 SQL> 
04:01:51 SQL> -- rpt
04:01:51 SQL> -- We should see just 1 row:
04:01:51 SQL> 
04:01:51 SQL> SELECT COUNT(prdate) FROM sme
04:01:51   2  
04:01:51 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:01:51   2  
04:01:51 SQL> 
04:01:51 SQL> -- Build the model:
04:01:51 SQL> CREATE OR REPLACE VIEW bme AS
04:01:51   2  SELECT
04:01:51   3  prdate
04:01:51   4  ,gattn
04:01:51   5  ,g00
04:01:51   6  ,g01
04:01:51   7  ,g02
04:01:51   8  ,g03
04:01:51   9  ,g04
04:01:51  10  ,g05
04:01:51  11  ,g06
04:01:51  12  ,g07
04:01:51  13  ,g08
04:01:51  14  ,g09
04:01:51  15  ,g10
04:01:51  16  ,g11
04:01:51  17  ,g12
04:01:51  18  ,g13
04:01:51  19  ,g14
04:01:51  20  ,g15
04:01:51  21  ,g16
04:01:51  22  ,g17
04:01:51  23  ,g18
04:01:51  24  ,g19
04:01:51  25  ,g20
04:01:51  26  ,g21
04:01:51  27  ,g22
04:01:51  28  ,g23
04:01:51  29  ,g24
04:01:51  30  ,g25
04:01:51  31  ,g26
04:01:51  32  ,g27
04:01:51  33  ,g28
04:01:51  34  ,g29
04:01:51  35  ,g30
04:01:51  36  ,g31
04:01:51  37  ,g32
04:01:51  38  ,g33
04:01:51  39  ,g34
04:01:51  40  ,g35
04:01:51  41  ,g36
04:01:51  42  ,g37
04:01:51  43  ,g38
04:01:51  44  ,g39
04:01:51  45  ,g40
04:01:51  46  ,g41
04:01:51  47  ,sc_corr
04:01:51  48  FROM modsrc24
04:01:51  49  WHERE gattn IN('nup','up')
04:01:51  50  -- Use only rows which are older than 1 day:
04:01:51  51  AND 1+ydate < '&1'||' '||'&2'
04:01:51  52  AND pair = '&3'
04:01:51  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'00:40:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:01:51 SQL> 
04:01:51 SQL> -- rpt
04:01:51 SQL> 
04:01:51 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:01:51   2  
04:01:51 SQL> SELECT MAX(prdate) FROM bme
04:01:51   2  
04:01:51 SQL> -- Now build model from bme and score sme
04:01:51 SQL> @score1.sql gattn
04:01:51 SQL> --
04:01:51 SQL> -- score1.sql
04:01:51 SQL> --
04:01:51 SQL> 
04:01:51 SQL> -- I use this script to send 5 params to score.sql
04:01:51 SQL> -- which does the heavy lifting of creating an SVM model.
04:01:51 SQL> -- Then at the very end of this script I use the model
04:01:51 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:01:51 SQL> 
04:01:51 SQL> -- I call this script from 2 other scripts:
04:01:51 SQL> -- score1_5min.sql
04:01:51 SQL> -- score1_5min_gattn.sql
04:01:51 SQL> 
04:01:51 SQL> -- The 1st param is the name of the target attribute.
04:01:51 SQL> -- I like to call my target attributes either gatt or gattn.
04:01:51 SQL> 
04:01:51 SQL> -- Demo:
04:01:51 SQL> -- @score1.sql 'gatt'
04:01:51 SQL> -- @score1.sql 'gattn'
04:01:51 SQL> 
04:01:51 SQL> -- Now, I fill up svmc_apply_prep.
04:01:51 SQL> -- I use same model_name used in score.sql
04:01:51 SQL> DEFINE model_name = 'svmfx101'
04:01:51 SQL> DEFINE bldtable	= 'bme'
04:01:51 SQL> DEFINE scoretable = 'sme'
04:01:51 SQL> DEFINE case_id	= 'prdate'
04:01:51 SQL> -- Demo:
04:01:51 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:01:51 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:01:51 SQL> --
04:01:51 SQL> -- score.sql
04:01:51 SQL> --
04:01:51 SQL> 
04:01:51 SQL> -- usage: score.sql
04:01:51 SQL> 
04:01:51 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:01:51 SQL> 
04:01:51 SQL> -- DEFINE target	   = 'gatt'
04:01:51 SQL> -- DEFINE model_name = 'svmfx101'
04:01:51 SQL> -- DEFINE bldtable   = 'bme'
04:01:51 SQL> -- DEFINE scoretable = 'sme'
04:01:51 SQL> -- DEFINE case_id    = 'prdate'
04:01:51 SQL> 
04:01:51 SQL> DEFINE target	= '&1'
04:01:51 SQL> DEFINE model_name = '&2'
04:01:51 SQL> DEFINE bldtable	= '&3'
04:01:51 SQL> DEFINE scoretable = '&4'
04:01:51 SQL> DEFINE case_id	= '&5'
04:01:51 SQL> 
04:01:51 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:01:51 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:01:51 SQL> 
04:01:51 SQL> -- Builds an SVM model using pl/sql.
04:01:51 SQL> 
04:01:51 SQL> -----------------------------------------------------------------------
04:01:51 SQL> --			    BUILD THE MODEL
04:01:51 SQL> -----------------------------------------------------------------------
04:01:51 SQL> 
04:01:51 SQL> -- Cleanup old build data preparation objects for repeat runs
04:01:51 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:01:51 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:01:51 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:01:51 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:01:51 SQL> 
04:01:51 SQL> 
04:01:51 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:01:51 SQL> --
04:01:51 SQL> -- DROP	TABLE svmc_settings ;
04:01:51 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:01:51 SQL> -- DELETE svmc_settings;
04:01:51 SQL> 
04:01:51 SQL> -- The default classification algorithm is Naive Bayes. So override
04:01:51 SQL> -- this choice to SVM using a settings table.
04:01:51 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:01:51 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:01:51 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:01:51 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:01:51 SQL> -- models.
04:01:51 SQL> --
04:01:51 SQL> 
04:01:51 SQL> -- Do this once and then comment it out.
04:01:51 SQL> -- That makes script go faster.
04:01:51 SQL> -- BEGIN
04:01:51 SQL> -- -- Populate settings table
04:01:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:51 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:01:51 SQL> --
04:01:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:51 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:01:51 SQL> --
04:01:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:01:51 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:01:51 SQL> --   COMMIT;
04:01:51 SQL> -- END;
04:01:51 SQL> -- /
04:01:51 SQL> 
04:01:51 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:01:51 SQL> 
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:01:51 SQL> 
04:01:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:01:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:01:51 SQL> 
04:01:51 SQL> --------------------------------
04:01:51 SQL> -- PREPARE BUILD (TRAINING) DATA
04:01:51 SQL> --
04:01:51 SQL> 
04:01:51 SQL> -- 1. Missing Value treatment for all Predictors and
04:01:51 SQL> -- 2. Outlier Treatment and
04:01:51 SQL> -- 3. Normalization are performed below.
04:01:51 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:01:51 SQL> --    normalized here.
04:01:51 SQL> 
04:01:51 SQL> BEGIN
04:01:51   2  	-- Perform missing value treatment for all predictors
04:01:51   3  	-- create miss tables
04:01:51   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:01:51   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:01:51   6  
04:01:51   7  	-- populate miss tables
04:01:51   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:01:51   9  	  miss_table_name => 'svmc_miss_num',
04:01:51  10  	  data_table_name => '&bldtable',
04:01:51  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:51  12  
04:01:51  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:01:51  14  	  miss_table_name => 'svmc_miss_cat',
04:01:51  15  	  data_table_name => '&bldtable',
04:01:51  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:51  17  
04:01:51  18  	-- xform input data to replace missing values
04:01:51  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:01:51  20  	  miss_table_name => 'svmc_miss_num',
04:01:51  21  	  data_table_name => '&bldtable',
04:01:51  22  	  xform_view_name => 'xformed_build_miss_num');
04:01:51  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:01:51  24  	  miss_table_name => 'svmc_miss_cat',
04:01:51  25  	  data_table_name => '&bldtable',
04:01:51  26  	  xform_view_name => 'xformed_build_miss_cat');
04:01:51  27  
04:01:51  28  	-- Perform outlier treatment.
04:01:51  29  	-- create clip table
04:01:51  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:01:51  31  
04:01:51  32  	-- populate clip table
04:01:51  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:01:51  34  	  clip_table_name => 'svmc_clip',
04:01:51  35  	  data_table_name => '&bldtable',
04:01:51  36  	  tail_frac	  => 0.025,
04:01:51  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:51  38  
04:01:51  39  	-- xform input data to winsorized data
04:01:51  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:01:51  41  	  clip_table_name => 'svmc_clip',
04:01:51  42  	  data_table_name => '&bldtable',
04:01:51  43  	  xform_view_name => 'svmc_winsor');
04:01:51  44  
04:01:51  45  	-- create normalization table
04:01:51  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:01:51  47  
04:01:51  48  	-- populate normalization table based on winsorized data
04:01:51  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:01:51  50  	  norm_table_name => 'svmc_norm',
04:01:51  51  	  data_table_name => 'svmc_winsor',
04:01:51  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:01:51  53  
04:01:51  54  	-- normalize the original data
04:01:51  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:01:51  56  	  norm_table_name => 'svmc_norm',
04:01:51  57  	  data_table_name => '&bldtable',
04:01:51  58  	  xform_view_name => 'svmc_build_prep');
04:01:51  59  END;
04:01:51  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.70
04:01:54 SQL> 
04:01:54 SQL> ---------------------
04:01:54 SQL> -- CREATE A NEW MODEL
04:01:54 SQL> --
04:01:54 SQL> -- Cleanup old model with the same name for repeat runs
04:01:54 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:01:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:01:54   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.42
04:01:56 SQL> 
04:01:56 SQL> -- Build a new SVM Model
04:01:56 SQL> BEGIN
04:01:56   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:01:56   3  	  model_name	      => '&model_name',
04:01:56   4  	  mining_function     => dbms_data_mining.classification,
04:01:56   5  	  data_table_name     => 'svmc_build_prep',
04:01:56   6  	  case_id_column_name => '&case_id',
04:01:56   7  	  target_column_name  => '&target',
04:01:56   8  	  settings_table_name => 'svmc_settings');
04:01:56   9  END;
04:01:56  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.56
04:02:01 SQL> 
04:02:01 SQL> -----------------------------------------------------------------------
04:02:01 SQL> --			       APPLY/score THE MODEL
04:02:01 SQL> -----------------------------------------------------------------------
04:02:01 SQL> 
04:02:01 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:02:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:02:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:02:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:02:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:01 SQL> -----------------------
04:02:01 SQL> -- PREPARE SCORING DATA
04:02:01 SQL> --
04:02:01 SQL> -- If the data for model creation has been prepared, then the data
04:02:01 SQL> -- to be scored using the model must be prepared in the same manner
04:02:01 SQL> -- in order to obtain meaningful results.
04:02:01 SQL> --
04:02:01 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:01 SQL> -- 2. Normalization
04:02:01 SQL> -- No outlier treatment will be performed during test and apply. The
04:02:01 SQL> -- normalization step is sufficient, since the normalization parameters
04:02:01 SQL> -- already capture the effects of outlier treatment done with build data.
04:02:01 SQL> --
04:02:01 SQL> BEGIN
04:02:01   2  	-- Xform Test data to replace missing values
04:02:01   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:01   4  	  miss_table_name => 'svmc_miss_num',
04:02:01   5  	  data_table_name => '&scoretable',
04:02:01   6  	  xform_view_name => 'xformed_apply_miss_num');
04:02:01   7  
04:02:01   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:01   9  	  miss_table_name => 'svmc_miss_cat',
04:02:01  10  	  data_table_name => '&scoretable',
04:02:01  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:02:01  12  
04:02:01  13  	-- Normalize the data to be scored
04:02:01  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:01  15  	  norm_table_name => 'svmc_norm',
04:02:01  16  	  data_table_name => '&scoretable',
04:02:01  17  	  xform_view_name => 'svmc_apply_prep');
04:02:01  18  END;
04:02:01  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
04:02:01 SQL> 
04:02:01 SQL> -- Maybe I already collected a score for this prdate.
04:02:01 SQL> -- DELETE it if I did:
04:02:01 SQL> DELETE svm24scores
04:02:01   2  WHERE score > 0
04:02:01   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:02:01   4  -- I need to supply the target attribute name:
04:02:01   5  AND targ = '&1'
04:02:01   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:02:01 SQL> 
04:02:01 SQL> -- We do a drumroll here:
04:02:01 SQL> 
04:02:01 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:02:01   2  SELECT
04:02:01   3  prdate
04:02:01   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:02:01   5  ,sysdate
04:02:01   6  ,SUBSTR(prdate,1,7)pair
04:02:01   7  ,SUBSTR(prdate,-19)ydate
04:02:01   8  ,'&1'
04:02:01   9  FROM svmc_apply_prep
04:02:01  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.07
04:02:02 SQL> @score1_5min_gattn.sql	2011-01-21 07:45:00 eur_usd
04:02:02 SQL> --
04:02:02 SQL> -- score1_5min_gattn.sql
04:02:02 SQL> --
04:02:02 SQL> 
04:02:02 SQL> -- Demo:
04:02:02 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:02:02 SQL> 
04:02:02 SQL> CREATE OR REPLACE VIEW sme AS
04:02:02   2  SELECT
04:02:02   3  prdate
04:02:02   4  ,NULL gattn
04:02:02   5  ,g00
04:02:02   6  ,g01
04:02:02   7  ,g02
04:02:02   8  ,g03
04:02:02   9  ,g04
04:02:02  10  ,g05
04:02:02  11  ,g06
04:02:02  12  ,g07
04:02:02  13  ,g08
04:02:02  14  ,g09
04:02:02  15  ,g10
04:02:02  16  ,g11
04:02:02  17  ,g12
04:02:02  18  ,g13
04:02:02  19  ,g14
04:02:02  20  ,g15
04:02:02  21  ,g16
04:02:02  22  ,g17
04:02:02  23  ,g18
04:02:02  24  ,g19
04:02:02  25  ,g20
04:02:02  26  ,g21
04:02:02  27  ,g22
04:02:02  28  ,g23
04:02:02  29  ,g24
04:02:02  30  ,g25
04:02:02  31  ,g26
04:02:02  32  ,g27
04:02:02  33  ,g28
04:02:02  34  ,g29
04:02:02  35  ,g30
04:02:02  36  ,g31
04:02:02  37  ,g32
04:02:02  38  ,g33
04:02:02  39  ,g34
04:02:02  40  ,g35
04:02:02  41  ,g36
04:02:02  42  ,g37
04:02:02  43  ,g38
04:02:02  44  ,g39
04:02:02  45  ,g40
04:02:02  46  ,g41
04:02:02  47  ,s.sc_corr
04:02:02  48  FROM modsrc24
04:02:02  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:02:02  50  WHERE ydate = '&1'||' '||'&2'
04:02:02  51  AND pair = '&3'
04:02:02  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-21'||' '||'07:45:00'AND ydate<'2011-01-21'||' '||'07:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-21'||' '||'07:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:02 SQL> 
04:02:02 SQL> -- rpt
04:02:02 SQL> -- We should see just 1 row:
04:02:02 SQL> 
04:02:02 SQL> SELECT COUNT(prdate) FROM sme
04:02:02   2  
04:02:02 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:02:02   2  
04:02:02 SQL> 
04:02:02 SQL> -- Build the model:
04:02:02 SQL> CREATE OR REPLACE VIEW bme AS
04:02:02   2  SELECT
04:02:02   3  prdate
04:02:02   4  ,gattn
04:02:02   5  ,g00
04:02:02   6  ,g01
04:02:02   7  ,g02
04:02:02   8  ,g03
04:02:02   9  ,g04
04:02:02  10  ,g05
04:02:02  11  ,g06
04:02:02  12  ,g07
04:02:02  13  ,g08
04:02:02  14  ,g09
04:02:02  15  ,g10
04:02:02  16  ,g11
04:02:02  17  ,g12
04:02:02  18  ,g13
04:02:02  19  ,g14
04:02:02  20  ,g15
04:02:02  21  ,g16
04:02:02  22  ,g17
04:02:02  23  ,g18
04:02:02  24  ,g19
04:02:02  25  ,g20
04:02:02  26  ,g21
04:02:02  27  ,g22
04:02:02  28  ,g23
04:02:02  29  ,g24
04:02:02  30  ,g25
04:02:02  31  ,g26
04:02:02  32  ,g27
04:02:02  33  ,g28
04:02:02  34  ,g29
04:02:02  35  ,g30
04:02:02  36  ,g31
04:02:02  37  ,g32
04:02:02  38  ,g33
04:02:02  39  ,g34
04:02:02  40  ,g35
04:02:02  41  ,g36
04:02:02  42  ,g37
04:02:02  43  ,g38
04:02:02  44  ,g39
04:02:02  45  ,g40
04:02:02  46  ,g41
04:02:02  47  ,sc_corr
04:02:02  48  FROM modsrc24
04:02:02  49  WHERE gattn IN('nup','up')
04:02:02  50  -- Use only rows which are older than 1 day:
04:02:02  51  AND 1+ydate < '&1'||' '||'&2'
04:02:02  52  AND pair = '&3'
04:02:02  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-21'||' '||'07:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
04:02:02 SQL> 
04:02:02 SQL> -- rpt
04:02:02 SQL> 
04:02:02 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:02:02   2  
04:02:02 SQL> SELECT MAX(prdate) FROM bme
04:02:02   2  
04:02:02 SQL> -- Now build model from bme and score sme
04:02:02 SQL> @score1.sql gattn
04:02:02 SQL> --
04:02:02 SQL> -- score1.sql
04:02:02 SQL> --
04:02:02 SQL> 
04:02:02 SQL> -- I use this script to send 5 params to score.sql
04:02:02 SQL> -- which does the heavy lifting of creating an SVM model.
04:02:02 SQL> -- Then at the very end of this script I use the model
04:02:02 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:02:02 SQL> 
04:02:02 SQL> -- I call this script from 2 other scripts:
04:02:02 SQL> -- score1_5min.sql
04:02:02 SQL> -- score1_5min_gattn.sql
04:02:02 SQL> 
04:02:02 SQL> -- The 1st param is the name of the target attribute.
04:02:02 SQL> -- I like to call my target attributes either gatt or gattn.
04:02:02 SQL> 
04:02:02 SQL> -- Demo:
04:02:02 SQL> -- @score1.sql 'gatt'
04:02:02 SQL> -- @score1.sql 'gattn'
04:02:02 SQL> 
04:02:02 SQL> -- Now, I fill up svmc_apply_prep.
04:02:02 SQL> -- I use same model_name used in score.sql
04:02:02 SQL> DEFINE model_name = 'svmfx101'
04:02:02 SQL> DEFINE bldtable	= 'bme'
04:02:02 SQL> DEFINE scoretable = 'sme'
04:02:02 SQL> DEFINE case_id	= 'prdate'
04:02:02 SQL> -- Demo:
04:02:02 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:02:02 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:02:02 SQL> --
04:02:02 SQL> -- score.sql
04:02:02 SQL> --
04:02:02 SQL> 
04:02:02 SQL> -- usage: score.sql
04:02:02 SQL> 
04:02:02 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:02:02 SQL> 
04:02:02 SQL> -- DEFINE target	   = 'gatt'
04:02:02 SQL> -- DEFINE model_name = 'svmfx101'
04:02:02 SQL> -- DEFINE bldtable   = 'bme'
04:02:02 SQL> -- DEFINE scoretable = 'sme'
04:02:02 SQL> -- DEFINE case_id    = 'prdate'
04:02:02 SQL> 
04:02:02 SQL> DEFINE target	= '&1'
04:02:02 SQL> DEFINE model_name = '&2'
04:02:02 SQL> DEFINE bldtable	= '&3'
04:02:02 SQL> DEFINE scoretable = '&4'
04:02:02 SQL> DEFINE case_id	= '&5'
04:02:02 SQL> 
04:02:02 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:02:02 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:02:02 SQL> 
04:02:02 SQL> -- Builds an SVM model using pl/sql.
04:02:02 SQL> 
04:02:02 SQL> -----------------------------------------------------------------------
04:02:02 SQL> --			    BUILD THE MODEL
04:02:02 SQL> -----------------------------------------------------------------------
04:02:02 SQL> 
04:02:02 SQL> -- Cleanup old build data preparation objects for repeat runs
04:02:02 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:02 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
04:02:02 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:02 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:02:02 SQL> 
04:02:02 SQL> 
04:02:02 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:02:02 SQL> --
04:02:02 SQL> -- DROP	TABLE svmc_settings ;
04:02:02 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:02:02 SQL> -- DELETE svmc_settings;
04:02:02 SQL> 
04:02:02 SQL> -- The default classification algorithm is Naive Bayes. So override
04:02:02 SQL> -- this choice to SVM using a settings table.
04:02:02 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:02:02 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:02:02 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:02:02 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:02:02 SQL> -- models.
04:02:02 SQL> --
04:02:02 SQL> 
04:02:02 SQL> -- Do this once and then comment it out.
04:02:02 SQL> -- That makes script go faster.
04:02:02 SQL> -- BEGIN
04:02:02 SQL> -- -- Populate settings table
04:02:02 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:02 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:02:02 SQL> --
04:02:02 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:02 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:02:02 SQL> --
04:02:02 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:02 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:02:02 SQL> --   COMMIT;
04:02:02 SQL> -- END;
04:02:02 SQL> -- /
04:02:02 SQL> 
04:02:02 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:02:02 SQL> 
04:02:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:02:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
04:02:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:02:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:02:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:02 SQL> 
04:02:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:02:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:02 SQL> 
04:02:02 SQL> --------------------------------
04:02:02 SQL> -- PREPARE BUILD (TRAINING) DATA
04:02:02 SQL> --
04:02:02 SQL> 
04:02:02 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:02 SQL> -- 2. Outlier Treatment and
04:02:02 SQL> -- 3. Normalization are performed below.
04:02:02 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:02:02 SQL> --    normalized here.
04:02:02 SQL> 
04:02:02 SQL> BEGIN
04:02:02   2  	-- Perform missing value treatment for all predictors
04:02:02   3  	-- create miss tables
04:02:02   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:02:02   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:02:02   6  
04:02:02   7  	-- populate miss tables
04:02:02   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:02:02   9  	  miss_table_name => 'svmc_miss_num',
04:02:02  10  	  data_table_name => '&bldtable',
04:02:02  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:02  12  
04:02:02  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:02:02  14  	  miss_table_name => 'svmc_miss_cat',
04:02:02  15  	  data_table_name => '&bldtable',
04:02:02  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:02  17  
04:02:02  18  	-- xform input data to replace missing values
04:02:02  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:02  20  	  miss_table_name => 'svmc_miss_num',
04:02:02  21  	  data_table_name => '&bldtable',
04:02:02  22  	  xform_view_name => 'xformed_build_miss_num');
04:02:02  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:02  24  	  miss_table_name => 'svmc_miss_cat',
04:02:02  25  	  data_table_name => '&bldtable',
04:02:02  26  	  xform_view_name => 'xformed_build_miss_cat');
04:02:02  27  
04:02:02  28  	-- Perform outlier treatment.
04:02:02  29  	-- create clip table
04:02:02  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:02:02  31  
04:02:02  32  	-- populate clip table
04:02:02  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:02:02  34  	  clip_table_name => 'svmc_clip',
04:02:02  35  	  data_table_name => '&bldtable',
04:02:02  36  	  tail_frac	  => 0.025,
04:02:02  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:02  38  
04:02:02  39  	-- xform input data to winsorized data
04:02:02  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:02:02  41  	  clip_table_name => 'svmc_clip',
04:02:02  42  	  data_table_name => '&bldtable',
04:02:02  43  	  xform_view_name => 'svmc_winsor');
04:02:02  44  
04:02:02  45  	-- create normalization table
04:02:02  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:02:02  47  
04:02:02  48  	-- populate normalization table based on winsorized data
04:02:02  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:02:02  50  	  norm_table_name => 'svmc_norm',
04:02:02  51  	  data_table_name => 'svmc_winsor',
04:02:02  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:02  53  
04:02:02  54  	-- normalize the original data
04:02:02  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:02  56  	  norm_table_name => 'svmc_norm',
04:02:02  57  	  data_table_name => '&bldtable',
04:02:02  58  	  xform_view_name => 'svmc_build_prep');
04:02:02  59  END;
04:02:02  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
04:02:04 SQL> 
04:02:04 SQL> ---------------------
04:02:04 SQL> -- CREATE A NEW MODEL
04:02:04 SQL> --
04:02:04 SQL> -- Cleanup old model with the same name for repeat runs
04:02:04 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:02:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:04   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.63
04:02:06 SQL> 
04:02:06 SQL> -- Build a new SVM Model
04:02:06 SQL> BEGIN
04:02:06   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:02:06   3  	  model_name	      => '&model_name',
04:02:06   4  	  mining_function     => dbms_data_mining.classification,
04:02:06   5  	  data_table_name     => 'svmc_build_prep',
04:02:06   6  	  case_id_column_name => '&case_id',
04:02:06   7  	  target_column_name  => '&target',
04:02:06   8  	  settings_table_name => 'svmc_settings');
04:02:06   9  END;
04:02:06  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.28
04:02:12 SQL> 
04:02:12 SQL> -----------------------------------------------------------------------
04:02:12 SQL> --			       APPLY/score THE MODEL
04:02:12 SQL> -----------------------------------------------------------------------
04:02:12 SQL> 
04:02:12 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:02:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:02:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:02:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:02:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:12 SQL> -----------------------
04:02:12 SQL> -- PREPARE SCORING DATA
04:02:12 SQL> --
04:02:12 SQL> -- If the data for model creation has been prepared, then the data
04:02:12 SQL> -- to be scored using the model must be prepared in the same manner
04:02:12 SQL> -- in order to obtain meaningful results.
04:02:12 SQL> --
04:02:12 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:12 SQL> -- 2. Normalization
04:02:12 SQL> -- No outlier treatment will be performed during test and apply. The
04:02:12 SQL> -- normalization step is sufficient, since the normalization parameters
04:02:12 SQL> -- already capture the effects of outlier treatment done with build data.
04:02:12 SQL> --
04:02:12 SQL> BEGIN
04:02:12   2  	-- Xform Test data to replace missing values
04:02:12   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:12   4  	  miss_table_name => 'svmc_miss_num',
04:02:12   5  	  data_table_name => '&scoretable',
04:02:12   6  	  xform_view_name => 'xformed_apply_miss_num');
04:02:12   7  
04:02:12   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:12   9  	  miss_table_name => 'svmc_miss_cat',
04:02:12  10  	  data_table_name => '&scoretable',
04:02:12  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:02:12  12  
04:02:12  13  	-- Normalize the data to be scored
04:02:12  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:12  15  	  norm_table_name => 'svmc_norm',
04:02:12  16  	  data_table_name => '&scoretable',
04:02:12  17  	  xform_view_name => 'svmc_apply_prep');
04:02:12  18  END;
04:02:12  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.31
04:02:13 SQL> 
04:02:13 SQL> -- Maybe I already collected a score for this prdate.
04:02:13 SQL> -- DELETE it if I did:
04:02:13 SQL> DELETE svm24scores
04:02:13   2  WHERE score > 0
04:02:13   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:02:13   4  -- I need to supply the target attribute name:
04:02:13   5  AND targ = '&1'
04:02:13   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
04:02:13 SQL> 
04:02:13 SQL> -- We do a drumroll here:
04:02:13 SQL> 
04:02:13 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:02:13   2  SELECT
04:02:13   3  prdate
04:02:13   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:02:13   5  ,sysdate
04:02:13   6  ,SUBSTR(prdate,1,7)pair
04:02:13   7  ,SUBSTR(prdate,-19)ydate
04:02:13   8  ,'&1'
04:02:13   9  FROM svmc_apply_prep
04:02:13  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:02:13 SQL> @score1_5min_gattn.sql	2011-01-24 20:50:00 eur_usd
04:02:13 SQL> --
04:02:13 SQL> -- score1_5min_gattn.sql
04:02:13 SQL> --
04:02:13 SQL> 
04:02:13 SQL> -- Demo:
04:02:13 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:02:13 SQL> 
04:02:13 SQL> CREATE OR REPLACE VIEW sme AS
04:02:13   2  SELECT
04:02:13   3  prdate
04:02:13   4  ,NULL gattn
04:02:13   5  ,g00
04:02:13   6  ,g01
04:02:13   7  ,g02
04:02:13   8  ,g03
04:02:13   9  ,g04
04:02:13  10  ,g05
04:02:13  11  ,g06
04:02:13  12  ,g07
04:02:13  13  ,g08
04:02:13  14  ,g09
04:02:13  15  ,g10
04:02:13  16  ,g11
04:02:13  17  ,g12
04:02:13  18  ,g13
04:02:13  19  ,g14
04:02:13  20  ,g15
04:02:13  21  ,g16
04:02:13  22  ,g17
04:02:13  23  ,g18
04:02:13  24  ,g19
04:02:13  25  ,g20
04:02:13  26  ,g21
04:02:13  27  ,g22
04:02:13  28  ,g23
04:02:13  29  ,g24
04:02:13  30  ,g25
04:02:13  31  ,g26
04:02:13  32  ,g27
04:02:13  33  ,g28
04:02:13  34  ,g29
04:02:13  35  ,g30
04:02:13  36  ,g31
04:02:13  37  ,g32
04:02:13  38  ,g33
04:02:13  39  ,g34
04:02:13  40  ,g35
04:02:13  41  ,g36
04:02:13  42  ,g37
04:02:13  43  ,g38
04:02:13  44  ,g39
04:02:13  45  ,g40
04:02:13  46  ,g41
04:02:13  47  ,s.sc_corr
04:02:13  48  FROM modsrc24
04:02:13  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:02:13  50  WHERE ydate = '&1'||' '||'&2'
04:02:13  51  AND pair = '&3'
04:02:13  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-24'||' '||'20:50:00'AND ydate<'2011-01-24'||' '||'20:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-24'||' '||'20:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:13 SQL> 
04:02:13 SQL> -- rpt
04:02:13 SQL> -- We should see just 1 row:
04:02:13 SQL> 
04:02:13 SQL> SELECT COUNT(prdate) FROM sme
04:02:13   2  
04:02:13 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:02:13   2  
04:02:13 SQL> 
04:02:13 SQL> -- Build the model:
04:02:13 SQL> CREATE OR REPLACE VIEW bme AS
04:02:13   2  SELECT
04:02:13   3  prdate
04:02:13   4  ,gattn
04:02:13   5  ,g00
04:02:13   6  ,g01
04:02:13   7  ,g02
04:02:13   8  ,g03
04:02:13   9  ,g04
04:02:13  10  ,g05
04:02:13  11  ,g06
04:02:13  12  ,g07
04:02:13  13  ,g08
04:02:13  14  ,g09
04:02:13  15  ,g10
04:02:13  16  ,g11
04:02:13  17  ,g12
04:02:13  18  ,g13
04:02:13  19  ,g14
04:02:13  20  ,g15
04:02:13  21  ,g16
04:02:13  22  ,g17
04:02:13  23  ,g18
04:02:13  24  ,g19
04:02:13  25  ,g20
04:02:13  26  ,g21
04:02:13  27  ,g22
04:02:13  28  ,g23
04:02:13  29  ,g24
04:02:13  30  ,g25
04:02:13  31  ,g26
04:02:13  32  ,g27
04:02:13  33  ,g28
04:02:13  34  ,g29
04:02:13  35  ,g30
04:02:13  36  ,g31
04:02:13  37  ,g32
04:02:13  38  ,g33
04:02:13  39  ,g34
04:02:13  40  ,g35
04:02:13  41  ,g36
04:02:13  42  ,g37
04:02:13  43  ,g38
04:02:13  44  ,g39
04:02:13  45  ,g40
04:02:13  46  ,g41
04:02:13  47  ,sc_corr
04:02:13  48  FROM modsrc24
04:02:13  49  WHERE gattn IN('nup','up')
04:02:13  50  -- Use only rows which are older than 1 day:
04:02:13  51  AND 1+ydate < '&1'||' '||'&2'
04:02:13  52  AND pair = '&3'
04:02:13  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-24'||' '||'20:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.06
04:02:13 SQL> 
04:02:13 SQL> -- rpt
04:02:13 SQL> 
04:02:13 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:02:13   2  
04:02:13 SQL> SELECT MAX(prdate) FROM bme
04:02:13   2  
04:02:13 SQL> -- Now build model from bme and score sme
04:02:13 SQL> @score1.sql gattn
04:02:13 SQL> --
04:02:13 SQL> -- score1.sql
04:02:13 SQL> --
04:02:13 SQL> 
04:02:13 SQL> -- I use this script to send 5 params to score.sql
04:02:13 SQL> -- which does the heavy lifting of creating an SVM model.
04:02:13 SQL> -- Then at the very end of this script I use the model
04:02:13 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:02:13 SQL> 
04:02:13 SQL> -- I call this script from 2 other scripts:
04:02:13 SQL> -- score1_5min.sql
04:02:13 SQL> -- score1_5min_gattn.sql
04:02:13 SQL> 
04:02:13 SQL> -- The 1st param is the name of the target attribute.
04:02:13 SQL> -- I like to call my target attributes either gatt or gattn.
04:02:13 SQL> 
04:02:13 SQL> -- Demo:
04:02:13 SQL> -- @score1.sql 'gatt'
04:02:13 SQL> -- @score1.sql 'gattn'
04:02:13 SQL> 
04:02:13 SQL> -- Now, I fill up svmc_apply_prep.
04:02:13 SQL> -- I use same model_name used in score.sql
04:02:13 SQL> DEFINE model_name = 'svmfx101'
04:02:13 SQL> DEFINE bldtable	= 'bme'
04:02:13 SQL> DEFINE scoretable = 'sme'
04:02:13 SQL> DEFINE case_id	= 'prdate'
04:02:13 SQL> -- Demo:
04:02:13 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:02:13 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:02:13 SQL> --
04:02:13 SQL> -- score.sql
04:02:13 SQL> --
04:02:13 SQL> 
04:02:13 SQL> -- usage: score.sql
04:02:13 SQL> 
04:02:13 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:02:13 SQL> 
04:02:13 SQL> -- DEFINE target	   = 'gatt'
04:02:13 SQL> -- DEFINE model_name = 'svmfx101'
04:02:13 SQL> -- DEFINE bldtable   = 'bme'
04:02:13 SQL> -- DEFINE scoretable = 'sme'
04:02:13 SQL> -- DEFINE case_id    = 'prdate'
04:02:13 SQL> 
04:02:13 SQL> DEFINE target	= '&1'
04:02:13 SQL> DEFINE model_name = '&2'
04:02:13 SQL> DEFINE bldtable	= '&3'
04:02:13 SQL> DEFINE scoretable = '&4'
04:02:13 SQL> DEFINE case_id	= '&5'
04:02:13 SQL> 
04:02:13 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:02:13 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:02:13 SQL> 
04:02:13 SQL> -- Builds an SVM model using pl/sql.
04:02:13 SQL> 
04:02:13 SQL> -----------------------------------------------------------------------
04:02:13 SQL> --			    BUILD THE MODEL
04:02:13 SQL> -----------------------------------------------------------------------
04:02:13 SQL> 
04:02:13 SQL> -- Cleanup old build data preparation objects for repeat runs
04:02:13 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
04:02:13 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:02:13 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:13 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
04:02:13 SQL> 
04:02:13 SQL> 
04:02:13 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:02:13 SQL> --
04:02:13 SQL> -- DROP	TABLE svmc_settings ;
04:02:13 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:02:13 SQL> -- DELETE svmc_settings;
04:02:13 SQL> 
04:02:13 SQL> -- The default classification algorithm is Naive Bayes. So override
04:02:13 SQL> -- this choice to SVM using a settings table.
04:02:13 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:02:13 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:02:13 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:02:13 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:02:13 SQL> -- models.
04:02:13 SQL> --
04:02:13 SQL> 
04:02:13 SQL> -- Do this once and then comment it out.
04:02:13 SQL> -- That makes script go faster.
04:02:13 SQL> -- BEGIN
04:02:13 SQL> -- -- Populate settings table
04:02:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:13 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:02:13 SQL> --
04:02:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:13 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:02:13 SQL> --
04:02:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:13 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:02:13 SQL> --   COMMIT;
04:02:13 SQL> -- END;
04:02:13 SQL> -- /
04:02:13 SQL> 
04:02:13 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:02:13 SQL> 
04:02:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:02:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
04:02:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:02:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:02:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:13 SQL> 
04:02:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:02:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:13 SQL> 
04:02:13 SQL> --------------------------------
04:02:13 SQL> -- PREPARE BUILD (TRAINING) DATA
04:02:13 SQL> --
04:02:13 SQL> 
04:02:13 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:13 SQL> -- 2. Outlier Treatment and
04:02:13 SQL> -- 3. Normalization are performed below.
04:02:13 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:02:13 SQL> --    normalized here.
04:02:13 SQL> 
04:02:13 SQL> BEGIN
04:02:13   2  	-- Perform missing value treatment for all predictors
04:02:13   3  	-- create miss tables
04:02:13   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:02:13   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:02:13   6  
04:02:13   7  	-- populate miss tables
04:02:13   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:02:13   9  	  miss_table_name => 'svmc_miss_num',
04:02:13  10  	  data_table_name => '&bldtable',
04:02:13  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:13  12  
04:02:13  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:02:13  14  	  miss_table_name => 'svmc_miss_cat',
04:02:13  15  	  data_table_name => '&bldtable',
04:02:13  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:13  17  
04:02:13  18  	-- xform input data to replace missing values
04:02:13  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:13  20  	  miss_table_name => 'svmc_miss_num',
04:02:13  21  	  data_table_name => '&bldtable',
04:02:13  22  	  xform_view_name => 'xformed_build_miss_num');
04:02:13  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:13  24  	  miss_table_name => 'svmc_miss_cat',
04:02:13  25  	  data_table_name => '&bldtable',
04:02:13  26  	  xform_view_name => 'xformed_build_miss_cat');
04:02:13  27  
04:02:13  28  	-- Perform outlier treatment.
04:02:13  29  	-- create clip table
04:02:13  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:02:13  31  
04:02:13  32  	-- populate clip table
04:02:13  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:02:13  34  	  clip_table_name => 'svmc_clip',
04:02:13  35  	  data_table_name => '&bldtable',
04:02:13  36  	  tail_frac	  => 0.025,
04:02:13  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:13  38  
04:02:13  39  	-- xform input data to winsorized data
04:02:13  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:02:13  41  	  clip_table_name => 'svmc_clip',
04:02:13  42  	  data_table_name => '&bldtable',
04:02:13  43  	  xform_view_name => 'svmc_winsor');
04:02:13  44  
04:02:13  45  	-- create normalization table
04:02:13  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:02:13  47  
04:02:13  48  	-- populate normalization table based on winsorized data
04:02:13  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:02:13  50  	  norm_table_name => 'svmc_norm',
04:02:13  51  	  data_table_name => 'svmc_winsor',
04:02:13  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:13  53  
04:02:13  54  	-- normalize the original data
04:02:13  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:13  56  	  norm_table_name => 'svmc_norm',
04:02:13  57  	  data_table_name => '&bldtable',
04:02:13  58  	  xform_view_name => 'svmc_build_prep');
04:02:13  59  END;
04:02:13  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.61
04:02:16 SQL> 
04:02:16 SQL> ---------------------
04:02:16 SQL> -- CREATE A NEW MODEL
04:02:16 SQL> --
04:02:16 SQL> -- Cleanup old model with the same name for repeat runs
04:02:16 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:02:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:16   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.47
04:02:17 SQL> 
04:02:17 SQL> -- Build a new SVM Model
04:02:17 SQL> BEGIN
04:02:17   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:02:17   3  	  model_name	      => '&model_name',
04:02:17   4  	  mining_function     => dbms_data_mining.classification,
04:02:17   5  	  data_table_name     => 'svmc_build_prep',
04:02:17   6  	  case_id_column_name => '&case_id',
04:02:17   7  	  target_column_name  => '&target',
04:02:17   8  	  settings_table_name => 'svmc_settings');
04:02:17   9  END;
04:02:17  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.33
04:02:22 SQL> 
04:02:22 SQL> -----------------------------------------------------------------------
04:02:22 SQL> --			       APPLY/score THE MODEL
04:02:22 SQL> -----------------------------------------------------------------------
04:02:22 SQL> 
04:02:22 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:02:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:02:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:02:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:02:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:23 SQL> -----------------------
04:02:23 SQL> -- PREPARE SCORING DATA
04:02:23 SQL> --
04:02:23 SQL> -- If the data for model creation has been prepared, then the data
04:02:23 SQL> -- to be scored using the model must be prepared in the same manner
04:02:23 SQL> -- in order to obtain meaningful results.
04:02:23 SQL> --
04:02:23 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:23 SQL> -- 2. Normalization
04:02:23 SQL> -- No outlier treatment will be performed during test and apply. The
04:02:23 SQL> -- normalization step is sufficient, since the normalization parameters
04:02:23 SQL> -- already capture the effects of outlier treatment done with build data.
04:02:23 SQL> --
04:02:23 SQL> BEGIN
04:02:23   2  	-- Xform Test data to replace missing values
04:02:23   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:23   4  	  miss_table_name => 'svmc_miss_num',
04:02:23   5  	  data_table_name => '&scoretable',
04:02:23   6  	  xform_view_name => 'xformed_apply_miss_num');
04:02:23   7  
04:02:23   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:23   9  	  miss_table_name => 'svmc_miss_cat',
04:02:23  10  	  data_table_name => '&scoretable',
04:02:23  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:02:23  12  
04:02:23  13  	-- Normalize the data to be scored
04:02:23  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:23  15  	  norm_table_name => 'svmc_norm',
04:02:23  16  	  data_table_name => '&scoretable',
04:02:23  17  	  xform_view_name => 'svmc_apply_prep');
04:02:23  18  END;
04:02:23  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
04:02:23 SQL> 
04:02:23 SQL> -- Maybe I already collected a score for this prdate.
04:02:23 SQL> -- DELETE it if I did:
04:02:23 SQL> DELETE svm24scores
04:02:23   2  WHERE score > 0
04:02:23   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:02:23   4  -- I need to supply the target attribute name:
04:02:23   5  AND targ = '&1'
04:02:23   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
04:02:23 SQL> 
04:02:23 SQL> -- We do a drumroll here:
04:02:23 SQL> 
04:02:23 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:02:23   2  SELECT
04:02:23   3  prdate
04:02:23   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:02:23   5  ,sysdate
04:02:23   6  ,SUBSTR(prdate,1,7)pair
04:02:23   7  ,SUBSTR(prdate,-19)ydate
04:02:23   8  ,'&1'
04:02:23   9  FROM svmc_apply_prep
04:02:23  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:02:23 SQL> @score1_5min_gattn.sql	2011-01-25 15:55:00 eur_usd
04:02:23 SQL> --
04:02:23 SQL> -- score1_5min_gattn.sql
04:02:23 SQL> --
04:02:23 SQL> 
04:02:23 SQL> -- Demo:
04:02:23 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:02:23 SQL> 
04:02:23 SQL> CREATE OR REPLACE VIEW sme AS
04:02:23   2  SELECT
04:02:23   3  prdate
04:02:23   4  ,NULL gattn
04:02:23   5  ,g00
04:02:23   6  ,g01
04:02:23   7  ,g02
04:02:23   8  ,g03
04:02:23   9  ,g04
04:02:23  10  ,g05
04:02:23  11  ,g06
04:02:23  12  ,g07
04:02:23  13  ,g08
04:02:23  14  ,g09
04:02:23  15  ,g10
04:02:23  16  ,g11
04:02:23  17  ,g12
04:02:23  18  ,g13
04:02:23  19  ,g14
04:02:23  20  ,g15
04:02:23  21  ,g16
04:02:23  22  ,g17
04:02:23  23  ,g18
04:02:23  24  ,g19
04:02:23  25  ,g20
04:02:23  26  ,g21
04:02:23  27  ,g22
04:02:23  28  ,g23
04:02:23  29  ,g24
04:02:23  30  ,g25
04:02:23  31  ,g26
04:02:23  32  ,g27
04:02:23  33  ,g28
04:02:23  34  ,g29
04:02:23  35  ,g30
04:02:23  36  ,g31
04:02:23  37  ,g32
04:02:23  38  ,g33
04:02:23  39  ,g34
04:02:23  40  ,g35
04:02:23  41  ,g36
04:02:23  42  ,g37
04:02:23  43  ,g38
04:02:23  44  ,g39
04:02:23  45  ,g40
04:02:23  46  ,g41
04:02:23  47  ,s.sc_corr
04:02:23  48  FROM modsrc24
04:02:23  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:02:23  50  WHERE ydate = '&1'||' '||'&2'
04:02:23  51  AND pair = '&3'
04:02:23  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'15:55:00'AND ydate<'2011-01-25'||' '||'15:55:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'15:55:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:02:23 SQL> 
04:02:23 SQL> -- rpt
04:02:23 SQL> -- We should see just 1 row:
04:02:23 SQL> 
04:02:23 SQL> SELECT COUNT(prdate) FROM sme
04:02:23   2  
04:02:23 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:02:23   2  
04:02:23 SQL> 
04:02:23 SQL> -- Build the model:
04:02:23 SQL> CREATE OR REPLACE VIEW bme AS
04:02:23   2  SELECT
04:02:23   3  prdate
04:02:23   4  ,gattn
04:02:23   5  ,g00
04:02:23   6  ,g01
04:02:23   7  ,g02
04:02:23   8  ,g03
04:02:23   9  ,g04
04:02:23  10  ,g05
04:02:23  11  ,g06
04:02:23  12  ,g07
04:02:23  13  ,g08
04:02:23  14  ,g09
04:02:23  15  ,g10
04:02:23  16  ,g11
04:02:23  17  ,g12
04:02:23  18  ,g13
04:02:23  19  ,g14
04:02:23  20  ,g15
04:02:23  21  ,g16
04:02:23  22  ,g17
04:02:23  23  ,g18
04:02:23  24  ,g19
04:02:23  25  ,g20
04:02:23  26  ,g21
04:02:23  27  ,g22
04:02:23  28  ,g23
04:02:23  29  ,g24
04:02:23  30  ,g25
04:02:23  31  ,g26
04:02:23  32  ,g27
04:02:23  33  ,g28
04:02:23  34  ,g29
04:02:23  35  ,g30
04:02:23  36  ,g31
04:02:23  37  ,g32
04:02:23  38  ,g33
04:02:23  39  ,g34
04:02:23  40  ,g35
04:02:23  41  ,g36
04:02:23  42  ,g37
04:02:23  43  ,g38
04:02:23  44  ,g39
04:02:23  45  ,g40
04:02:23  46  ,g41
04:02:23  47  ,sc_corr
04:02:23  48  FROM modsrc24
04:02:23  49  WHERE gattn IN('nup','up')
04:02:23  50  -- Use only rows which are older than 1 day:
04:02:23  51  AND 1+ydate < '&1'||' '||'&2'
04:02:23  52  AND pair = '&3'
04:02:23  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'15:55:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:23 SQL> 
04:02:23 SQL> -- rpt
04:02:23 SQL> 
04:02:23 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:02:23   2  
04:02:23 SQL> SELECT MAX(prdate) FROM bme
04:02:23   2  
04:02:23 SQL> -- Now build model from bme and score sme
04:02:23 SQL> @score1.sql gattn
04:02:23 SQL> --
04:02:23 SQL> -- score1.sql
04:02:23 SQL> --
04:02:23 SQL> 
04:02:23 SQL> -- I use this script to send 5 params to score.sql
04:02:23 SQL> -- which does the heavy lifting of creating an SVM model.
04:02:23 SQL> -- Then at the very end of this script I use the model
04:02:23 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:02:23 SQL> 
04:02:23 SQL> -- I call this script from 2 other scripts:
04:02:23 SQL> -- score1_5min.sql
04:02:23 SQL> -- score1_5min_gattn.sql
04:02:23 SQL> 
04:02:23 SQL> -- The 1st param is the name of the target attribute.
04:02:23 SQL> -- I like to call my target attributes either gatt or gattn.
04:02:23 SQL> 
04:02:23 SQL> -- Demo:
04:02:23 SQL> -- @score1.sql 'gatt'
04:02:23 SQL> -- @score1.sql 'gattn'
04:02:23 SQL> 
04:02:23 SQL> -- Now, I fill up svmc_apply_prep.
04:02:23 SQL> -- I use same model_name used in score.sql
04:02:23 SQL> DEFINE model_name = 'svmfx101'
04:02:23 SQL> DEFINE bldtable	= 'bme'
04:02:23 SQL> DEFINE scoretable = 'sme'
04:02:23 SQL> DEFINE case_id	= 'prdate'
04:02:23 SQL> -- Demo:
04:02:23 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:02:23 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:02:23 SQL> --
04:02:23 SQL> -- score.sql
04:02:23 SQL> --
04:02:23 SQL> 
04:02:23 SQL> -- usage: score.sql
04:02:23 SQL> 
04:02:23 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:02:23 SQL> 
04:02:23 SQL> -- DEFINE target	   = 'gatt'
04:02:23 SQL> -- DEFINE model_name = 'svmfx101'
04:02:23 SQL> -- DEFINE bldtable   = 'bme'
04:02:23 SQL> -- DEFINE scoretable = 'sme'
04:02:23 SQL> -- DEFINE case_id    = 'prdate'
04:02:23 SQL> 
04:02:23 SQL> DEFINE target	= '&1'
04:02:23 SQL> DEFINE model_name = '&2'
04:02:23 SQL> DEFINE bldtable	= '&3'
04:02:23 SQL> DEFINE scoretable = '&4'
04:02:23 SQL> DEFINE case_id	= '&5'
04:02:23 SQL> 
04:02:23 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:02:23 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:02:23 SQL> 
04:02:23 SQL> -- Builds an SVM model using pl/sql.
04:02:23 SQL> 
04:02:23 SQL> -----------------------------------------------------------------------
04:02:23 SQL> --			    BUILD THE MODEL
04:02:23 SQL> -----------------------------------------------------------------------
04:02:23 SQL> 
04:02:23 SQL> -- Cleanup old build data preparation objects for repeat runs
04:02:23 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:23 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:02:23 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:02:23 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:02:23 SQL> 
04:02:23 SQL> 
04:02:23 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:02:23 SQL> --
04:02:23 SQL> -- DROP	TABLE svmc_settings ;
04:02:23 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:02:23 SQL> -- DELETE svmc_settings;
04:02:23 SQL> 
04:02:23 SQL> -- The default classification algorithm is Naive Bayes. So override
04:02:23 SQL> -- this choice to SVM using a settings table.
04:02:23 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:02:23 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:02:23 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:02:23 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:02:23 SQL> -- models.
04:02:23 SQL> --
04:02:23 SQL> 
04:02:23 SQL> -- Do this once and then comment it out.
04:02:23 SQL> -- That makes script go faster.
04:02:23 SQL> -- BEGIN
04:02:23 SQL> -- -- Populate settings table
04:02:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:23 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:02:23 SQL> --
04:02:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:23 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:02:23 SQL> --
04:02:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:23 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:02:23 SQL> --   COMMIT;
04:02:23 SQL> -- END;
04:02:23 SQL> -- /
04:02:23 SQL> 
04:02:23 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:02:23 SQL> 
04:02:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:02:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
04:02:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:02:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:02:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:23 SQL> 
04:02:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:02:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:23 SQL> 
04:02:23 SQL> --------------------------------
04:02:23 SQL> -- PREPARE BUILD (TRAINING) DATA
04:02:23 SQL> --
04:02:23 SQL> 
04:02:23 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:23 SQL> -- 2. Outlier Treatment and
04:02:23 SQL> -- 3. Normalization are performed below.
04:02:23 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:02:23 SQL> --    normalized here.
04:02:23 SQL> 
04:02:23 SQL> BEGIN
04:02:23   2  	-- Perform missing value treatment for all predictors
04:02:23   3  	-- create miss tables
04:02:23   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:02:23   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:02:23   6  
04:02:23   7  	-- populate miss tables
04:02:23   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:02:23   9  	  miss_table_name => 'svmc_miss_num',
04:02:23  10  	  data_table_name => '&bldtable',
04:02:23  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:23  12  
04:02:23  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:02:23  14  	  miss_table_name => 'svmc_miss_cat',
04:02:23  15  	  data_table_name => '&bldtable',
04:02:23  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:23  17  
04:02:23  18  	-- xform input data to replace missing values
04:02:23  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:23  20  	  miss_table_name => 'svmc_miss_num',
04:02:23  21  	  data_table_name => '&bldtable',
04:02:23  22  	  xform_view_name => 'xformed_build_miss_num');
04:02:23  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:23  24  	  miss_table_name => 'svmc_miss_cat',
04:02:23  25  	  data_table_name => '&bldtable',
04:02:23  26  	  xform_view_name => 'xformed_build_miss_cat');
04:02:23  27  
04:02:23  28  	-- Perform outlier treatment.
04:02:23  29  	-- create clip table
04:02:23  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:02:23  31  
04:02:23  32  	-- populate clip table
04:02:23  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:02:23  34  	  clip_table_name => 'svmc_clip',
04:02:23  35  	  data_table_name => '&bldtable',
04:02:23  36  	  tail_frac	  => 0.025,
04:02:23  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:23  38  
04:02:23  39  	-- xform input data to winsorized data
04:02:23  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:02:23  41  	  clip_table_name => 'svmc_clip',
04:02:23  42  	  data_table_name => '&bldtable',
04:02:23  43  	  xform_view_name => 'svmc_winsor');
04:02:23  44  
04:02:23  45  	-- create normalization table
04:02:23  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:02:23  47  
04:02:23  48  	-- populate normalization table based on winsorized data
04:02:23  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:02:23  50  	  norm_table_name => 'svmc_norm',
04:02:23  51  	  data_table_name => 'svmc_winsor',
04:02:23  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:23  53  
04:02:23  54  	-- normalize the original data
04:02:23  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:23  56  	  norm_table_name => 'svmc_norm',
04:02:23  57  	  data_table_name => '&bldtable',
04:02:23  58  	  xform_view_name => 'svmc_build_prep');
04:02:23  59  END;
04:02:23  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.62
04:02:26 SQL> 
04:02:26 SQL> ---------------------
04:02:26 SQL> -- CREATE A NEW MODEL
04:02:26 SQL> --
04:02:26 SQL> -- Cleanup old model with the same name for repeat runs
04:02:26 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:02:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:26   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.51
04:02:27 SQL> 
04:02:27 SQL> -- Build a new SVM Model
04:02:27 SQL> BEGIN
04:02:27   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:02:27   3  	  model_name	      => '&model_name',
04:02:27   4  	  mining_function     => dbms_data_mining.classification,
04:02:27   5  	  data_table_name     => 'svmc_build_prep',
04:02:27   6  	  case_id_column_name => '&case_id',
04:02:27   7  	  target_column_name  => '&target',
04:02:27   8  	  settings_table_name => 'svmc_settings');
04:02:27   9  END;
04:02:27  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.68
04:02:33 SQL> 
04:02:33 SQL> -----------------------------------------------------------------------
04:02:33 SQL> --			       APPLY/score THE MODEL
04:02:33 SQL> -----------------------------------------------------------------------
04:02:33 SQL> 
04:02:33 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:02:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:02:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:02:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:02:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:33 SQL> -----------------------
04:02:33 SQL> -- PREPARE SCORING DATA
04:02:33 SQL> --
04:02:33 SQL> -- If the data for model creation has been prepared, then the data
04:02:33 SQL> -- to be scored using the model must be prepared in the same manner
04:02:33 SQL> -- in order to obtain meaningful results.
04:02:33 SQL> --
04:02:33 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:33 SQL> -- 2. Normalization
04:02:33 SQL> -- No outlier treatment will be performed during test and apply. The
04:02:33 SQL> -- normalization step is sufficient, since the normalization parameters
04:02:33 SQL> -- already capture the effects of outlier treatment done with build data.
04:02:33 SQL> --
04:02:33 SQL> BEGIN
04:02:33   2  	-- Xform Test data to replace missing values
04:02:33   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:33   4  	  miss_table_name => 'svmc_miss_num',
04:02:33   5  	  data_table_name => '&scoretable',
04:02:33   6  	  xform_view_name => 'xformed_apply_miss_num');
04:02:33   7  
04:02:33   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:33   9  	  miss_table_name => 'svmc_miss_cat',
04:02:33  10  	  data_table_name => '&scoretable',
04:02:33  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:02:33  12  
04:02:33  13  	-- Normalize the data to be scored
04:02:33  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:33  15  	  norm_table_name => 'svmc_norm',
04:02:33  16  	  data_table_name => '&scoretable',
04:02:33  17  	  xform_view_name => 'svmc_apply_prep');
04:02:33  18  END;
04:02:33  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:02:33 SQL> 
04:02:33 SQL> -- Maybe I already collected a score for this prdate.
04:02:33 SQL> -- DELETE it if I did:
04:02:33 SQL> DELETE svm24scores
04:02:33   2  WHERE score > 0
04:02:33   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:02:33   4  -- I need to supply the target attribute name:
04:02:33   5  AND targ = '&1'
04:02:33   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.04
04:02:33 SQL> 
04:02:33 SQL> -- We do a drumroll here:
04:02:33 SQL> 
04:02:33 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:02:33   2  SELECT
04:02:33   3  prdate
04:02:33   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:02:33   5  ,sysdate
04:02:33   6  ,SUBSTR(prdate,1,7)pair
04:02:33   7  ,SUBSTR(prdate,-19)ydate
04:02:33   8  ,'&1'
04:02:33   9  FROM svmc_apply_prep
04:02:33  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:02:33 SQL> @score1_5min_gattn.sql	2011-01-25 04:00:00 eur_usd
04:02:33 SQL> --
04:02:33 SQL> -- score1_5min_gattn.sql
04:02:33 SQL> --
04:02:33 SQL> 
04:02:33 SQL> -- Demo:
04:02:33 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:02:33 SQL> 
04:02:33 SQL> CREATE OR REPLACE VIEW sme AS
04:02:33   2  SELECT
04:02:33   3  prdate
04:02:33   4  ,NULL gattn
04:02:33   5  ,g00
04:02:33   6  ,g01
04:02:33   7  ,g02
04:02:33   8  ,g03
04:02:33   9  ,g04
04:02:33  10  ,g05
04:02:33  11  ,g06
04:02:33  12  ,g07
04:02:33  13  ,g08
04:02:33  14  ,g09
04:02:33  15  ,g10
04:02:33  16  ,g11
04:02:33  17  ,g12
04:02:33  18  ,g13
04:02:33  19  ,g14
04:02:33  20  ,g15
04:02:33  21  ,g16
04:02:33  22  ,g17
04:02:33  23  ,g18
04:02:33  24  ,g19
04:02:33  25  ,g20
04:02:33  26  ,g21
04:02:33  27  ,g22
04:02:33  28  ,g23
04:02:33  29  ,g24
04:02:33  30  ,g25
04:02:33  31  ,g26
04:02:33  32  ,g27
04:02:33  33  ,g28
04:02:33  34  ,g29
04:02:33  35  ,g30
04:02:33  36  ,g31
04:02:33  37  ,g32
04:02:33  38  ,g33
04:02:33  39  ,g34
04:02:33  40  ,g35
04:02:33  41  ,g36
04:02:33  42  ,g37
04:02:33  43  ,g38
04:02:33  44  ,g39
04:02:33  45  ,g40
04:02:33  46  ,g41
04:02:33  47  ,s.sc_corr
04:02:33  48  FROM modsrc24
04:02:33  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:02:33  50  WHERE ydate = '&1'||' '||'&2'
04:02:33  51  AND pair = '&3'
04:02:33  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-25'||' '||'04:00:00'AND ydate<'2011-01-25'||' '||'04:00:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-25'||' '||'04:00:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:02:33 SQL> 
04:02:33 SQL> -- rpt
04:02:33 SQL> -- We should see just 1 row:
04:02:33 SQL> 
04:02:33 SQL> SELECT COUNT(prdate) FROM sme
04:02:33   2  
04:02:33 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:02:33   2  
04:02:33 SQL> 
04:02:33 SQL> -- Build the model:
04:02:33 SQL> CREATE OR REPLACE VIEW bme AS
04:02:33   2  SELECT
04:02:33   3  prdate
04:02:33   4  ,gattn
04:02:33   5  ,g00
04:02:33   6  ,g01
04:02:33   7  ,g02
04:02:33   8  ,g03
04:02:33   9  ,g04
04:02:33  10  ,g05
04:02:33  11  ,g06
04:02:33  12  ,g07
04:02:33  13  ,g08
04:02:33  14  ,g09
04:02:33  15  ,g10
04:02:33  16  ,g11
04:02:33  17  ,g12
04:02:33  18  ,g13
04:02:33  19  ,g14
04:02:33  20  ,g15
04:02:33  21  ,g16
04:02:33  22  ,g17
04:02:33  23  ,g18
04:02:33  24  ,g19
04:02:33  25  ,g20
04:02:33  26  ,g21
04:02:33  27  ,g22
04:02:33  28  ,g23
04:02:33  29  ,g24
04:02:33  30  ,g25
04:02:33  31  ,g26
04:02:33  32  ,g27
04:02:33  33  ,g28
04:02:33  34  ,g29
04:02:33  35  ,g30
04:02:33  36  ,g31
04:02:33  37  ,g32
04:02:33  38  ,g33
04:02:33  39  ,g34
04:02:33  40  ,g35
04:02:33  41  ,g36
04:02:33  42  ,g37
04:02:33  43  ,g38
04:02:33  44  ,g39
04:02:33  45  ,g40
04:02:33  46  ,g41
04:02:33  47  ,sc_corr
04:02:33  48  FROM modsrc24
04:02:33  49  WHERE gattn IN('nup','up')
04:02:33  50  -- Use only rows which are older than 1 day:
04:02:33  51  AND 1+ydate < '&1'||' '||'&2'
04:02:33  52  AND pair = '&3'
04:02:33  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-25'||' '||'04:00:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:33 SQL> 
04:02:33 SQL> -- rpt
04:02:33 SQL> 
04:02:33 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:02:33   2  
04:02:33 SQL> SELECT MAX(prdate) FROM bme
04:02:33   2  
04:02:33 SQL> -- Now build model from bme and score sme
04:02:33 SQL> @score1.sql gattn
04:02:33 SQL> --
04:02:33 SQL> -- score1.sql
04:02:33 SQL> --
04:02:33 SQL> 
04:02:33 SQL> -- I use this script to send 5 params to score.sql
04:02:33 SQL> -- which does the heavy lifting of creating an SVM model.
04:02:33 SQL> -- Then at the very end of this script I use the model
04:02:33 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:02:33 SQL> 
04:02:33 SQL> -- I call this script from 2 other scripts:
04:02:33 SQL> -- score1_5min.sql
04:02:33 SQL> -- score1_5min_gattn.sql
04:02:33 SQL> 
04:02:33 SQL> -- The 1st param is the name of the target attribute.
04:02:33 SQL> -- I like to call my target attributes either gatt or gattn.
04:02:33 SQL> 
04:02:33 SQL> -- Demo:
04:02:33 SQL> -- @score1.sql 'gatt'
04:02:33 SQL> -- @score1.sql 'gattn'
04:02:33 SQL> 
04:02:33 SQL> -- Now, I fill up svmc_apply_prep.
04:02:33 SQL> -- I use same model_name used in score.sql
04:02:33 SQL> DEFINE model_name = 'svmfx101'
04:02:33 SQL> DEFINE bldtable	= 'bme'
04:02:33 SQL> DEFINE scoretable = 'sme'
04:02:33 SQL> DEFINE case_id	= 'prdate'
04:02:33 SQL> -- Demo:
04:02:33 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:02:33 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:02:33 SQL> --
04:02:33 SQL> -- score.sql
04:02:33 SQL> --
04:02:33 SQL> 
04:02:33 SQL> -- usage: score.sql
04:02:33 SQL> 
04:02:33 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:02:33 SQL> 
04:02:33 SQL> -- DEFINE target	   = 'gatt'
04:02:33 SQL> -- DEFINE model_name = 'svmfx101'
04:02:33 SQL> -- DEFINE bldtable   = 'bme'
04:02:33 SQL> -- DEFINE scoretable = 'sme'
04:02:33 SQL> -- DEFINE case_id    = 'prdate'
04:02:33 SQL> 
04:02:33 SQL> DEFINE target	= '&1'
04:02:33 SQL> DEFINE model_name = '&2'
04:02:33 SQL> DEFINE bldtable	= '&3'
04:02:33 SQL> DEFINE scoretable = '&4'
04:02:33 SQL> DEFINE case_id	= '&5'
04:02:33 SQL> 
04:02:33 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:02:33 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:02:33 SQL> 
04:02:33 SQL> -- Builds an SVM model using pl/sql.
04:02:33 SQL> 
04:02:33 SQL> -----------------------------------------------------------------------
04:02:33 SQL> --			    BUILD THE MODEL
04:02:33 SQL> -----------------------------------------------------------------------
04:02:33 SQL> 
04:02:33 SQL> -- Cleanup old build data preparation objects for repeat runs
04:02:33 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
04:02:33 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:02:33 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:33 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:02:34 SQL> 
04:02:34 SQL> 
04:02:34 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:02:34 SQL> --
04:02:34 SQL> -- DROP	TABLE svmc_settings ;
04:02:34 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:02:34 SQL> -- DELETE svmc_settings;
04:02:34 SQL> 
04:02:34 SQL> -- The default classification algorithm is Naive Bayes. So override
04:02:34 SQL> -- this choice to SVM using a settings table.
04:02:34 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:02:34 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:02:34 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:02:34 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:02:34 SQL> -- models.
04:02:34 SQL> --
04:02:34 SQL> 
04:02:34 SQL> -- Do this once and then comment it out.
04:02:34 SQL> -- That makes script go faster.
04:02:34 SQL> -- BEGIN
04:02:34 SQL> -- -- Populate settings table
04:02:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:34 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:02:34 SQL> --
04:02:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:34 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:02:34 SQL> --
04:02:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:34 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:02:34 SQL> --   COMMIT;
04:02:34 SQL> -- END;
04:02:34 SQL> -- /
04:02:34 SQL> 
04:02:34 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:02:34 SQL> 
04:02:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:02:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
04:02:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:02:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:02:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:34 SQL> 
04:02:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:02:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:34 SQL> 
04:02:34 SQL> --------------------------------
04:02:34 SQL> -- PREPARE BUILD (TRAINING) DATA
04:02:34 SQL> --
04:02:34 SQL> 
04:02:34 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:34 SQL> -- 2. Outlier Treatment and
04:02:34 SQL> -- 3. Normalization are performed below.
04:02:34 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:02:34 SQL> --    normalized here.
04:02:34 SQL> 
04:02:34 SQL> BEGIN
04:02:34   2  	-- Perform missing value treatment for all predictors
04:02:34   3  	-- create miss tables
04:02:34   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:02:34   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:02:34   6  
04:02:34   7  	-- populate miss tables
04:02:34   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:02:34   9  	  miss_table_name => 'svmc_miss_num',
04:02:34  10  	  data_table_name => '&bldtable',
04:02:34  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:34  12  
04:02:34  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:02:34  14  	  miss_table_name => 'svmc_miss_cat',
04:02:34  15  	  data_table_name => '&bldtable',
04:02:34  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:34  17  
04:02:34  18  	-- xform input data to replace missing values
04:02:34  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:34  20  	  miss_table_name => 'svmc_miss_num',
04:02:34  21  	  data_table_name => '&bldtable',
04:02:34  22  	  xform_view_name => 'xformed_build_miss_num');
04:02:34  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:34  24  	  miss_table_name => 'svmc_miss_cat',
04:02:34  25  	  data_table_name => '&bldtable',
04:02:34  26  	  xform_view_name => 'xformed_build_miss_cat');
04:02:34  27  
04:02:34  28  	-- Perform outlier treatment.
04:02:34  29  	-- create clip table
04:02:34  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:02:34  31  
04:02:34  32  	-- populate clip table
04:02:34  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:02:34  34  	  clip_table_name => 'svmc_clip',
04:02:34  35  	  data_table_name => '&bldtable',
04:02:34  36  	  tail_frac	  => 0.025,
04:02:34  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:34  38  
04:02:34  39  	-- xform input data to winsorized data
04:02:34  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:02:34  41  	  clip_table_name => 'svmc_clip',
04:02:34  42  	  data_table_name => '&bldtable',
04:02:34  43  	  xform_view_name => 'svmc_winsor');
04:02:34  44  
04:02:34  45  	-- create normalization table
04:02:34  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:02:34  47  
04:02:34  48  	-- populate normalization table based on winsorized data
04:02:34  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:02:34  50  	  norm_table_name => 'svmc_norm',
04:02:34  51  	  data_table_name => 'svmc_winsor',
04:02:34  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:34  53  
04:02:34  54  	-- normalize the original data
04:02:34  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:34  56  	  norm_table_name => 'svmc_norm',
04:02:34  57  	  data_table_name => '&bldtable',
04:02:34  58  	  xform_view_name => 'svmc_build_prep');
04:02:34  59  END;
04:02:34  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.60
04:02:36 SQL> 
04:02:36 SQL> ---------------------
04:02:36 SQL> -- CREATE A NEW MODEL
04:02:36 SQL> --
04:02:36 SQL> -- Cleanup old model with the same name for repeat runs
04:02:36 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:02:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:36   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.38
04:02:38 SQL> 
04:02:38 SQL> -- Build a new SVM Model
04:02:38 SQL> BEGIN
04:02:38   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:02:38   3  	  model_name	      => '&model_name',
04:02:38   4  	  mining_function     => dbms_data_mining.classification,
04:02:38   5  	  data_table_name     => 'svmc_build_prep',
04:02:38   6  	  case_id_column_name => '&case_id',
04:02:38   7  	  target_column_name  => '&target',
04:02:38   8  	  settings_table_name => 'svmc_settings');
04:02:38   9  END;
04:02:38  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:07.98
04:02:46 SQL> 
04:02:46 SQL> -----------------------------------------------------------------------
04:02:46 SQL> --			       APPLY/score THE MODEL
04:02:46 SQL> -----------------------------------------------------------------------
04:02:46 SQL> 
04:02:46 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:46 SQL> -----------------------
04:02:46 SQL> -- PREPARE SCORING DATA
04:02:46 SQL> --
04:02:46 SQL> -- If the data for model creation has been prepared, then the data
04:02:46 SQL> -- to be scored using the model must be prepared in the same manner
04:02:46 SQL> -- in order to obtain meaningful results.
04:02:46 SQL> --
04:02:46 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:46 SQL> -- 2. Normalization
04:02:46 SQL> -- No outlier treatment will be performed during test and apply. The
04:02:46 SQL> -- normalization step is sufficient, since the normalization parameters
04:02:46 SQL> -- already capture the effects of outlier treatment done with build data.
04:02:46 SQL> --
04:02:46 SQL> BEGIN
04:02:46   2  	-- Xform Test data to replace missing values
04:02:46   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:46   4  	  miss_table_name => 'svmc_miss_num',
04:02:46   5  	  data_table_name => '&scoretable',
04:02:46   6  	  xform_view_name => 'xformed_apply_miss_num');
04:02:46   7  
04:02:46   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:46   9  	  miss_table_name => 'svmc_miss_cat',
04:02:46  10  	  data_table_name => '&scoretable',
04:02:46  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:02:46  12  
04:02:46  13  	-- Normalize the data to be scored
04:02:46  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:46  15  	  norm_table_name => 'svmc_norm',
04:02:46  16  	  data_table_name => '&scoretable',
04:02:46  17  	  xform_view_name => 'svmc_apply_prep');
04:02:46  18  END;
04:02:46  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
04:02:46 SQL> 
04:02:46 SQL> -- Maybe I already collected a score for this prdate.
04:02:46 SQL> -- DELETE it if I did:
04:02:46 SQL> DELETE svm24scores
04:02:46   2  WHERE score > 0
04:02:46   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:02:46   4  -- I need to supply the target attribute name:
04:02:46   5  AND targ = '&1'
04:02:46   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.05
04:02:46 SQL> 
04:02:46 SQL> -- We do a drumroll here:
04:02:46 SQL> 
04:02:46 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:02:46   2  SELECT
04:02:46   3  prdate
04:02:46   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:02:46   5  ,sysdate
04:02:46   6  ,SUBSTR(prdate,1,7)pair
04:02:46   7  ,SUBSTR(prdate,-19)ydate
04:02:46   8  ,'&1'
04:02:46   9  FROM svmc_apply_prep
04:02:46  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:02:46 SQL> @score1_5min_gattn.sql	2011-01-27 03:50:00 eur_usd
04:02:46 SQL> --
04:02:46 SQL> -- score1_5min_gattn.sql
04:02:46 SQL> --
04:02:46 SQL> 
04:02:46 SQL> -- Demo:
04:02:46 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:02:46 SQL> 
04:02:46 SQL> CREATE OR REPLACE VIEW sme AS
04:02:46   2  SELECT
04:02:46   3  prdate
04:02:46   4  ,NULL gattn
04:02:46   5  ,g00
04:02:46   6  ,g01
04:02:46   7  ,g02
04:02:46   8  ,g03
04:02:46   9  ,g04
04:02:46  10  ,g05
04:02:46  11  ,g06
04:02:46  12  ,g07
04:02:46  13  ,g08
04:02:46  14  ,g09
04:02:46  15  ,g10
04:02:46  16  ,g11
04:02:46  17  ,g12
04:02:46  18  ,g13
04:02:46  19  ,g14
04:02:46  20  ,g15
04:02:46  21  ,g16
04:02:46  22  ,g17
04:02:46  23  ,g18
04:02:46  24  ,g19
04:02:46  25  ,g20
04:02:46  26  ,g21
04:02:46  27  ,g22
04:02:46  28  ,g23
04:02:46  29  ,g24
04:02:46  30  ,g25
04:02:46  31  ,g26
04:02:46  32  ,g27
04:02:46  33  ,g28
04:02:46  34  ,g29
04:02:46  35  ,g30
04:02:46  36  ,g31
04:02:46  37  ,g32
04:02:46  38  ,g33
04:02:46  39  ,g34
04:02:46  40  ,g35
04:02:46  41  ,g36
04:02:46  42  ,g37
04:02:46  43  ,g38
04:02:46  44  ,g39
04:02:46  45  ,g40
04:02:46  46  ,g41
04:02:46  47  ,s.sc_corr
04:02:46  48  FROM modsrc24
04:02:46  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:02:46  50  WHERE ydate = '&1'||' '||'&2'
04:02:46  51  AND pair = '&3'
04:02:46  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-27'||' '||'03:50:00'AND ydate<'2011-01-27'||' '||'03:50:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-27'||' '||'03:50:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.04
04:02:46 SQL> 
04:02:46 SQL> -- rpt
04:02:46 SQL> -- We should see just 1 row:
04:02:46 SQL> 
04:02:46 SQL> SELECT COUNT(prdate) FROM sme
04:02:46   2  
04:02:46 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:02:46   2  
04:02:46 SQL> 
04:02:46 SQL> -- Build the model:
04:02:46 SQL> CREATE OR REPLACE VIEW bme AS
04:02:46   2  SELECT
04:02:46   3  prdate
04:02:46   4  ,gattn
04:02:46   5  ,g00
04:02:46   6  ,g01
04:02:46   7  ,g02
04:02:46   8  ,g03
04:02:46   9  ,g04
04:02:46  10  ,g05
04:02:46  11  ,g06
04:02:46  12  ,g07
04:02:46  13  ,g08
04:02:46  14  ,g09
04:02:46  15  ,g10
04:02:46  16  ,g11
04:02:46  17  ,g12
04:02:46  18  ,g13
04:02:46  19  ,g14
04:02:46  20  ,g15
04:02:46  21  ,g16
04:02:46  22  ,g17
04:02:46  23  ,g18
04:02:46  24  ,g19
04:02:46  25  ,g20
04:02:46  26  ,g21
04:02:46  27  ,g22
04:02:46  28  ,g23
04:02:46  29  ,g24
04:02:46  30  ,g25
04:02:46  31  ,g26
04:02:46  32  ,g27
04:02:46  33  ,g28
04:02:46  34  ,g29
04:02:46  35  ,g30
04:02:46  36  ,g31
04:02:46  37  ,g32
04:02:46  38  ,g33
04:02:46  39  ,g34
04:02:46  40  ,g35
04:02:46  41  ,g36
04:02:46  42  ,g37
04:02:46  43  ,g38
04:02:46  44  ,g39
04:02:46  45  ,g40
04:02:46  46  ,g41
04:02:46  47  ,sc_corr
04:02:46  48  FROM modsrc24
04:02:46  49  WHERE gattn IN('nup','up')
04:02:46  50  -- Use only rows which are older than 1 day:
04:02:46  51  AND 1+ydate < '&1'||' '||'&2'
04:02:46  52  AND pair = '&3'
04:02:46  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-27'||' '||'03:50:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:46 SQL> 
04:02:46 SQL> -- rpt
04:02:46 SQL> 
04:02:46 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:02:46   2  
04:02:46 SQL> SELECT MAX(prdate) FROM bme
04:02:46   2  
04:02:46 SQL> -- Now build model from bme and score sme
04:02:46 SQL> @score1.sql gattn
04:02:46 SQL> --
04:02:46 SQL> -- score1.sql
04:02:46 SQL> --
04:02:46 SQL> 
04:02:46 SQL> -- I use this script to send 5 params to score.sql
04:02:46 SQL> -- which does the heavy lifting of creating an SVM model.
04:02:46 SQL> -- Then at the very end of this script I use the model
04:02:46 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:02:46 SQL> 
04:02:46 SQL> -- I call this script from 2 other scripts:
04:02:46 SQL> -- score1_5min.sql
04:02:46 SQL> -- score1_5min_gattn.sql
04:02:46 SQL> 
04:02:46 SQL> -- The 1st param is the name of the target attribute.
04:02:46 SQL> -- I like to call my target attributes either gatt or gattn.
04:02:46 SQL> 
04:02:46 SQL> -- Demo:
04:02:46 SQL> -- @score1.sql 'gatt'
04:02:46 SQL> -- @score1.sql 'gattn'
04:02:46 SQL> 
04:02:46 SQL> -- Now, I fill up svmc_apply_prep.
04:02:46 SQL> -- I use same model_name used in score.sql
04:02:46 SQL> DEFINE model_name = 'svmfx101'
04:02:46 SQL> DEFINE bldtable	= 'bme'
04:02:46 SQL> DEFINE scoretable = 'sme'
04:02:46 SQL> DEFINE case_id	= 'prdate'
04:02:46 SQL> -- Demo:
04:02:46 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:02:46 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:02:46 SQL> --
04:02:46 SQL> -- score.sql
04:02:46 SQL> --
04:02:46 SQL> 
04:02:46 SQL> -- usage: score.sql
04:02:46 SQL> 
04:02:46 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:02:46 SQL> 
04:02:46 SQL> -- DEFINE target	   = 'gatt'
04:02:46 SQL> -- DEFINE model_name = 'svmfx101'
04:02:46 SQL> -- DEFINE bldtable   = 'bme'
04:02:46 SQL> -- DEFINE scoretable = 'sme'
04:02:46 SQL> -- DEFINE case_id    = 'prdate'
04:02:46 SQL> 
04:02:46 SQL> DEFINE target	= '&1'
04:02:46 SQL> DEFINE model_name = '&2'
04:02:46 SQL> DEFINE bldtable	= '&3'
04:02:46 SQL> DEFINE scoretable = '&4'
04:02:46 SQL> DEFINE case_id	= '&5'
04:02:46 SQL> 
04:02:46 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:02:46 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:02:46 SQL> 
04:02:46 SQL> -- Builds an SVM model using pl/sql.
04:02:46 SQL> 
04:02:46 SQL> -----------------------------------------------------------------------
04:02:46 SQL> --			    BUILD THE MODEL
04:02:46 SQL> -----------------------------------------------------------------------
04:02:46 SQL> 
04:02:46 SQL> -- Cleanup old build data preparation objects for repeat runs
04:02:46 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:46 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:02:46 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.01
04:02:46 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:02:46 SQL> 
04:02:46 SQL> 
04:02:46 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:02:46 SQL> --
04:02:46 SQL> -- DROP	TABLE svmc_settings ;
04:02:46 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:02:46 SQL> -- DELETE svmc_settings;
04:02:46 SQL> 
04:02:46 SQL> -- The default classification algorithm is Naive Bayes. So override
04:02:46 SQL> -- this choice to SVM using a settings table.
04:02:46 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:02:46 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:02:46 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:02:46 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:02:46 SQL> -- models.
04:02:46 SQL> --
04:02:46 SQL> 
04:02:46 SQL> -- Do this once and then comment it out.
04:02:46 SQL> -- That makes script go faster.
04:02:46 SQL> -- BEGIN
04:02:46 SQL> -- -- Populate settings table
04:02:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:46 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:02:46 SQL> --
04:02:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:46 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:02:46 SQL> --
04:02:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:46 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:02:46 SQL> --   COMMIT;
04:02:46 SQL> -- END;
04:02:46 SQL> -- /
04:02:46 SQL> 
04:02:46 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:02:46 SQL> 
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:46 SQL> 
04:02:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:02:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:46 SQL> 
04:02:46 SQL> --------------------------------
04:02:46 SQL> -- PREPARE BUILD (TRAINING) DATA
04:02:46 SQL> --
04:02:46 SQL> 
04:02:46 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:46 SQL> -- 2. Outlier Treatment and
04:02:46 SQL> -- 3. Normalization are performed below.
04:02:46 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:02:46 SQL> --    normalized here.
04:02:46 SQL> 
04:02:46 SQL> BEGIN
04:02:46   2  	-- Perform missing value treatment for all predictors
04:02:46   3  	-- create miss tables
04:02:46   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:02:46   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:02:46   6  
04:02:46   7  	-- populate miss tables
04:02:46   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:02:46   9  	  miss_table_name => 'svmc_miss_num',
04:02:46  10  	  data_table_name => '&bldtable',
04:02:46  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:46  12  
04:02:46  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:02:46  14  	  miss_table_name => 'svmc_miss_cat',
04:02:46  15  	  data_table_name => '&bldtable',
04:02:46  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:46  17  
04:02:46  18  	-- xform input data to replace missing values
04:02:46  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:46  20  	  miss_table_name => 'svmc_miss_num',
04:02:46  21  	  data_table_name => '&bldtable',
04:02:46  22  	  xform_view_name => 'xformed_build_miss_num');
04:02:46  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:46  24  	  miss_table_name => 'svmc_miss_cat',
04:02:46  25  	  data_table_name => '&bldtable',
04:02:46  26  	  xform_view_name => 'xformed_build_miss_cat');
04:02:46  27  
04:02:46  28  	-- Perform outlier treatment.
04:02:46  29  	-- create clip table
04:02:46  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:02:46  31  
04:02:46  32  	-- populate clip table
04:02:46  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:02:46  34  	  clip_table_name => 'svmc_clip',
04:02:46  35  	  data_table_name => '&bldtable',
04:02:46  36  	  tail_frac	  => 0.025,
04:02:46  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:46  38  
04:02:46  39  	-- xform input data to winsorized data
04:02:46  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:02:46  41  	  clip_table_name => 'svmc_clip',
04:02:46  42  	  data_table_name => '&bldtable',
04:02:46  43  	  xform_view_name => 'svmc_winsor');
04:02:46  44  
04:02:46  45  	-- create normalization table
04:02:46  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:02:46  47  
04:02:46  48  	-- populate normalization table based on winsorized data
04:02:46  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:02:46  50  	  norm_table_name => 'svmc_norm',
04:02:46  51  	  data_table_name => 'svmc_winsor',
04:02:46  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:46  53  
04:02:46  54  	-- normalize the original data
04:02:46  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:46  56  	  norm_table_name => 'svmc_norm',
04:02:46  57  	  data_table_name => '&bldtable',
04:02:46  58  	  xform_view_name => 'svmc_build_prep');
04:02:46  59  END;
04:02:46  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.65
04:02:49 SQL> 
04:02:49 SQL> ---------------------
04:02:49 SQL> -- CREATE A NEW MODEL
04:02:49 SQL> --
04:02:49 SQL> -- Cleanup old model with the same name for repeat runs
04:02:49 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:02:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:49   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.42
04:02:50 SQL> 
04:02:50 SQL> -- Build a new SVM Model
04:02:50 SQL> BEGIN
04:02:50   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:02:50   3  	  model_name	      => '&model_name',
04:02:50   4  	  mining_function     => dbms_data_mining.classification,
04:02:50   5  	  data_table_name     => 'svmc_build_prep',
04:02:50   6  	  case_id_column_name => '&case_id',
04:02:50   7  	  target_column_name  => '&target',
04:02:50   8  	  settings_table_name => 'svmc_settings');
04:02:50   9  END;
04:02:50  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:06.06
04:02:56 SQL> 
04:02:56 SQL> -----------------------------------------------------------------------
04:02:56 SQL> --			       APPLY/score THE MODEL
04:02:56 SQL> -----------------------------------------------------------------------
04:02:56 SQL> 
04:02:56 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:02:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:02:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:02:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:02:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:57 SQL> -----------------------
04:02:57 SQL> -- PREPARE SCORING DATA
04:02:57 SQL> --
04:02:57 SQL> -- If the data for model creation has been prepared, then the data
04:02:57 SQL> -- to be scored using the model must be prepared in the same manner
04:02:57 SQL> -- in order to obtain meaningful results.
04:02:57 SQL> --
04:02:57 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:57 SQL> -- 2. Normalization
04:02:57 SQL> -- No outlier treatment will be performed during test and apply. The
04:02:57 SQL> -- normalization step is sufficient, since the normalization parameters
04:02:57 SQL> -- already capture the effects of outlier treatment done with build data.
04:02:57 SQL> --
04:02:57 SQL> BEGIN
04:02:57   2  	-- Xform Test data to replace missing values
04:02:57   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:57   4  	  miss_table_name => 'svmc_miss_num',
04:02:57   5  	  data_table_name => '&scoretable',
04:02:57   6  	  xform_view_name => 'xformed_apply_miss_num');
04:02:57   7  
04:02:57   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:57   9  	  miss_table_name => 'svmc_miss_cat',
04:02:57  10  	  data_table_name => '&scoretable',
04:02:57  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:02:57  12  
04:02:57  13  	-- Normalize the data to be scored
04:02:57  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:57  15  	  norm_table_name => 'svmc_norm',
04:02:57  16  	  data_table_name => '&scoretable',
04:02:57  17  	  xform_view_name => 'svmc_apply_prep');
04:02:57  18  END;
04:02:57  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
04:02:57 SQL> 
04:02:57 SQL> -- Maybe I already collected a score for this prdate.
04:02:57 SQL> -- DELETE it if I did:
04:02:57 SQL> DELETE svm24scores
04:02:57   2  WHERE score > 0
04:02:57   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:02:57   4  -- I need to supply the target attribute name:
04:02:57   5  AND targ = '&1'
04:02:57   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:02:57 SQL> 
04:02:57 SQL> -- We do a drumroll here:
04:02:57 SQL> 
04:02:57 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:02:57   2  SELECT
04:02:57   3  prdate
04:02:57   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:02:57   5  ,sysdate
04:02:57   6  ,SUBSTR(prdate,1,7)pair
04:02:57   7  ,SUBSTR(prdate,-19)ydate
04:02:57   8  ,'&1'
04:02:57   9  FROM svmc_apply_prep
04:02:57  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:02:57 SQL> @score1_5min_gattn.sql	2011-01-28 15:45:00 eur_usd
04:02:57 SQL> --
04:02:57 SQL> -- score1_5min_gattn.sql
04:02:57 SQL> --
04:02:57 SQL> 
04:02:57 SQL> -- Demo:
04:02:57 SQL> -- @score1_5min_gattn.sql 2010-12-31 20:45:01 aud_usd
04:02:57 SQL> 
04:02:57 SQL> CREATE OR REPLACE VIEW sme AS
04:02:57   2  SELECT
04:02:57   3  prdate
04:02:57   4  ,NULL gattn
04:02:57   5  ,g00
04:02:57   6  ,g01
04:02:57   7  ,g02
04:02:57   8  ,g03
04:02:57   9  ,g04
04:02:57  10  ,g05
04:02:57  11  ,g06
04:02:57  12  ,g07
04:02:57  13  ,g08
04:02:57  14  ,g09
04:02:57  15  ,g10
04:02:57  16  ,g11
04:02:57  17  ,g12
04:02:57  18  ,g13
04:02:57  19  ,g14
04:02:57  20  ,g15
04:02:57  21  ,g16
04:02:57  22  ,g17
04:02:57  23  ,g18
04:02:57  24  ,g19
04:02:57  25  ,g20
04:02:57  26  ,g21
04:02:57  27  ,g22
04:02:57  28  ,g23
04:02:57  29  ,g24
04:02:57  30  ,g25
04:02:57  31  ,g26
04:02:57  32  ,g27
04:02:57  33  ,g28
04:02:57  34  ,g29
04:02:57  35  ,g30
04:02:57  36  ,g31
04:02:57  37  ,g32
04:02:57  38  ,g33
04:02:57  39  ,g34
04:02:57  40  ,g35
04:02:57  41  ,g36
04:02:57  42  ,g37
04:02:57  43  ,g38
04:02:57  44  ,g39
04:02:57  45  ,g40
04:02:57  46  ,g41
04:02:57  47  ,s.sc_corr
04:02:57  48  FROM modsrc24
04:02:57  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:02:57  50  WHERE ydate = '&1'||' '||'&2'
04:02:57  51  AND pair = '&3'
04:02:57  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-28'||' '||'15:45:00'AND ydate<'2011-01-28'||' '||'15:45:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-28'||' '||'15:45:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:57 SQL> 
04:02:57 SQL> -- rpt
04:02:57 SQL> -- We should see just 1 row:
04:02:57 SQL> 
04:02:57 SQL> SELECT COUNT(prdate) FROM sme
04:02:57   2  
04:02:57 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:02:57   2  
04:02:57 SQL> 
04:02:57 SQL> -- Build the model:
04:02:57 SQL> CREATE OR REPLACE VIEW bme AS
04:02:57   2  SELECT
04:02:57   3  prdate
04:02:57   4  ,gattn
04:02:57   5  ,g00
04:02:57   6  ,g01
04:02:57   7  ,g02
04:02:57   8  ,g03
04:02:57   9  ,g04
04:02:57  10  ,g05
04:02:57  11  ,g06
04:02:57  12  ,g07
04:02:57  13  ,g08
04:02:57  14  ,g09
04:02:57  15  ,g10
04:02:57  16  ,g11
04:02:57  17  ,g12
04:02:57  18  ,g13
04:02:57  19  ,g14
04:02:57  20  ,g15
04:02:57  21  ,g16
04:02:57  22  ,g17
04:02:57  23  ,g18
04:02:57  24  ,g19
04:02:57  25  ,g20
04:02:57  26  ,g21
04:02:57  27  ,g22
04:02:57  28  ,g23
04:02:57  29  ,g24
04:02:57  30  ,g25
04:02:57  31  ,g26
04:02:57  32  ,g27
04:02:57  33  ,g28
04:02:57  34  ,g29
04:02:57  35  ,g30
04:02:57  36  ,g31
04:02:57  37  ,g32
04:02:57  38  ,g33
04:02:57  39  ,g34
04:02:57  40  ,g35
04:02:57  41  ,g36
04:02:57  42  ,g37
04:02:57  43  ,g38
04:02:57  44  ,g39
04:02:57  45  ,g40
04:02:57  46  ,g41
04:02:57  47  ,sc_corr
04:02:57  48  FROM modsrc24
04:02:57  49  WHERE gattn IN('nup','up')
04:02:57  50  -- Use only rows which are older than 1 day:
04:02:57  51  AND 1+ydate < '&1'||' '||'&2'
04:02:57  52  AND pair = '&3'
04:02:57  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-28'||' '||'15:45:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:02:57 SQL> 
04:02:57 SQL> -- rpt
04:02:57 SQL> 
04:02:57 SQL> SELECT gattn, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gattn
04:02:57   2  
04:02:57 SQL> SELECT MAX(prdate) FROM bme
04:02:57   2  
04:02:57 SQL> -- Now build model from bme and score sme
04:02:57 SQL> @score1.sql gattn
04:02:57 SQL> --
04:02:57 SQL> -- score1.sql
04:02:57 SQL> --
04:02:57 SQL> 
04:02:57 SQL> -- I use this script to send 5 params to score.sql
04:02:57 SQL> -- which does the heavy lifting of creating an SVM model.
04:02:57 SQL> -- Then at the very end of this script I use the model
04:02:57 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:02:57 SQL> 
04:02:57 SQL> -- I call this script from 2 other scripts:
04:02:57 SQL> -- score1_5min.sql
04:02:57 SQL> -- score1_5min_gattn.sql
04:02:57 SQL> 
04:02:57 SQL> -- The 1st param is the name of the target attribute.
04:02:57 SQL> -- I like to call my target attributes either gatt or gattn.
04:02:57 SQL> 
04:02:57 SQL> -- Demo:
04:02:57 SQL> -- @score1.sql 'gatt'
04:02:57 SQL> -- @score1.sql 'gattn'
04:02:57 SQL> 
04:02:57 SQL> -- Now, I fill up svmc_apply_prep.
04:02:57 SQL> -- I use same model_name used in score.sql
04:02:57 SQL> DEFINE model_name = 'svmfx101'
04:02:57 SQL> DEFINE bldtable	= 'bme'
04:02:57 SQL> DEFINE scoretable = 'sme'
04:02:57 SQL> DEFINE case_id	= 'prdate'
04:02:57 SQL> -- Demo:
04:02:57 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:02:57 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:02:57 SQL> --
04:02:57 SQL> -- score.sql
04:02:57 SQL> --
04:02:57 SQL> 
04:02:57 SQL> -- usage: score.sql
04:02:57 SQL> 
04:02:57 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:02:57 SQL> 
04:02:57 SQL> -- DEFINE target	   = 'gatt'
04:02:57 SQL> -- DEFINE model_name = 'svmfx101'
04:02:57 SQL> -- DEFINE bldtable   = 'bme'
04:02:57 SQL> -- DEFINE scoretable = 'sme'
04:02:57 SQL> -- DEFINE case_id    = 'prdate'
04:02:57 SQL> 
04:02:57 SQL> DEFINE target	= '&1'
04:02:57 SQL> DEFINE model_name = '&2'
04:02:57 SQL> DEFINE bldtable	= '&3'
04:02:57 SQL> DEFINE scoretable = '&4'
04:02:57 SQL> DEFINE case_id	= '&5'
04:02:57 SQL> 
04:02:57 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:02:57 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:02:57 SQL> 
04:02:57 SQL> -- Builds an SVM model using pl/sql.
04:02:57 SQL> 
04:02:57 SQL> -----------------------------------------------------------------------
04:02:57 SQL> --			    BUILD THE MODEL
04:02:57 SQL> -----------------------------------------------------------------------
04:02:57 SQL> 
04:02:57 SQL> -- Cleanup old build data preparation objects for repeat runs
04:02:57 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:57 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
04:02:57 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:02:57 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.00
04:02:57 SQL> 
04:02:57 SQL> 
04:02:57 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:02:57 SQL> --
04:02:57 SQL> -- DROP	TABLE svmc_settings ;
04:02:57 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:02:57 SQL> -- DELETE svmc_settings;
04:02:57 SQL> 
04:02:57 SQL> -- The default classification algorithm is Naive Bayes. So override
04:02:57 SQL> -- this choice to SVM using a settings table.
04:02:57 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:02:57 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:02:57 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:02:57 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:02:57 SQL> -- models.
04:02:57 SQL> --
04:02:57 SQL> 
04:02:57 SQL> -- Do this once and then comment it out.
04:02:57 SQL> -- That makes script go faster.
04:02:57 SQL> -- BEGIN
04:02:57 SQL> -- -- Populate settings table
04:02:57 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:57 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:02:57 SQL> --
04:02:57 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:57 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:02:57 SQL> --
04:02:57 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:02:57 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:02:57 SQL> --   COMMIT;
04:02:57 SQL> -- END;
04:02:57 SQL> -- /
04:02:57 SQL> 
04:02:57 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
04:02:57 SQL> 
04:02:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:02:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:02:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
04:02:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:02:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
04:02:57 SQL> 
04:02:57 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:02:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:02:57   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:02:57 SQL> 
04:02:57 SQL> --------------------------------
04:02:57 SQL> -- PREPARE BUILD (TRAINING) DATA
04:02:57 SQL> --
04:02:57 SQL> 
04:02:57 SQL> -- 1. Missing Value treatment for all Predictors and
04:02:57 SQL> -- 2. Outlier Treatment and
04:02:57 SQL> -- 3. Normalization are performed below.
04:02:57 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:02:57 SQL> --    normalized here.
04:02:57 SQL> 
04:02:57 SQL> BEGIN
04:02:57   2  	-- Perform missing value treatment for all predictors
04:02:57   3  	-- create miss tables
04:02:57   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:02:57   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:02:57   6  
04:02:57   7  	-- populate miss tables
04:02:57   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:02:57   9  	  miss_table_name => 'svmc_miss_num',
04:02:57  10  	  data_table_name => '&bldtable',
04:02:57  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:57  12  
04:02:57  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:02:57  14  	  miss_table_name => 'svmc_miss_cat',
04:02:57  15  	  data_table_name => '&bldtable',
04:02:57  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:57  17  
04:02:57  18  	-- xform input data to replace missing values
04:02:57  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:02:57  20  	  miss_table_name => 'svmc_miss_num',
04:02:57  21  	  data_table_name => '&bldtable',
04:02:57  22  	  xform_view_name => 'xformed_build_miss_num');
04:02:57  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:02:57  24  	  miss_table_name => 'svmc_miss_cat',
04:02:57  25  	  data_table_name => '&bldtable',
04:02:57  26  	  xform_view_name => 'xformed_build_miss_cat');
04:02:57  27  
04:02:57  28  	-- Perform outlier treatment.
04:02:57  29  	-- create clip table
04:02:57  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:02:57  31  
04:02:57  32  	-- populate clip table
04:02:57  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:02:57  34  	  clip_table_name => 'svmc_clip',
04:02:57  35  	  data_table_name => '&bldtable',
04:02:57  36  	  tail_frac	  => 0.025,
04:02:57  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:57  38  
04:02:57  39  	-- xform input data to winsorized data
04:02:57  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:02:57  41  	  clip_table_name => 'svmc_clip',
04:02:57  42  	  data_table_name => '&bldtable',
04:02:57  43  	  xform_view_name => 'svmc_winsor');
04:02:57  44  
04:02:57  45  	-- create normalization table
04:02:57  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:02:57  47  
04:02:57  48  	-- populate normalization table based on winsorized data
04:02:57  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:02:57  50  	  norm_table_name => 'svmc_norm',
04:02:57  51  	  data_table_name => 'svmc_winsor',
04:02:57  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:02:57  53  
04:02:57  54  	-- normalize the original data
04:02:57  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:02:57  56  	  norm_table_name => 'svmc_norm',
04:02:57  57  	  data_table_name => '&bldtable',
04:02:57  58  	  xform_view_name => 'svmc_build_prep');
04:02:57  59  END;
04:02:57  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.77
04:03:00 SQL> 
04:03:00 SQL> ---------------------
04:03:00 SQL> -- CREATE A NEW MODEL
04:03:00 SQL> --
04:03:00 SQL> -- Cleanup old model with the same name for repeat runs
04:03:00 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:03:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:00   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.70
04:03:02 SQL> 
04:03:02 SQL> -- Build a new SVM Model
04:03:02 SQL> BEGIN
04:03:02   2  	DBMS_DATA_MINING.CREATE_MODEL(
04:03:02   3  	  model_name	      => '&model_name',
04:03:02   4  	  mining_function     => dbms_data_mining.classification,
04:03:02   5  	  data_table_name     => 'svmc_build_prep',
04:03:02   6  	  case_id_column_name => '&case_id',
04:03:02   7  	  target_column_name  => '&target',
04:03:02   8  	  settings_table_name => 'svmc_settings');
04:03:02   9  END;
04:03:02  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmfx101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'prdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:05.28
04:03:07 SQL> 
04:03:07 SQL> -----------------------------------------------------------------------
04:03:07 SQL> --			       APPLY/score THE MODEL
04:03:07 SQL> -----------------------------------------------------------------------
04:03:07 SQL> 
04:03:07 SQL> -- Cleanup old scoring data preparation objects for repeat runs
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:03:07 SQL> -----------------------
04:03:07 SQL> -- PREPARE SCORING DATA
04:03:07 SQL> --
04:03:07 SQL> -- If the data for model creation has been prepared, then the data
04:03:07 SQL> -- to be scored using the model must be prepared in the same manner
04:03:07 SQL> -- in order to obtain meaningful results.
04:03:07 SQL> --
04:03:07 SQL> -- 1. Missing Value treatment for all Predictors and
04:03:07 SQL> -- 2. Normalization
04:03:07 SQL> -- No outlier treatment will be performed during test and apply. The
04:03:07 SQL> -- normalization step is sufficient, since the normalization parameters
04:03:07 SQL> -- already capture the effects of outlier treatment done with build data.
04:03:07 SQL> --
04:03:07 SQL> BEGIN
04:03:07   2  	-- Xform Test data to replace missing values
04:03:07   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:03:07   4  	  miss_table_name => 'svmc_miss_num',
04:03:07   5  	  data_table_name => '&scoretable',
04:03:07   6  	  xform_view_name => 'xformed_apply_miss_num');
04:03:07   7  
04:03:07   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:03:07   9  	  miss_table_name => 'svmc_miss_cat',
04:03:07  10  	  data_table_name => '&scoretable',
04:03:07  11  	  xform_view_name => 'xformed_apply_miss_cat');
04:03:07  12  
04:03:07  13  	-- Normalize the data to be scored
04:03:07  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:03:07  15  	  norm_table_name => 'svmc_norm',
04:03:07  16  	  data_table_name => '&scoretable',
04:03:07  17  	  xform_view_name => 'svmc_apply_prep');
04:03:07  18  END;
04:03:07  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
04:03:07 SQL> 
04:03:07 SQL> -- Maybe I already collected a score for this prdate.
04:03:07 SQL> -- DELETE it if I did:
04:03:07 SQL> DELETE svm24scores
04:03:07   2  WHERE score > 0
04:03:07   3  AND prdate IN(SELECT prdate FROM svmc_apply_prep)
04:03:07   4  -- I need to supply the target attribute name:
04:03:07   5  AND targ = '&1'
04:03:07   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.03
04:03:07 SQL> 
04:03:07 SQL> -- We do a drumroll here:
04:03:07 SQL> 
04:03:07 SQL> INSERT INTO svm24scores (prdate,score,rundate,pair,ydate,targ)
04:03:07   2  SELECT
04:03:07   3  prdate
04:03:07   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
04:03:07   5  ,sysdate
04:03:07   6  ,SUBSTR(prdate,1,7)pair
04:03:07   7  ,SUBSTR(prdate,-19)ydate
04:03:07   8  ,'&1'
04:03:07   9  FROM svmc_apply_prep
04:03:07  10  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmfx101,'up' USING *)score
old   8: ,'&1'
new   8: ,'gattn'

1 row created.

Elapsed: 00:00:00.06
04:03:07 SQL> @score1_5min.sql	      2011-01-20 06:15:00 eur_usd
04:03:07 SQL> --
04:03:07 SQL> -- score1_5min.sql
04:03:07 SQL> --
04:03:07 SQL> 
04:03:07 SQL> -- Demo:
04:03:07 SQL> -- @score1_5min.sql 2010-12-31 20:45:01 aud_usd
04:03:07 SQL> 
04:03:07 SQL> CREATE OR REPLACE VIEW sme AS
04:03:07   2  SELECT
04:03:07   3  prdate
04:03:07   4  ,NULL gatt
04:03:07   5  ,g00
04:03:07   6  ,g01
04:03:07   7  ,g02
04:03:07   8  ,g03
04:03:07   9  ,g04
04:03:07  10  ,g05
04:03:07  11  ,g06
04:03:07  12  ,g07
04:03:07  13  ,g08
04:03:07  14  ,g09
04:03:07  15  ,g10
04:03:07  16  ,g11
04:03:07  17  ,g12
04:03:07  18  ,g13
04:03:07  19  ,g14
04:03:07  20  ,g15
04:03:07  21  ,g16
04:03:07  22  ,g17
04:03:07  23  ,g18
04:03:07  24  ,g19
04:03:07  25  ,g20
04:03:07  26  ,g21
04:03:07  27  ,g22
04:03:07  28  ,g23
04:03:07  29  ,g24
04:03:07  30  ,g25
04:03:07  31  ,g26
04:03:07  32  ,g27
04:03:07  33  ,g28
04:03:07  34  ,g29
04:03:07  35  ,g30
04:03:07  36  ,g31
04:03:07  37  ,g32
04:03:07  38  ,g33
04:03:07  39  ,g34
04:03:07  40  ,g35
04:03:07  41  ,g36
04:03:07  42  ,g37
04:03:07  43  ,g38
04:03:07  44  ,g39
04:03:07  45  ,g40
04:03:07  46  ,g41
04:03:07  47  ,s.sc_corr
04:03:07  48  FROM modsrc24
04:03:07  49  ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
04:03:07  50  WHERE ydate = '&1'||' '||'&2'
04:03:07  51  AND pair = '&3'
04:03:07  52  /
old  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2')s
new  49: ,(SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'2011-01-20'||' '||'06:15:00'AND ydate<'2011-01-20'||' '||'06:15:00')s
old  50: WHERE ydate = '&1'||' '||'&2'
new  50: WHERE ydate = '2011-01-20'||' '||'06:15:00'
old  51: AND pair = '&3'
new  51: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:03:07 SQL> 
04:03:07 SQL> -- rpt
04:03:07 SQL> -- We should see just 1 row:
04:03:07 SQL> 
04:03:07 SQL> SELECT COUNT(prdate) FROM sme
04:03:07   2  
04:03:07 SQL> SELECT AVG(sc_corr)sc_corr FROM modsrc24 WHERE 11+ydate>'&1'||' '||'&2'AND ydate<'&1'||' '||'&2'
04:03:07   2  
04:03:07 SQL> 
04:03:07 SQL> -- Build the model:
04:03:07 SQL> CREATE OR REPLACE VIEW bme AS
04:03:07   2  SELECT
04:03:07   3  prdate
04:03:07   4  ,gatt
04:03:07   5  ,g00
04:03:07   6  ,g01
04:03:07   7  ,g02
04:03:07   8  ,g03
04:03:07   9  ,g04
04:03:07  10  ,g05
04:03:07  11  ,g06
04:03:07  12  ,g07
04:03:07  13  ,g08
04:03:07  14  ,g09
04:03:07  15  ,g10
04:03:07  16  ,g11
04:03:07  17  ,g12
04:03:07  18  ,g13
04:03:07  19  ,g14
04:03:07  20  ,g15
04:03:07  21  ,g16
04:03:07  22  ,g17
04:03:07  23  ,g18
04:03:07  24  ,g19
04:03:07  25  ,g20
04:03:07  26  ,g21
04:03:07  27  ,g22
04:03:07  28  ,g23
04:03:07  29  ,g24
04:03:07  30  ,g25
04:03:07  31  ,g26
04:03:07  32  ,g27
04:03:07  33  ,g28
04:03:07  34  ,g29
04:03:07  35  ,g30
04:03:07  36  ,g31
04:03:07  37  ,g32
04:03:07  38  ,g33
04:03:07  39  ,g34
04:03:07  40  ,g35
04:03:07  41  ,g36
04:03:07  42  ,g37
04:03:07  43  ,g38
04:03:07  44  ,g39
04:03:07  45  ,g40
04:03:07  46  ,g41
04:03:07  47  ,sc_corr
04:03:07  48  FROM modsrc24
04:03:07  49  WHERE gatt IN('nup','up')
04:03:07  50  -- Use only rows which are older than 1 day:
04:03:07  51  AND 1+ydate < '&1'||' '||'&2'
04:03:07  52  AND pair = '&3'
04:03:07  53  /
old  51: AND 1+ydate < '&1'||' '||'&2'
new  51: AND 1+ydate < '2011-01-20'||' '||'06:15:00'
old  52: AND pair = '&3'
new  52: AND pair = 'eur_usd'

View created.

Elapsed: 00:00:00.05
04:03:07 SQL> 
04:03:07 SQL> -- rpt
04:03:07 SQL> 
04:03:07 SQL> SELECT gatt, AVG(sc_corr), COUNT(prdate) FROM bme GROUP BY gatt
04:03:07   2  
04:03:07 SQL> SELECT MAX(prdate) FROM bme
04:03:07   2  
04:03:07 SQL> -- Now build model from bme and score sme
04:03:07 SQL> @score1.sql gatt
04:03:07 SQL> --
04:03:07 SQL> -- score1.sql
04:03:07 SQL> --
04:03:07 SQL> 
04:03:07 SQL> -- I use this script to send 5 params to score.sql
04:03:07 SQL> -- which does the heavy lifting of creating an SVM model.
04:03:07 SQL> -- Then at the very end of this script I use the model
04:03:07 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
04:03:07 SQL> 
04:03:07 SQL> -- I call this script from 2 other scripts:
04:03:07 SQL> -- score1_5min.sql
04:03:07 SQL> -- score1_5min_gattn.sql
04:03:07 SQL> 
04:03:07 SQL> -- The 1st param is the name of the target attribute.
04:03:07 SQL> -- I like to call my target attributes either gatt or gattn.
04:03:07 SQL> 
04:03:07 SQL> -- Demo:
04:03:07 SQL> -- @score1.sql 'gatt'
04:03:07 SQL> -- @score1.sql 'gattn'
04:03:07 SQL> 
04:03:07 SQL> -- Now, I fill up svmc_apply_prep.
04:03:07 SQL> -- I use same model_name used in score.sql
04:03:07 SQL> DEFINE model_name = 'svmfx101'
04:03:07 SQL> DEFINE bldtable	= 'bme'
04:03:07 SQL> DEFINE scoretable = 'sme'
04:03:07 SQL> DEFINE case_id	= 'prdate'
04:03:07 SQL> -- Demo:
04:03:07 SQL> -- @score.sql gatt mymodel   bme	       sme	     prdate
04:03:07 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
04:03:07 SQL> --
04:03:07 SQL> -- score.sql
04:03:07 SQL> --
04:03:07 SQL> 
04:03:07 SQL> -- usage: score.sql
04:03:07 SQL> 
04:03:07 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
04:03:07 SQL> 
04:03:07 SQL> -- DEFINE target	   = 'gatt'
04:03:07 SQL> -- DEFINE model_name = 'svmfx101'
04:03:07 SQL> -- DEFINE bldtable   = 'bme'
04:03:07 SQL> -- DEFINE scoretable = 'sme'
04:03:07 SQL> -- DEFINE case_id    = 'prdate'
04:03:07 SQL> 
04:03:07 SQL> DEFINE target	= '&1'
04:03:07 SQL> DEFINE model_name = '&2'
04:03:07 SQL> DEFINE bldtable	= '&3'
04:03:07 SQL> DEFINE scoretable = '&4'
04:03:07 SQL> DEFINE case_id	= '&5'
04:03:07 SQL> 
04:03:07 SQL> -- Define a variable to help me exclude some columns from some data mining calls
04:03:07 SQL> DEFINE exclude1 = "'&target','&case_id'"
04:03:07 SQL> 
04:03:07 SQL> -- Builds an SVM model using pl/sql.
04:03:07 SQL> 
04:03:07 SQL> -----------------------------------------------------------------------
04:03:07 SQL> --			    BUILD THE MODEL
04:03:07 SQL> -----------------------------------------------------------------------
04:03:07 SQL> 
04:03:07 SQL> -- Cleanup old build data preparation objects for repeat runs
04:03:07 SQL> DELETE svmc_miss_num;

43 rows deleted.

Elapsed: 00:00:00.01
04:03:07 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
04:03:07 SQL> DELETE svmc_clip;

43 rows deleted.

Elapsed: 00:00:00.00
04:03:07 SQL> DELETE svmc_norm;

42 rows deleted.

Elapsed: 00:00:00.01
04:03:07 SQL> 
04:03:07 SQL> 
04:03:07 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
04:03:07 SQL> --
04:03:07 SQL> -- DROP	TABLE svmc_settings ;
04:03:07 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
04:03:07 SQL> -- DELETE svmc_settings;
04:03:07 SQL> 
04:03:07 SQL> -- The default classification algorithm is Naive Bayes. So override
04:03:07 SQL> -- this choice to SVM using a settings table.
04:03:07 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
04:03:07 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
04:03:07 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
04:03:07 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
04:03:07 SQL> -- models.
04:03:07 SQL> --
04:03:07 SQL> 
04:03:07 SQL> -- Do this once and then comment it out.
04:03:07 SQL> -- That makes script go faster.
04:03:07 SQL> -- BEGIN
04:03:07 SQL> -- -- Populate settings table
04:03:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:03:07 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
04:03:07 SQL> --
04:03:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:03:07 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
04:03:07 SQL> --
04:03:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
04:03:07 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
04:03:07 SQL> --   COMMIT;
04:03:07 SQL> -- END;
04:03:07 SQL> -- /
04:03:07 SQL> 
04:03:07 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
04:03:07 SQL> 
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:03:07 SQL> 
04:03:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
04:03:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
04:03:07 SQL> 
04:03:07 SQL> --------------------------------
04:03:07 SQL> -- PREPARE BUILD (TRAINING) DATA
04:03:07 SQL> --
04:03:07 SQL> 
04:03:07 SQL> -- 1. Missing Value treatment for all Predictors and
04:03:07 SQL> -- 2. Outlier Treatment and
04:03:07 SQL> -- 3. Normalization are performed below.
04:03:07 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
04:03:07 SQL> --    normalized here.
04:03:07 SQL> 
04:03:07 SQL> BEGIN
04:03:07   2  	-- Perform missing value treatment for all predictors
04:03:07   3  	-- create miss tables
04:03:07   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
04:03:07   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
04:03:07   6  
04:03:07   7  	-- populate miss tables
04:03:07   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
04:03:07   9  	  miss_table_name => 'svmc_miss_num',
04:03:07  10  	  data_table_name => '&bldtable',
04:03:07  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:03:07  12  
04:03:07  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
04:03:07  14  	  miss_table_name => 'svmc_miss_cat',
04:03:07  15  	  data_table_name => '&bldtable',
04:03:07  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:03:07  17  
04:03:07  18  	-- xform input data to replace missing values
04:03:07  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
04:03:07  20  	  miss_table_name => 'svmc_miss_num',
04:03:07  21  	  data_table_name => '&bldtable',
04:03:07  22  	  xform_view_name => 'xformed_build_miss_num');
04:03:07  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
04:03:07  24  	  miss_table_name => 'svmc_miss_cat',
04:03:07  25  	  data_table_name => '&bldtable',
04:03:07  26  	  xform_view_name => 'xformed_build_miss_cat');
04:03:07  27  
04:03:07  28  	-- Perform outlier treatment.
04:03:07  29  	-- create clip table
04:03:07  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
04:03:07  31  
04:03:07  32  	-- populate clip table
04:03:07  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
04:03:07  34  	  clip_table_name => 'svmc_clip',
04:03:07  35  	  data_table_name => '&bldtable',
04:03:07  36  	  tail_frac	  => 0.025,
04:03:07  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:03:07  38  
04:03:07  39  	-- xform input data to winsorized data
04:03:07  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
04:03:07  41  	  clip_table_name => 'svmc_clip',
04:03:07  42  	  data_table_name => '&bldtable',
04:03:07  43  	  xform_view_name => 'svmc_winsor');
04:03:07  44  
04:03:07  45  	-- create normalization table
04:03:07  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
04:03:07  47  
04:03:07  48  	-- populate normalization table based on winsorized data
04:03:07  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
04:03:07  50  	  norm_table_name => 'svmc_norm',
04:03:07  51  	  data_table_name => 'svmc_winsor',
04:03:07  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
04:03:07  53  
04:03:07  54  	-- normalize the original data
04:03:07  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
04:03:07  56  	  norm_table_name => 'svmc_norm',
04:03:07  57  	  data_table_name => '&bldtable',
04:03:07  58  	  xform_view_name => 'svmc_build_prep');
04:03:07  59  END;
04:03:07  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','prdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.54
04:03:10 SQL> 
04:03:10 SQL> ---------------------
04:03:10 SQL> -- CREATE A NEW MODEL
04:03:10 SQL> --
04:03:10 SQL> -- Cleanup old model with the same name for repeat runs
04:03:10 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
04:03:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
04:03:10   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmfx101');
