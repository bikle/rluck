
SQL*Plus: Release 11.2.0.1.0 Production on Sun Jan 9 10:24:00 2011

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

10:24:00 SQL> ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';

Session altered.

Elapsed: 00:00:00.00
10:24:00 SQL> 10:24:00 SQL> @score1_5min_gattn.sql	2010-07-15 TLT
10:24:00 SQL> --
10:24:00 SQL> -- score1_5min_gattn.sql
10:24:00 SQL> --
10:24:00 SQL> 
10:24:00 SQL> -- Demo:
10:24:00 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:00 SQL> 
10:24:00 SQL> CREATE OR REPLACE VIEW sme AS
10:24:00   2  SELECT
10:24:00   3  tkrdate
10:24:00   4  ,NULL gattn
10:24:00   5  ,g00
10:24:00   6  ,g01
10:24:00   7  ,g02
10:24:00   8  ,g03
10:24:00   9  ,g04
10:24:00  10  ,g05
10:24:00  11  ,g06
10:24:00  12  ,g07
10:24:00  13  ,g08
10:24:00  14  ,g09
10:24:00  15  ,g10
10:24:00  16  ,g11
10:24:00  17  ,g12
10:24:00  18  ,g13
10:24:00  19  ,g14
10:24:00  20  ,g15
10:24:00  21  ,g16
10:24:00  22  ,g17
10:24:00  23  ,g18
10:24:00  24  ,g19
10:24:00  25  ,g20
10:24:00  26  ,g21
10:24:00  27  ,g22
10:24:00  28  ,g23
10:24:00  29  ,g24
10:24:00  30  ,g25
10:24:00  31  ,g26
10:24:00  32  ,g27
10:24:00  33  ,g28
10:24:00  34  ,g29
10:24:00  35  FROM stk_ms
10:24:00  36  WHERE ydate = '&1'
10:24:00  37  AND tkr = '&2'
10:24:00  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-07-15'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:00 SQL> 
10:24:00 SQL> -- rpt
10:24:00 SQL> -- We should see just 1 row:
10:24:00 SQL> 
10:24:00 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:00   2  
10:24:00 SQL> -- Build the model:
10:24:00 SQL> CREATE OR REPLACE VIEW bme AS
10:24:00   2  SELECT
10:24:00   3  tkrdate
10:24:00   4  ,gattn
10:24:00   5  ,g00
10:24:00   6  ,g01
10:24:00   7  ,g02
10:24:00   8  ,g03
10:24:00   9  ,g04
10:24:00  10  ,g05
10:24:00  11  ,g06
10:24:00  12  ,g07
10:24:00  13  ,g08
10:24:00  14  ,g09
10:24:00  15  ,g10
10:24:00  16  ,g11
10:24:00  17  ,g12
10:24:00  18  ,g13
10:24:00  19  ,g14
10:24:00  20  ,g15
10:24:00  21  ,g16
10:24:00  22  ,g17
10:24:00  23  ,g18
10:24:00  24  ,g19
10:24:00  25  ,g20
10:24:00  26  ,g21
10:24:00  27  ,g22
10:24:00  28  ,g23
10:24:00  29  ,g24
10:24:00  30  ,g25
10:24:00  31  ,g26
10:24:00  32  ,g27
10:24:00  33  ,g28
10:24:00  34  ,g29
10:24:00  35  FROM stk_ms
10:24:00  36  WHERE gattn IN('nup','up')
10:24:00  37  -- Use only rows which are older than 1 day:
10:24:00  38  AND 1+ydate < '&1'
10:24:00  39  AND tkr = '&2'
10:24:00  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-07-15'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:00 SQL> 
10:24:00 SQL> -- rpt
10:24:00 SQL> 
10:24:00 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:00   2  
10:24:00 SQL> SELECT MAX(tkrdate) FROM bme
10:24:00   2  
10:24:00 SQL> -- Now build model from bme and score sme
10:24:00 SQL> @score1.sql gattn
10:24:00 SQL> -- score1.sql
10:24:00 SQL> 
10:24:00 SQL> -- I use this script to send 5 params to score.sql
10:24:00 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:00 SQL> -- Then at the very end of this script I use the model
10:24:00 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:00 SQL> 
10:24:00 SQL> -- I call this script from 2 other scripts:
10:24:00 SQL> -- score1_5min.sql
10:24:00 SQL> -- score1_5min_gattn.sql
10:24:00 SQL> 
10:24:00 SQL> -- The 1st param is the name of the target attribute.
10:24:00 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:00 SQL> 
10:24:00 SQL> -- Demo:
10:24:00 SQL> -- @score1.sql 'gatt'
10:24:00 SQL> -- @score1.sql 'gattn'
10:24:00 SQL> 
10:24:00 SQL> -- Now, I fill up svmc_apply_prep.
10:24:00 SQL> -- I use same model_name used in score.sql
10:24:00 SQL> DEFINE model_name = 'svmspy101'
10:24:00 SQL> DEFINE bldtable	= 'bme'
10:24:00 SQL> DEFINE scoretable = 'sme'
10:24:00 SQL> DEFINE case_id	= 'tkrdate'
10:24:00 SQL> -- Demo:
10:24:00 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:00 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:00 SQL> --
10:24:00 SQL> -- score.sql
10:24:00 SQL> --
10:24:00 SQL> 
10:24:00 SQL> -- usage: score.sql
10:24:00 SQL> 
10:24:00 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:00 SQL> 
10:24:00 SQL> -- DEFINE target	   = 'gatt'
10:24:00 SQL> -- DEFINE model_name = 'svmspy100'
10:24:00 SQL> -- DEFINE bldtable   = 'bme'
10:24:00 SQL> -- DEFINE scoretable = 'sme'
10:24:00 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:00 SQL> 
10:24:00 SQL> DEFINE target	= '&1'
10:24:00 SQL> DEFINE model_name = '&2'
10:24:00 SQL> DEFINE bldtable	= '&3'
10:24:00 SQL> DEFINE scoretable = '&4'
10:24:00 SQL> DEFINE case_id	= '&5'
10:24:00 SQL> 
10:24:00 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:00 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:00 SQL> 
10:24:00 SQL> -- Builds an SVM model using pl/sql.
10:24:00 SQL> 
10:24:00 SQL> -----------------------------------------------------------------------
10:24:00 SQL> --			    BUILD THE MODEL
10:24:00 SQL> -----------------------------------------------------------------------
10:24:00 SQL> 
10:24:00 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:00 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:00 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:00 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:00 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:00 SQL> 
10:24:00 SQL> 
10:24:00 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:00 SQL> --
10:24:00 SQL> -- DROP	TABLE svmc_settings ;
10:24:00 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:00 SQL> -- DELETE svmc_settings;
10:24:00 SQL> 
10:24:00 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:00 SQL> -- this choice to SVM using a settings table.
10:24:00 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:00 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:00 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:00 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:00 SQL> -- models.
10:24:00 SQL> --
10:24:00 SQL> 
10:24:00 SQL> -- Do this once and then comment it out.
10:24:00 SQL> -- That makes script go faster.
10:24:00 SQL> -- BEGIN
10:24:00 SQL> -- -- Populate settings table
10:24:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:00 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:00 SQL> --
10:24:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:00 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:00 SQL> --
10:24:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:00 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:00 SQL> --   COMMIT;
10:24:00 SQL> -- END;
10:24:00 SQL> -- /
10:24:00 SQL> 
10:24:00 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:00 SQL> 
10:24:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:00 SQL> 
10:24:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:00 SQL> 
10:24:00 SQL> --------------------------------
10:24:00 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:00 SQL> --
10:24:00 SQL> 
10:24:00 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:00 SQL> -- 2. Outlier Treatment and
10:24:00 SQL> -- 3. Normalization are performed below.
10:24:00 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:00 SQL> --    normalized here.
10:24:00 SQL> 
10:24:00 SQL> BEGIN
10:24:00   2  	-- Perform missing value treatment for all predictors
10:24:00   3  	-- create miss tables
10:24:00   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:00   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:00   6  
10:24:00   7  	-- populate miss tables
10:24:00   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:00   9  	  miss_table_name => 'svmc_miss_num',
10:24:00  10  	  data_table_name => '&bldtable',
10:24:00  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:00  12  
10:24:00  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:00  14  	  miss_table_name => 'svmc_miss_cat',
10:24:00  15  	  data_table_name => '&bldtable',
10:24:00  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:00  17  
10:24:00  18  	-- xform input data to replace missing values
10:24:00  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:00  20  	  miss_table_name => 'svmc_miss_num',
10:24:00  21  	  data_table_name => '&bldtable',
10:24:00  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:00  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:00  24  	  miss_table_name => 'svmc_miss_cat',
10:24:00  25  	  data_table_name => '&bldtable',
10:24:00  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:00  27  
10:24:00  28  	-- Perform outlier treatment.
10:24:00  29  	-- create clip table
10:24:00  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:00  31  
10:24:00  32  	-- populate clip table
10:24:00  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:00  34  	  clip_table_name => 'svmc_clip',
10:24:00  35  	  data_table_name => '&bldtable',
10:24:00  36  	  tail_frac	  => 0.025,
10:24:00  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:00  38  
10:24:00  39  	-- xform input data to winsorized data
10:24:00  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:00  41  	  clip_table_name => 'svmc_clip',
10:24:00  42  	  data_table_name => '&bldtable',
10:24:00  43  	  xform_view_name => 'svmc_winsor');
10:24:00  44  
10:24:00  45  	-- create normalization table
10:24:00  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:00  47  
10:24:00  48  	-- populate normalization table based on winsorized data
10:24:00  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:00  50  	  norm_table_name => 'svmc_norm',
10:24:00  51  	  data_table_name => 'svmc_winsor',
10:24:00  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:00  53  
10:24:00  54  	-- normalize the original data
10:24:00  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:00  56  	  norm_table_name => 'svmc_norm',
10:24:00  57  	  data_table_name => '&bldtable',
10:24:00  58  	  xform_view_name => 'svmc_build_prep');
10:24:00  59  END;
10:24:00  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.63
10:24:01 SQL> 
10:24:01 SQL> ---------------------
10:24:01 SQL> -- CREATE A NEW MODEL
10:24:01 SQL> --
10:24:01 SQL> -- Cleanup old model with the same name for repeat runs
10:24:01 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:01   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.00
10:24:02 SQL> 
10:24:02 SQL> -- Build a new SVM Model
10:24:02 SQL> BEGIN
10:24:02   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:02   3  	  model_name	      => '&model_name',
10:24:02   4  	  mining_function     => dbms_data_mining.classification,
10:24:02   5  	  data_table_name     => 'svmc_build_prep',
10:24:02   6  	  case_id_column_name => '&case_id',
10:24:02   7  	  target_column_name  => '&target',
10:24:02   8  	  settings_table_name => 'svmc_settings');
10:24:02   9  END;
10:24:02  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.35
10:24:04 SQL> 
10:24:04 SQL> -----------------------------------------------------------------------
10:24:04 SQL> --			       APPLY/score THE MODEL
10:24:04 SQL> -----------------------------------------------------------------------
10:24:04 SQL> 
10:24:04 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.42
10:24:04 SQL> -----------------------
10:24:04 SQL> -- PREPARE SCORING DATA
10:24:04 SQL> --
10:24:04 SQL> -- If the data for model creation has been prepared, then the data
10:24:04 SQL> -- to be scored using the model must be prepared in the same manner
10:24:04 SQL> -- in order to obtain meaningful results.
10:24:04 SQL> --
10:24:04 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:04 SQL> -- 2. Normalization
10:24:04 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:04 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:04 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:04 SQL> --
10:24:04 SQL> BEGIN
10:24:04   2  	-- Xform Test data to replace missing values
10:24:04   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:04   4  	  miss_table_name => 'svmc_miss_num',
10:24:04   5  	  data_table_name => '&scoretable',
10:24:04   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:04   7  
10:24:04   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:04   9  	  miss_table_name => 'svmc_miss_cat',
10:24:04  10  	  data_table_name => '&scoretable',
10:24:04  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:04  12  
10:24:04  13  	-- Normalize the data to be scored
10:24:04  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:04  15  	  norm_table_name => 'svmc_norm',
10:24:04  16  	  data_table_name => '&scoretable',
10:24:04  17  	  xform_view_name => 'svmc_apply_prep');
10:24:04  18  END;
10:24:04  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:05 SQL> 
10:24:05 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:05 SQL> -- DELETE it if I did:
10:24:05 SQL> DELETE ystkscores
10:24:05   2  WHERE score > 0
10:24:05   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:05   4  -- I need to supply the target attribute name:
10:24:05   5  AND targ = '&1'
10:24:05   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:24:05 SQL> 
10:24:05 SQL> -- We do a drumroll here:
10:24:05 SQL> 
10:24:05 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:05   2  SELECT
10:24:05   3  tkrdate
10:24:05   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:05   5  ,sysdate
10:24:05   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:05   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:05   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:05   9  ,SUBSTR(tkrdate,-10)ydate
10:24:05  10  ,'&1'
10:24:05  11  FROM svmc_apply_prep
10:24:05  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:24:05 SQL> @score1_5min_gattn.sql	2010-11-03 TLT
10:24:05 SQL> --
10:24:05 SQL> -- score1_5min_gattn.sql
10:24:05 SQL> --
10:24:05 SQL> 
10:24:05 SQL> -- Demo:
10:24:05 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:05 SQL> 
10:24:05 SQL> CREATE OR REPLACE VIEW sme AS
10:24:05   2  SELECT
10:24:05   3  tkrdate
10:24:05   4  ,NULL gattn
10:24:05   5  ,g00
10:24:05   6  ,g01
10:24:05   7  ,g02
10:24:05   8  ,g03
10:24:05   9  ,g04
10:24:05  10  ,g05
10:24:05  11  ,g06
10:24:05  12  ,g07
10:24:05  13  ,g08
10:24:05  14  ,g09
10:24:05  15  ,g10
10:24:05  16  ,g11
10:24:05  17  ,g12
10:24:05  18  ,g13
10:24:05  19  ,g14
10:24:05  20  ,g15
10:24:05  21  ,g16
10:24:05  22  ,g17
10:24:05  23  ,g18
10:24:05  24  ,g19
10:24:05  25  ,g20
10:24:05  26  ,g21
10:24:05  27  ,g22
10:24:05  28  ,g23
10:24:05  29  ,g24
10:24:05  30  ,g25
10:24:05  31  ,g26
10:24:05  32  ,g27
10:24:05  33  ,g28
10:24:05  34  ,g29
10:24:05  35  FROM stk_ms
10:24:05  36  WHERE ydate = '&1'
10:24:05  37  AND tkr = '&2'
10:24:05  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-03'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.02
10:24:05 SQL> 
10:24:05 SQL> -- rpt
10:24:05 SQL> -- We should see just 1 row:
10:24:05 SQL> 
10:24:05 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:05   2  
10:24:05 SQL> -- Build the model:
10:24:05 SQL> CREATE OR REPLACE VIEW bme AS
10:24:05   2  SELECT
10:24:05   3  tkrdate
10:24:05   4  ,gattn
10:24:05   5  ,g00
10:24:05   6  ,g01
10:24:05   7  ,g02
10:24:05   8  ,g03
10:24:05   9  ,g04
10:24:05  10  ,g05
10:24:05  11  ,g06
10:24:05  12  ,g07
10:24:05  13  ,g08
10:24:05  14  ,g09
10:24:05  15  ,g10
10:24:05  16  ,g11
10:24:05  17  ,g12
10:24:05  18  ,g13
10:24:05  19  ,g14
10:24:05  20  ,g15
10:24:05  21  ,g16
10:24:05  22  ,g17
10:24:05  23  ,g18
10:24:05  24  ,g19
10:24:05  25  ,g20
10:24:05  26  ,g21
10:24:05  27  ,g22
10:24:05  28  ,g23
10:24:05  29  ,g24
10:24:05  30  ,g25
10:24:05  31  ,g26
10:24:05  32  ,g27
10:24:05  33  ,g28
10:24:05  34  ,g29
10:24:05  35  FROM stk_ms
10:24:05  36  WHERE gattn IN('nup','up')
10:24:05  37  -- Use only rows which are older than 1 day:
10:24:05  38  AND 1+ydate < '&1'
10:24:05  39  AND tkr = '&2'
10:24:05  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-03'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:05 SQL> 
10:24:05 SQL> -- rpt
10:24:05 SQL> 
10:24:05 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:05   2  
10:24:05 SQL> SELECT MAX(tkrdate) FROM bme
10:24:05   2  
10:24:05 SQL> -- Now build model from bme and score sme
10:24:05 SQL> @score1.sql gattn
10:24:05 SQL> -- score1.sql
10:24:05 SQL> 
10:24:05 SQL> -- I use this script to send 5 params to score.sql
10:24:05 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:05 SQL> -- Then at the very end of this script I use the model
10:24:05 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:05 SQL> 
10:24:05 SQL> -- I call this script from 2 other scripts:
10:24:05 SQL> -- score1_5min.sql
10:24:05 SQL> -- score1_5min_gattn.sql
10:24:05 SQL> 
10:24:05 SQL> -- The 1st param is the name of the target attribute.
10:24:05 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:05 SQL> 
10:24:05 SQL> -- Demo:
10:24:05 SQL> -- @score1.sql 'gatt'
10:24:05 SQL> -- @score1.sql 'gattn'
10:24:05 SQL> 
10:24:05 SQL> -- Now, I fill up svmc_apply_prep.
10:24:05 SQL> -- I use same model_name used in score.sql
10:24:05 SQL> DEFINE model_name = 'svmspy101'
10:24:05 SQL> DEFINE bldtable	= 'bme'
10:24:05 SQL> DEFINE scoretable = 'sme'
10:24:05 SQL> DEFINE case_id	= 'tkrdate'
10:24:05 SQL> -- Demo:
10:24:05 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:05 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:05 SQL> --
10:24:05 SQL> -- score.sql
10:24:05 SQL> --
10:24:05 SQL> 
10:24:05 SQL> -- usage: score.sql
10:24:05 SQL> 
10:24:05 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:05 SQL> 
10:24:05 SQL> -- DEFINE target	   = 'gatt'
10:24:05 SQL> -- DEFINE model_name = 'svmspy100'
10:24:05 SQL> -- DEFINE bldtable   = 'bme'
10:24:05 SQL> -- DEFINE scoretable = 'sme'
10:24:05 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:05 SQL> 
10:24:05 SQL> DEFINE target	= '&1'
10:24:05 SQL> DEFINE model_name = '&2'
10:24:05 SQL> DEFINE bldtable	= '&3'
10:24:05 SQL> DEFINE scoretable = '&4'
10:24:05 SQL> DEFINE case_id	= '&5'
10:24:05 SQL> 
10:24:05 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:05 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:05 SQL> 
10:24:05 SQL> -- Builds an SVM model using pl/sql.
10:24:05 SQL> 
10:24:05 SQL> -----------------------------------------------------------------------
10:24:05 SQL> --			    BUILD THE MODEL
10:24:05 SQL> -----------------------------------------------------------------------
10:24:05 SQL> 
10:24:05 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:05 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:05 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:05 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:05 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:24:05 SQL> 
10:24:05 SQL> 
10:24:05 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:05 SQL> --
10:24:05 SQL> -- DROP	TABLE svmc_settings ;
10:24:05 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:05 SQL> -- DELETE svmc_settings;
10:24:05 SQL> 
10:24:05 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:05 SQL> -- this choice to SVM using a settings table.
10:24:05 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:05 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:05 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:05 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:05 SQL> -- models.
10:24:05 SQL> --
10:24:05 SQL> 
10:24:05 SQL> -- Do this once and then comment it out.
10:24:05 SQL> -- That makes script go faster.
10:24:05 SQL> -- BEGIN
10:24:05 SQL> -- -- Populate settings table
10:24:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:05 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:05 SQL> --
10:24:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:05 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:05 SQL> --
10:24:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:05 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:05 SQL> --   COMMIT;
10:24:05 SQL> -- END;
10:24:05 SQL> -- /
10:24:05 SQL> 
10:24:05 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:05 SQL> 
10:24:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:24:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:05 SQL> 
10:24:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:05 SQL> 
10:24:05 SQL> --------------------------------
10:24:05 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:05 SQL> --
10:24:05 SQL> 
10:24:05 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:05 SQL> -- 2. Outlier Treatment and
10:24:05 SQL> -- 3. Normalization are performed below.
10:24:05 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:05 SQL> --    normalized here.
10:24:05 SQL> 
10:24:05 SQL> BEGIN
10:24:05   2  	-- Perform missing value treatment for all predictors
10:24:05   3  	-- create miss tables
10:24:05   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:05   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:05   6  
10:24:05   7  	-- populate miss tables
10:24:05   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:05   9  	  miss_table_name => 'svmc_miss_num',
10:24:05  10  	  data_table_name => '&bldtable',
10:24:05  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:05  12  
10:24:05  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:05  14  	  miss_table_name => 'svmc_miss_cat',
10:24:05  15  	  data_table_name => '&bldtable',
10:24:05  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:05  17  
10:24:05  18  	-- xform input data to replace missing values
10:24:05  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:05  20  	  miss_table_name => 'svmc_miss_num',
10:24:05  21  	  data_table_name => '&bldtable',
10:24:05  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:05  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:05  24  	  miss_table_name => 'svmc_miss_cat',
10:24:05  25  	  data_table_name => '&bldtable',
10:24:05  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:05  27  
10:24:05  28  	-- Perform outlier treatment.
10:24:05  29  	-- create clip table
10:24:05  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:05  31  
10:24:05  32  	-- populate clip table
10:24:05  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:05  34  	  clip_table_name => 'svmc_clip',
10:24:05  35  	  data_table_name => '&bldtable',
10:24:05  36  	  tail_frac	  => 0.025,
10:24:05  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:05  38  
10:24:05  39  	-- xform input data to winsorized data
10:24:05  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:05  41  	  clip_table_name => 'svmc_clip',
10:24:05  42  	  data_table_name => '&bldtable',
10:24:05  43  	  xform_view_name => 'svmc_winsor');
10:24:05  44  
10:24:05  45  	-- create normalization table
10:24:05  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:05  47  
10:24:05  48  	-- populate normalization table based on winsorized data
10:24:05  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:05  50  	  norm_table_name => 'svmc_norm',
10:24:05  51  	  data_table_name => 'svmc_winsor',
10:24:05  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:05  53  
10:24:05  54  	-- normalize the original data
10:24:05  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:05  56  	  norm_table_name => 'svmc_norm',
10:24:05  57  	  data_table_name => '&bldtable',
10:24:05  58  	  xform_view_name => 'svmc_build_prep');
10:24:05  59  END;
10:24:05  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:24:06 SQL> 
10:24:06 SQL> ---------------------
10:24:06 SQL> -- CREATE A NEW MODEL
10:24:06 SQL> --
10:24:06 SQL> -- Cleanup old model with the same name for repeat runs
10:24:06 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:06   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.98
10:24:07 SQL> 
10:24:07 SQL> -- Build a new SVM Model
10:24:07 SQL> BEGIN
10:24:07   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:07   3  	  model_name	      => '&model_name',
10:24:07   4  	  mining_function     => dbms_data_mining.classification,
10:24:07   5  	  data_table_name     => 'svmc_build_prep',
10:24:07   6  	  case_id_column_name => '&case_id',
10:24:07   7  	  target_column_name  => '&target',
10:24:07   8  	  settings_table_name => 'svmc_settings');
10:24:07   9  END;
10:24:07  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.06
10:24:09 SQL> 
10:24:09 SQL> -----------------------------------------------------------------------
10:24:09 SQL> --			       APPLY/score THE MODEL
10:24:09 SQL> -----------------------------------------------------------------------
10:24:09 SQL> 
10:24:09 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:09 SQL> -----------------------
10:24:09 SQL> -- PREPARE SCORING DATA
10:24:09 SQL> --
10:24:09 SQL> -- If the data for model creation has been prepared, then the data
10:24:09 SQL> -- to be scored using the model must be prepared in the same manner
10:24:09 SQL> -- in order to obtain meaningful results.
10:24:09 SQL> --
10:24:09 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:09 SQL> -- 2. Normalization
10:24:09 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:09 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:09 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:09 SQL> --
10:24:09 SQL> BEGIN
10:24:09   2  	-- Xform Test data to replace missing values
10:24:09   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:09   4  	  miss_table_name => 'svmc_miss_num',
10:24:09   5  	  data_table_name => '&scoretable',
10:24:09   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:09   7  
10:24:09   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:09   9  	  miss_table_name => 'svmc_miss_cat',
10:24:09  10  	  data_table_name => '&scoretable',
10:24:09  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:09  12  
10:24:09  13  	-- Normalize the data to be scored
10:24:09  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:09  15  	  norm_table_name => 'svmc_norm',
10:24:09  16  	  data_table_name => '&scoretable',
10:24:09  17  	  xform_view_name => 'svmc_apply_prep');
10:24:09  18  END;
10:24:09  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:24:09 SQL> 
10:24:09 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:09 SQL> -- DELETE it if I did:
10:24:09 SQL> DELETE ystkscores
10:24:09   2  WHERE score > 0
10:24:09   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:09   4  -- I need to supply the target attribute name:
10:24:09   5  AND targ = '&1'
10:24:09   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:09 SQL> 
10:24:09 SQL> -- We do a drumroll here:
10:24:09 SQL> 
10:24:09 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:09   2  SELECT
10:24:09   3  tkrdate
10:24:09   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:09   5  ,sysdate
10:24:09   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:09   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:09   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:09   9  ,SUBSTR(tkrdate,-10)ydate
10:24:09  10  ,'&1'
10:24:09  11  FROM svmc_apply_prep
10:24:09  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:24:09 SQL> @score1_5min.sql	      2010-09-17 TLT
10:24:09 SQL> --
10:24:09 SQL> -- score1_5min.sql
10:24:09 SQL> --
10:24:09 SQL> 
10:24:09 SQL> -- Demo:
10:24:09 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:24:09 SQL> 
10:24:09 SQL> CREATE OR REPLACE VIEW sme AS
10:24:09   2  SELECT
10:24:09   3  tkrdate
10:24:09   4  ,NULL gatt
10:24:09   5  ,g00
10:24:09   6  ,g01
10:24:09   7  ,g02
10:24:09   8  ,g03
10:24:09   9  ,g04
10:24:09  10  ,g05
10:24:09  11  ,g06
10:24:09  12  ,g07
10:24:09  13  ,g08
10:24:09  14  ,g09
10:24:09  15  ,g10
10:24:09  16  ,g11
10:24:09  17  ,g12
10:24:09  18  ,g13
10:24:09  19  ,g14
10:24:09  20  ,g15
10:24:09  21  ,g16
10:24:09  22  ,g17
10:24:09  23  ,g18
10:24:09  24  ,g19
10:24:09  25  ,g20
10:24:09  26  ,g21
10:24:09  27  ,g22
10:24:09  28  ,g23
10:24:09  29  ,g24
10:24:09  30  ,g25
10:24:09  31  ,g26
10:24:09  32  ,g27
10:24:09  33  ,g28
10:24:09  34  ,g29
10:24:09  35  FROM stk_ms
10:24:09  36  WHERE ydate = '&1'
10:24:09  37  AND tkr = '&2'
10:24:09  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-09-17'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:24:09 SQL> 
10:24:09 SQL> -- rpt
10:24:09 SQL> -- We should see just 1 row:
10:24:09 SQL> 
10:24:09 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:09   2  
10:24:09 SQL> -- Build the model:
10:24:09 SQL> CREATE OR REPLACE VIEW bme AS
10:24:09   2  SELECT
10:24:09   3  tkrdate
10:24:09   4  ,gatt
10:24:09   5  ,g00
10:24:09   6  ,g01
10:24:09   7  ,g02
10:24:09   8  ,g03
10:24:09   9  ,g04
10:24:09  10  ,g05
10:24:09  11  ,g06
10:24:09  12  ,g07
10:24:09  13  ,g08
10:24:09  14  ,g09
10:24:09  15  ,g10
10:24:09  16  ,g11
10:24:09  17  ,g12
10:24:09  18  ,g13
10:24:09  19  ,g14
10:24:09  20  ,g15
10:24:09  21  ,g16
10:24:09  22  ,g17
10:24:09  23  ,g18
10:24:09  24  ,g19
10:24:09  25  ,g20
10:24:09  26  ,g21
10:24:09  27  ,g22
10:24:09  28  ,g23
10:24:09  29  ,g24
10:24:09  30  ,g25
10:24:09  31  ,g26
10:24:09  32  ,g27
10:24:09  33  ,g28
10:24:09  34  ,g29
10:24:09  35  FROM stk_ms
10:24:09  36  WHERE gatt IN('nup','up')
10:24:09  37  -- Use only rows which are older than 1 day:
10:24:09  38  AND 1+ydate < '&1'
10:24:09  39  AND tkr = '&2'
10:24:09  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-09-17'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:09 SQL> 
10:24:09 SQL> -- rpt
10:24:09 SQL> 
10:24:09 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:24:09   2  
10:24:09 SQL> SELECT MAX(tkrdate) FROM bme
10:24:09   2  
10:24:09 SQL> -- Now build model from bme and score sme
10:24:09 SQL> @score1.sql gatt
10:24:09 SQL> -- score1.sql
10:24:09 SQL> 
10:24:09 SQL> -- I use this script to send 5 params to score.sql
10:24:09 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:09 SQL> -- Then at the very end of this script I use the model
10:24:09 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:09 SQL> 
10:24:09 SQL> -- I call this script from 2 other scripts:
10:24:09 SQL> -- score1_5min.sql
10:24:09 SQL> -- score1_5min_gattn.sql
10:24:09 SQL> 
10:24:09 SQL> -- The 1st param is the name of the target attribute.
10:24:09 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:09 SQL> 
10:24:09 SQL> -- Demo:
10:24:09 SQL> -- @score1.sql 'gatt'
10:24:09 SQL> -- @score1.sql 'gattn'
10:24:09 SQL> 
10:24:09 SQL> -- Now, I fill up svmc_apply_prep.
10:24:09 SQL> -- I use same model_name used in score.sql
10:24:09 SQL> DEFINE model_name = 'svmspy101'
10:24:09 SQL> DEFINE bldtable	= 'bme'
10:24:09 SQL> DEFINE scoretable = 'sme'
10:24:09 SQL> DEFINE case_id	= 'tkrdate'
10:24:09 SQL> -- Demo:
10:24:09 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:09 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:09 SQL> --
10:24:09 SQL> -- score.sql
10:24:09 SQL> --
10:24:09 SQL> 
10:24:09 SQL> -- usage: score.sql
10:24:09 SQL> 
10:24:09 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:09 SQL> 
10:24:09 SQL> -- DEFINE target	   = 'gatt'
10:24:09 SQL> -- DEFINE model_name = 'svmspy100'
10:24:09 SQL> -- DEFINE bldtable   = 'bme'
10:24:09 SQL> -- DEFINE scoretable = 'sme'
10:24:09 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:09 SQL> 
10:24:09 SQL> DEFINE target	= '&1'
10:24:09 SQL> DEFINE model_name = '&2'
10:24:09 SQL> DEFINE bldtable	= '&3'
10:24:09 SQL> DEFINE scoretable = '&4'
10:24:09 SQL> DEFINE case_id	= '&5'
10:24:09 SQL> 
10:24:09 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:09 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:09 SQL> 
10:24:09 SQL> -- Builds an SVM model using pl/sql.
10:24:09 SQL> 
10:24:09 SQL> -----------------------------------------------------------------------
10:24:09 SQL> --			    BUILD THE MODEL
10:24:09 SQL> -----------------------------------------------------------------------
10:24:09 SQL> 
10:24:09 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:09 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:09 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:09 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:09 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:09 SQL> 
10:24:09 SQL> 
10:24:09 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:09 SQL> --
10:24:09 SQL> -- DROP	TABLE svmc_settings ;
10:24:09 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:09 SQL> -- DELETE svmc_settings;
10:24:09 SQL> 
10:24:09 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:09 SQL> -- this choice to SVM using a settings table.
10:24:09 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:09 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:09 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:09 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:09 SQL> -- models.
10:24:09 SQL> --
10:24:09 SQL> 
10:24:09 SQL> -- Do this once and then comment it out.
10:24:09 SQL> -- That makes script go faster.
10:24:09 SQL> -- BEGIN
10:24:09 SQL> -- -- Populate settings table
10:24:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:09 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:09 SQL> --
10:24:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:09 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:09 SQL> --
10:24:09 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:09 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:09 SQL> --   COMMIT;
10:24:09 SQL> -- END;
10:24:09 SQL> -- /
10:24:09 SQL> 
10:24:09 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:09 SQL> 
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:09 SQL> 
10:24:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:09 SQL> 
10:24:09 SQL> --------------------------------
10:24:09 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:09 SQL> --
10:24:09 SQL> 
10:24:09 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:09 SQL> -- 2. Outlier Treatment and
10:24:09 SQL> -- 3. Normalization are performed below.
10:24:09 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:09 SQL> --    normalized here.
10:24:09 SQL> 
10:24:09 SQL> BEGIN
10:24:09   2  	-- Perform missing value treatment for all predictors
10:24:09   3  	-- create miss tables
10:24:09   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:09   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:09   6  
10:24:09   7  	-- populate miss tables
10:24:09   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:09   9  	  miss_table_name => 'svmc_miss_num',
10:24:09  10  	  data_table_name => '&bldtable',
10:24:09  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:09  12  
10:24:09  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:09  14  	  miss_table_name => 'svmc_miss_cat',
10:24:09  15  	  data_table_name => '&bldtable',
10:24:09  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:09  17  
10:24:09  18  	-- xform input data to replace missing values
10:24:09  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:09  20  	  miss_table_name => 'svmc_miss_num',
10:24:09  21  	  data_table_name => '&bldtable',
10:24:09  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:09  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:09  24  	  miss_table_name => 'svmc_miss_cat',
10:24:09  25  	  data_table_name => '&bldtable',
10:24:09  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:09  27  
10:24:09  28  	-- Perform outlier treatment.
10:24:09  29  	-- create clip table
10:24:09  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:09  31  
10:24:09  32  	-- populate clip table
10:24:09  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:09  34  	  clip_table_name => 'svmc_clip',
10:24:09  35  	  data_table_name => '&bldtable',
10:24:09  36  	  tail_frac	  => 0.025,
10:24:09  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:09  38  
10:24:09  39  	-- xform input data to winsorized data
10:24:09  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:09  41  	  clip_table_name => 'svmc_clip',
10:24:09  42  	  data_table_name => '&bldtable',
10:24:09  43  	  xform_view_name => 'svmc_winsor');
10:24:09  44  
10:24:09  45  	-- create normalization table
10:24:09  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:09  47  
10:24:09  48  	-- populate normalization table based on winsorized data
10:24:09  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:09  50  	  norm_table_name => 'svmc_norm',
10:24:09  51  	  data_table_name => 'svmc_winsor',
10:24:09  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:09  53  
10:24:09  54  	-- normalize the original data
10:24:09  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:09  56  	  norm_table_name => 'svmc_norm',
10:24:09  57  	  data_table_name => '&bldtable',
10:24:09  58  	  xform_view_name => 'svmc_build_prep');
10:24:09  59  END;
10:24:09  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.65
10:24:10 SQL> 
10:24:10 SQL> ---------------------
10:24:10 SQL> -- CREATE A NEW MODEL
10:24:10 SQL> --
10:24:10 SQL> -- Cleanup old model with the same name for repeat runs
10:24:10 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:10   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.39
10:24:11 SQL> 
10:24:11 SQL> -- Build a new SVM Model
10:24:11 SQL> BEGIN
10:24:11   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:11   3  	  model_name	      => '&model_name',
10:24:11   4  	  mining_function     => dbms_data_mining.classification,
10:24:11   5  	  data_table_name     => 'svmc_build_prep',
10:24:11   6  	  case_id_column_name => '&case_id',
10:24:11   7  	  target_column_name  => '&target',
10:24:11   8  	  settings_table_name => 'svmc_settings');
10:24:11   9  END;
10:24:11  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.85
10:24:13 SQL> 
10:24:13 SQL> -----------------------------------------------------------------------
10:24:13 SQL> --			       APPLY/score THE MODEL
10:24:13 SQL> -----------------------------------------------------------------------
10:24:13 SQL> 
10:24:13 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:13 SQL> -----------------------
10:24:13 SQL> -- PREPARE SCORING DATA
10:24:13 SQL> --
10:24:13 SQL> -- If the data for model creation has been prepared, then the data
10:24:13 SQL> -- to be scored using the model must be prepared in the same manner
10:24:13 SQL> -- in order to obtain meaningful results.
10:24:13 SQL> --
10:24:13 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:13 SQL> -- 2. Normalization
10:24:13 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:13 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:13 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:13 SQL> --
10:24:13 SQL> BEGIN
10:24:13   2  	-- Xform Test data to replace missing values
10:24:13   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:13   4  	  miss_table_name => 'svmc_miss_num',
10:24:13   5  	  data_table_name => '&scoretable',
10:24:13   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:13   7  
10:24:13   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:13   9  	  miss_table_name => 'svmc_miss_cat',
10:24:13  10  	  data_table_name => '&scoretable',
10:24:13  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:13  12  
10:24:13  13  	-- Normalize the data to be scored
10:24:13  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:13  15  	  norm_table_name => 'svmc_norm',
10:24:13  16  	  data_table_name => '&scoretable',
10:24:13  17  	  xform_view_name => 'svmc_apply_prep');
10:24:13  18  END;
10:24:13  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:24:13 SQL> 
10:24:13 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:13 SQL> -- DELETE it if I did:
10:24:13 SQL> DELETE ystkscores
10:24:13   2  WHERE score > 0
10:24:13   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:13   4  -- I need to supply the target attribute name:
10:24:13   5  AND targ = '&1'
10:24:13   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:13 SQL> 
10:24:13 SQL> -- We do a drumroll here:
10:24:13 SQL> 
10:24:13 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:13   2  SELECT
10:24:13   3  tkrdate
10:24:13   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:13   5  ,sysdate
10:24:13   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:13   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:13   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:13   9  ,SUBSTR(tkrdate,-10)ydate
10:24:13  10  ,'&1'
10:24:13  11  FROM svmc_apply_prep
10:24:13  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:24:14 SQL> @score1_5min_gattn.sql	2010-01-22 TLT
10:24:14 SQL> --
10:24:14 SQL> -- score1_5min_gattn.sql
10:24:14 SQL> --
10:24:14 SQL> 
10:24:14 SQL> -- Demo:
10:24:14 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:14 SQL> 
10:24:14 SQL> CREATE OR REPLACE VIEW sme AS
10:24:14   2  SELECT
10:24:14   3  tkrdate
10:24:14   4  ,NULL gattn
10:24:14   5  ,g00
10:24:14   6  ,g01
10:24:14   7  ,g02
10:24:14   8  ,g03
10:24:14   9  ,g04
10:24:14  10  ,g05
10:24:14  11  ,g06
10:24:14  12  ,g07
10:24:14  13  ,g08
10:24:14  14  ,g09
10:24:14  15  ,g10
10:24:14  16  ,g11
10:24:14  17  ,g12
10:24:14  18  ,g13
10:24:14  19  ,g14
10:24:14  20  ,g15
10:24:14  21  ,g16
10:24:14  22  ,g17
10:24:14  23  ,g18
10:24:14  24  ,g19
10:24:14  25  ,g20
10:24:14  26  ,g21
10:24:14  27  ,g22
10:24:14  28  ,g23
10:24:14  29  ,g24
10:24:14  30  ,g25
10:24:14  31  ,g26
10:24:14  32  ,g27
10:24:14  33  ,g28
10:24:14  34  ,g29
10:24:14  35  FROM stk_ms
10:24:14  36  WHERE ydate = '&1'
10:24:14  37  AND tkr = '&2'
10:24:14  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-22'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:14 SQL> 
10:24:14 SQL> -- rpt
10:24:14 SQL> -- We should see just 1 row:
10:24:14 SQL> 
10:24:14 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:14   2  
10:24:14 SQL> -- Build the model:
10:24:14 SQL> CREATE OR REPLACE VIEW bme AS
10:24:14   2  SELECT
10:24:14   3  tkrdate
10:24:14   4  ,gattn
10:24:14   5  ,g00
10:24:14   6  ,g01
10:24:14   7  ,g02
10:24:14   8  ,g03
10:24:14   9  ,g04
10:24:14  10  ,g05
10:24:14  11  ,g06
10:24:14  12  ,g07
10:24:14  13  ,g08
10:24:14  14  ,g09
10:24:14  15  ,g10
10:24:14  16  ,g11
10:24:14  17  ,g12
10:24:14  18  ,g13
10:24:14  19  ,g14
10:24:14  20  ,g15
10:24:14  21  ,g16
10:24:14  22  ,g17
10:24:14  23  ,g18
10:24:14  24  ,g19
10:24:14  25  ,g20
10:24:14  26  ,g21
10:24:14  27  ,g22
10:24:14  28  ,g23
10:24:14  29  ,g24
10:24:14  30  ,g25
10:24:14  31  ,g26
10:24:14  32  ,g27
10:24:14  33  ,g28
10:24:14  34  ,g29
10:24:14  35  FROM stk_ms
10:24:14  36  WHERE gattn IN('nup','up')
10:24:14  37  -- Use only rows which are older than 1 day:
10:24:14  38  AND 1+ydate < '&1'
10:24:14  39  AND tkr = '&2'
10:24:14  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-22'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:14 SQL> 
10:24:14 SQL> -- rpt
10:24:14 SQL> 
10:24:14 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:14   2  
10:24:14 SQL> SELECT MAX(tkrdate) FROM bme
10:24:14   2  
10:24:14 SQL> -- Now build model from bme and score sme
10:24:14 SQL> @score1.sql gattn
10:24:14 SQL> -- score1.sql
10:24:14 SQL> 
10:24:14 SQL> -- I use this script to send 5 params to score.sql
10:24:14 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:14 SQL> -- Then at the very end of this script I use the model
10:24:14 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:14 SQL> 
10:24:14 SQL> -- I call this script from 2 other scripts:
10:24:14 SQL> -- score1_5min.sql
10:24:14 SQL> -- score1_5min_gattn.sql
10:24:14 SQL> 
10:24:14 SQL> -- The 1st param is the name of the target attribute.
10:24:14 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:14 SQL> 
10:24:14 SQL> -- Demo:
10:24:14 SQL> -- @score1.sql 'gatt'
10:24:14 SQL> -- @score1.sql 'gattn'
10:24:14 SQL> 
10:24:14 SQL> -- Now, I fill up svmc_apply_prep.
10:24:14 SQL> -- I use same model_name used in score.sql
10:24:14 SQL> DEFINE model_name = 'svmspy101'
10:24:14 SQL> DEFINE bldtable	= 'bme'
10:24:14 SQL> DEFINE scoretable = 'sme'
10:24:14 SQL> DEFINE case_id	= 'tkrdate'
10:24:14 SQL> -- Demo:
10:24:14 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:14 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:14 SQL> --
10:24:14 SQL> -- score.sql
10:24:14 SQL> --
10:24:14 SQL> 
10:24:14 SQL> -- usage: score.sql
10:24:14 SQL> 
10:24:14 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:14 SQL> 
10:24:14 SQL> -- DEFINE target	   = 'gatt'
10:24:14 SQL> -- DEFINE model_name = 'svmspy100'
10:24:14 SQL> -- DEFINE bldtable   = 'bme'
10:24:14 SQL> -- DEFINE scoretable = 'sme'
10:24:14 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:14 SQL> 
10:24:14 SQL> DEFINE target	= '&1'
10:24:14 SQL> DEFINE model_name = '&2'
10:24:14 SQL> DEFINE bldtable	= '&3'
10:24:14 SQL> DEFINE scoretable = '&4'
10:24:14 SQL> DEFINE case_id	= '&5'
10:24:14 SQL> 
10:24:14 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:14 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:14 SQL> 
10:24:14 SQL> -- Builds an SVM model using pl/sql.
10:24:14 SQL> 
10:24:14 SQL> -----------------------------------------------------------------------
10:24:14 SQL> --			    BUILD THE MODEL
10:24:14 SQL> -----------------------------------------------------------------------
10:24:14 SQL> 
10:24:14 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:14 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:24:14 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:14 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:14 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:14 SQL> 
10:24:14 SQL> 
10:24:14 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:14 SQL> --
10:24:14 SQL> -- DROP	TABLE svmc_settings ;
10:24:14 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:14 SQL> -- DELETE svmc_settings;
10:24:14 SQL> 
10:24:14 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:14 SQL> -- this choice to SVM using a settings table.
10:24:14 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:14 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:14 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:14 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:14 SQL> -- models.
10:24:14 SQL> --
10:24:14 SQL> 
10:24:14 SQL> -- Do this once and then comment it out.
10:24:14 SQL> -- That makes script go faster.
10:24:14 SQL> -- BEGIN
10:24:14 SQL> -- -- Populate settings table
10:24:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:14 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:14 SQL> --
10:24:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:14 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:14 SQL> --
10:24:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:14 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:14 SQL> --   COMMIT;
10:24:14 SQL> -- END;
10:24:14 SQL> -- /
10:24:14 SQL> 
10:24:14 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:14 SQL> 
10:24:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:14 SQL> 
10:24:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:14 SQL> 
10:24:14 SQL> --------------------------------
10:24:14 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:14 SQL> --
10:24:14 SQL> 
10:24:14 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:14 SQL> -- 2. Outlier Treatment and
10:24:14 SQL> -- 3. Normalization are performed below.
10:24:14 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:14 SQL> --    normalized here.
10:24:14 SQL> 
10:24:14 SQL> BEGIN
10:24:14   2  	-- Perform missing value treatment for all predictors
10:24:14   3  	-- create miss tables
10:24:14   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:14   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:14   6  
10:24:14   7  	-- populate miss tables
10:24:14   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:14   9  	  miss_table_name => 'svmc_miss_num',
10:24:14  10  	  data_table_name => '&bldtable',
10:24:14  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:14  12  
10:24:14  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:14  14  	  miss_table_name => 'svmc_miss_cat',
10:24:14  15  	  data_table_name => '&bldtable',
10:24:14  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:14  17  
10:24:14  18  	-- xform input data to replace missing values
10:24:14  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:14  20  	  miss_table_name => 'svmc_miss_num',
10:24:14  21  	  data_table_name => '&bldtable',
10:24:14  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:14  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:14  24  	  miss_table_name => 'svmc_miss_cat',
10:24:14  25  	  data_table_name => '&bldtable',
10:24:14  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:14  27  
10:24:14  28  	-- Perform outlier treatment.
10:24:14  29  	-- create clip table
10:24:14  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:14  31  
10:24:14  32  	-- populate clip table
10:24:14  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:14  34  	  clip_table_name => 'svmc_clip',
10:24:14  35  	  data_table_name => '&bldtable',
10:24:14  36  	  tail_frac	  => 0.025,
10:24:14  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:14  38  
10:24:14  39  	-- xform input data to winsorized data
10:24:14  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:14  41  	  clip_table_name => 'svmc_clip',
10:24:14  42  	  data_table_name => '&bldtable',
10:24:14  43  	  xform_view_name => 'svmc_winsor');
10:24:14  44  
10:24:14  45  	-- create normalization table
10:24:14  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:14  47  
10:24:14  48  	-- populate normalization table based on winsorized data
10:24:14  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:14  50  	  norm_table_name => 'svmc_norm',
10:24:14  51  	  data_table_name => 'svmc_winsor',
10:24:14  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:14  53  
10:24:14  54  	-- normalize the original data
10:24:14  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:14  56  	  norm_table_name => 'svmc_norm',
10:24:14  57  	  data_table_name => '&bldtable',
10:24:14  58  	  xform_view_name => 'svmc_build_prep');
10:24:14  59  END;
10:24:14  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:24:14 SQL> 
10:24:14 SQL> ---------------------
10:24:14 SQL> -- CREATE A NEW MODEL
10:24:14 SQL> --
10:24:14 SQL> -- Cleanup old model with the same name for repeat runs
10:24:14 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:14   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.11
10:24:15 SQL> 
10:24:15 SQL> -- Build a new SVM Model
10:24:15 SQL> BEGIN
10:24:15   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:15   3  	  model_name	      => '&model_name',
10:24:15   4  	  mining_function     => dbms_data_mining.classification,
10:24:15   5  	  data_table_name     => 'svmc_build_prep',
10:24:15   6  	  case_id_column_name => '&case_id',
10:24:15   7  	  target_column_name  => '&target',
10:24:15   8  	  settings_table_name => 'svmc_settings');
10:24:15   9  END;
10:24:15  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.94
10:24:17 SQL> 
10:24:17 SQL> -----------------------------------------------------------------------
10:24:17 SQL> --			       APPLY/score THE MODEL
10:24:17 SQL> -----------------------------------------------------------------------
10:24:17 SQL> 
10:24:17 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.37
10:24:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:18 SQL> -----------------------
10:24:18 SQL> -- PREPARE SCORING DATA
10:24:18 SQL> --
10:24:18 SQL> -- If the data for model creation has been prepared, then the data
10:24:18 SQL> -- to be scored using the model must be prepared in the same manner
10:24:18 SQL> -- in order to obtain meaningful results.
10:24:18 SQL> --
10:24:18 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:18 SQL> -- 2. Normalization
10:24:18 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:18 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:18 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:18 SQL> --
10:24:18 SQL> BEGIN
10:24:18   2  	-- Xform Test data to replace missing values
10:24:18   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:18   4  	  miss_table_name => 'svmc_miss_num',
10:24:18   5  	  data_table_name => '&scoretable',
10:24:18   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:18   7  
10:24:18   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:18   9  	  miss_table_name => 'svmc_miss_cat',
10:24:18  10  	  data_table_name => '&scoretable',
10:24:18  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:18  12  
10:24:18  13  	-- Normalize the data to be scored
10:24:18  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:18  15  	  norm_table_name => 'svmc_norm',
10:24:18  16  	  data_table_name => '&scoretable',
10:24:18  17  	  xform_view_name => 'svmc_apply_prep');
10:24:18  18  END;
10:24:18  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:18 SQL> 
10:24:18 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:18 SQL> -- DELETE it if I did:
10:24:18 SQL> DELETE ystkscores
10:24:18   2  WHERE score > 0
10:24:18   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:18   4  -- I need to supply the target attribute name:
10:24:18   5  AND targ = '&1'
10:24:18   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:24:18 SQL> 
10:24:18 SQL> -- We do a drumroll here:
10:24:18 SQL> 
10:24:18 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:18   2  SELECT
10:24:18   3  tkrdate
10:24:18   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:18   5  ,sysdate
10:24:18   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:18   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:18   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:18   9  ,SUBSTR(tkrdate,-10)ydate
10:24:18  10  ,'&1'
10:24:18  11  FROM svmc_apply_prep
10:24:18  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:24:18 SQL> @score1_5min_gattn.sql	2010-10-18 TLT
10:24:18 SQL> --
10:24:18 SQL> -- score1_5min_gattn.sql
10:24:18 SQL> --
10:24:18 SQL> 
10:24:18 SQL> -- Demo:
10:24:18 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:18 SQL> 
10:24:18 SQL> CREATE OR REPLACE VIEW sme AS
10:24:18   2  SELECT
10:24:18   3  tkrdate
10:24:18   4  ,NULL gattn
10:24:18   5  ,g00
10:24:18   6  ,g01
10:24:18   7  ,g02
10:24:18   8  ,g03
10:24:18   9  ,g04
10:24:18  10  ,g05
10:24:18  11  ,g06
10:24:18  12  ,g07
10:24:18  13  ,g08
10:24:18  14  ,g09
10:24:18  15  ,g10
10:24:18  16  ,g11
10:24:18  17  ,g12
10:24:18  18  ,g13
10:24:18  19  ,g14
10:24:18  20  ,g15
10:24:18  21  ,g16
10:24:18  22  ,g17
10:24:18  23  ,g18
10:24:18  24  ,g19
10:24:18  25  ,g20
10:24:18  26  ,g21
10:24:18  27  ,g22
10:24:18  28  ,g23
10:24:18  29  ,g24
10:24:18  30  ,g25
10:24:18  31  ,g26
10:24:18  32  ,g27
10:24:18  33  ,g28
10:24:18  34  ,g29
10:24:18  35  FROM stk_ms
10:24:18  36  WHERE ydate = '&1'
10:24:18  37  AND tkr = '&2'
10:24:18  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-10-18'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:24:18 SQL> 
10:24:18 SQL> -- rpt
10:24:18 SQL> -- We should see just 1 row:
10:24:18 SQL> 
10:24:18 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:18   2  
10:24:18 SQL> -- Build the model:
10:24:18 SQL> CREATE OR REPLACE VIEW bme AS
10:24:18   2  SELECT
10:24:18   3  tkrdate
10:24:18   4  ,gattn
10:24:18   5  ,g00
10:24:18   6  ,g01
10:24:18   7  ,g02
10:24:18   8  ,g03
10:24:18   9  ,g04
10:24:18  10  ,g05
10:24:18  11  ,g06
10:24:18  12  ,g07
10:24:18  13  ,g08
10:24:18  14  ,g09
10:24:18  15  ,g10
10:24:18  16  ,g11
10:24:18  17  ,g12
10:24:18  18  ,g13
10:24:18  19  ,g14
10:24:18  20  ,g15
10:24:18  21  ,g16
10:24:18  22  ,g17
10:24:18  23  ,g18
10:24:18  24  ,g19
10:24:18  25  ,g20
10:24:18  26  ,g21
10:24:18  27  ,g22
10:24:18  28  ,g23
10:24:18  29  ,g24
10:24:18  30  ,g25
10:24:18  31  ,g26
10:24:18  32  ,g27
10:24:18  33  ,g28
10:24:18  34  ,g29
10:24:18  35  FROM stk_ms
10:24:18  36  WHERE gattn IN('nup','up')
10:24:18  37  -- Use only rows which are older than 1 day:
10:24:18  38  AND 1+ydate < '&1'
10:24:18  39  AND tkr = '&2'
10:24:18  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-10-18'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:18 SQL> 
10:24:18 SQL> -- rpt
10:24:18 SQL> 
10:24:18 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:18   2  
10:24:18 SQL> SELECT MAX(tkrdate) FROM bme
10:24:18   2  
10:24:18 SQL> -- Now build model from bme and score sme
10:24:18 SQL> @score1.sql gattn
10:24:18 SQL> -- score1.sql
10:24:18 SQL> 
10:24:18 SQL> -- I use this script to send 5 params to score.sql
10:24:18 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:18 SQL> -- Then at the very end of this script I use the model
10:24:18 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:18 SQL> 
10:24:18 SQL> -- I call this script from 2 other scripts:
10:24:18 SQL> -- score1_5min.sql
10:24:18 SQL> -- score1_5min_gattn.sql
10:24:18 SQL> 
10:24:18 SQL> -- The 1st param is the name of the target attribute.
10:24:18 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:18 SQL> 
10:24:18 SQL> -- Demo:
10:24:18 SQL> -- @score1.sql 'gatt'
10:24:18 SQL> -- @score1.sql 'gattn'
10:24:18 SQL> 
10:24:18 SQL> -- Now, I fill up svmc_apply_prep.
10:24:18 SQL> -- I use same model_name used in score.sql
10:24:18 SQL> DEFINE model_name = 'svmspy101'
10:24:18 SQL> DEFINE bldtable	= 'bme'
10:24:18 SQL> DEFINE scoretable = 'sme'
10:24:18 SQL> DEFINE case_id	= 'tkrdate'
10:24:18 SQL> -- Demo:
10:24:18 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:18 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:18 SQL> --
10:24:18 SQL> -- score.sql
10:24:18 SQL> --
10:24:18 SQL> 
10:24:18 SQL> -- usage: score.sql
10:24:18 SQL> 
10:24:18 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:18 SQL> 
10:24:18 SQL> -- DEFINE target	   = 'gatt'
10:24:18 SQL> -- DEFINE model_name = 'svmspy100'
10:24:18 SQL> -- DEFINE bldtable   = 'bme'
10:24:18 SQL> -- DEFINE scoretable = 'sme'
10:24:18 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:18 SQL> 
10:24:18 SQL> DEFINE target	= '&1'
10:24:18 SQL> DEFINE model_name = '&2'
10:24:18 SQL> DEFINE bldtable	= '&3'
10:24:18 SQL> DEFINE scoretable = '&4'
10:24:18 SQL> DEFINE case_id	= '&5'
10:24:18 SQL> 
10:24:18 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:18 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:18 SQL> 
10:24:18 SQL> -- Builds an SVM model using pl/sql.
10:24:18 SQL> 
10:24:18 SQL> -----------------------------------------------------------------------
10:24:18 SQL> --			    BUILD THE MODEL
10:24:18 SQL> -----------------------------------------------------------------------
10:24:18 SQL> 
10:24:18 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:18 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:18 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:18 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:18 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:18 SQL> 
10:24:18 SQL> 
10:24:18 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:18 SQL> --
10:24:18 SQL> -- DROP	TABLE svmc_settings ;
10:24:18 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:18 SQL> -- DELETE svmc_settings;
10:24:18 SQL> 
10:24:18 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:18 SQL> -- this choice to SVM using a settings table.
10:24:18 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:18 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:18 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:18 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:18 SQL> -- models.
10:24:18 SQL> --
10:24:18 SQL> 
10:24:18 SQL> -- Do this once and then comment it out.
10:24:18 SQL> -- That makes script go faster.
10:24:18 SQL> -- BEGIN
10:24:18 SQL> -- -- Populate settings table
10:24:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:18 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:18 SQL> --
10:24:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:18 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:18 SQL> --
10:24:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:18 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:18 SQL> --   COMMIT;
10:24:18 SQL> -- END;
10:24:18 SQL> -- /
10:24:18 SQL> 
10:24:18 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:18 SQL> 
10:24:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:18 SQL> 
10:24:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:18 SQL> 
10:24:18 SQL> --------------------------------
10:24:18 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:18 SQL> --
10:24:18 SQL> 
10:24:18 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:18 SQL> -- 2. Outlier Treatment and
10:24:18 SQL> -- 3. Normalization are performed below.
10:24:18 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:18 SQL> --    normalized here.
10:24:18 SQL> 
10:24:18 SQL> BEGIN
10:24:18   2  	-- Perform missing value treatment for all predictors
10:24:18   3  	-- create miss tables
10:24:18   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:18   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:18   6  
10:24:18   7  	-- populate miss tables
10:24:18   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:18   9  	  miss_table_name => 'svmc_miss_num',
10:24:18  10  	  data_table_name => '&bldtable',
10:24:18  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:18  12  
10:24:18  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:18  14  	  miss_table_name => 'svmc_miss_cat',
10:24:18  15  	  data_table_name => '&bldtable',
10:24:18  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:18  17  
10:24:18  18  	-- xform input data to replace missing values
10:24:18  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:18  20  	  miss_table_name => 'svmc_miss_num',
10:24:18  21  	  data_table_name => '&bldtable',
10:24:18  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:18  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:18  24  	  miss_table_name => 'svmc_miss_cat',
10:24:18  25  	  data_table_name => '&bldtable',
10:24:18  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:18  27  
10:24:18  28  	-- Perform outlier treatment.
10:24:18  29  	-- create clip table
10:24:18  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:18  31  
10:24:18  32  	-- populate clip table
10:24:18  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:18  34  	  clip_table_name => 'svmc_clip',
10:24:18  35  	  data_table_name => '&bldtable',
10:24:18  36  	  tail_frac	  => 0.025,
10:24:18  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:18  38  
10:24:18  39  	-- xform input data to winsorized data
10:24:18  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:18  41  	  clip_table_name => 'svmc_clip',
10:24:18  42  	  data_table_name => '&bldtable',
10:24:18  43  	  xform_view_name => 'svmc_winsor');
10:24:18  44  
10:24:18  45  	-- create normalization table
10:24:18  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:18  47  
10:24:18  48  	-- populate normalization table based on winsorized data
10:24:18  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:18  50  	  norm_table_name => 'svmc_norm',
10:24:18  51  	  data_table_name => 'svmc_winsor',
10:24:18  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:18  53  
10:24:18  54  	-- normalize the original data
10:24:18  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:18  56  	  norm_table_name => 'svmc_norm',
10:24:18  57  	  data_table_name => '&bldtable',
10:24:18  58  	  xform_view_name => 'svmc_build_prep');
10:24:18  59  END;
10:24:18  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:24:19 SQL> 
10:24:19 SQL> ---------------------
10:24:19 SQL> -- CREATE A NEW MODEL
10:24:19 SQL> --
10:24:19 SQL> -- Cleanup old model with the same name for repeat runs
10:24:19 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:19   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.94
10:24:20 SQL> 
10:24:20 SQL> -- Build a new SVM Model
10:24:20 SQL> BEGIN
10:24:20   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:20   3  	  model_name	      => '&model_name',
10:24:20   4  	  mining_function     => dbms_data_mining.classification,
10:24:20   5  	  data_table_name     => 'svmc_build_prep',
10:24:20   6  	  case_id_column_name => '&case_id',
10:24:20   7  	  target_column_name  => '&target',
10:24:20   8  	  settings_table_name => 'svmc_settings');
10:24:20   9  END;
10:24:20  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.95
10:24:22 SQL> 
10:24:22 SQL> -----------------------------------------------------------------------
10:24:22 SQL> --			       APPLY/score THE MODEL
10:24:22 SQL> -----------------------------------------------------------------------
10:24:22 SQL> 
10:24:22 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.16
10:24:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:22 SQL> -----------------------
10:24:22 SQL> -- PREPARE SCORING DATA
10:24:22 SQL> --
10:24:22 SQL> -- If the data for model creation has been prepared, then the data
10:24:22 SQL> -- to be scored using the model must be prepared in the same manner
10:24:22 SQL> -- in order to obtain meaningful results.
10:24:22 SQL> --
10:24:22 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:22 SQL> -- 2. Normalization
10:24:22 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:22 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:22 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:22 SQL> --
10:24:22 SQL> BEGIN
10:24:22   2  	-- Xform Test data to replace missing values
10:24:22   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:22   4  	  miss_table_name => 'svmc_miss_num',
10:24:22   5  	  data_table_name => '&scoretable',
10:24:22   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:22   7  
10:24:22   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:22   9  	  miss_table_name => 'svmc_miss_cat',
10:24:22  10  	  data_table_name => '&scoretable',
10:24:22  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:22  12  
10:24:22  13  	-- Normalize the data to be scored
10:24:22  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:22  15  	  norm_table_name => 'svmc_norm',
10:24:22  16  	  data_table_name => '&scoretable',
10:24:22  17  	  xform_view_name => 'svmc_apply_prep');
10:24:22  18  END;
10:24:22  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.41
10:24:23 SQL> 
10:24:23 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:23 SQL> -- DELETE it if I did:
10:24:23 SQL> DELETE ystkscores
10:24:23   2  WHERE score > 0
10:24:23   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:23   4  -- I need to supply the target attribute name:
10:24:23   5  AND targ = '&1'
10:24:23   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:23 SQL> 
10:24:23 SQL> -- We do a drumroll here:
10:24:23 SQL> 
10:24:23 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:23   2  SELECT
10:24:23   3  tkrdate
10:24:23   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:23   5  ,sysdate
10:24:23   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:23   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:23   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:23   9  ,SUBSTR(tkrdate,-10)ydate
10:24:23  10  ,'&1'
10:24:23  11  FROM svmc_apply_prep
10:24:23  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:24:23 SQL> @score1_5min_gattn.sql	2010-03-15 TLT
10:24:23 SQL> --
10:24:23 SQL> -- score1_5min_gattn.sql
10:24:23 SQL> --
10:24:23 SQL> 
10:24:23 SQL> -- Demo:
10:24:23 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:23 SQL> 
10:24:23 SQL> CREATE OR REPLACE VIEW sme AS
10:24:23   2  SELECT
10:24:23   3  tkrdate
10:24:23   4  ,NULL gattn
10:24:23   5  ,g00
10:24:23   6  ,g01
10:24:23   7  ,g02
10:24:23   8  ,g03
10:24:23   9  ,g04
10:24:23  10  ,g05
10:24:23  11  ,g06
10:24:23  12  ,g07
10:24:23  13  ,g08
10:24:23  14  ,g09
10:24:23  15  ,g10
10:24:23  16  ,g11
10:24:23  17  ,g12
10:24:23  18  ,g13
10:24:23  19  ,g14
10:24:23  20  ,g15
10:24:23  21  ,g16
10:24:23  22  ,g17
10:24:23  23  ,g18
10:24:23  24  ,g19
10:24:23  25  ,g20
10:24:23  26  ,g21
10:24:23  27  ,g22
10:24:23  28  ,g23
10:24:23  29  ,g24
10:24:23  30  ,g25
10:24:23  31  ,g26
10:24:23  32  ,g27
10:24:23  33  ,g28
10:24:23  34  ,g29
10:24:23  35  FROM stk_ms
10:24:23  36  WHERE ydate = '&1'
10:24:23  37  AND tkr = '&2'
10:24:23  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-15'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.19
10:24:23 SQL> 
10:24:23 SQL> -- rpt
10:24:23 SQL> -- We should see just 1 row:
10:24:23 SQL> 
10:24:23 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:23   2  
10:24:23 SQL> -- Build the model:
10:24:23 SQL> CREATE OR REPLACE VIEW bme AS
10:24:23   2  SELECT
10:24:23   3  tkrdate
10:24:23   4  ,gattn
10:24:23   5  ,g00
10:24:23   6  ,g01
10:24:23   7  ,g02
10:24:23   8  ,g03
10:24:23   9  ,g04
10:24:23  10  ,g05
10:24:23  11  ,g06
10:24:23  12  ,g07
10:24:23  13  ,g08
10:24:23  14  ,g09
10:24:23  15  ,g10
10:24:23  16  ,g11
10:24:23  17  ,g12
10:24:23  18  ,g13
10:24:23  19  ,g14
10:24:23  20  ,g15
10:24:23  21  ,g16
10:24:23  22  ,g17
10:24:23  23  ,g18
10:24:23  24  ,g19
10:24:23  25  ,g20
10:24:23  26  ,g21
10:24:23  27  ,g22
10:24:23  28  ,g23
10:24:23  29  ,g24
10:24:23  30  ,g25
10:24:23  31  ,g26
10:24:23  32  ,g27
10:24:23  33  ,g28
10:24:23  34  ,g29
10:24:23  35  FROM stk_ms
10:24:23  36  WHERE gattn IN('nup','up')
10:24:23  37  -- Use only rows which are older than 1 day:
10:24:23  38  AND 1+ydate < '&1'
10:24:23  39  AND tkr = '&2'
10:24:23  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-15'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.21
10:24:23 SQL> 
10:24:23 SQL> -- rpt
10:24:23 SQL> 
10:24:23 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:23   2  
10:24:23 SQL> SELECT MAX(tkrdate) FROM bme
10:24:23   2  
10:24:23 SQL> -- Now build model from bme and score sme
10:24:23 SQL> @score1.sql gattn
10:24:23 SQL> -- score1.sql
10:24:23 SQL> 
10:24:23 SQL> -- I use this script to send 5 params to score.sql
10:24:23 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:23 SQL> -- Then at the very end of this script I use the model
10:24:23 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:23 SQL> 
10:24:23 SQL> -- I call this script from 2 other scripts:
10:24:23 SQL> -- score1_5min.sql
10:24:23 SQL> -- score1_5min_gattn.sql
10:24:23 SQL> 
10:24:23 SQL> -- The 1st param is the name of the target attribute.
10:24:23 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:23 SQL> 
10:24:23 SQL> -- Demo:
10:24:23 SQL> -- @score1.sql 'gatt'
10:24:23 SQL> -- @score1.sql 'gattn'
10:24:23 SQL> 
10:24:23 SQL> -- Now, I fill up svmc_apply_prep.
10:24:23 SQL> -- I use same model_name used in score.sql
10:24:23 SQL> DEFINE model_name = 'svmspy101'
10:24:23 SQL> DEFINE bldtable	= 'bme'
10:24:23 SQL> DEFINE scoretable = 'sme'
10:24:23 SQL> DEFINE case_id	= 'tkrdate'
10:24:23 SQL> -- Demo:
10:24:23 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:23 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:23 SQL> --
10:24:23 SQL> -- score.sql
10:24:23 SQL> --
10:24:23 SQL> 
10:24:23 SQL> -- usage: score.sql
10:24:23 SQL> 
10:24:23 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:23 SQL> 
10:24:23 SQL> -- DEFINE target	   = 'gatt'
10:24:23 SQL> -- DEFINE model_name = 'svmspy100'
10:24:23 SQL> -- DEFINE bldtable   = 'bme'
10:24:23 SQL> -- DEFINE scoretable = 'sme'
10:24:23 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:23 SQL> 
10:24:23 SQL> DEFINE target	= '&1'
10:24:23 SQL> DEFINE model_name = '&2'
10:24:23 SQL> DEFINE bldtable	= '&3'
10:24:23 SQL> DEFINE scoretable = '&4'
10:24:23 SQL> DEFINE case_id	= '&5'
10:24:23 SQL> 
10:24:23 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:23 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:23 SQL> 
10:24:23 SQL> -- Builds an SVM model using pl/sql.
10:24:23 SQL> 
10:24:23 SQL> -----------------------------------------------------------------------
10:24:23 SQL> --			    BUILD THE MODEL
10:24:23 SQL> -----------------------------------------------------------------------
10:24:23 SQL> 
10:24:23 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:23 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:23 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:23 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:23 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:23 SQL> 
10:24:23 SQL> 
10:24:23 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:23 SQL> --
10:24:23 SQL> -- DROP	TABLE svmc_settings ;
10:24:23 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:23 SQL> -- DELETE svmc_settings;
10:24:23 SQL> 
10:24:23 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:23 SQL> -- this choice to SVM using a settings table.
10:24:23 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:23 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:23 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:23 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:23 SQL> -- models.
10:24:23 SQL> --
10:24:23 SQL> 
10:24:23 SQL> -- Do this once and then comment it out.
10:24:23 SQL> -- That makes script go faster.
10:24:23 SQL> -- BEGIN
10:24:23 SQL> -- -- Populate settings table
10:24:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:23 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:23 SQL> --
10:24:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:23 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:23 SQL> --
10:24:23 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:23 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:23 SQL> --   COMMIT;
10:24:23 SQL> -- END;
10:24:23 SQL> -- /
10:24:23 SQL> 
10:24:23 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:23 SQL> 
10:24:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:23 SQL> 
10:24:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:23 SQL> 
10:24:23 SQL> --------------------------------
10:24:23 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:23 SQL> --
10:24:23 SQL> 
10:24:23 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:23 SQL> -- 2. Outlier Treatment and
10:24:23 SQL> -- 3. Normalization are performed below.
10:24:23 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:23 SQL> --    normalized here.
10:24:23 SQL> 
10:24:23 SQL> BEGIN
10:24:23   2  	-- Perform missing value treatment for all predictors
10:24:23   3  	-- create miss tables
10:24:23   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:23   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:23   6  
10:24:23   7  	-- populate miss tables
10:24:23   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:23   9  	  miss_table_name => 'svmc_miss_num',
10:24:23  10  	  data_table_name => '&bldtable',
10:24:23  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:23  12  
10:24:23  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:23  14  	  miss_table_name => 'svmc_miss_cat',
10:24:23  15  	  data_table_name => '&bldtable',
10:24:23  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:23  17  
10:24:23  18  	-- xform input data to replace missing values
10:24:23  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:23  20  	  miss_table_name => 'svmc_miss_num',
10:24:23  21  	  data_table_name => '&bldtable',
10:24:23  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:23  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:23  24  	  miss_table_name => 'svmc_miss_cat',
10:24:23  25  	  data_table_name => '&bldtable',
10:24:23  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:23  27  
10:24:23  28  	-- Perform outlier treatment.
10:24:23  29  	-- create clip table
10:24:23  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:23  31  
10:24:23  32  	-- populate clip table
10:24:23  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:23  34  	  clip_table_name => 'svmc_clip',
10:24:23  35  	  data_table_name => '&bldtable',
10:24:23  36  	  tail_frac	  => 0.025,
10:24:23  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:23  38  
10:24:23  39  	-- xform input data to winsorized data
10:24:23  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:23  41  	  clip_table_name => 'svmc_clip',
10:24:23  42  	  data_table_name => '&bldtable',
10:24:23  43  	  xform_view_name => 'svmc_winsor');
10:24:23  44  
10:24:23  45  	-- create normalization table
10:24:23  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:23  47  
10:24:23  48  	-- populate normalization table based on winsorized data
10:24:23  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:23  50  	  norm_table_name => 'svmc_norm',
10:24:23  51  	  data_table_name => 'svmc_winsor',
10:24:23  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:23  53  
10:24:23  54  	-- normalize the original data
10:24:23  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:23  56  	  norm_table_name => 'svmc_norm',
10:24:23  57  	  data_table_name => '&bldtable',
10:24:23  58  	  xform_view_name => 'svmc_build_prep');
10:24:23  59  END;
10:24:23  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:24:24 SQL> 
10:24:24 SQL> ---------------------
10:24:24 SQL> -- CREATE A NEW MODEL
10:24:24 SQL> --
10:24:24 SQL> -- Cleanup old model with the same name for repeat runs
10:24:24 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:24   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.19
10:24:25 SQL> 
10:24:25 SQL> -- Build a new SVM Model
10:24:25 SQL> BEGIN
10:24:25   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:25   3  	  model_name	      => '&model_name',
10:24:25   4  	  mining_function     => dbms_data_mining.classification,
10:24:25   5  	  data_table_name     => 'svmc_build_prep',
10:24:25   6  	  case_id_column_name => '&case_id',
10:24:25   7  	  target_column_name  => '&target',
10:24:25   8  	  settings_table_name => 'svmc_settings');
10:24:25   9  END;
10:24:25  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.89
10:24:27 SQL> 
10:24:27 SQL> -----------------------------------------------------------------------
10:24:27 SQL> --			       APPLY/score THE MODEL
10:24:27 SQL> -----------------------------------------------------------------------
10:24:27 SQL> 
10:24:27 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:27 SQL> -----------------------
10:24:27 SQL> -- PREPARE SCORING DATA
10:24:27 SQL> --
10:24:27 SQL> -- If the data for model creation has been prepared, then the data
10:24:27 SQL> -- to be scored using the model must be prepared in the same manner
10:24:27 SQL> -- in order to obtain meaningful results.
10:24:27 SQL> --
10:24:27 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:27 SQL> -- 2. Normalization
10:24:27 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:27 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:27 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:27 SQL> --
10:24:27 SQL> BEGIN
10:24:27   2  	-- Xform Test data to replace missing values
10:24:27   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:27   4  	  miss_table_name => 'svmc_miss_num',
10:24:27   5  	  data_table_name => '&scoretable',
10:24:27   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:27   7  
10:24:27   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:27   9  	  miss_table_name => 'svmc_miss_cat',
10:24:27  10  	  data_table_name => '&scoretable',
10:24:27  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:27  12  
10:24:27  13  	-- Normalize the data to be scored
10:24:27  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:27  15  	  norm_table_name => 'svmc_norm',
10:24:27  16  	  data_table_name => '&scoretable',
10:24:27  17  	  xform_view_name => 'svmc_apply_prep');
10:24:27  18  END;
10:24:27  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
10:24:27 SQL> 
10:24:27 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:27 SQL> -- DELETE it if I did:
10:24:27 SQL> DELETE ystkscores
10:24:27   2  WHERE score > 0
10:24:27   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:27   4  -- I need to supply the target attribute name:
10:24:27   5  AND targ = '&1'
10:24:27   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:27 SQL> 
10:24:27 SQL> -- We do a drumroll here:
10:24:27 SQL> 
10:24:27 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:27   2  SELECT
10:24:27   3  tkrdate
10:24:27   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:27   5  ,sysdate
10:24:27   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:27   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:27   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:27   9  ,SUBSTR(tkrdate,-10)ydate
10:24:27  10  ,'&1'
10:24:27  11  FROM svmc_apply_prep
10:24:27  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:24:27 SQL> @score1_5min_gattn.sql	2010-01-14 TLT
10:24:27 SQL> --
10:24:27 SQL> -- score1_5min_gattn.sql
10:24:27 SQL> --
10:24:27 SQL> 
10:24:27 SQL> -- Demo:
10:24:27 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:27 SQL> 
10:24:27 SQL> CREATE OR REPLACE VIEW sme AS
10:24:27   2  SELECT
10:24:27   3  tkrdate
10:24:27   4  ,NULL gattn
10:24:27   5  ,g00
10:24:27   6  ,g01
10:24:27   7  ,g02
10:24:27   8  ,g03
10:24:27   9  ,g04
10:24:27  10  ,g05
10:24:27  11  ,g06
10:24:27  12  ,g07
10:24:27  13  ,g08
10:24:27  14  ,g09
10:24:27  15  ,g10
10:24:27  16  ,g11
10:24:27  17  ,g12
10:24:27  18  ,g13
10:24:27  19  ,g14
10:24:27  20  ,g15
10:24:27  21  ,g16
10:24:27  22  ,g17
10:24:27  23  ,g18
10:24:27  24  ,g19
10:24:27  25  ,g20
10:24:27  26  ,g21
10:24:27  27  ,g22
10:24:27  28  ,g23
10:24:27  29  ,g24
10:24:27  30  ,g25
10:24:27  31  ,g26
10:24:27  32  ,g27
10:24:27  33  ,g28
10:24:27  34  ,g29
10:24:27  35  FROM stk_ms
10:24:27  36  WHERE ydate = '&1'
10:24:27  37  AND tkr = '&2'
10:24:27  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-14'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:27 SQL> 
10:24:27 SQL> -- rpt
10:24:27 SQL> -- We should see just 1 row:
10:24:27 SQL> 
10:24:27 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:27   2  
10:24:27 SQL> -- Build the model:
10:24:27 SQL> CREATE OR REPLACE VIEW bme AS
10:24:27   2  SELECT
10:24:27   3  tkrdate
10:24:27   4  ,gattn
10:24:27   5  ,g00
10:24:27   6  ,g01
10:24:27   7  ,g02
10:24:27   8  ,g03
10:24:27   9  ,g04
10:24:27  10  ,g05
10:24:27  11  ,g06
10:24:27  12  ,g07
10:24:27  13  ,g08
10:24:27  14  ,g09
10:24:27  15  ,g10
10:24:27  16  ,g11
10:24:27  17  ,g12
10:24:27  18  ,g13
10:24:27  19  ,g14
10:24:27  20  ,g15
10:24:27  21  ,g16
10:24:27  22  ,g17
10:24:27  23  ,g18
10:24:27  24  ,g19
10:24:27  25  ,g20
10:24:27  26  ,g21
10:24:27  27  ,g22
10:24:27  28  ,g23
10:24:27  29  ,g24
10:24:27  30  ,g25
10:24:27  31  ,g26
10:24:27  32  ,g27
10:24:27  33  ,g28
10:24:27  34  ,g29
10:24:27  35  FROM stk_ms
10:24:27  36  WHERE gattn IN('nup','up')
10:24:27  37  -- Use only rows which are older than 1 day:
10:24:27  38  AND 1+ydate < '&1'
10:24:27  39  AND tkr = '&2'
10:24:27  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-14'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.21
10:24:27 SQL> 
10:24:27 SQL> -- rpt
10:24:27 SQL> 
10:24:27 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:27   2  
10:24:27 SQL> SELECT MAX(tkrdate) FROM bme
10:24:27   2  
10:24:27 SQL> -- Now build model from bme and score sme
10:24:27 SQL> @score1.sql gattn
10:24:27 SQL> -- score1.sql
10:24:27 SQL> 
10:24:27 SQL> -- I use this script to send 5 params to score.sql
10:24:27 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:27 SQL> -- Then at the very end of this script I use the model
10:24:27 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:27 SQL> 
10:24:27 SQL> -- I call this script from 2 other scripts:
10:24:27 SQL> -- score1_5min.sql
10:24:27 SQL> -- score1_5min_gattn.sql
10:24:27 SQL> 
10:24:27 SQL> -- The 1st param is the name of the target attribute.
10:24:27 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:27 SQL> 
10:24:27 SQL> -- Demo:
10:24:27 SQL> -- @score1.sql 'gatt'
10:24:27 SQL> -- @score1.sql 'gattn'
10:24:27 SQL> 
10:24:27 SQL> -- Now, I fill up svmc_apply_prep.
10:24:27 SQL> -- I use same model_name used in score.sql
10:24:27 SQL> DEFINE model_name = 'svmspy101'
10:24:27 SQL> DEFINE bldtable	= 'bme'
10:24:27 SQL> DEFINE scoretable = 'sme'
10:24:27 SQL> DEFINE case_id	= 'tkrdate'
10:24:27 SQL> -- Demo:
10:24:27 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:27 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:27 SQL> --
10:24:27 SQL> -- score.sql
10:24:27 SQL> --
10:24:27 SQL> 
10:24:27 SQL> -- usage: score.sql
10:24:27 SQL> 
10:24:27 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:27 SQL> 
10:24:27 SQL> -- DEFINE target	   = 'gatt'
10:24:27 SQL> -- DEFINE model_name = 'svmspy100'
10:24:27 SQL> -- DEFINE bldtable   = 'bme'
10:24:27 SQL> -- DEFINE scoretable = 'sme'
10:24:27 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:27 SQL> 
10:24:27 SQL> DEFINE target	= '&1'
10:24:27 SQL> DEFINE model_name = '&2'
10:24:27 SQL> DEFINE bldtable	= '&3'
10:24:27 SQL> DEFINE scoretable = '&4'
10:24:27 SQL> DEFINE case_id	= '&5'
10:24:27 SQL> 
10:24:27 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:27 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:27 SQL> 
10:24:27 SQL> -- Builds an SVM model using pl/sql.
10:24:27 SQL> 
10:24:27 SQL> -----------------------------------------------------------------------
10:24:27 SQL> --			    BUILD THE MODEL
10:24:27 SQL> -----------------------------------------------------------------------
10:24:27 SQL> 
10:24:27 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:27 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:27 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:27 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:27 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:27 SQL> 
10:24:27 SQL> 
10:24:27 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:27 SQL> --
10:24:27 SQL> -- DROP	TABLE svmc_settings ;
10:24:27 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:27 SQL> -- DELETE svmc_settings;
10:24:27 SQL> 
10:24:27 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:27 SQL> -- this choice to SVM using a settings table.
10:24:27 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:27 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:27 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:27 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:27 SQL> -- models.
10:24:27 SQL> --
10:24:27 SQL> 
10:24:27 SQL> -- Do this once and then comment it out.
10:24:27 SQL> -- That makes script go faster.
10:24:27 SQL> -- BEGIN
10:24:27 SQL> -- -- Populate settings table
10:24:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:27 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:27 SQL> --
10:24:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:27 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:27 SQL> --
10:24:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:27 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:27 SQL> --   COMMIT;
10:24:27 SQL> -- END;
10:24:27 SQL> -- /
10:24:27 SQL> 
10:24:27 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:27 SQL> 
10:24:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.23
10:24:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:28 SQL> 
10:24:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:28 SQL> 
10:24:28 SQL> --------------------------------
10:24:28 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:28 SQL> --
10:24:28 SQL> 
10:24:28 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:28 SQL> -- 2. Outlier Treatment and
10:24:28 SQL> -- 3. Normalization are performed below.
10:24:28 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:28 SQL> --    normalized here.
10:24:28 SQL> 
10:24:28 SQL> BEGIN
10:24:28   2  	-- Perform missing value treatment for all predictors
10:24:28   3  	-- create miss tables
10:24:28   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:28   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:28   6  
10:24:28   7  	-- populate miss tables
10:24:28   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:28   9  	  miss_table_name => 'svmc_miss_num',
10:24:28  10  	  data_table_name => '&bldtable',
10:24:28  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:28  12  
10:24:28  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:28  14  	  miss_table_name => 'svmc_miss_cat',
10:24:28  15  	  data_table_name => '&bldtable',
10:24:28  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:28  17  
10:24:28  18  	-- xform input data to replace missing values
10:24:28  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:28  20  	  miss_table_name => 'svmc_miss_num',
10:24:28  21  	  data_table_name => '&bldtable',
10:24:28  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:28  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:28  24  	  miss_table_name => 'svmc_miss_cat',
10:24:28  25  	  data_table_name => '&bldtable',
10:24:28  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:28  27  
10:24:28  28  	-- Perform outlier treatment.
10:24:28  29  	-- create clip table
10:24:28  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:28  31  
10:24:28  32  	-- populate clip table
10:24:28  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:28  34  	  clip_table_name => 'svmc_clip',
10:24:28  35  	  data_table_name => '&bldtable',
10:24:28  36  	  tail_frac	  => 0.025,
10:24:28  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:28  38  
10:24:28  39  	-- xform input data to winsorized data
10:24:28  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:28  41  	  clip_table_name => 'svmc_clip',
10:24:28  42  	  data_table_name => '&bldtable',
10:24:28  43  	  xform_view_name => 'svmc_winsor');
10:24:28  44  
10:24:28  45  	-- create normalization table
10:24:28  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:28  47  
10:24:28  48  	-- populate normalization table based on winsorized data
10:24:28  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:28  50  	  norm_table_name => 'svmc_norm',
10:24:28  51  	  data_table_name => 'svmc_winsor',
10:24:28  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:28  53  
10:24:28  54  	-- normalize the original data
10:24:28  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:28  56  	  norm_table_name => 'svmc_norm',
10:24:28  57  	  data_table_name => '&bldtable',
10:24:28  58  	  xform_view_name => 'svmc_build_prep');
10:24:28  59  END;
10:24:28  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:24:28 SQL> 
10:24:28 SQL> ---------------------
10:24:28 SQL> -- CREATE A NEW MODEL
10:24:28 SQL> --
10:24:28 SQL> -- Cleanup old model with the same name for repeat runs
10:24:28 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:28   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.99
10:24:29 SQL> 
10:24:29 SQL> -- Build a new SVM Model
10:24:29 SQL> BEGIN
10:24:29   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:29   3  	  model_name	      => '&model_name',
10:24:29   4  	  mining_function     => dbms_data_mining.classification,
10:24:29   5  	  data_table_name     => 'svmc_build_prep',
10:24:29   6  	  case_id_column_name => '&case_id',
10:24:29   7  	  target_column_name  => '&target',
10:24:29   8  	  settings_table_name => 'svmc_settings');
10:24:29   9  END;
10:24:29  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.92
10:24:31 SQL> 
10:24:31 SQL> -----------------------------------------------------------------------
10:24:31 SQL> --			       APPLY/score THE MODEL
10:24:31 SQL> -----------------------------------------------------------------------
10:24:31 SQL> 
10:24:31 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:24:31 SQL> -----------------------
10:24:31 SQL> -- PREPARE SCORING DATA
10:24:31 SQL> --
10:24:31 SQL> -- If the data for model creation has been prepared, then the data
10:24:31 SQL> -- to be scored using the model must be prepared in the same manner
10:24:31 SQL> -- in order to obtain meaningful results.
10:24:31 SQL> --
10:24:31 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:31 SQL> -- 2. Normalization
10:24:31 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:31 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:31 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:31 SQL> --
10:24:31 SQL> BEGIN
10:24:31   2  	-- Xform Test data to replace missing values
10:24:31   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:31   4  	  miss_table_name => 'svmc_miss_num',
10:24:31   5  	  data_table_name => '&scoretable',
10:24:31   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:31   7  
10:24:31   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:31   9  	  miss_table_name => 'svmc_miss_cat',
10:24:31  10  	  data_table_name => '&scoretable',
10:24:31  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:31  12  
10:24:31  13  	-- Normalize the data to be scored
10:24:31  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:31  15  	  norm_table_name => 'svmc_norm',
10:24:31  16  	  data_table_name => '&scoretable',
10:24:31  17  	  xform_view_name => 'svmc_apply_prep');
10:24:31  18  END;
10:24:31  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:24:32 SQL> 
10:24:32 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:32 SQL> -- DELETE it if I did:
10:24:32 SQL> DELETE ystkscores
10:24:32   2  WHERE score > 0
10:24:32   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:32   4  -- I need to supply the target attribute name:
10:24:32   5  AND targ = '&1'
10:24:32   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:32 SQL> 
10:24:32 SQL> -- We do a drumroll here:
10:24:32 SQL> 
10:24:32 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:32   2  SELECT
10:24:32   3  tkrdate
10:24:32   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:32   5  ,sysdate
10:24:32   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:32   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:32   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:32   9  ,SUBSTR(tkrdate,-10)ydate
10:24:32  10  ,'&1'
10:24:32  11  FROM svmc_apply_prep
10:24:32  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:24:32 SQL> @score1_5min_gattn.sql	2010-01-13 TLT
10:24:32 SQL> --
10:24:32 SQL> -- score1_5min_gattn.sql
10:24:32 SQL> --
10:24:32 SQL> 
10:24:32 SQL> -- Demo:
10:24:32 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:32 SQL> 
10:24:32 SQL> CREATE OR REPLACE VIEW sme AS
10:24:32   2  SELECT
10:24:32   3  tkrdate
10:24:32   4  ,NULL gattn
10:24:32   5  ,g00
10:24:32   6  ,g01
10:24:32   7  ,g02
10:24:32   8  ,g03
10:24:32   9  ,g04
10:24:32  10  ,g05
10:24:32  11  ,g06
10:24:32  12  ,g07
10:24:32  13  ,g08
10:24:32  14  ,g09
10:24:32  15  ,g10
10:24:32  16  ,g11
10:24:32  17  ,g12
10:24:32  18  ,g13
10:24:32  19  ,g14
10:24:32  20  ,g15
10:24:32  21  ,g16
10:24:32  22  ,g17
10:24:32  23  ,g18
10:24:32  24  ,g19
10:24:32  25  ,g20
10:24:32  26  ,g21
10:24:32  27  ,g22
10:24:32  28  ,g23
10:24:32  29  ,g24
10:24:32  30  ,g25
10:24:32  31  ,g26
10:24:32  32  ,g27
10:24:32  33  ,g28
10:24:32  34  ,g29
10:24:32  35  FROM stk_ms
10:24:32  36  WHERE ydate = '&1'
10:24:32  37  AND tkr = '&2'
10:24:32  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-13'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:32 SQL> 
10:24:32 SQL> -- rpt
10:24:32 SQL> -- We should see just 1 row:
10:24:32 SQL> 
10:24:32 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:32   2  
10:24:32 SQL> -- Build the model:
10:24:32 SQL> CREATE OR REPLACE VIEW bme AS
10:24:32   2  SELECT
10:24:32   3  tkrdate
10:24:32   4  ,gattn
10:24:32   5  ,g00
10:24:32   6  ,g01
10:24:32   7  ,g02
10:24:32   8  ,g03
10:24:32   9  ,g04
10:24:32  10  ,g05
10:24:32  11  ,g06
10:24:32  12  ,g07
10:24:32  13  ,g08
10:24:32  14  ,g09
10:24:32  15  ,g10
10:24:32  16  ,g11
10:24:32  17  ,g12
10:24:32  18  ,g13
10:24:32  19  ,g14
10:24:32  20  ,g15
10:24:32  21  ,g16
10:24:32  22  ,g17
10:24:32  23  ,g18
10:24:32  24  ,g19
10:24:32  25  ,g20
10:24:32  26  ,g21
10:24:32  27  ,g22
10:24:32  28  ,g23
10:24:32  29  ,g24
10:24:32  30  ,g25
10:24:32  31  ,g26
10:24:32  32  ,g27
10:24:32  33  ,g28
10:24:32  34  ,g29
10:24:32  35  FROM stk_ms
10:24:32  36  WHERE gattn IN('nup','up')
10:24:32  37  -- Use only rows which are older than 1 day:
10:24:32  38  AND 1+ydate < '&1'
10:24:32  39  AND tkr = '&2'
10:24:32  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-13'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:32 SQL> 
10:24:32 SQL> -- rpt
10:24:32 SQL> 
10:24:32 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:32   2  
10:24:32 SQL> SELECT MAX(tkrdate) FROM bme
10:24:32   2  
10:24:32 SQL> -- Now build model from bme and score sme
10:24:32 SQL> @score1.sql gattn
10:24:32 SQL> -- score1.sql
10:24:32 SQL> 
10:24:32 SQL> -- I use this script to send 5 params to score.sql
10:24:32 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:32 SQL> -- Then at the very end of this script I use the model
10:24:32 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:32 SQL> 
10:24:32 SQL> -- I call this script from 2 other scripts:
10:24:32 SQL> -- score1_5min.sql
10:24:32 SQL> -- score1_5min_gattn.sql
10:24:32 SQL> 
10:24:32 SQL> -- The 1st param is the name of the target attribute.
10:24:32 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:32 SQL> 
10:24:32 SQL> -- Demo:
10:24:32 SQL> -- @score1.sql 'gatt'
10:24:32 SQL> -- @score1.sql 'gattn'
10:24:32 SQL> 
10:24:32 SQL> -- Now, I fill up svmc_apply_prep.
10:24:32 SQL> -- I use same model_name used in score.sql
10:24:32 SQL> DEFINE model_name = 'svmspy101'
10:24:32 SQL> DEFINE bldtable	= 'bme'
10:24:32 SQL> DEFINE scoretable = 'sme'
10:24:32 SQL> DEFINE case_id	= 'tkrdate'
10:24:32 SQL> -- Demo:
10:24:32 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:32 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:32 SQL> --
10:24:32 SQL> -- score.sql
10:24:32 SQL> --
10:24:32 SQL> 
10:24:32 SQL> -- usage: score.sql
10:24:32 SQL> 
10:24:32 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:32 SQL> 
10:24:32 SQL> -- DEFINE target	   = 'gatt'
10:24:32 SQL> -- DEFINE model_name = 'svmspy100'
10:24:32 SQL> -- DEFINE bldtable   = 'bme'
10:24:32 SQL> -- DEFINE scoretable = 'sme'
10:24:32 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:32 SQL> 
10:24:32 SQL> DEFINE target	= '&1'
10:24:32 SQL> DEFINE model_name = '&2'
10:24:32 SQL> DEFINE bldtable	= '&3'
10:24:32 SQL> DEFINE scoretable = '&4'
10:24:32 SQL> DEFINE case_id	= '&5'
10:24:32 SQL> 
10:24:32 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:32 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:32 SQL> 
10:24:32 SQL> -- Builds an SVM model using pl/sql.
10:24:32 SQL> 
10:24:32 SQL> -----------------------------------------------------------------------
10:24:32 SQL> --			    BUILD THE MODEL
10:24:32 SQL> -----------------------------------------------------------------------
10:24:32 SQL> 
10:24:32 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:32 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:24:32 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:32 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:32 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:32 SQL> 
10:24:32 SQL> 
10:24:32 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:32 SQL> --
10:24:32 SQL> -- DROP	TABLE svmc_settings ;
10:24:32 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:32 SQL> -- DELETE svmc_settings;
10:24:32 SQL> 
10:24:32 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:32 SQL> -- this choice to SVM using a settings table.
10:24:32 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:32 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:32 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:32 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:32 SQL> -- models.
10:24:32 SQL> --
10:24:32 SQL> 
10:24:32 SQL> -- Do this once and then comment it out.
10:24:32 SQL> -- That makes script go faster.
10:24:32 SQL> -- BEGIN
10:24:32 SQL> -- -- Populate settings table
10:24:32 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:32 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:32 SQL> --
10:24:32 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:32 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:32 SQL> --
10:24:32 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:32 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:32 SQL> --   COMMIT;
10:24:32 SQL> -- END;
10:24:32 SQL> -- /
10:24:32 SQL> 
10:24:32 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:32 SQL> 
10:24:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:32 SQL> 
10:24:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:32 SQL> 
10:24:32 SQL> --------------------------------
10:24:32 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:32 SQL> --
10:24:32 SQL> 
10:24:32 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:32 SQL> -- 2. Outlier Treatment and
10:24:32 SQL> -- 3. Normalization are performed below.
10:24:32 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:32 SQL> --    normalized here.
10:24:32 SQL> 
10:24:32 SQL> BEGIN
10:24:32   2  	-- Perform missing value treatment for all predictors
10:24:32   3  	-- create miss tables
10:24:32   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:32   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:32   6  
10:24:32   7  	-- populate miss tables
10:24:32   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:32   9  	  miss_table_name => 'svmc_miss_num',
10:24:32  10  	  data_table_name => '&bldtable',
10:24:32  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:32  12  
10:24:32  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:32  14  	  miss_table_name => 'svmc_miss_cat',
10:24:32  15  	  data_table_name => '&bldtable',
10:24:32  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:32  17  
10:24:32  18  	-- xform input data to replace missing values
10:24:32  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:32  20  	  miss_table_name => 'svmc_miss_num',
10:24:32  21  	  data_table_name => '&bldtable',
10:24:32  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:32  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:32  24  	  miss_table_name => 'svmc_miss_cat',
10:24:32  25  	  data_table_name => '&bldtable',
10:24:32  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:32  27  
10:24:32  28  	-- Perform outlier treatment.
10:24:32  29  	-- create clip table
10:24:32  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:32  31  
10:24:32  32  	-- populate clip table
10:24:32  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:32  34  	  clip_table_name => 'svmc_clip',
10:24:32  35  	  data_table_name => '&bldtable',
10:24:32  36  	  tail_frac	  => 0.025,
10:24:32  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:32  38  
10:24:32  39  	-- xform input data to winsorized data
10:24:32  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:32  41  	  clip_table_name => 'svmc_clip',
10:24:32  42  	  data_table_name => '&bldtable',
10:24:32  43  	  xform_view_name => 'svmc_winsor');
10:24:32  44  
10:24:32  45  	-- create normalization table
10:24:32  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:32  47  
10:24:32  48  	-- populate normalization table based on winsorized data
10:24:32  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:32  50  	  norm_table_name => 'svmc_norm',
10:24:32  51  	  data_table_name => 'svmc_winsor',
10:24:32  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:32  53  
10:24:32  54  	-- normalize the original data
10:24:32  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:32  56  	  norm_table_name => 'svmc_norm',
10:24:32  57  	  data_table_name => '&bldtable',
10:24:32  58  	  xform_view_name => 'svmc_build_prep');
10:24:32  59  END;
10:24:32  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:24:33 SQL> 
10:24:33 SQL> ---------------------
10:24:33 SQL> -- CREATE A NEW MODEL
10:24:33 SQL> --
10:24:33 SQL> -- Cleanup old model with the same name for repeat runs
10:24:33 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:33   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.35
10:24:34 SQL> 
10:24:34 SQL> -- Build a new SVM Model
10:24:34 SQL> BEGIN
10:24:34   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:34   3  	  model_name	      => '&model_name',
10:24:34   4  	  mining_function     => dbms_data_mining.classification,
10:24:34   5  	  data_table_name     => 'svmc_build_prep',
10:24:34   6  	  case_id_column_name => '&case_id',
10:24:34   7  	  target_column_name  => '&target',
10:24:34   8  	  settings_table_name => 'svmc_settings');
10:24:34   9  END;
10:24:34  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.05
10:24:36 SQL> 
10:24:36 SQL> -----------------------------------------------------------------------
10:24:36 SQL> --			       APPLY/score THE MODEL
10:24:36 SQL> -----------------------------------------------------------------------
10:24:36 SQL> 
10:24:36 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:36 SQL> -----------------------
10:24:36 SQL> -- PREPARE SCORING DATA
10:24:36 SQL> --
10:24:36 SQL> -- If the data for model creation has been prepared, then the data
10:24:36 SQL> -- to be scored using the model must be prepared in the same manner
10:24:36 SQL> -- in order to obtain meaningful results.
10:24:36 SQL> --
10:24:36 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:36 SQL> -- 2. Normalization
10:24:36 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:36 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:36 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:36 SQL> --
10:24:36 SQL> BEGIN
10:24:36   2  	-- Xform Test data to replace missing values
10:24:36   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:36   4  	  miss_table_name => 'svmc_miss_num',
10:24:36   5  	  data_table_name => '&scoretable',
10:24:36   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:36   7  
10:24:36   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:36   9  	  miss_table_name => 'svmc_miss_cat',
10:24:36  10  	  data_table_name => '&scoretable',
10:24:36  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:36  12  
10:24:36  13  	-- Normalize the data to be scored
10:24:36  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:36  15  	  norm_table_name => 'svmc_norm',
10:24:36  16  	  data_table_name => '&scoretable',
10:24:36  17  	  xform_view_name => 'svmc_apply_prep');
10:24:36  18  END;
10:24:36  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:24:36 SQL> 
10:24:36 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:36 SQL> -- DELETE it if I did:
10:24:36 SQL> DELETE ystkscores
10:24:36   2  WHERE score > 0
10:24:36   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:36   4  -- I need to supply the target attribute name:
10:24:36   5  AND targ = '&1'
10:24:36   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:24:36 SQL> 
10:24:36 SQL> -- We do a drumroll here:
10:24:36 SQL> 
10:24:36 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:36   2  SELECT
10:24:36   3  tkrdate
10:24:36   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:36   5  ,sysdate
10:24:36   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:36   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:36   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:36   9  ,SUBSTR(tkrdate,-10)ydate
10:24:36  10  ,'&1'
10:24:36  11  FROM svmc_apply_prep
10:24:36  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:24:36 SQL> @score1_5min_gattn.sql	2010-11-17 TLT
10:24:36 SQL> --
10:24:36 SQL> -- score1_5min_gattn.sql
10:24:36 SQL> --
10:24:36 SQL> 
10:24:36 SQL> -- Demo:
10:24:36 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:36 SQL> 
10:24:36 SQL> CREATE OR REPLACE VIEW sme AS
10:24:36   2  SELECT
10:24:36   3  tkrdate
10:24:36   4  ,NULL gattn
10:24:36   5  ,g00
10:24:36   6  ,g01
10:24:36   7  ,g02
10:24:36   8  ,g03
10:24:36   9  ,g04
10:24:36  10  ,g05
10:24:36  11  ,g06
10:24:36  12  ,g07
10:24:36  13  ,g08
10:24:36  14  ,g09
10:24:36  15  ,g10
10:24:36  16  ,g11
10:24:36  17  ,g12
10:24:36  18  ,g13
10:24:36  19  ,g14
10:24:36  20  ,g15
10:24:36  21  ,g16
10:24:36  22  ,g17
10:24:36  23  ,g18
10:24:36  24  ,g19
10:24:36  25  ,g20
10:24:36  26  ,g21
10:24:36  27  ,g22
10:24:36  28  ,g23
10:24:36  29  ,g24
10:24:36  30  ,g25
10:24:36  31  ,g26
10:24:36  32  ,g27
10:24:36  33  ,g28
10:24:36  34  ,g29
10:24:36  35  FROM stk_ms
10:24:36  36  WHERE ydate = '&1'
10:24:36  37  AND tkr = '&2'
10:24:36  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-17'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:36 SQL> 
10:24:36 SQL> -- rpt
10:24:36 SQL> -- We should see just 1 row:
10:24:36 SQL> 
10:24:36 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:36   2  
10:24:36 SQL> -- Build the model:
10:24:36 SQL> CREATE OR REPLACE VIEW bme AS
10:24:36   2  SELECT
10:24:36   3  tkrdate
10:24:36   4  ,gattn
10:24:36   5  ,g00
10:24:36   6  ,g01
10:24:36   7  ,g02
10:24:36   8  ,g03
10:24:36   9  ,g04
10:24:36  10  ,g05
10:24:36  11  ,g06
10:24:36  12  ,g07
10:24:36  13  ,g08
10:24:36  14  ,g09
10:24:36  15  ,g10
10:24:36  16  ,g11
10:24:36  17  ,g12
10:24:36  18  ,g13
10:24:36  19  ,g14
10:24:36  20  ,g15
10:24:36  21  ,g16
10:24:36  22  ,g17
10:24:36  23  ,g18
10:24:36  24  ,g19
10:24:36  25  ,g20
10:24:36  26  ,g21
10:24:36  27  ,g22
10:24:36  28  ,g23
10:24:36  29  ,g24
10:24:36  30  ,g25
10:24:36  31  ,g26
10:24:36  32  ,g27
10:24:36  33  ,g28
10:24:36  34  ,g29
10:24:36  35  FROM stk_ms
10:24:36  36  WHERE gattn IN('nup','up')
10:24:36  37  -- Use only rows which are older than 1 day:
10:24:36  38  AND 1+ydate < '&1'
10:24:36  39  AND tkr = '&2'
10:24:36  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-17'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.06
10:24:36 SQL> 
10:24:36 SQL> -- rpt
10:24:36 SQL> 
10:24:36 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:36   2  
10:24:36 SQL> SELECT MAX(tkrdate) FROM bme
10:24:36   2  
10:24:36 SQL> -- Now build model from bme and score sme
10:24:36 SQL> @score1.sql gattn
10:24:36 SQL> -- score1.sql
10:24:36 SQL> 
10:24:36 SQL> -- I use this script to send 5 params to score.sql
10:24:36 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:36 SQL> -- Then at the very end of this script I use the model
10:24:36 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:36 SQL> 
10:24:36 SQL> -- I call this script from 2 other scripts:
10:24:36 SQL> -- score1_5min.sql
10:24:36 SQL> -- score1_5min_gattn.sql
10:24:36 SQL> 
10:24:36 SQL> -- The 1st param is the name of the target attribute.
10:24:36 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:36 SQL> 
10:24:36 SQL> -- Demo:
10:24:36 SQL> -- @score1.sql 'gatt'
10:24:36 SQL> -- @score1.sql 'gattn'
10:24:36 SQL> 
10:24:36 SQL> -- Now, I fill up svmc_apply_prep.
10:24:36 SQL> -- I use same model_name used in score.sql
10:24:36 SQL> DEFINE model_name = 'svmspy101'
10:24:36 SQL> DEFINE bldtable	= 'bme'
10:24:36 SQL> DEFINE scoretable = 'sme'
10:24:36 SQL> DEFINE case_id	= 'tkrdate'
10:24:36 SQL> -- Demo:
10:24:36 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:36 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:36 SQL> --
10:24:36 SQL> -- score.sql
10:24:36 SQL> --
10:24:36 SQL> 
10:24:36 SQL> -- usage: score.sql
10:24:36 SQL> 
10:24:36 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:36 SQL> 
10:24:36 SQL> -- DEFINE target	   = 'gatt'
10:24:36 SQL> -- DEFINE model_name = 'svmspy100'
10:24:36 SQL> -- DEFINE bldtable   = 'bme'
10:24:36 SQL> -- DEFINE scoretable = 'sme'
10:24:36 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:36 SQL> 
10:24:36 SQL> DEFINE target	= '&1'
10:24:36 SQL> DEFINE model_name = '&2'
10:24:36 SQL> DEFINE bldtable	= '&3'
10:24:36 SQL> DEFINE scoretable = '&4'
10:24:36 SQL> DEFINE case_id	= '&5'
10:24:36 SQL> 
10:24:36 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:36 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:36 SQL> 
10:24:36 SQL> -- Builds an SVM model using pl/sql.
10:24:36 SQL> 
10:24:36 SQL> -----------------------------------------------------------------------
10:24:36 SQL> --			    BUILD THE MODEL
10:24:36 SQL> -----------------------------------------------------------------------
10:24:36 SQL> 
10:24:36 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:36 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:24:36 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:36 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:36 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:36 SQL> 
10:24:36 SQL> 
10:24:36 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:36 SQL> --
10:24:36 SQL> -- DROP	TABLE svmc_settings ;
10:24:36 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:36 SQL> -- DELETE svmc_settings;
10:24:36 SQL> 
10:24:36 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:36 SQL> -- this choice to SVM using a settings table.
10:24:36 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:36 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:36 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:36 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:36 SQL> -- models.
10:24:36 SQL> --
10:24:36 SQL> 
10:24:36 SQL> -- Do this once and then comment it out.
10:24:36 SQL> -- That makes script go faster.
10:24:36 SQL> -- BEGIN
10:24:36 SQL> -- -- Populate settings table
10:24:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:36 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:36 SQL> --
10:24:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:36 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:36 SQL> --
10:24:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:36 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:36 SQL> --   COMMIT;
10:24:36 SQL> -- END;
10:24:36 SQL> -- /
10:24:36 SQL> 
10:24:36 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:36 SQL> 
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:36 SQL> 
10:24:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:37 SQL> 
10:24:37 SQL> --------------------------------
10:24:37 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:37 SQL> --
10:24:37 SQL> 
10:24:37 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:37 SQL> -- 2. Outlier Treatment and
10:24:37 SQL> -- 3. Normalization are performed below.
10:24:37 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:37 SQL> --    normalized here.
10:24:37 SQL> 
10:24:37 SQL> BEGIN
10:24:37   2  	-- Perform missing value treatment for all predictors
10:24:37   3  	-- create miss tables
10:24:37   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:37   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:37   6  
10:24:37   7  	-- populate miss tables
10:24:37   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:37   9  	  miss_table_name => 'svmc_miss_num',
10:24:37  10  	  data_table_name => '&bldtable',
10:24:37  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:37  12  
10:24:37  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:37  14  	  miss_table_name => 'svmc_miss_cat',
10:24:37  15  	  data_table_name => '&bldtable',
10:24:37  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:37  17  
10:24:37  18  	-- xform input data to replace missing values
10:24:37  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:37  20  	  miss_table_name => 'svmc_miss_num',
10:24:37  21  	  data_table_name => '&bldtable',
10:24:37  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:37  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:37  24  	  miss_table_name => 'svmc_miss_cat',
10:24:37  25  	  data_table_name => '&bldtable',
10:24:37  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:37  27  
10:24:37  28  	-- Perform outlier treatment.
10:24:37  29  	-- create clip table
10:24:37  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:37  31  
10:24:37  32  	-- populate clip table
10:24:37  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:37  34  	  clip_table_name => 'svmc_clip',
10:24:37  35  	  data_table_name => '&bldtable',
10:24:37  36  	  tail_frac	  => 0.025,
10:24:37  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:37  38  
10:24:37  39  	-- xform input data to winsorized data
10:24:37  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:37  41  	  clip_table_name => 'svmc_clip',
10:24:37  42  	  data_table_name => '&bldtable',
10:24:37  43  	  xform_view_name => 'svmc_winsor');
10:24:37  44  
10:24:37  45  	-- create normalization table
10:24:37  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:37  47  
10:24:37  48  	-- populate normalization table based on winsorized data
10:24:37  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:37  50  	  norm_table_name => 'svmc_norm',
10:24:37  51  	  data_table_name => 'svmc_winsor',
10:24:37  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:37  53  
10:24:37  54  	-- normalize the original data
10:24:37  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:37  56  	  norm_table_name => 'svmc_norm',
10:24:37  57  	  data_table_name => '&bldtable',
10:24:37  58  	  xform_view_name => 'svmc_build_prep');
10:24:37  59  END;
10:24:37  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.65
10:24:37 SQL> 
10:24:37 SQL> ---------------------
10:24:37 SQL> -- CREATE A NEW MODEL
10:24:37 SQL> --
10:24:37 SQL> -- Cleanup old model with the same name for repeat runs
10:24:37 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:37   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.97
10:24:38 SQL> 
10:24:38 SQL> -- Build a new SVM Model
10:24:38 SQL> BEGIN
10:24:38   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:38   3  	  model_name	      => '&model_name',
10:24:38   4  	  mining_function     => dbms_data_mining.classification,
10:24:38   5  	  data_table_name     => 'svmc_build_prep',
10:24:38   6  	  case_id_column_name => '&case_id',
10:24:38   7  	  target_column_name  => '&target',
10:24:38   8  	  settings_table_name => 'svmc_settings');
10:24:38   9  END;
10:24:38  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.56
10:24:41 SQL> 
10:24:41 SQL> -----------------------------------------------------------------------
10:24:41 SQL> --			       APPLY/score THE MODEL
10:24:41 SQL> -----------------------------------------------------------------------
10:24:41 SQL> 
10:24:41 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:41 SQL> -----------------------
10:24:41 SQL> -- PREPARE SCORING DATA
10:24:41 SQL> --
10:24:41 SQL> -- If the data for model creation has been prepared, then the data
10:24:41 SQL> -- to be scored using the model must be prepared in the same manner
10:24:41 SQL> -- in order to obtain meaningful results.
10:24:41 SQL> --
10:24:41 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:41 SQL> -- 2. Normalization
10:24:41 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:41 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:41 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:41 SQL> --
10:24:41 SQL> BEGIN
10:24:41   2  	-- Xform Test data to replace missing values
10:24:41   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:41   4  	  miss_table_name => 'svmc_miss_num',
10:24:41   5  	  data_table_name => '&scoretable',
10:24:41   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:41   7  
10:24:41   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:41   9  	  miss_table_name => 'svmc_miss_cat',
10:24:41  10  	  data_table_name => '&scoretable',
10:24:41  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:41  12  
10:24:41  13  	-- Normalize the data to be scored
10:24:41  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:41  15  	  norm_table_name => 'svmc_norm',
10:24:41  16  	  data_table_name => '&scoretable',
10:24:41  17  	  xform_view_name => 'svmc_apply_prep');
10:24:41  18  END;
10:24:41  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:41 SQL> 
10:24:41 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:41 SQL> -- DELETE it if I did:
10:24:41 SQL> DELETE ystkscores
10:24:41   2  WHERE score > 0
10:24:41   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:41   4  -- I need to supply the target attribute name:
10:24:41   5  AND targ = '&1'
10:24:41   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:41 SQL> 
10:24:41 SQL> -- We do a drumroll here:
10:24:41 SQL> 
10:24:41 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:41   2  SELECT
10:24:41   3  tkrdate
10:24:41   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:41   5  ,sysdate
10:24:41   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:41   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:41   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:41   9  ,SUBSTR(tkrdate,-10)ydate
10:24:41  10  ,'&1'
10:24:41  11  FROM svmc_apply_prep
10:24:41  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:24:41 SQL> @score1_5min_gattn.sql	2010-08-17 TLT
10:24:41 SQL> --
10:24:41 SQL> -- score1_5min_gattn.sql
10:24:41 SQL> --
10:24:41 SQL> 
10:24:41 SQL> -- Demo:
10:24:41 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:41 SQL> 
10:24:41 SQL> CREATE OR REPLACE VIEW sme AS
10:24:41   2  SELECT
10:24:41   3  tkrdate
10:24:41   4  ,NULL gattn
10:24:41   5  ,g00
10:24:41   6  ,g01
10:24:41   7  ,g02
10:24:41   8  ,g03
10:24:41   9  ,g04
10:24:41  10  ,g05
10:24:41  11  ,g06
10:24:41  12  ,g07
10:24:41  13  ,g08
10:24:41  14  ,g09
10:24:41  15  ,g10
10:24:41  16  ,g11
10:24:41  17  ,g12
10:24:41  18  ,g13
10:24:41  19  ,g14
10:24:41  20  ,g15
10:24:41  21  ,g16
10:24:41  22  ,g17
10:24:41  23  ,g18
10:24:41  24  ,g19
10:24:41  25  ,g20
10:24:41  26  ,g21
10:24:41  27  ,g22
10:24:41  28  ,g23
10:24:41  29  ,g24
10:24:41  30  ,g25
10:24:41  31  ,g26
10:24:41  32  ,g27
10:24:41  33  ,g28
10:24:41  34  ,g29
10:24:41  35  FROM stk_ms
10:24:41  36  WHERE ydate = '&1'
10:24:41  37  AND tkr = '&2'
10:24:41  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-17'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:41 SQL> 
10:24:41 SQL> -- rpt
10:24:41 SQL> -- We should see just 1 row:
10:24:41 SQL> 
10:24:41 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:41   2  
10:24:41 SQL> -- Build the model:
10:24:41 SQL> CREATE OR REPLACE VIEW bme AS
10:24:41   2  SELECT
10:24:41   3  tkrdate
10:24:41   4  ,gattn
10:24:41   5  ,g00
10:24:41   6  ,g01
10:24:41   7  ,g02
10:24:41   8  ,g03
10:24:41   9  ,g04
10:24:41  10  ,g05
10:24:41  11  ,g06
10:24:41  12  ,g07
10:24:41  13  ,g08
10:24:41  14  ,g09
10:24:41  15  ,g10
10:24:41  16  ,g11
10:24:41  17  ,g12
10:24:41  18  ,g13
10:24:41  19  ,g14
10:24:41  20  ,g15
10:24:41  21  ,g16
10:24:41  22  ,g17
10:24:41  23  ,g18
10:24:41  24  ,g19
10:24:41  25  ,g20
10:24:41  26  ,g21
10:24:41  27  ,g22
10:24:41  28  ,g23
10:24:41  29  ,g24
10:24:41  30  ,g25
10:24:41  31  ,g26
10:24:41  32  ,g27
10:24:41  33  ,g28
10:24:41  34  ,g29
10:24:41  35  FROM stk_ms
10:24:41  36  WHERE gattn IN('nup','up')
10:24:41  37  -- Use only rows which are older than 1 day:
10:24:41  38  AND 1+ydate < '&1'
10:24:41  39  AND tkr = '&2'
10:24:41  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-17'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:41 SQL> 
10:24:41 SQL> -- rpt
10:24:41 SQL> 
10:24:41 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:41   2  
10:24:41 SQL> SELECT MAX(tkrdate) FROM bme
10:24:41   2  
10:24:41 SQL> -- Now build model from bme and score sme
10:24:41 SQL> @score1.sql gattn
10:24:41 SQL> -- score1.sql
10:24:41 SQL> 
10:24:41 SQL> -- I use this script to send 5 params to score.sql
10:24:41 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:41 SQL> -- Then at the very end of this script I use the model
10:24:41 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:41 SQL> 
10:24:41 SQL> -- I call this script from 2 other scripts:
10:24:41 SQL> -- score1_5min.sql
10:24:41 SQL> -- score1_5min_gattn.sql
10:24:41 SQL> 
10:24:41 SQL> -- The 1st param is the name of the target attribute.
10:24:41 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:41 SQL> 
10:24:41 SQL> -- Demo:
10:24:41 SQL> -- @score1.sql 'gatt'
10:24:41 SQL> -- @score1.sql 'gattn'
10:24:41 SQL> 
10:24:41 SQL> -- Now, I fill up svmc_apply_prep.
10:24:41 SQL> -- I use same model_name used in score.sql
10:24:41 SQL> DEFINE model_name = 'svmspy101'
10:24:41 SQL> DEFINE bldtable	= 'bme'
10:24:41 SQL> DEFINE scoretable = 'sme'
10:24:41 SQL> DEFINE case_id	= 'tkrdate'
10:24:41 SQL> -- Demo:
10:24:41 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:41 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:41 SQL> --
10:24:41 SQL> -- score.sql
10:24:41 SQL> --
10:24:41 SQL> 
10:24:41 SQL> -- usage: score.sql
10:24:41 SQL> 
10:24:41 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:41 SQL> 
10:24:41 SQL> -- DEFINE target	   = 'gatt'
10:24:41 SQL> -- DEFINE model_name = 'svmspy100'
10:24:41 SQL> -- DEFINE bldtable   = 'bme'
10:24:41 SQL> -- DEFINE scoretable = 'sme'
10:24:41 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:41 SQL> 
10:24:41 SQL> DEFINE target	= '&1'
10:24:41 SQL> DEFINE model_name = '&2'
10:24:41 SQL> DEFINE bldtable	= '&3'
10:24:41 SQL> DEFINE scoretable = '&4'
10:24:41 SQL> DEFINE case_id	= '&5'
10:24:41 SQL> 
10:24:41 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:41 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:41 SQL> 
10:24:41 SQL> -- Builds an SVM model using pl/sql.
10:24:41 SQL> 
10:24:41 SQL> -----------------------------------------------------------------------
10:24:41 SQL> --			    BUILD THE MODEL
10:24:41 SQL> -----------------------------------------------------------------------
10:24:41 SQL> 
10:24:41 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:41 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:41 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:24:41 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:41 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:41 SQL> 
10:24:41 SQL> 
10:24:41 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:41 SQL> --
10:24:41 SQL> -- DROP	TABLE svmc_settings ;
10:24:41 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:41 SQL> -- DELETE svmc_settings;
10:24:41 SQL> 
10:24:41 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:41 SQL> -- this choice to SVM using a settings table.
10:24:41 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:41 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:41 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:41 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:41 SQL> -- models.
10:24:41 SQL> --
10:24:41 SQL> 
10:24:41 SQL> -- Do this once and then comment it out.
10:24:41 SQL> -- That makes script go faster.
10:24:41 SQL> -- BEGIN
10:24:41 SQL> -- -- Populate settings table
10:24:41 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:41 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:41 SQL> --
10:24:41 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:41 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:41 SQL> --
10:24:41 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:41 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:41 SQL> --   COMMIT;
10:24:41 SQL> -- END;
10:24:41 SQL> -- /
10:24:41 SQL> 
10:24:41 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:41 SQL> 
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:41 SQL> 
10:24:41 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:41   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:41 SQL> 
10:24:41 SQL> --------------------------------
10:24:41 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:41 SQL> --
10:24:41 SQL> 
10:24:41 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:41 SQL> -- 2. Outlier Treatment and
10:24:41 SQL> -- 3. Normalization are performed below.
10:24:41 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:41 SQL> --    normalized here.
10:24:41 SQL> 
10:24:41 SQL> BEGIN
10:24:41   2  	-- Perform missing value treatment for all predictors
10:24:41   3  	-- create miss tables
10:24:41   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:41   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:41   6  
10:24:41   7  	-- populate miss tables
10:24:41   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:41   9  	  miss_table_name => 'svmc_miss_num',
10:24:41  10  	  data_table_name => '&bldtable',
10:24:41  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:41  12  
10:24:41  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:41  14  	  miss_table_name => 'svmc_miss_cat',
10:24:41  15  	  data_table_name => '&bldtable',
10:24:41  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:41  17  
10:24:41  18  	-- xform input data to replace missing values
10:24:41  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:41  20  	  miss_table_name => 'svmc_miss_num',
10:24:41  21  	  data_table_name => '&bldtable',
10:24:41  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:41  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:41  24  	  miss_table_name => 'svmc_miss_cat',
10:24:41  25  	  data_table_name => '&bldtable',
10:24:41  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:41  27  
10:24:41  28  	-- Perform outlier treatment.
10:24:41  29  	-- create clip table
10:24:41  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:41  31  
10:24:41  32  	-- populate clip table
10:24:41  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:41  34  	  clip_table_name => 'svmc_clip',
10:24:41  35  	  data_table_name => '&bldtable',
10:24:41  36  	  tail_frac	  => 0.025,
10:24:41  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:41  38  
10:24:41  39  	-- xform input data to winsorized data
10:24:41  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:41  41  	  clip_table_name => 'svmc_clip',
10:24:41  42  	  data_table_name => '&bldtable',
10:24:41  43  	  xform_view_name => 'svmc_winsor');
10:24:41  44  
10:24:41  45  	-- create normalization table
10:24:41  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:41  47  
10:24:41  48  	-- populate normalization table based on winsorized data
10:24:41  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:41  50  	  norm_table_name => 'svmc_norm',
10:24:41  51  	  data_table_name => 'svmc_winsor',
10:24:41  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:41  53  
10:24:41  54  	-- normalize the original data
10:24:41  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:41  56  	  norm_table_name => 'svmc_norm',
10:24:41  57  	  data_table_name => '&bldtable',
10:24:41  58  	  xform_view_name => 'svmc_build_prep');
10:24:41  59  END;
10:24:41  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:24:42 SQL> 
10:24:42 SQL> ---------------------
10:24:42 SQL> -- CREATE A NEW MODEL
10:24:42 SQL> --
10:24:42 SQL> -- Cleanup old model with the same name for repeat runs
10:24:42 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:42   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.41
10:24:43 SQL> 
10:24:43 SQL> -- Build a new SVM Model
10:24:43 SQL> BEGIN
10:24:43   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:43   3  	  model_name	      => '&model_name',
10:24:43   4  	  mining_function     => dbms_data_mining.classification,
10:24:43   5  	  data_table_name     => 'svmc_build_prep',
10:24:43   6  	  case_id_column_name => '&case_id',
10:24:43   7  	  target_column_name  => '&target',
10:24:43   8  	  settings_table_name => 'svmc_settings');
10:24:43   9  END;
10:24:43  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.11
10:24:45 SQL> 
10:24:45 SQL> -----------------------------------------------------------------------
10:24:45 SQL> --			       APPLY/score THE MODEL
10:24:45 SQL> -----------------------------------------------------------------------
10:24:45 SQL> 
10:24:45 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:45 SQL> -----------------------
10:24:45 SQL> -- PREPARE SCORING DATA
10:24:45 SQL> --
10:24:45 SQL> -- If the data for model creation has been prepared, then the data
10:24:45 SQL> -- to be scored using the model must be prepared in the same manner
10:24:45 SQL> -- in order to obtain meaningful results.
10:24:45 SQL> --
10:24:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:45 SQL> -- 2. Normalization
10:24:45 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:45 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:45 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:45 SQL> --
10:24:45 SQL> BEGIN
10:24:45   2  	-- Xform Test data to replace missing values
10:24:45   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:45   4  	  miss_table_name => 'svmc_miss_num',
10:24:45   5  	  data_table_name => '&scoretable',
10:24:45   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:45   7  
10:24:45   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:45   9  	  miss_table_name => 'svmc_miss_cat',
10:24:45  10  	  data_table_name => '&scoretable',
10:24:45  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:45  12  
10:24:45  13  	-- Normalize the data to be scored
10:24:45  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:45  15  	  norm_table_name => 'svmc_norm',
10:24:45  16  	  data_table_name => '&scoretable',
10:24:45  17  	  xform_view_name => 'svmc_apply_prep');
10:24:45  18  END;
10:24:45  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
10:24:46 SQL> 
10:24:46 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:46 SQL> -- DELETE it if I did:
10:24:46 SQL> DELETE ystkscores
10:24:46   2  WHERE score > 0
10:24:46   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:46   4  -- I need to supply the target attribute name:
10:24:46   5  AND targ = '&1'
10:24:46   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:24:46 SQL> 
10:24:46 SQL> -- We do a drumroll here:
10:24:46 SQL> 
10:24:46 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:46   2  SELECT
10:24:46   3  tkrdate
10:24:46   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:46   5  ,sysdate
10:24:46   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:46   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:46   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:46   9  ,SUBSTR(tkrdate,-10)ydate
10:24:46  10  ,'&1'
10:24:46  11  FROM svmc_apply_prep
10:24:46  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:24:46 SQL> @score1_5min.sql	      2010-01-15 TLT
10:24:46 SQL> --
10:24:46 SQL> -- score1_5min.sql
10:24:46 SQL> --
10:24:46 SQL> 
10:24:46 SQL> -- Demo:
10:24:46 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:24:46 SQL> 
10:24:46 SQL> CREATE OR REPLACE VIEW sme AS
10:24:46   2  SELECT
10:24:46   3  tkrdate
10:24:46   4  ,NULL gatt
10:24:46   5  ,g00
10:24:46   6  ,g01
10:24:46   7  ,g02
10:24:46   8  ,g03
10:24:46   9  ,g04
10:24:46  10  ,g05
10:24:46  11  ,g06
10:24:46  12  ,g07
10:24:46  13  ,g08
10:24:46  14  ,g09
10:24:46  15  ,g10
10:24:46  16  ,g11
10:24:46  17  ,g12
10:24:46  18  ,g13
10:24:46  19  ,g14
10:24:46  20  ,g15
10:24:46  21  ,g16
10:24:46  22  ,g17
10:24:46  23  ,g18
10:24:46  24  ,g19
10:24:46  25  ,g20
10:24:46  26  ,g21
10:24:46  27  ,g22
10:24:46  28  ,g23
10:24:46  29  ,g24
10:24:46  30  ,g25
10:24:46  31  ,g26
10:24:46  32  ,g27
10:24:46  33  ,g28
10:24:46  34  ,g29
10:24:46  35  FROM stk_ms
10:24:46  36  WHERE ydate = '&1'
10:24:46  37  AND tkr = '&2'
10:24:46  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-15'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.38
10:24:46 SQL> 
10:24:46 SQL> -- rpt
10:24:46 SQL> -- We should see just 1 row:
10:24:46 SQL> 
10:24:46 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:46   2  
10:24:46 SQL> -- Build the model:
10:24:46 SQL> CREATE OR REPLACE VIEW bme AS
10:24:46   2  SELECT
10:24:46   3  tkrdate
10:24:46   4  ,gatt
10:24:46   5  ,g00
10:24:46   6  ,g01
10:24:46   7  ,g02
10:24:46   8  ,g03
10:24:46   9  ,g04
10:24:46  10  ,g05
10:24:46  11  ,g06
10:24:46  12  ,g07
10:24:46  13  ,g08
10:24:46  14  ,g09
10:24:46  15  ,g10
10:24:46  16  ,g11
10:24:46  17  ,g12
10:24:46  18  ,g13
10:24:46  19  ,g14
10:24:46  20  ,g15
10:24:46  21  ,g16
10:24:46  22  ,g17
10:24:46  23  ,g18
10:24:46  24  ,g19
10:24:46  25  ,g20
10:24:46  26  ,g21
10:24:46  27  ,g22
10:24:46  28  ,g23
10:24:46  29  ,g24
10:24:46  30  ,g25
10:24:46  31  ,g26
10:24:46  32  ,g27
10:24:46  33  ,g28
10:24:46  34  ,g29
10:24:46  35  FROM stk_ms
10:24:46  36  WHERE gatt IN('nup','up')
10:24:46  37  -- Use only rows which are older than 1 day:
10:24:46  38  AND 1+ydate < '&1'
10:24:46  39  AND tkr = '&2'
10:24:46  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-15'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.13
10:24:46 SQL> 
10:24:46 SQL> -- rpt
10:24:46 SQL> 
10:24:46 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:24:46   2  
10:24:46 SQL> SELECT MAX(tkrdate) FROM bme
10:24:46   2  
10:24:46 SQL> -- Now build model from bme and score sme
10:24:46 SQL> @score1.sql gatt
10:24:46 SQL> -- score1.sql
10:24:46 SQL> 
10:24:46 SQL> -- I use this script to send 5 params to score.sql
10:24:46 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:46 SQL> -- Then at the very end of this script I use the model
10:24:46 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:46 SQL> 
10:24:46 SQL> -- I call this script from 2 other scripts:
10:24:46 SQL> -- score1_5min.sql
10:24:46 SQL> -- score1_5min_gattn.sql
10:24:46 SQL> 
10:24:46 SQL> -- The 1st param is the name of the target attribute.
10:24:46 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:46 SQL> 
10:24:46 SQL> -- Demo:
10:24:46 SQL> -- @score1.sql 'gatt'
10:24:46 SQL> -- @score1.sql 'gattn'
10:24:46 SQL> 
10:24:46 SQL> -- Now, I fill up svmc_apply_prep.
10:24:46 SQL> -- I use same model_name used in score.sql
10:24:46 SQL> DEFINE model_name = 'svmspy101'
10:24:46 SQL> DEFINE bldtable	= 'bme'
10:24:46 SQL> DEFINE scoretable = 'sme'
10:24:46 SQL> DEFINE case_id	= 'tkrdate'
10:24:46 SQL> -- Demo:
10:24:46 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:46 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:46 SQL> --
10:24:46 SQL> -- score.sql
10:24:46 SQL> --
10:24:46 SQL> 
10:24:46 SQL> -- usage: score.sql
10:24:46 SQL> 
10:24:46 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:46 SQL> 
10:24:46 SQL> -- DEFINE target	   = 'gatt'
10:24:46 SQL> -- DEFINE model_name = 'svmspy100'
10:24:46 SQL> -- DEFINE bldtable   = 'bme'
10:24:46 SQL> -- DEFINE scoretable = 'sme'
10:24:46 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:46 SQL> 
10:24:46 SQL> DEFINE target	= '&1'
10:24:46 SQL> DEFINE model_name = '&2'
10:24:46 SQL> DEFINE bldtable	= '&3'
10:24:46 SQL> DEFINE scoretable = '&4'
10:24:46 SQL> DEFINE case_id	= '&5'
10:24:46 SQL> 
10:24:46 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:46 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:46 SQL> 
10:24:46 SQL> -- Builds an SVM model using pl/sql.
10:24:46 SQL> 
10:24:46 SQL> -----------------------------------------------------------------------
10:24:46 SQL> --			    BUILD THE MODEL
10:24:46 SQL> -----------------------------------------------------------------------
10:24:46 SQL> 
10:24:46 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:46 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:46 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:46 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:46 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:46 SQL> 
10:24:46 SQL> 
10:24:46 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:46 SQL> --
10:24:46 SQL> -- DROP	TABLE svmc_settings ;
10:24:46 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:46 SQL> -- DELETE svmc_settings;
10:24:46 SQL> 
10:24:46 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:46 SQL> -- this choice to SVM using a settings table.
10:24:46 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:46 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:46 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:46 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:46 SQL> -- models.
10:24:46 SQL> --
10:24:46 SQL> 
10:24:46 SQL> -- Do this once and then comment it out.
10:24:46 SQL> -- That makes script go faster.
10:24:46 SQL> -- BEGIN
10:24:46 SQL> -- -- Populate settings table
10:24:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:46 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:46 SQL> --
10:24:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:46 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:46 SQL> --
10:24:46 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:46 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:46 SQL> --   COMMIT;
10:24:46 SQL> -- END;
10:24:46 SQL> -- /
10:24:46 SQL> 
10:24:46 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:46 SQL> 
10:24:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:46 SQL> 
10:24:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:46 SQL> 
10:24:46 SQL> --------------------------------
10:24:46 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:46 SQL> --
10:24:46 SQL> 
10:24:46 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:46 SQL> -- 2. Outlier Treatment and
10:24:46 SQL> -- 3. Normalization are performed below.
10:24:46 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:46 SQL> --    normalized here.
10:24:46 SQL> 
10:24:46 SQL> BEGIN
10:24:46   2  	-- Perform missing value treatment for all predictors
10:24:46   3  	-- create miss tables
10:24:46   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:46   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:46   6  
10:24:46   7  	-- populate miss tables
10:24:46   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:46   9  	  miss_table_name => 'svmc_miss_num',
10:24:46  10  	  data_table_name => '&bldtable',
10:24:46  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:46  12  
10:24:46  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:46  14  	  miss_table_name => 'svmc_miss_cat',
10:24:46  15  	  data_table_name => '&bldtable',
10:24:46  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:46  17  
10:24:46  18  	-- xform input data to replace missing values
10:24:46  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:46  20  	  miss_table_name => 'svmc_miss_num',
10:24:46  21  	  data_table_name => '&bldtable',
10:24:46  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:46  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:46  24  	  miss_table_name => 'svmc_miss_cat',
10:24:46  25  	  data_table_name => '&bldtable',
10:24:46  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:46  27  
10:24:46  28  	-- Perform outlier treatment.
10:24:46  29  	-- create clip table
10:24:46  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:46  31  
10:24:46  32  	-- populate clip table
10:24:46  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:46  34  	  clip_table_name => 'svmc_clip',
10:24:46  35  	  data_table_name => '&bldtable',
10:24:46  36  	  tail_frac	  => 0.025,
10:24:46  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:46  38  
10:24:46  39  	-- xform input data to winsorized data
10:24:46  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:46  41  	  clip_table_name => 'svmc_clip',
10:24:46  42  	  data_table_name => '&bldtable',
10:24:46  43  	  xform_view_name => 'svmc_winsor');
10:24:46  44  
10:24:46  45  	-- create normalization table
10:24:46  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:46  47  
10:24:46  48  	-- populate normalization table based on winsorized data
10:24:46  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:46  50  	  norm_table_name => 'svmc_norm',
10:24:46  51  	  data_table_name => 'svmc_winsor',
10:24:46  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:46  53  
10:24:46  54  	-- normalize the original data
10:24:46  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:46  56  	  norm_table_name => 'svmc_norm',
10:24:46  57  	  data_table_name => '&bldtable',
10:24:46  58  	  xform_view_name => 'svmc_build_prep');
10:24:46  59  END;
10:24:46  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:24:47 SQL> 
10:24:47 SQL> ---------------------
10:24:47 SQL> -- CREATE A NEW MODEL
10:24:47 SQL> --
10:24:47 SQL> -- Cleanup old model with the same name for repeat runs
10:24:47 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:47   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.28
10:24:48 SQL> 
10:24:48 SQL> -- Build a new SVM Model
10:24:48 SQL> BEGIN
10:24:48   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:48   3  	  model_name	      => '&model_name',
10:24:48   4  	  mining_function     => dbms_data_mining.classification,
10:24:48   5  	  data_table_name     => 'svmc_build_prep',
10:24:48   6  	  case_id_column_name => '&case_id',
10:24:48   7  	  target_column_name  => '&target',
10:24:48   8  	  settings_table_name => 'svmc_settings');
10:24:48   9  END;
10:24:48  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.33
10:24:51 SQL> 
10:24:51 SQL> -----------------------------------------------------------------------
10:24:51 SQL> --			       APPLY/score THE MODEL
10:24:51 SQL> -----------------------------------------------------------------------
10:24:51 SQL> 
10:24:51 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:51 SQL> -----------------------
10:24:51 SQL> -- PREPARE SCORING DATA
10:24:51 SQL> --
10:24:51 SQL> -- If the data for model creation has been prepared, then the data
10:24:51 SQL> -- to be scored using the model must be prepared in the same manner
10:24:51 SQL> -- in order to obtain meaningful results.
10:24:51 SQL> --
10:24:51 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:51 SQL> -- 2. Normalization
10:24:51 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:51 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:51 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:51 SQL> --
10:24:51 SQL> BEGIN
10:24:51   2  	-- Xform Test data to replace missing values
10:24:51   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:51   4  	  miss_table_name => 'svmc_miss_num',
10:24:51   5  	  data_table_name => '&scoretable',
10:24:51   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:51   7  
10:24:51   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:51   9  	  miss_table_name => 'svmc_miss_cat',
10:24:51  10  	  data_table_name => '&scoretable',
10:24:51  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:51  12  
10:24:51  13  	-- Normalize the data to be scored
10:24:51  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:51  15  	  norm_table_name => 'svmc_norm',
10:24:51  16  	  data_table_name => '&scoretable',
10:24:51  17  	  xform_view_name => 'svmc_apply_prep');
10:24:51  18  END;
10:24:51  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:51 SQL> 
10:24:51 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:51 SQL> -- DELETE it if I did:
10:24:51 SQL> DELETE ystkscores
10:24:51   2  WHERE score > 0
10:24:51   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:51   4  -- I need to supply the target attribute name:
10:24:51   5  AND targ = '&1'
10:24:51   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:51 SQL> 
10:24:51 SQL> -- We do a drumroll here:
10:24:51 SQL> 
10:24:51 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:51   2  SELECT
10:24:51   3  tkrdate
10:24:51   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:51   5  ,sysdate
10:24:51   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:51   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:51   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:51   9  ,SUBSTR(tkrdate,-10)ydate
10:24:51  10  ,'&1'
10:24:51  11  FROM svmc_apply_prep
10:24:51  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:24:51 SQL> @score1_5min.sql	      2010-06-15 TLT
10:24:51 SQL> --
10:24:51 SQL> -- score1_5min.sql
10:24:51 SQL> --
10:24:51 SQL> 
10:24:51 SQL> -- Demo:
10:24:51 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:24:51 SQL> 
10:24:51 SQL> CREATE OR REPLACE VIEW sme AS
10:24:51   2  SELECT
10:24:51   3  tkrdate
10:24:51   4  ,NULL gatt
10:24:51   5  ,g00
10:24:51   6  ,g01
10:24:51   7  ,g02
10:24:51   8  ,g03
10:24:51   9  ,g04
10:24:51  10  ,g05
10:24:51  11  ,g06
10:24:51  12  ,g07
10:24:51  13  ,g08
10:24:51  14  ,g09
10:24:51  15  ,g10
10:24:51  16  ,g11
10:24:51  17  ,g12
10:24:51  18  ,g13
10:24:51  19  ,g14
10:24:51  20  ,g15
10:24:51  21  ,g16
10:24:51  22  ,g17
10:24:51  23  ,g18
10:24:51  24  ,g19
10:24:51  25  ,g20
10:24:51  26  ,g21
10:24:51  27  ,g22
10:24:51  28  ,g23
10:24:51  29  ,g24
10:24:51  30  ,g25
10:24:51  31  ,g26
10:24:51  32  ,g27
10:24:51  33  ,g28
10:24:51  34  ,g29
10:24:51  35  FROM stk_ms
10:24:51  36  WHERE ydate = '&1'
10:24:51  37  AND tkr = '&2'
10:24:51  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-15'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:51 SQL> 
10:24:51 SQL> -- rpt
10:24:51 SQL> -- We should see just 1 row:
10:24:51 SQL> 
10:24:51 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:51   2  
10:24:51 SQL> -- Build the model:
10:24:51 SQL> CREATE OR REPLACE VIEW bme AS
10:24:51   2  SELECT
10:24:51   3  tkrdate
10:24:51   4  ,gatt
10:24:51   5  ,g00
10:24:51   6  ,g01
10:24:51   7  ,g02
10:24:51   8  ,g03
10:24:51   9  ,g04
10:24:51  10  ,g05
10:24:51  11  ,g06
10:24:51  12  ,g07
10:24:51  13  ,g08
10:24:51  14  ,g09
10:24:51  15  ,g10
10:24:51  16  ,g11
10:24:51  17  ,g12
10:24:51  18  ,g13
10:24:51  19  ,g14
10:24:51  20  ,g15
10:24:51  21  ,g16
10:24:51  22  ,g17
10:24:51  23  ,g18
10:24:51  24  ,g19
10:24:51  25  ,g20
10:24:51  26  ,g21
10:24:51  27  ,g22
10:24:51  28  ,g23
10:24:51  29  ,g24
10:24:51  30  ,g25
10:24:51  31  ,g26
10:24:51  32  ,g27
10:24:51  33  ,g28
10:24:51  34  ,g29
10:24:51  35  FROM stk_ms
10:24:51  36  WHERE gatt IN('nup','up')
10:24:51  37  -- Use only rows which are older than 1 day:
10:24:51  38  AND 1+ydate < '&1'
10:24:51  39  AND tkr = '&2'
10:24:51  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-15'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:51 SQL> 
10:24:51 SQL> -- rpt
10:24:51 SQL> 
10:24:51 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:24:51   2  
10:24:51 SQL> SELECT MAX(tkrdate) FROM bme
10:24:51   2  
10:24:51 SQL> -- Now build model from bme and score sme
10:24:51 SQL> @score1.sql gatt
10:24:51 SQL> -- score1.sql
10:24:51 SQL> 
10:24:51 SQL> -- I use this script to send 5 params to score.sql
10:24:51 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:51 SQL> -- Then at the very end of this script I use the model
10:24:51 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:51 SQL> 
10:24:51 SQL> -- I call this script from 2 other scripts:
10:24:51 SQL> -- score1_5min.sql
10:24:51 SQL> -- score1_5min_gattn.sql
10:24:51 SQL> 
10:24:51 SQL> -- The 1st param is the name of the target attribute.
10:24:51 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:51 SQL> 
10:24:51 SQL> -- Demo:
10:24:51 SQL> -- @score1.sql 'gatt'
10:24:51 SQL> -- @score1.sql 'gattn'
10:24:51 SQL> 
10:24:51 SQL> -- Now, I fill up svmc_apply_prep.
10:24:51 SQL> -- I use same model_name used in score.sql
10:24:51 SQL> DEFINE model_name = 'svmspy101'
10:24:51 SQL> DEFINE bldtable	= 'bme'
10:24:51 SQL> DEFINE scoretable = 'sme'
10:24:51 SQL> DEFINE case_id	= 'tkrdate'
10:24:51 SQL> -- Demo:
10:24:51 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:51 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:51 SQL> --
10:24:51 SQL> -- score.sql
10:24:51 SQL> --
10:24:51 SQL> 
10:24:51 SQL> -- usage: score.sql
10:24:51 SQL> 
10:24:51 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:51 SQL> 
10:24:51 SQL> -- DEFINE target	   = 'gatt'
10:24:51 SQL> -- DEFINE model_name = 'svmspy100'
10:24:51 SQL> -- DEFINE bldtable   = 'bme'
10:24:51 SQL> -- DEFINE scoretable = 'sme'
10:24:51 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:51 SQL> 
10:24:51 SQL> DEFINE target	= '&1'
10:24:51 SQL> DEFINE model_name = '&2'
10:24:51 SQL> DEFINE bldtable	= '&3'
10:24:51 SQL> DEFINE scoretable = '&4'
10:24:51 SQL> DEFINE case_id	= '&5'
10:24:51 SQL> 
10:24:51 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:51 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:51 SQL> 
10:24:51 SQL> -- Builds an SVM model using pl/sql.
10:24:51 SQL> 
10:24:51 SQL> -----------------------------------------------------------------------
10:24:51 SQL> --			    BUILD THE MODEL
10:24:51 SQL> -----------------------------------------------------------------------
10:24:51 SQL> 
10:24:51 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:51 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:51 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:51 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:51 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:24:51 SQL> 
10:24:51 SQL> 
10:24:51 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:51 SQL> --
10:24:51 SQL> -- DROP	TABLE svmc_settings ;
10:24:51 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:51 SQL> -- DELETE svmc_settings;
10:24:51 SQL> 
10:24:51 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:51 SQL> -- this choice to SVM using a settings table.
10:24:51 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:51 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:51 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:51 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:51 SQL> -- models.
10:24:51 SQL> --
10:24:51 SQL> 
10:24:51 SQL> -- Do this once and then comment it out.
10:24:51 SQL> -- That makes script go faster.
10:24:51 SQL> -- BEGIN
10:24:51 SQL> -- -- Populate settings table
10:24:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:51 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:51 SQL> --
10:24:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:51 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:51 SQL> --
10:24:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:51 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:51 SQL> --   COMMIT;
10:24:51 SQL> -- END;
10:24:51 SQL> -- /
10:24:51 SQL> 
10:24:51 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:51 SQL> 
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:51 SQL> 
10:24:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:24:51 SQL> 
10:24:51 SQL> --------------------------------
10:24:51 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:51 SQL> --
10:24:51 SQL> 
10:24:51 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:51 SQL> -- 2. Outlier Treatment and
10:24:51 SQL> -- 3. Normalization are performed below.
10:24:51 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:51 SQL> --    normalized here.
10:24:51 SQL> 
10:24:51 SQL> BEGIN
10:24:51   2  	-- Perform missing value treatment for all predictors
10:24:51   3  	-- create miss tables
10:24:51   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:51   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:51   6  
10:24:51   7  	-- populate miss tables
10:24:51   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:51   9  	  miss_table_name => 'svmc_miss_num',
10:24:51  10  	  data_table_name => '&bldtable',
10:24:51  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:51  12  
10:24:51  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:51  14  	  miss_table_name => 'svmc_miss_cat',
10:24:51  15  	  data_table_name => '&bldtable',
10:24:51  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:51  17  
10:24:51  18  	-- xform input data to replace missing values
10:24:51  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:51  20  	  miss_table_name => 'svmc_miss_num',
10:24:51  21  	  data_table_name => '&bldtable',
10:24:51  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:51  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:51  24  	  miss_table_name => 'svmc_miss_cat',
10:24:51  25  	  data_table_name => '&bldtable',
10:24:51  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:51  27  
10:24:51  28  	-- Perform outlier treatment.
10:24:51  29  	-- create clip table
10:24:51  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:51  31  
10:24:51  32  	-- populate clip table
10:24:51  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:51  34  	  clip_table_name => 'svmc_clip',
10:24:51  35  	  data_table_name => '&bldtable',
10:24:51  36  	  tail_frac	  => 0.025,
10:24:51  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:51  38  
10:24:51  39  	-- xform input data to winsorized data
10:24:51  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:51  41  	  clip_table_name => 'svmc_clip',
10:24:51  42  	  data_table_name => '&bldtable',
10:24:51  43  	  xform_view_name => 'svmc_winsor');
10:24:51  44  
10:24:51  45  	-- create normalization table
10:24:51  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:51  47  
10:24:51  48  	-- populate normalization table based on winsorized data
10:24:51  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:51  50  	  norm_table_name => 'svmc_norm',
10:24:51  51  	  data_table_name => 'svmc_winsor',
10:24:51  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:51  53  
10:24:51  54  	-- normalize the original data
10:24:51  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:51  56  	  norm_table_name => 'svmc_norm',
10:24:51  57  	  data_table_name => '&bldtable',
10:24:51  58  	  xform_view_name => 'svmc_build_prep');
10:24:51  59  END;
10:24:51  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:24:52 SQL> 
10:24:52 SQL> ---------------------
10:24:52 SQL> -- CREATE A NEW MODEL
10:24:52 SQL> --
10:24:52 SQL> -- Cleanup old model with the same name for repeat runs
10:24:52 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:52   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:52   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.02
10:24:53 SQL> 
10:24:53 SQL> -- Build a new SVM Model
10:24:53 SQL> BEGIN
10:24:53   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:53   3  	  model_name	      => '&model_name',
10:24:53   4  	  mining_function     => dbms_data_mining.classification,
10:24:53   5  	  data_table_name     => 'svmc_build_prep',
10:24:53   6  	  case_id_column_name => '&case_id',
10:24:53   7  	  target_column_name  => '&target',
10:24:53   8  	  settings_table_name => 'svmc_settings');
10:24:53   9  END;
10:24:53  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.54
10:24:55 SQL> 
10:24:55 SQL> -----------------------------------------------------------------------
10:24:55 SQL> --			       APPLY/score THE MODEL
10:24:55 SQL> -----------------------------------------------------------------------
10:24:55 SQL> 
10:24:55 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:24:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:24:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:24:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:24:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:55 SQL> -----------------------
10:24:55 SQL> -- PREPARE SCORING DATA
10:24:55 SQL> --
10:24:55 SQL> -- If the data for model creation has been prepared, then the data
10:24:55 SQL> -- to be scored using the model must be prepared in the same manner
10:24:55 SQL> -- in order to obtain meaningful results.
10:24:55 SQL> --
10:24:55 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:55 SQL> -- 2. Normalization
10:24:55 SQL> -- No outlier treatment will be performed during test and apply. The
10:24:55 SQL> -- normalization step is sufficient, since the normalization parameters
10:24:55 SQL> -- already capture the effects of outlier treatment done with build data.
10:24:55 SQL> --
10:24:55 SQL> BEGIN
10:24:55   2  	-- Xform Test data to replace missing values
10:24:55   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:55   4  	  miss_table_name => 'svmc_miss_num',
10:24:55   5  	  data_table_name => '&scoretable',
10:24:55   6  	  xform_view_name => 'xformed_apply_miss_num');
10:24:55   7  
10:24:55   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:55   9  	  miss_table_name => 'svmc_miss_cat',
10:24:55  10  	  data_table_name => '&scoretable',
10:24:55  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:24:55  12  
10:24:55  13  	-- Normalize the data to be scored
10:24:55  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:55  15  	  norm_table_name => 'svmc_norm',
10:24:55  16  	  data_table_name => '&scoretable',
10:24:55  17  	  xform_view_name => 'svmc_apply_prep');
10:24:55  18  END;
10:24:55  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:24:56 SQL> 
10:24:56 SQL> -- Maybe I already collected a score for this tkrdate.
10:24:56 SQL> -- DELETE it if I did:
10:24:56 SQL> DELETE ystkscores
10:24:56   2  WHERE score > 0
10:24:56   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:24:56   4  -- I need to supply the target attribute name:
10:24:56   5  AND targ = '&1'
10:24:56   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:24:56 SQL> 
10:24:56 SQL> -- We do a drumroll here:
10:24:56 SQL> 
10:24:56 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:24:56   2  SELECT
10:24:56   3  tkrdate
10:24:56   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:24:56   5  ,sysdate
10:24:56   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:24:56   7  -- rluck/oracle_sql_demos/substr.sql :
10:24:56   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:24:56   9  ,SUBSTR(tkrdate,-10)ydate
10:24:56  10  ,'&1'
10:24:56  11  FROM svmc_apply_prep
10:24:56  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.05
10:24:56 SQL> @score1_5min_gattn.sql	2010-02-17 TLT
10:24:56 SQL> --
10:24:56 SQL> -- score1_5min_gattn.sql
10:24:56 SQL> --
10:24:56 SQL> 
10:24:56 SQL> -- Demo:
10:24:56 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:24:56 SQL> 
10:24:56 SQL> CREATE OR REPLACE VIEW sme AS
10:24:56   2  SELECT
10:24:56   3  tkrdate
10:24:56   4  ,NULL gattn
10:24:56   5  ,g00
10:24:56   6  ,g01
10:24:56   7  ,g02
10:24:56   8  ,g03
10:24:56   9  ,g04
10:24:56  10  ,g05
10:24:56  11  ,g06
10:24:56  12  ,g07
10:24:56  13  ,g08
10:24:56  14  ,g09
10:24:56  15  ,g10
10:24:56  16  ,g11
10:24:56  17  ,g12
10:24:56  18  ,g13
10:24:56  19  ,g14
10:24:56  20  ,g15
10:24:56  21  ,g16
10:24:56  22  ,g17
10:24:56  23  ,g18
10:24:56  24  ,g19
10:24:56  25  ,g20
10:24:56  26  ,g21
10:24:56  27  ,g22
10:24:56  28  ,g23
10:24:56  29  ,g24
10:24:56  30  ,g25
10:24:56  31  ,g26
10:24:56  32  ,g27
10:24:56  33  ,g28
10:24:56  34  ,g29
10:24:56  35  FROM stk_ms
10:24:56  36  WHERE ydate = '&1'
10:24:56  37  AND tkr = '&2'
10:24:56  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-17'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:24:56 SQL> 
10:24:56 SQL> -- rpt
10:24:56 SQL> -- We should see just 1 row:
10:24:56 SQL> 
10:24:56 SQL> SELECT COUNT(tkrdate) FROM sme
10:24:56   2  
10:24:56 SQL> -- Build the model:
10:24:56 SQL> CREATE OR REPLACE VIEW bme AS
10:24:56   2  SELECT
10:24:56   3  tkrdate
10:24:56   4  ,gattn
10:24:56   5  ,g00
10:24:56   6  ,g01
10:24:56   7  ,g02
10:24:56   8  ,g03
10:24:56   9  ,g04
10:24:56  10  ,g05
10:24:56  11  ,g06
10:24:56  12  ,g07
10:24:56  13  ,g08
10:24:56  14  ,g09
10:24:56  15  ,g10
10:24:56  16  ,g11
10:24:56  17  ,g12
10:24:56  18  ,g13
10:24:56  19  ,g14
10:24:56  20  ,g15
10:24:56  21  ,g16
10:24:56  22  ,g17
10:24:56  23  ,g18
10:24:56  24  ,g19
10:24:56  25  ,g20
10:24:56  26  ,g21
10:24:56  27  ,g22
10:24:56  28  ,g23
10:24:56  29  ,g24
10:24:56  30  ,g25
10:24:56  31  ,g26
10:24:56  32  ,g27
10:24:56  33  ,g28
10:24:56  34  ,g29
10:24:56  35  FROM stk_ms
10:24:56  36  WHERE gattn IN('nup','up')
10:24:56  37  -- Use only rows which are older than 1 day:
10:24:56  38  AND 1+ydate < '&1'
10:24:56  39  AND tkr = '&2'
10:24:56  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-17'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:24:56 SQL> 
10:24:56 SQL> -- rpt
10:24:56 SQL> 
10:24:56 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:24:56   2  
10:24:56 SQL> SELECT MAX(tkrdate) FROM bme
10:24:56   2  
10:24:56 SQL> -- Now build model from bme and score sme
10:24:56 SQL> @score1.sql gattn
10:24:56 SQL> -- score1.sql
10:24:56 SQL> 
10:24:56 SQL> -- I use this script to send 5 params to score.sql
10:24:56 SQL> -- which does the heavy lifting of creating an SVM model.
10:24:56 SQL> -- Then at the very end of this script I use the model
10:24:56 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:24:56 SQL> 
10:24:56 SQL> -- I call this script from 2 other scripts:
10:24:56 SQL> -- score1_5min.sql
10:24:56 SQL> -- score1_5min_gattn.sql
10:24:56 SQL> 
10:24:56 SQL> -- The 1st param is the name of the target attribute.
10:24:56 SQL> -- I like to call my target attributes either gatt or gattn.
10:24:56 SQL> 
10:24:56 SQL> -- Demo:
10:24:56 SQL> -- @score1.sql 'gatt'
10:24:56 SQL> -- @score1.sql 'gattn'
10:24:56 SQL> 
10:24:56 SQL> -- Now, I fill up svmc_apply_prep.
10:24:56 SQL> -- I use same model_name used in score.sql
10:24:56 SQL> DEFINE model_name = 'svmspy101'
10:24:56 SQL> DEFINE bldtable	= 'bme'
10:24:56 SQL> DEFINE scoretable = 'sme'
10:24:56 SQL> DEFINE case_id	= 'tkrdate'
10:24:56 SQL> -- Demo:
10:24:56 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:24:56 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:24:56 SQL> --
10:24:56 SQL> -- score.sql
10:24:56 SQL> --
10:24:56 SQL> 
10:24:56 SQL> -- usage: score.sql
10:24:56 SQL> 
10:24:56 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:24:56 SQL> 
10:24:56 SQL> -- DEFINE target	   = 'gatt'
10:24:56 SQL> -- DEFINE model_name = 'svmspy100'
10:24:56 SQL> -- DEFINE bldtable   = 'bme'
10:24:56 SQL> -- DEFINE scoretable = 'sme'
10:24:56 SQL> -- DEFINE case_id    = 'tkrdate'
10:24:56 SQL> 
10:24:56 SQL> DEFINE target	= '&1'
10:24:56 SQL> DEFINE model_name = '&2'
10:24:56 SQL> DEFINE bldtable	= '&3'
10:24:56 SQL> DEFINE scoretable = '&4'
10:24:56 SQL> DEFINE case_id	= '&5'
10:24:56 SQL> 
10:24:56 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:24:56 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:24:56 SQL> 
10:24:56 SQL> -- Builds an SVM model using pl/sql.
10:24:56 SQL> 
10:24:56 SQL> -----------------------------------------------------------------------
10:24:56 SQL> --			    BUILD THE MODEL
10:24:56 SQL> -----------------------------------------------------------------------
10:24:56 SQL> 
10:24:56 SQL> -- Cleanup old build data preparation objects for repeat runs
10:24:56 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:56 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:24:56 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:24:56 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:24:56 SQL> 
10:24:56 SQL> 
10:24:56 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:24:56 SQL> --
10:24:56 SQL> -- DROP	TABLE svmc_settings ;
10:24:56 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:24:56 SQL> -- DELETE svmc_settings;
10:24:56 SQL> 
10:24:56 SQL> -- The default classification algorithm is Naive Bayes. So override
10:24:56 SQL> -- this choice to SVM using a settings table.
10:24:56 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:24:56 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:24:56 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:24:56 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:24:56 SQL> -- models.
10:24:56 SQL> --
10:24:56 SQL> 
10:24:56 SQL> -- Do this once and then comment it out.
10:24:56 SQL> -- That makes script go faster.
10:24:56 SQL> -- BEGIN
10:24:56 SQL> -- -- Populate settings table
10:24:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:56 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:24:56 SQL> --
10:24:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:56 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:24:56 SQL> --
10:24:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:24:56 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:24:56 SQL> --   COMMIT;
10:24:56 SQL> -- END;
10:24:56 SQL> -- /
10:24:56 SQL> 
10:24:56 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:24:56 SQL> 
10:24:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:24:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:24:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:24:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:24:56 SQL> 
10:24:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:24:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:24:56 SQL> 
10:24:56 SQL> --------------------------------
10:24:56 SQL> -- PREPARE BUILD (TRAINING) DATA
10:24:56 SQL> --
10:24:56 SQL> 
10:24:56 SQL> -- 1. Missing Value treatment for all Predictors and
10:24:56 SQL> -- 2. Outlier Treatment and
10:24:56 SQL> -- 3. Normalization are performed below.
10:24:56 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:24:56 SQL> --    normalized here.
10:24:56 SQL> 
10:24:56 SQL> BEGIN
10:24:56   2  	-- Perform missing value treatment for all predictors
10:24:56   3  	-- create miss tables
10:24:56   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:24:56   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:24:56   6  
10:24:56   7  	-- populate miss tables
10:24:56   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:24:56   9  	  miss_table_name => 'svmc_miss_num',
10:24:56  10  	  data_table_name => '&bldtable',
10:24:56  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:56  12  
10:24:56  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:24:56  14  	  miss_table_name => 'svmc_miss_cat',
10:24:56  15  	  data_table_name => '&bldtable',
10:24:56  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:56  17  
10:24:56  18  	-- xform input data to replace missing values
10:24:56  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:24:56  20  	  miss_table_name => 'svmc_miss_num',
10:24:56  21  	  data_table_name => '&bldtable',
10:24:56  22  	  xform_view_name => 'xformed_build_miss_num');
10:24:56  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:24:56  24  	  miss_table_name => 'svmc_miss_cat',
10:24:56  25  	  data_table_name => '&bldtable',
10:24:56  26  	  xform_view_name => 'xformed_build_miss_cat');
10:24:56  27  
10:24:56  28  	-- Perform outlier treatment.
10:24:56  29  	-- create clip table
10:24:56  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:24:56  31  
10:24:56  32  	-- populate clip table
10:24:56  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:24:56  34  	  clip_table_name => 'svmc_clip',
10:24:56  35  	  data_table_name => '&bldtable',
10:24:56  36  	  tail_frac	  => 0.025,
10:24:56  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:56  38  
10:24:56  39  	-- xform input data to winsorized data
10:24:56  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:24:56  41  	  clip_table_name => 'svmc_clip',
10:24:56  42  	  data_table_name => '&bldtable',
10:24:56  43  	  xform_view_name => 'svmc_winsor');
10:24:56  44  
10:24:56  45  	-- create normalization table
10:24:56  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:24:56  47  
10:24:56  48  	-- populate normalization table based on winsorized data
10:24:56  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:24:56  50  	  norm_table_name => 'svmc_norm',
10:24:56  51  	  data_table_name => 'svmc_winsor',
10:24:56  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:24:56  53  
10:24:56  54  	-- normalize the original data
10:24:56  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:24:56  56  	  norm_table_name => 'svmc_norm',
10:24:56  57  	  data_table_name => '&bldtable',
10:24:56  58  	  xform_view_name => 'svmc_build_prep');
10:24:56  59  END;
10:24:56  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:24:57 SQL> 
10:24:57 SQL> ---------------------
10:24:57 SQL> -- CREATE A NEW MODEL
10:24:57 SQL> --
10:24:57 SQL> -- Cleanup old model with the same name for repeat runs
10:24:57 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:24:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:24:57   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.57
10:24:58 SQL> 
10:24:58 SQL> -- Build a new SVM Model
10:24:58 SQL> BEGIN
10:24:58   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:24:58   3  	  model_name	      => '&model_name',
10:24:58   4  	  mining_function     => dbms_data_mining.classification,
10:24:58   5  	  data_table_name     => 'svmc_build_prep',
10:24:58   6  	  case_id_column_name => '&case_id',
10:24:58   7  	  target_column_name  => '&target',
10:24:58   8  	  settings_table_name => 'svmc_settings');
10:24:58   9  END;
10:24:58  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.22
10:25:00 SQL> 
10:25:00 SQL> -----------------------------------------------------------------------
10:25:00 SQL> --			       APPLY/score THE MODEL
10:25:00 SQL> -----------------------------------------------------------------------
10:25:00 SQL> 
10:25:00 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:00 SQL> -----------------------
10:25:00 SQL> -- PREPARE SCORING DATA
10:25:00 SQL> --
10:25:00 SQL> -- If the data for model creation has been prepared, then the data
10:25:00 SQL> -- to be scored using the model must be prepared in the same manner
10:25:00 SQL> -- in order to obtain meaningful results.
10:25:00 SQL> --
10:25:00 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:00 SQL> -- 2. Normalization
10:25:00 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:00 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:00 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:00 SQL> --
10:25:00 SQL> BEGIN
10:25:00   2  	-- Xform Test data to replace missing values
10:25:00   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:00   4  	  miss_table_name => 'svmc_miss_num',
10:25:00   5  	  data_table_name => '&scoretable',
10:25:00   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:00   7  
10:25:00   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:00   9  	  miss_table_name => 'svmc_miss_cat',
10:25:00  10  	  data_table_name => '&scoretable',
10:25:00  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:00  12  
10:25:00  13  	-- Normalize the data to be scored
10:25:00  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:00  15  	  norm_table_name => 'svmc_norm',
10:25:00  16  	  data_table_name => '&scoretable',
10:25:00  17  	  xform_view_name => 'svmc_apply_prep');
10:25:00  18  END;
10:25:00  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:25:01 SQL> 
10:25:01 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:01 SQL> -- DELETE it if I did:
10:25:01 SQL> DELETE ystkscores
10:25:01   2  WHERE score > 0
10:25:01   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:01   4  -- I need to supply the target attribute name:
10:25:01   5  AND targ = '&1'
10:25:01   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:25:01 SQL> 
10:25:01 SQL> -- We do a drumroll here:
10:25:01 SQL> 
10:25:01 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:01   2  SELECT
10:25:01   3  tkrdate
10:25:01   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:01   5  ,sysdate
10:25:01   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:01   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:01   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:01   9  ,SUBSTR(tkrdate,-10)ydate
10:25:01  10  ,'&1'
10:25:01  11  FROM svmc_apply_prep
10:25:01  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:25:01 SQL> @score1_5min.sql	      2010-06-04 TLT
10:25:01 SQL> --
10:25:01 SQL> -- score1_5min.sql
10:25:01 SQL> --
10:25:01 SQL> 
10:25:01 SQL> -- Demo:
10:25:01 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:01 SQL> 
10:25:01 SQL> CREATE OR REPLACE VIEW sme AS
10:25:01   2  SELECT
10:25:01   3  tkrdate
10:25:01   4  ,NULL gatt
10:25:01   5  ,g00
10:25:01   6  ,g01
10:25:01   7  ,g02
10:25:01   8  ,g03
10:25:01   9  ,g04
10:25:01  10  ,g05
10:25:01  11  ,g06
10:25:01  12  ,g07
10:25:01  13  ,g08
10:25:01  14  ,g09
10:25:01  15  ,g10
10:25:01  16  ,g11
10:25:01  17  ,g12
10:25:01  18  ,g13
10:25:01  19  ,g14
10:25:01  20  ,g15
10:25:01  21  ,g16
10:25:01  22  ,g17
10:25:01  23  ,g18
10:25:01  24  ,g19
10:25:01  25  ,g20
10:25:01  26  ,g21
10:25:01  27  ,g22
10:25:01  28  ,g23
10:25:01  29  ,g24
10:25:01  30  ,g25
10:25:01  31  ,g26
10:25:01  32  ,g27
10:25:01  33  ,g28
10:25:01  34  ,g29
10:25:01  35  FROM stk_ms
10:25:01  36  WHERE ydate = '&1'
10:25:01  37  AND tkr = '&2'
10:25:01  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-04'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:01 SQL> 
10:25:01 SQL> -- rpt
10:25:01 SQL> -- We should see just 1 row:
10:25:01 SQL> 
10:25:01 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:01   2  
10:25:01 SQL> -- Build the model:
10:25:01 SQL> CREATE OR REPLACE VIEW bme AS
10:25:01   2  SELECT
10:25:01   3  tkrdate
10:25:01   4  ,gatt
10:25:01   5  ,g00
10:25:01   6  ,g01
10:25:01   7  ,g02
10:25:01   8  ,g03
10:25:01   9  ,g04
10:25:01  10  ,g05
10:25:01  11  ,g06
10:25:01  12  ,g07
10:25:01  13  ,g08
10:25:01  14  ,g09
10:25:01  15  ,g10
10:25:01  16  ,g11
10:25:01  17  ,g12
10:25:01  18  ,g13
10:25:01  19  ,g14
10:25:01  20  ,g15
10:25:01  21  ,g16
10:25:01  22  ,g17
10:25:01  23  ,g18
10:25:01  24  ,g19
10:25:01  25  ,g20
10:25:01  26  ,g21
10:25:01  27  ,g22
10:25:01  28  ,g23
10:25:01  29  ,g24
10:25:01  30  ,g25
10:25:01  31  ,g26
10:25:01  32  ,g27
10:25:01  33  ,g28
10:25:01  34  ,g29
10:25:01  35  FROM stk_ms
10:25:01  36  WHERE gatt IN('nup','up')
10:25:01  37  -- Use only rows which are older than 1 day:
10:25:01  38  AND 1+ydate < '&1'
10:25:01  39  AND tkr = '&2'
10:25:01  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-04'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:01 SQL> 
10:25:01 SQL> -- rpt
10:25:01 SQL> 
10:25:01 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:01   2  
10:25:01 SQL> SELECT MAX(tkrdate) FROM bme
10:25:01   2  
10:25:01 SQL> -- Now build model from bme and score sme
10:25:01 SQL> @score1.sql gatt
10:25:01 SQL> -- score1.sql
10:25:01 SQL> 
10:25:01 SQL> -- I use this script to send 5 params to score.sql
10:25:01 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:01 SQL> -- Then at the very end of this script I use the model
10:25:01 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:01 SQL> 
10:25:01 SQL> -- I call this script from 2 other scripts:
10:25:01 SQL> -- score1_5min.sql
10:25:01 SQL> -- score1_5min_gattn.sql
10:25:01 SQL> 
10:25:01 SQL> -- The 1st param is the name of the target attribute.
10:25:01 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:01 SQL> 
10:25:01 SQL> -- Demo:
10:25:01 SQL> -- @score1.sql 'gatt'
10:25:01 SQL> -- @score1.sql 'gattn'
10:25:01 SQL> 
10:25:01 SQL> -- Now, I fill up svmc_apply_prep.
10:25:01 SQL> -- I use same model_name used in score.sql
10:25:01 SQL> DEFINE model_name = 'svmspy101'
10:25:01 SQL> DEFINE bldtable	= 'bme'
10:25:01 SQL> DEFINE scoretable = 'sme'
10:25:01 SQL> DEFINE case_id	= 'tkrdate'
10:25:01 SQL> -- Demo:
10:25:01 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:01 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:01 SQL> --
10:25:01 SQL> -- score.sql
10:25:01 SQL> --
10:25:01 SQL> 
10:25:01 SQL> -- usage: score.sql
10:25:01 SQL> 
10:25:01 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:01 SQL> 
10:25:01 SQL> -- DEFINE target	   = 'gatt'
10:25:01 SQL> -- DEFINE model_name = 'svmspy100'
10:25:01 SQL> -- DEFINE bldtable   = 'bme'
10:25:01 SQL> -- DEFINE scoretable = 'sme'
10:25:01 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:01 SQL> 
10:25:01 SQL> DEFINE target	= '&1'
10:25:01 SQL> DEFINE model_name = '&2'
10:25:01 SQL> DEFINE bldtable	= '&3'
10:25:01 SQL> DEFINE scoretable = '&4'
10:25:01 SQL> DEFINE case_id	= '&5'
10:25:01 SQL> 
10:25:01 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:01 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:01 SQL> 
10:25:01 SQL> -- Builds an SVM model using pl/sql.
10:25:01 SQL> 
10:25:01 SQL> -----------------------------------------------------------------------
10:25:01 SQL> --			    BUILD THE MODEL
10:25:01 SQL> -----------------------------------------------------------------------
10:25:01 SQL> 
10:25:01 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:01 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:01 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:01 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:01 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:01 SQL> 
10:25:01 SQL> 
10:25:01 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:01 SQL> --
10:25:01 SQL> -- DROP	TABLE svmc_settings ;
10:25:01 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:01 SQL> -- DELETE svmc_settings;
10:25:01 SQL> 
10:25:01 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:01 SQL> -- this choice to SVM using a settings table.
10:25:01 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:01 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:01 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:01 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:01 SQL> -- models.
10:25:01 SQL> --
10:25:01 SQL> 
10:25:01 SQL> -- Do this once and then comment it out.
10:25:01 SQL> -- That makes script go faster.
10:25:01 SQL> -- BEGIN
10:25:01 SQL> -- -- Populate settings table
10:25:01 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:01 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:01 SQL> --
10:25:01 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:01 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:01 SQL> --
10:25:01 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:01 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:01 SQL> --   COMMIT;
10:25:01 SQL> -- END;
10:25:01 SQL> -- /
10:25:01 SQL> 
10:25:01 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:01 SQL> 
10:25:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:01 SQL> 
10:25:01 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:01   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:01 SQL> 
10:25:01 SQL> --------------------------------
10:25:01 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:01 SQL> --
10:25:01 SQL> 
10:25:01 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:01 SQL> -- 2. Outlier Treatment and
10:25:01 SQL> -- 3. Normalization are performed below.
10:25:01 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:01 SQL> --    normalized here.
10:25:01 SQL> 
10:25:01 SQL> BEGIN
10:25:01   2  	-- Perform missing value treatment for all predictors
10:25:01   3  	-- create miss tables
10:25:01   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:01   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:01   6  
10:25:01   7  	-- populate miss tables
10:25:01   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:01   9  	  miss_table_name => 'svmc_miss_num',
10:25:01  10  	  data_table_name => '&bldtable',
10:25:01  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:01  12  
10:25:01  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:01  14  	  miss_table_name => 'svmc_miss_cat',
10:25:01  15  	  data_table_name => '&bldtable',
10:25:01  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:01  17  
10:25:01  18  	-- xform input data to replace missing values
10:25:01  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:01  20  	  miss_table_name => 'svmc_miss_num',
10:25:01  21  	  data_table_name => '&bldtable',
10:25:01  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:01  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:01  24  	  miss_table_name => 'svmc_miss_cat',
10:25:01  25  	  data_table_name => '&bldtable',
10:25:01  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:01  27  
10:25:01  28  	-- Perform outlier treatment.
10:25:01  29  	-- create clip table
10:25:01  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:01  31  
10:25:01  32  	-- populate clip table
10:25:01  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:01  34  	  clip_table_name => 'svmc_clip',
10:25:01  35  	  data_table_name => '&bldtable',
10:25:01  36  	  tail_frac	  => 0.025,
10:25:01  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:01  38  
10:25:01  39  	-- xform input data to winsorized data
10:25:01  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:01  41  	  clip_table_name => 'svmc_clip',
10:25:01  42  	  data_table_name => '&bldtable',
10:25:01  43  	  xform_view_name => 'svmc_winsor');
10:25:01  44  
10:25:01  45  	-- create normalization table
10:25:01  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:01  47  
10:25:01  48  	-- populate normalization table based on winsorized data
10:25:01  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:01  50  	  norm_table_name => 'svmc_norm',
10:25:01  51  	  data_table_name => 'svmc_winsor',
10:25:01  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:01  53  
10:25:01  54  	-- normalize the original data
10:25:01  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:01  56  	  norm_table_name => 'svmc_norm',
10:25:01  57  	  data_table_name => '&bldtable',
10:25:01  58  	  xform_view_name => 'svmc_build_prep');
10:25:01  59  END;
10:25:01  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:25:02 SQL> 
10:25:02 SQL> ---------------------
10:25:02 SQL> -- CREATE A NEW MODEL
10:25:02 SQL> --
10:25:02 SQL> -- Cleanup old model with the same name for repeat runs
10:25:02 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:02   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.45
10:25:03 SQL> 
10:25:03 SQL> -- Build a new SVM Model
10:25:03 SQL> BEGIN
10:25:03   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:03   3  	  model_name	      => '&model_name',
10:25:03   4  	  mining_function     => dbms_data_mining.classification,
10:25:03   5  	  data_table_name     => 'svmc_build_prep',
10:25:03   6  	  case_id_column_name => '&case_id',
10:25:03   7  	  target_column_name  => '&target',
10:25:03   8  	  settings_table_name => 'svmc_settings');
10:25:03   9  END;
10:25:03  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.12
10:25:05 SQL> 
10:25:05 SQL> -----------------------------------------------------------------------
10:25:05 SQL> --			       APPLY/score THE MODEL
10:25:05 SQL> -----------------------------------------------------------------------
10:25:05 SQL> 
10:25:05 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:05 SQL> -----------------------
10:25:05 SQL> -- PREPARE SCORING DATA
10:25:05 SQL> --
10:25:05 SQL> -- If the data for model creation has been prepared, then the data
10:25:05 SQL> -- to be scored using the model must be prepared in the same manner
10:25:05 SQL> -- in order to obtain meaningful results.
10:25:05 SQL> --
10:25:05 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:05 SQL> -- 2. Normalization
10:25:05 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:05 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:05 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:05 SQL> --
10:25:05 SQL> BEGIN
10:25:05   2  	-- Xform Test data to replace missing values
10:25:05   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:05   4  	  miss_table_name => 'svmc_miss_num',
10:25:05   5  	  data_table_name => '&scoretable',
10:25:05   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:05   7  
10:25:05   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:05   9  	  miss_table_name => 'svmc_miss_cat',
10:25:05  10  	  data_table_name => '&scoretable',
10:25:05  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:05  12  
10:25:05  13  	-- Normalize the data to be scored
10:25:05  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:05  15  	  norm_table_name => 'svmc_norm',
10:25:05  16  	  data_table_name => '&scoretable',
10:25:05  17  	  xform_view_name => 'svmc_apply_prep');
10:25:05  18  END;
10:25:05  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:25:05 SQL> 
10:25:05 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:05 SQL> -- DELETE it if I did:
10:25:05 SQL> DELETE ystkscores
10:25:05   2  WHERE score > 0
10:25:05   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:05   4  -- I need to supply the target attribute name:
10:25:05   5  AND targ = '&1'
10:25:05   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:05 SQL> 
10:25:05 SQL> -- We do a drumroll here:
10:25:05 SQL> 
10:25:05 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:05   2  SELECT
10:25:05   3  tkrdate
10:25:05   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:05   5  ,sysdate
10:25:05   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:05   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:05   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:05   9  ,SUBSTR(tkrdate,-10)ydate
10:25:05  10  ,'&1'
10:25:05  11  FROM svmc_apply_prep
10:25:05  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:25:05 SQL> @score1_5min_gattn.sql	2010-07-22 TLT
10:25:05 SQL> --
10:25:05 SQL> -- score1_5min_gattn.sql
10:25:05 SQL> --
10:25:05 SQL> 
10:25:05 SQL> -- Demo:
10:25:05 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:25:05 SQL> 
10:25:05 SQL> CREATE OR REPLACE VIEW sme AS
10:25:05   2  SELECT
10:25:05   3  tkrdate
10:25:05   4  ,NULL gattn
10:25:05   5  ,g00
10:25:05   6  ,g01
10:25:05   7  ,g02
10:25:05   8  ,g03
10:25:05   9  ,g04
10:25:05  10  ,g05
10:25:05  11  ,g06
10:25:05  12  ,g07
10:25:05  13  ,g08
10:25:05  14  ,g09
10:25:05  15  ,g10
10:25:05  16  ,g11
10:25:05  17  ,g12
10:25:05  18  ,g13
10:25:05  19  ,g14
10:25:05  20  ,g15
10:25:05  21  ,g16
10:25:05  22  ,g17
10:25:05  23  ,g18
10:25:05  24  ,g19
10:25:05  25  ,g20
10:25:05  26  ,g21
10:25:05  27  ,g22
10:25:05  28  ,g23
10:25:05  29  ,g24
10:25:05  30  ,g25
10:25:05  31  ,g26
10:25:05  32  ,g27
10:25:05  33  ,g28
10:25:05  34  ,g29
10:25:05  35  FROM stk_ms
10:25:05  36  WHERE ydate = '&1'
10:25:05  37  AND tkr = '&2'
10:25:05  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-07-22'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:06 SQL> 
10:25:06 SQL> -- rpt
10:25:06 SQL> -- We should see just 1 row:
10:25:06 SQL> 
10:25:06 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:06   2  
10:25:06 SQL> -- Build the model:
10:25:06 SQL> CREATE OR REPLACE VIEW bme AS
10:25:06   2  SELECT
10:25:06   3  tkrdate
10:25:06   4  ,gattn
10:25:06   5  ,g00
10:25:06   6  ,g01
10:25:06   7  ,g02
10:25:06   8  ,g03
10:25:06   9  ,g04
10:25:06  10  ,g05
10:25:06  11  ,g06
10:25:06  12  ,g07
10:25:06  13  ,g08
10:25:06  14  ,g09
10:25:06  15  ,g10
10:25:06  16  ,g11
10:25:06  17  ,g12
10:25:06  18  ,g13
10:25:06  19  ,g14
10:25:06  20  ,g15
10:25:06  21  ,g16
10:25:06  22  ,g17
10:25:06  23  ,g18
10:25:06  24  ,g19
10:25:06  25  ,g20
10:25:06  26  ,g21
10:25:06  27  ,g22
10:25:06  28  ,g23
10:25:06  29  ,g24
10:25:06  30  ,g25
10:25:06  31  ,g26
10:25:06  32  ,g27
10:25:06  33  ,g28
10:25:06  34  ,g29
10:25:06  35  FROM stk_ms
10:25:06  36  WHERE gattn IN('nup','up')
10:25:06  37  -- Use only rows which are older than 1 day:
10:25:06  38  AND 1+ydate < '&1'
10:25:06  39  AND tkr = '&2'
10:25:06  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-07-22'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:06 SQL> 
10:25:06 SQL> -- rpt
10:25:06 SQL> 
10:25:06 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:25:06   2  
10:25:06 SQL> SELECT MAX(tkrdate) FROM bme
10:25:06   2  
10:25:06 SQL> -- Now build model from bme and score sme
10:25:06 SQL> @score1.sql gattn
10:25:06 SQL> -- score1.sql
10:25:06 SQL> 
10:25:06 SQL> -- I use this script to send 5 params to score.sql
10:25:06 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:06 SQL> -- Then at the very end of this script I use the model
10:25:06 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:06 SQL> 
10:25:06 SQL> -- I call this script from 2 other scripts:
10:25:06 SQL> -- score1_5min.sql
10:25:06 SQL> -- score1_5min_gattn.sql
10:25:06 SQL> 
10:25:06 SQL> -- The 1st param is the name of the target attribute.
10:25:06 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:06 SQL> 
10:25:06 SQL> -- Demo:
10:25:06 SQL> -- @score1.sql 'gatt'
10:25:06 SQL> -- @score1.sql 'gattn'
10:25:06 SQL> 
10:25:06 SQL> -- Now, I fill up svmc_apply_prep.
10:25:06 SQL> -- I use same model_name used in score.sql
10:25:06 SQL> DEFINE model_name = 'svmspy101'
10:25:06 SQL> DEFINE bldtable	= 'bme'
10:25:06 SQL> DEFINE scoretable = 'sme'
10:25:06 SQL> DEFINE case_id	= 'tkrdate'
10:25:06 SQL> -- Demo:
10:25:06 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:06 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:06 SQL> --
10:25:06 SQL> -- score.sql
10:25:06 SQL> --
10:25:06 SQL> 
10:25:06 SQL> -- usage: score.sql
10:25:06 SQL> 
10:25:06 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:06 SQL> 
10:25:06 SQL> -- DEFINE target	   = 'gatt'
10:25:06 SQL> -- DEFINE model_name = 'svmspy100'
10:25:06 SQL> -- DEFINE bldtable   = 'bme'
10:25:06 SQL> -- DEFINE scoretable = 'sme'
10:25:06 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:06 SQL> 
10:25:06 SQL> DEFINE target	= '&1'
10:25:06 SQL> DEFINE model_name = '&2'
10:25:06 SQL> DEFINE bldtable	= '&3'
10:25:06 SQL> DEFINE scoretable = '&4'
10:25:06 SQL> DEFINE case_id	= '&5'
10:25:06 SQL> 
10:25:06 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:06 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:06 SQL> 
10:25:06 SQL> -- Builds an SVM model using pl/sql.
10:25:06 SQL> 
10:25:06 SQL> -----------------------------------------------------------------------
10:25:06 SQL> --			    BUILD THE MODEL
10:25:06 SQL> -----------------------------------------------------------------------
10:25:06 SQL> 
10:25:06 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:06 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:06 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:06 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:06 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:06 SQL> 
10:25:06 SQL> 
10:25:06 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:06 SQL> --
10:25:06 SQL> -- DROP	TABLE svmc_settings ;
10:25:06 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:06 SQL> -- DELETE svmc_settings;
10:25:06 SQL> 
10:25:06 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:06 SQL> -- this choice to SVM using a settings table.
10:25:06 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:06 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:06 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:06 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:06 SQL> -- models.
10:25:06 SQL> --
10:25:06 SQL> 
10:25:06 SQL> -- Do this once and then comment it out.
10:25:06 SQL> -- That makes script go faster.
10:25:06 SQL> -- BEGIN
10:25:06 SQL> -- -- Populate settings table
10:25:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:06 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:06 SQL> --
10:25:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:06 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:06 SQL> --
10:25:06 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:06 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:06 SQL> --   COMMIT;
10:25:06 SQL> -- END;
10:25:06 SQL> -- /
10:25:06 SQL> 
10:25:06 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:06 SQL> 
10:25:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:06 SQL> 
10:25:06 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:06   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:06 SQL> 
10:25:06 SQL> --------------------------------
10:25:06 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:06 SQL> --
10:25:06 SQL> 
10:25:06 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:06 SQL> -- 2. Outlier Treatment and
10:25:06 SQL> -- 3. Normalization are performed below.
10:25:06 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:06 SQL> --    normalized here.
10:25:06 SQL> 
10:25:06 SQL> BEGIN
10:25:06   2  	-- Perform missing value treatment for all predictors
10:25:06   3  	-- create miss tables
10:25:06   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:06   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:06   6  
10:25:06   7  	-- populate miss tables
10:25:06   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:06   9  	  miss_table_name => 'svmc_miss_num',
10:25:06  10  	  data_table_name => '&bldtable',
10:25:06  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:06  12  
10:25:06  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:06  14  	  miss_table_name => 'svmc_miss_cat',
10:25:06  15  	  data_table_name => '&bldtable',
10:25:06  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:06  17  
10:25:06  18  	-- xform input data to replace missing values
10:25:06  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:06  20  	  miss_table_name => 'svmc_miss_num',
10:25:06  21  	  data_table_name => '&bldtable',
10:25:06  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:06  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:06  24  	  miss_table_name => 'svmc_miss_cat',
10:25:06  25  	  data_table_name => '&bldtable',
10:25:06  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:06  27  
10:25:06  28  	-- Perform outlier treatment.
10:25:06  29  	-- create clip table
10:25:06  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:06  31  
10:25:06  32  	-- populate clip table
10:25:06  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:06  34  	  clip_table_name => 'svmc_clip',
10:25:06  35  	  data_table_name => '&bldtable',
10:25:06  36  	  tail_frac	  => 0.025,
10:25:06  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:06  38  
10:25:06  39  	-- xform input data to winsorized data
10:25:06  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:06  41  	  clip_table_name => 'svmc_clip',
10:25:06  42  	  data_table_name => '&bldtable',
10:25:06  43  	  xform_view_name => 'svmc_winsor');
10:25:06  44  
10:25:06  45  	-- create normalization table
10:25:06  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:06  47  
10:25:06  48  	-- populate normalization table based on winsorized data
10:25:06  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:06  50  	  norm_table_name => 'svmc_norm',
10:25:06  51  	  data_table_name => 'svmc_winsor',
10:25:06  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:06  53  
10:25:06  54  	-- normalize the original data
10:25:06  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:06  56  	  norm_table_name => 'svmc_norm',
10:25:06  57  	  data_table_name => '&bldtable',
10:25:06  58  	  xform_view_name => 'svmc_build_prep');
10:25:06  59  END;
10:25:06  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:25:06 SQL> 
10:25:06 SQL> ---------------------
10:25:06 SQL> -- CREATE A NEW MODEL
10:25:06 SQL> --
10:25:06 SQL> -- Cleanup old model with the same name for repeat runs
10:25:06 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:06   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:06   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.01
10:25:07 SQL> 
10:25:07 SQL> -- Build a new SVM Model
10:25:07 SQL> BEGIN
10:25:07   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:07   3  	  model_name	      => '&model_name',
10:25:07   4  	  mining_function     => dbms_data_mining.classification,
10:25:07   5  	  data_table_name     => 'svmc_build_prep',
10:25:07   6  	  case_id_column_name => '&case_id',
10:25:07   7  	  target_column_name  => '&target',
10:25:07   8  	  settings_table_name => 'svmc_settings');
10:25:07   9  END;
10:25:07  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.15
10:25:09 SQL> 
10:25:09 SQL> -----------------------------------------------------------------------
10:25:09 SQL> --			       APPLY/score THE MODEL
10:25:09 SQL> -----------------------------------------------------------------------
10:25:09 SQL> 
10:25:09 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:10 SQL> -----------------------
10:25:10 SQL> -- PREPARE SCORING DATA
10:25:10 SQL> --
10:25:10 SQL> -- If the data for model creation has been prepared, then the data
10:25:10 SQL> -- to be scored using the model must be prepared in the same manner
10:25:10 SQL> -- in order to obtain meaningful results.
10:25:10 SQL> --
10:25:10 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:10 SQL> -- 2. Normalization
10:25:10 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:10 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:10 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:10 SQL> --
10:25:10 SQL> BEGIN
10:25:10   2  	-- Xform Test data to replace missing values
10:25:10   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:10   4  	  miss_table_name => 'svmc_miss_num',
10:25:10   5  	  data_table_name => '&scoretable',
10:25:10   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:10   7  
10:25:10   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:10   9  	  miss_table_name => 'svmc_miss_cat',
10:25:10  10  	  data_table_name => '&scoretable',
10:25:10  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:10  12  
10:25:10  13  	-- Normalize the data to be scored
10:25:10  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:10  15  	  norm_table_name => 'svmc_norm',
10:25:10  16  	  data_table_name => '&scoretable',
10:25:10  17  	  xform_view_name => 'svmc_apply_prep');
10:25:10  18  END;
10:25:10  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.48
10:25:10 SQL> 
10:25:10 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:10 SQL> -- DELETE it if I did:
10:25:10 SQL> DELETE ystkscores
10:25:10   2  WHERE score > 0
10:25:10   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:10   4  -- I need to supply the target attribute name:
10:25:10   5  AND targ = '&1'
10:25:10   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:10 SQL> 
10:25:10 SQL> -- We do a drumroll here:
10:25:10 SQL> 
10:25:10 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:10   2  SELECT
10:25:10   3  tkrdate
10:25:10   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:10   5  ,sysdate
10:25:10   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:10   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:10   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:10   9  ,SUBSTR(tkrdate,-10)ydate
10:25:10  10  ,'&1'
10:25:10  11  FROM svmc_apply_prep
10:25:10  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.05
10:25:10 SQL> @score1_5min_gattn.sql	2010-02-01 TLT
10:25:10 SQL> --
10:25:10 SQL> -- score1_5min_gattn.sql
10:25:10 SQL> --
10:25:10 SQL> 
10:25:10 SQL> -- Demo:
10:25:10 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:25:10 SQL> 
10:25:10 SQL> CREATE OR REPLACE VIEW sme AS
10:25:10   2  SELECT
10:25:10   3  tkrdate
10:25:10   4  ,NULL gattn
10:25:10   5  ,g00
10:25:10   6  ,g01
10:25:10   7  ,g02
10:25:10   8  ,g03
10:25:10   9  ,g04
10:25:10  10  ,g05
10:25:10  11  ,g06
10:25:10  12  ,g07
10:25:10  13  ,g08
10:25:10  14  ,g09
10:25:10  15  ,g10
10:25:10  16  ,g11
10:25:10  17  ,g12
10:25:10  18  ,g13
10:25:10  19  ,g14
10:25:10  20  ,g15
10:25:10  21  ,g16
10:25:10  22  ,g17
10:25:10  23  ,g18
10:25:10  24  ,g19
10:25:10  25  ,g20
10:25:10  26  ,g21
10:25:10  27  ,g22
10:25:10  28  ,g23
10:25:10  29  ,g24
10:25:10  30  ,g25
10:25:10  31  ,g26
10:25:10  32  ,g27
10:25:10  33  ,g28
10:25:10  34  ,g29
10:25:10  35  FROM stk_ms
10:25:10  36  WHERE ydate = '&1'
10:25:10  37  AND tkr = '&2'
10:25:10  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-01'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:01.71
10:25:12 SQL> 
10:25:12 SQL> -- rpt
10:25:12 SQL> -- We should see just 1 row:
10:25:12 SQL> 
10:25:12 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:12   2  
10:25:12 SQL> -- Build the model:
10:25:12 SQL> CREATE OR REPLACE VIEW bme AS
10:25:12   2  SELECT
10:25:12   3  tkrdate
10:25:12   4  ,gattn
10:25:12   5  ,g00
10:25:12   6  ,g01
10:25:12   7  ,g02
10:25:12   8  ,g03
10:25:12   9  ,g04
10:25:12  10  ,g05
10:25:12  11  ,g06
10:25:12  12  ,g07
10:25:12  13  ,g08
10:25:12  14  ,g09
10:25:12  15  ,g10
10:25:12  16  ,g11
10:25:12  17  ,g12
10:25:12  18  ,g13
10:25:12  19  ,g14
10:25:12  20  ,g15
10:25:12  21  ,g16
10:25:12  22  ,g17
10:25:12  23  ,g18
10:25:12  24  ,g19
10:25:12  25  ,g20
10:25:12  26  ,g21
10:25:12  27  ,g22
10:25:12  28  ,g23
10:25:12  29  ,g24
10:25:12  30  ,g25
10:25:12  31  ,g26
10:25:12  32  ,g27
10:25:12  33  ,g28
10:25:12  34  ,g29
10:25:12  35  FROM stk_ms
10:25:12  36  WHERE gattn IN('nup','up')
10:25:12  37  -- Use only rows which are older than 1 day:
10:25:12  38  AND 1+ydate < '&1'
10:25:12  39  AND tkr = '&2'
10:25:12  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-01'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:12 SQL> 
10:25:12 SQL> -- rpt
10:25:12 SQL> 
10:25:12 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:25:12   2  
10:25:12 SQL> SELECT MAX(tkrdate) FROM bme
10:25:12   2  
10:25:12 SQL> -- Now build model from bme and score sme
10:25:12 SQL> @score1.sql gattn
10:25:12 SQL> -- score1.sql
10:25:12 SQL> 
10:25:12 SQL> -- I use this script to send 5 params to score.sql
10:25:12 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:12 SQL> -- Then at the very end of this script I use the model
10:25:12 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:12 SQL> 
10:25:12 SQL> -- I call this script from 2 other scripts:
10:25:12 SQL> -- score1_5min.sql
10:25:12 SQL> -- score1_5min_gattn.sql
10:25:12 SQL> 
10:25:12 SQL> -- The 1st param is the name of the target attribute.
10:25:12 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:12 SQL> 
10:25:12 SQL> -- Demo:
10:25:12 SQL> -- @score1.sql 'gatt'
10:25:12 SQL> -- @score1.sql 'gattn'
10:25:12 SQL> 
10:25:12 SQL> -- Now, I fill up svmc_apply_prep.
10:25:12 SQL> -- I use same model_name used in score.sql
10:25:12 SQL> DEFINE model_name = 'svmspy101'
10:25:12 SQL> DEFINE bldtable	= 'bme'
10:25:12 SQL> DEFINE scoretable = 'sme'
10:25:12 SQL> DEFINE case_id	= 'tkrdate'
10:25:12 SQL> -- Demo:
10:25:12 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:12 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:12 SQL> --
10:25:12 SQL> -- score.sql
10:25:12 SQL> --
10:25:12 SQL> 
10:25:12 SQL> -- usage: score.sql
10:25:12 SQL> 
10:25:12 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:12 SQL> 
10:25:12 SQL> -- DEFINE target	   = 'gatt'
10:25:12 SQL> -- DEFINE model_name = 'svmspy100'
10:25:12 SQL> -- DEFINE bldtable   = 'bme'
10:25:12 SQL> -- DEFINE scoretable = 'sme'
10:25:12 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:12 SQL> 
10:25:12 SQL> DEFINE target	= '&1'
10:25:12 SQL> DEFINE model_name = '&2'
10:25:12 SQL> DEFINE bldtable	= '&3'
10:25:12 SQL> DEFINE scoretable = '&4'
10:25:12 SQL> DEFINE case_id	= '&5'
10:25:12 SQL> 
10:25:12 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:12 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:12 SQL> 
10:25:12 SQL> -- Builds an SVM model using pl/sql.
10:25:12 SQL> 
10:25:12 SQL> -----------------------------------------------------------------------
10:25:12 SQL> --			    BUILD THE MODEL
10:25:12 SQL> -----------------------------------------------------------------------
10:25:12 SQL> 
10:25:12 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:12 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:12 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:12 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:12 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:12 SQL> 
10:25:12 SQL> 
10:25:12 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:12 SQL> --
10:25:12 SQL> -- DROP	TABLE svmc_settings ;
10:25:12 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:12 SQL> -- DELETE svmc_settings;
10:25:12 SQL> 
10:25:12 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:12 SQL> -- this choice to SVM using a settings table.
10:25:12 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:12 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:12 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:12 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:12 SQL> -- models.
10:25:12 SQL> --
10:25:12 SQL> 
10:25:12 SQL> -- Do this once and then comment it out.
10:25:12 SQL> -- That makes script go faster.
10:25:12 SQL> -- BEGIN
10:25:12 SQL> -- -- Populate settings table
10:25:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:12 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:12 SQL> --
10:25:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:12 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:12 SQL> --
10:25:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:12 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:12 SQL> --   COMMIT;
10:25:12 SQL> -- END;
10:25:12 SQL> -- /
10:25:12 SQL> 
10:25:12 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:12 SQL> 
10:25:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:25:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:12 SQL> 
10:25:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:12 SQL> 
10:25:12 SQL> --------------------------------
10:25:12 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:12 SQL> --
10:25:12 SQL> 
10:25:12 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:12 SQL> -- 2. Outlier Treatment and
10:25:12 SQL> -- 3. Normalization are performed below.
10:25:12 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:12 SQL> --    normalized here.
10:25:12 SQL> 
10:25:12 SQL> BEGIN
10:25:12   2  	-- Perform missing value treatment for all predictors
10:25:12   3  	-- create miss tables
10:25:12   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:12   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:12   6  
10:25:12   7  	-- populate miss tables
10:25:12   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:12   9  	  miss_table_name => 'svmc_miss_num',
10:25:12  10  	  data_table_name => '&bldtable',
10:25:12  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:12  12  
10:25:12  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:12  14  	  miss_table_name => 'svmc_miss_cat',
10:25:12  15  	  data_table_name => '&bldtable',
10:25:12  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:12  17  
10:25:12  18  	-- xform input data to replace missing values
10:25:12  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:12  20  	  miss_table_name => 'svmc_miss_num',
10:25:12  21  	  data_table_name => '&bldtable',
10:25:12  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:12  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:12  24  	  miss_table_name => 'svmc_miss_cat',
10:25:12  25  	  data_table_name => '&bldtable',
10:25:12  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:12  27  
10:25:12  28  	-- Perform outlier treatment.
10:25:12  29  	-- create clip table
10:25:12  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:12  31  
10:25:12  32  	-- populate clip table
10:25:12  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:12  34  	  clip_table_name => 'svmc_clip',
10:25:12  35  	  data_table_name => '&bldtable',
10:25:12  36  	  tail_frac	  => 0.025,
10:25:12  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:12  38  
10:25:12  39  	-- xform input data to winsorized data
10:25:12  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:12  41  	  clip_table_name => 'svmc_clip',
10:25:12  42  	  data_table_name => '&bldtable',
10:25:12  43  	  xform_view_name => 'svmc_winsor');
10:25:12  44  
10:25:12  45  	-- create normalization table
10:25:12  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:12  47  
10:25:12  48  	-- populate normalization table based on winsorized data
10:25:12  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:12  50  	  norm_table_name => 'svmc_norm',
10:25:12  51  	  data_table_name => 'svmc_winsor',
10:25:12  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:12  53  
10:25:12  54  	-- normalize the original data
10:25:12  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:12  56  	  norm_table_name => 'svmc_norm',
10:25:12  57  	  data_table_name => '&bldtable',
10:25:12  58  	  xform_view_name => 'svmc_build_prep');
10:25:12  59  END;
10:25:12  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:25:13 SQL> 
10:25:13 SQL> ---------------------
10:25:13 SQL> -- CREATE A NEW MODEL
10:25:13 SQL> --
10:25:13 SQL> -- Cleanup old model with the same name for repeat runs
10:25:13 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:13   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.98
10:25:14 SQL> 
10:25:14 SQL> -- Build a new SVM Model
10:25:14 SQL> BEGIN
10:25:14   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:14   3  	  model_name	      => '&model_name',
10:25:14   4  	  mining_function     => dbms_data_mining.classification,
10:25:14   5  	  data_table_name     => 'svmc_build_prep',
10:25:14   6  	  case_id_column_name => '&case_id',
10:25:14   7  	  target_column_name  => '&target',
10:25:14   8  	  settings_table_name => 'svmc_settings');
10:25:14   9  END;
10:25:14  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.86
10:25:15 SQL> 
10:25:15 SQL> -----------------------------------------------------------------------
10:25:15 SQL> --			       APPLY/score THE MODEL
10:25:15 SQL> -----------------------------------------------------------------------
10:25:15 SQL> 
10:25:15 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:16 SQL> -----------------------
10:25:16 SQL> -- PREPARE SCORING DATA
10:25:16 SQL> --
10:25:16 SQL> -- If the data for model creation has been prepared, then the data
10:25:16 SQL> -- to be scored using the model must be prepared in the same manner
10:25:16 SQL> -- in order to obtain meaningful results.
10:25:16 SQL> --
10:25:16 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:16 SQL> -- 2. Normalization
10:25:16 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:16 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:16 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:16 SQL> --
10:25:16 SQL> BEGIN
10:25:16   2  	-- Xform Test data to replace missing values
10:25:16   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:16   4  	  miss_table_name => 'svmc_miss_num',
10:25:16   5  	  data_table_name => '&scoretable',
10:25:16   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:16   7  
10:25:16   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:16   9  	  miss_table_name => 'svmc_miss_cat',
10:25:16  10  	  data_table_name => '&scoretable',
10:25:16  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:16  12  
10:25:16  13  	-- Normalize the data to be scored
10:25:16  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:16  15  	  norm_table_name => 'svmc_norm',
10:25:16  16  	  data_table_name => '&scoretable',
10:25:16  17  	  xform_view_name => 'svmc_apply_prep');
10:25:16  18  END;
10:25:16  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:25:16 SQL> 
10:25:16 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:16 SQL> -- DELETE it if I did:
10:25:16 SQL> DELETE ystkscores
10:25:16   2  WHERE score > 0
10:25:16   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:16   4  -- I need to supply the target attribute name:
10:25:16   5  AND targ = '&1'
10:25:16   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:16 SQL> 
10:25:16 SQL> -- We do a drumroll here:
10:25:16 SQL> 
10:25:16 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:16   2  SELECT
10:25:16   3  tkrdate
10:25:16   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:16   5  ,sysdate
10:25:16   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:16   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:16   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:16   9  ,SUBSTR(tkrdate,-10)ydate
10:25:16  10  ,'&1'
10:25:16  11  FROM svmc_apply_prep
10:25:16  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:25:16 SQL> @score1_5min.sql	      2010-03-05 TLT
10:25:16 SQL> --
10:25:16 SQL> -- score1_5min.sql
10:25:16 SQL> --
10:25:16 SQL> 
10:25:16 SQL> -- Demo:
10:25:16 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:16 SQL> 
10:25:16 SQL> CREATE OR REPLACE VIEW sme AS
10:25:16   2  SELECT
10:25:16   3  tkrdate
10:25:16   4  ,NULL gatt
10:25:16   5  ,g00
10:25:16   6  ,g01
10:25:16   7  ,g02
10:25:16   8  ,g03
10:25:16   9  ,g04
10:25:16  10  ,g05
10:25:16  11  ,g06
10:25:16  12  ,g07
10:25:16  13  ,g08
10:25:16  14  ,g09
10:25:16  15  ,g10
10:25:16  16  ,g11
10:25:16  17  ,g12
10:25:16  18  ,g13
10:25:16  19  ,g14
10:25:16  20  ,g15
10:25:16  21  ,g16
10:25:16  22  ,g17
10:25:16  23  ,g18
10:25:16  24  ,g19
10:25:16  25  ,g20
10:25:16  26  ,g21
10:25:16  27  ,g22
10:25:16  28  ,g23
10:25:16  29  ,g24
10:25:16  30  ,g25
10:25:16  31  ,g26
10:25:16  32  ,g27
10:25:16  33  ,g28
10:25:16  34  ,g29
10:25:16  35  FROM stk_ms
10:25:16  36  WHERE ydate = '&1'
10:25:16  37  AND tkr = '&2'
10:25:16  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-05'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:16 SQL> 
10:25:16 SQL> -- rpt
10:25:16 SQL> -- We should see just 1 row:
10:25:16 SQL> 
10:25:16 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:16   2  
10:25:16 SQL> -- Build the model:
10:25:16 SQL> CREATE OR REPLACE VIEW bme AS
10:25:16   2  SELECT
10:25:16   3  tkrdate
10:25:16   4  ,gatt
10:25:16   5  ,g00
10:25:16   6  ,g01
10:25:16   7  ,g02
10:25:16   8  ,g03
10:25:16   9  ,g04
10:25:16  10  ,g05
10:25:16  11  ,g06
10:25:16  12  ,g07
10:25:16  13  ,g08
10:25:16  14  ,g09
10:25:16  15  ,g10
10:25:16  16  ,g11
10:25:16  17  ,g12
10:25:16  18  ,g13
10:25:16  19  ,g14
10:25:16  20  ,g15
10:25:16  21  ,g16
10:25:16  22  ,g17
10:25:16  23  ,g18
10:25:16  24  ,g19
10:25:16  25  ,g20
10:25:16  26  ,g21
10:25:16  27  ,g22
10:25:16  28  ,g23
10:25:16  29  ,g24
10:25:16  30  ,g25
10:25:16  31  ,g26
10:25:16  32  ,g27
10:25:16  33  ,g28
10:25:16  34  ,g29
10:25:16  35  FROM stk_ms
10:25:16  36  WHERE gatt IN('nup','up')
10:25:16  37  -- Use only rows which are older than 1 day:
10:25:16  38  AND 1+ydate < '&1'
10:25:16  39  AND tkr = '&2'
10:25:16  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-05'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:16 SQL> 
10:25:16 SQL> -- rpt
10:25:16 SQL> 
10:25:16 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:16   2  
10:25:16 SQL> SELECT MAX(tkrdate) FROM bme
10:25:16   2  
10:25:16 SQL> -- Now build model from bme and score sme
10:25:16 SQL> @score1.sql gatt
10:25:16 SQL> -- score1.sql
10:25:16 SQL> 
10:25:16 SQL> -- I use this script to send 5 params to score.sql
10:25:16 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:16 SQL> -- Then at the very end of this script I use the model
10:25:16 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:16 SQL> 
10:25:16 SQL> -- I call this script from 2 other scripts:
10:25:16 SQL> -- score1_5min.sql
10:25:16 SQL> -- score1_5min_gattn.sql
10:25:16 SQL> 
10:25:16 SQL> -- The 1st param is the name of the target attribute.
10:25:16 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:16 SQL> 
10:25:16 SQL> -- Demo:
10:25:16 SQL> -- @score1.sql 'gatt'
10:25:16 SQL> -- @score1.sql 'gattn'
10:25:16 SQL> 
10:25:16 SQL> -- Now, I fill up svmc_apply_prep.
10:25:16 SQL> -- I use same model_name used in score.sql
10:25:16 SQL> DEFINE model_name = 'svmspy101'
10:25:16 SQL> DEFINE bldtable	= 'bme'
10:25:16 SQL> DEFINE scoretable = 'sme'
10:25:16 SQL> DEFINE case_id	= 'tkrdate'
10:25:16 SQL> -- Demo:
10:25:16 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:16 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:16 SQL> --
10:25:16 SQL> -- score.sql
10:25:16 SQL> --
10:25:16 SQL> 
10:25:16 SQL> -- usage: score.sql
10:25:16 SQL> 
10:25:16 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:16 SQL> 
10:25:16 SQL> -- DEFINE target	   = 'gatt'
10:25:16 SQL> -- DEFINE model_name = 'svmspy100'
10:25:16 SQL> -- DEFINE bldtable   = 'bme'
10:25:16 SQL> -- DEFINE scoretable = 'sme'
10:25:16 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:16 SQL> 
10:25:16 SQL> DEFINE target	= '&1'
10:25:16 SQL> DEFINE model_name = '&2'
10:25:16 SQL> DEFINE bldtable	= '&3'
10:25:16 SQL> DEFINE scoretable = '&4'
10:25:16 SQL> DEFINE case_id	= '&5'
10:25:16 SQL> 
10:25:16 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:16 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:16 SQL> 
10:25:16 SQL> -- Builds an SVM model using pl/sql.
10:25:16 SQL> 
10:25:16 SQL> -----------------------------------------------------------------------
10:25:16 SQL> --			    BUILD THE MODEL
10:25:16 SQL> -----------------------------------------------------------------------
10:25:16 SQL> 
10:25:16 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:16 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:16 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:25:16 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:16 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:16 SQL> 
10:25:16 SQL> 
10:25:16 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:16 SQL> --
10:25:16 SQL> -- DROP	TABLE svmc_settings ;
10:25:16 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:16 SQL> -- DELETE svmc_settings;
10:25:16 SQL> 
10:25:16 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:16 SQL> -- this choice to SVM using a settings table.
10:25:16 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:16 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:16 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:16 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:16 SQL> -- models.
10:25:16 SQL> --
10:25:16 SQL> 
10:25:16 SQL> -- Do this once and then comment it out.
10:25:16 SQL> -- That makes script go faster.
10:25:16 SQL> -- BEGIN
10:25:16 SQL> -- -- Populate settings table
10:25:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:16 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:16 SQL> --
10:25:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:16 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:16 SQL> --
10:25:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:16 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:16 SQL> --   COMMIT;
10:25:16 SQL> -- END;
10:25:16 SQL> -- /
10:25:16 SQL> 
10:25:16 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:16 SQL> 
10:25:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:25:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:16 SQL> 
10:25:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:16 SQL> 
10:25:16 SQL> --------------------------------
10:25:16 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:16 SQL> --
10:25:16 SQL> 
10:25:16 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:16 SQL> -- 2. Outlier Treatment and
10:25:16 SQL> -- 3. Normalization are performed below.
10:25:16 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:16 SQL> --    normalized here.
10:25:16 SQL> 
10:25:16 SQL> BEGIN
10:25:16   2  	-- Perform missing value treatment for all predictors
10:25:16   3  	-- create miss tables
10:25:16   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:16   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:16   6  
10:25:16   7  	-- populate miss tables
10:25:16   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:16   9  	  miss_table_name => 'svmc_miss_num',
10:25:16  10  	  data_table_name => '&bldtable',
10:25:16  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:16  12  
10:25:16  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:16  14  	  miss_table_name => 'svmc_miss_cat',
10:25:16  15  	  data_table_name => '&bldtable',
10:25:16  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:16  17  
10:25:16  18  	-- xform input data to replace missing values
10:25:16  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:16  20  	  miss_table_name => 'svmc_miss_num',
10:25:16  21  	  data_table_name => '&bldtable',
10:25:16  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:16  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:16  24  	  miss_table_name => 'svmc_miss_cat',
10:25:16  25  	  data_table_name => '&bldtable',
10:25:16  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:16  27  
10:25:16  28  	-- Perform outlier treatment.
10:25:16  29  	-- create clip table
10:25:16  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:16  31  
10:25:16  32  	-- populate clip table
10:25:16  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:16  34  	  clip_table_name => 'svmc_clip',
10:25:16  35  	  data_table_name => '&bldtable',
10:25:16  36  	  tail_frac	  => 0.025,
10:25:16  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:16  38  
10:25:16  39  	-- xform input data to winsorized data
10:25:16  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:16  41  	  clip_table_name => 'svmc_clip',
10:25:16  42  	  data_table_name => '&bldtable',
10:25:16  43  	  xform_view_name => 'svmc_winsor');
10:25:16  44  
10:25:16  45  	-- create normalization table
10:25:16  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:16  47  
10:25:16  48  	-- populate normalization table based on winsorized data
10:25:16  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:16  50  	  norm_table_name => 'svmc_norm',
10:25:16  51  	  data_table_name => 'svmc_winsor',
10:25:16  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:16  53  
10:25:16  54  	-- normalize the original data
10:25:16  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:16  56  	  norm_table_name => 'svmc_norm',
10:25:16  57  	  data_table_name => '&bldtable',
10:25:16  58  	  xform_view_name => 'svmc_build_prep');
10:25:16  59  END;
10:25:16  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:25:17 SQL> 
10:25:17 SQL> ---------------------
10:25:17 SQL> -- CREATE A NEW MODEL
10:25:17 SQL> --
10:25:17 SQL> -- Cleanup old model with the same name for repeat runs
10:25:17 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:17   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.01
10:25:19 SQL> 
10:25:19 SQL> -- Build a new SVM Model
10:25:19 SQL> BEGIN
10:25:19   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:19   3  	  model_name	      => '&model_name',
10:25:19   4  	  mining_function     => dbms_data_mining.classification,
10:25:19   5  	  data_table_name     => 'svmc_build_prep',
10:25:19   6  	  case_id_column_name => '&case_id',
10:25:19   7  	  target_column_name  => '&target',
10:25:19   8  	  settings_table_name => 'svmc_settings');
10:25:19   9  END;
10:25:19  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.20
10:25:21 SQL> 
10:25:21 SQL> -----------------------------------------------------------------------
10:25:21 SQL> --			       APPLY/score THE MODEL
10:25:21 SQL> -----------------------------------------------------------------------
10:25:21 SQL> 
10:25:21 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:21 SQL> -----------------------
10:25:21 SQL> -- PREPARE SCORING DATA
10:25:21 SQL> --
10:25:21 SQL> -- If the data for model creation has been prepared, then the data
10:25:21 SQL> -- to be scored using the model must be prepared in the same manner
10:25:21 SQL> -- in order to obtain meaningful results.
10:25:21 SQL> --
10:25:21 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:21 SQL> -- 2. Normalization
10:25:21 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:21 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:21 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:21 SQL> --
10:25:21 SQL> BEGIN
10:25:21   2  	-- Xform Test data to replace missing values
10:25:21   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:21   4  	  miss_table_name => 'svmc_miss_num',
10:25:21   5  	  data_table_name => '&scoretable',
10:25:21   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:21   7  
10:25:21   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:21   9  	  miss_table_name => 'svmc_miss_cat',
10:25:21  10  	  data_table_name => '&scoretable',
10:25:21  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:21  12  
10:25:21  13  	-- Normalize the data to be scored
10:25:21  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:21  15  	  norm_table_name => 'svmc_norm',
10:25:21  16  	  data_table_name => '&scoretable',
10:25:21  17  	  xform_view_name => 'svmc_apply_prep');
10:25:21  18  END;
10:25:21  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:25:21 SQL> 
10:25:21 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:21 SQL> -- DELETE it if I did:
10:25:21 SQL> DELETE ystkscores
10:25:21   2  WHERE score > 0
10:25:21   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:21   4  -- I need to supply the target attribute name:
10:25:21   5  AND targ = '&1'
10:25:21   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:21 SQL> 
10:25:21 SQL> -- We do a drumroll here:
10:25:21 SQL> 
10:25:21 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:21   2  SELECT
10:25:21   3  tkrdate
10:25:21   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:21   5  ,sysdate
10:25:21   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:21   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:21   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:21   9  ,SUBSTR(tkrdate,-10)ydate
10:25:21  10  ,'&1'
10:25:21  11  FROM svmc_apply_prep
10:25:21  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:25:21 SQL> @score1_5min.sql	      2010-03-18 TLT
10:25:21 SQL> --
10:25:21 SQL> -- score1_5min.sql
10:25:21 SQL> --
10:25:21 SQL> 
10:25:21 SQL> -- Demo:
10:25:21 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:21 SQL> 
10:25:21 SQL> CREATE OR REPLACE VIEW sme AS
10:25:21   2  SELECT
10:25:21   3  tkrdate
10:25:21   4  ,NULL gatt
10:25:21   5  ,g00
10:25:21   6  ,g01
10:25:21   7  ,g02
10:25:21   8  ,g03
10:25:21   9  ,g04
10:25:21  10  ,g05
10:25:21  11  ,g06
10:25:21  12  ,g07
10:25:21  13  ,g08
10:25:21  14  ,g09
10:25:21  15  ,g10
10:25:21  16  ,g11
10:25:21  17  ,g12
10:25:21  18  ,g13
10:25:21  19  ,g14
10:25:21  20  ,g15
10:25:21  21  ,g16
10:25:21  22  ,g17
10:25:21  23  ,g18
10:25:21  24  ,g19
10:25:21  25  ,g20
10:25:21  26  ,g21
10:25:21  27  ,g22
10:25:21  28  ,g23
10:25:21  29  ,g24
10:25:21  30  ,g25
10:25:21  31  ,g26
10:25:21  32  ,g27
10:25:21  33  ,g28
10:25:21  34  ,g29
10:25:21  35  FROM stk_ms
10:25:21  36  WHERE ydate = '&1'
10:25:21  37  AND tkr = '&2'
10:25:21  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-18'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:21 SQL> 
10:25:21 SQL> -- rpt
10:25:21 SQL> -- We should see just 1 row:
10:25:21 SQL> 
10:25:21 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:21   2  
10:25:21 SQL> -- Build the model:
10:25:21 SQL> CREATE OR REPLACE VIEW bme AS
10:25:21   2  SELECT
10:25:21   3  tkrdate
10:25:21   4  ,gatt
10:25:21   5  ,g00
10:25:21   6  ,g01
10:25:21   7  ,g02
10:25:21   8  ,g03
10:25:21   9  ,g04
10:25:21  10  ,g05
10:25:21  11  ,g06
10:25:21  12  ,g07
10:25:21  13  ,g08
10:25:21  14  ,g09
10:25:21  15  ,g10
10:25:21  16  ,g11
10:25:21  17  ,g12
10:25:21  18  ,g13
10:25:21  19  ,g14
10:25:21  20  ,g15
10:25:21  21  ,g16
10:25:21  22  ,g17
10:25:21  23  ,g18
10:25:21  24  ,g19
10:25:21  25  ,g20
10:25:21  26  ,g21
10:25:21  27  ,g22
10:25:21  28  ,g23
10:25:21  29  ,g24
10:25:21  30  ,g25
10:25:21  31  ,g26
10:25:21  32  ,g27
10:25:21  33  ,g28
10:25:21  34  ,g29
10:25:21  35  FROM stk_ms
10:25:21  36  WHERE gatt IN('nup','up')
10:25:21  37  -- Use only rows which are older than 1 day:
10:25:21  38  AND 1+ydate < '&1'
10:25:21  39  AND tkr = '&2'
10:25:21  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-18'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:21 SQL> 
10:25:21 SQL> -- rpt
10:25:21 SQL> 
10:25:21 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:21   2  
10:25:21 SQL> SELECT MAX(tkrdate) FROM bme
10:25:21   2  
10:25:21 SQL> -- Now build model from bme and score sme
10:25:21 SQL> @score1.sql gatt
10:25:21 SQL> -- score1.sql
10:25:21 SQL> 
10:25:21 SQL> -- I use this script to send 5 params to score.sql
10:25:21 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:21 SQL> -- Then at the very end of this script I use the model
10:25:21 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:21 SQL> 
10:25:21 SQL> -- I call this script from 2 other scripts:
10:25:21 SQL> -- score1_5min.sql
10:25:21 SQL> -- score1_5min_gattn.sql
10:25:21 SQL> 
10:25:21 SQL> -- The 1st param is the name of the target attribute.
10:25:21 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:21 SQL> 
10:25:21 SQL> -- Demo:
10:25:21 SQL> -- @score1.sql 'gatt'
10:25:21 SQL> -- @score1.sql 'gattn'
10:25:21 SQL> 
10:25:21 SQL> -- Now, I fill up svmc_apply_prep.
10:25:21 SQL> -- I use same model_name used in score.sql
10:25:21 SQL> DEFINE model_name = 'svmspy101'
10:25:21 SQL> DEFINE bldtable	= 'bme'
10:25:21 SQL> DEFINE scoretable = 'sme'
10:25:21 SQL> DEFINE case_id	= 'tkrdate'
10:25:21 SQL> -- Demo:
10:25:21 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:21 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:21 SQL> --
10:25:21 SQL> -- score.sql
10:25:21 SQL> --
10:25:21 SQL> 
10:25:21 SQL> -- usage: score.sql
10:25:21 SQL> 
10:25:21 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:21 SQL> 
10:25:21 SQL> -- DEFINE target	   = 'gatt'
10:25:21 SQL> -- DEFINE model_name = 'svmspy100'
10:25:21 SQL> -- DEFINE bldtable   = 'bme'
10:25:21 SQL> -- DEFINE scoretable = 'sme'
10:25:21 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:21 SQL> 
10:25:21 SQL> DEFINE target	= '&1'
10:25:21 SQL> DEFINE model_name = '&2'
10:25:21 SQL> DEFINE bldtable	= '&3'
10:25:21 SQL> DEFINE scoretable = '&4'
10:25:21 SQL> DEFINE case_id	= '&5'
10:25:21 SQL> 
10:25:21 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:21 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:21 SQL> 
10:25:21 SQL> -- Builds an SVM model using pl/sql.
10:25:21 SQL> 
10:25:21 SQL> -----------------------------------------------------------------------
10:25:21 SQL> --			    BUILD THE MODEL
10:25:21 SQL> -----------------------------------------------------------------------
10:25:21 SQL> 
10:25:21 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:21 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:21 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:21 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:21 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:21 SQL> 
10:25:21 SQL> 
10:25:21 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:21 SQL> --
10:25:21 SQL> -- DROP	TABLE svmc_settings ;
10:25:21 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:21 SQL> -- DELETE svmc_settings;
10:25:21 SQL> 
10:25:21 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:21 SQL> -- this choice to SVM using a settings table.
10:25:21 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:21 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:21 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:21 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:21 SQL> -- models.
10:25:21 SQL> --
10:25:21 SQL> 
10:25:21 SQL> -- Do this once and then comment it out.
10:25:21 SQL> -- That makes script go faster.
10:25:21 SQL> -- BEGIN
10:25:21 SQL> -- -- Populate settings table
10:25:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:21 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:21 SQL> --
10:25:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:21 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:21 SQL> --
10:25:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:21 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:21 SQL> --   COMMIT;
10:25:21 SQL> -- END;
10:25:21 SQL> -- /
10:25:21 SQL> 
10:25:21 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:21 SQL> 
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:21 SQL> 
10:25:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:21 SQL> 
10:25:21 SQL> --------------------------------
10:25:21 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:21 SQL> --
10:25:21 SQL> 
10:25:21 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:21 SQL> -- 2. Outlier Treatment and
10:25:21 SQL> -- 3. Normalization are performed below.
10:25:21 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:21 SQL> --    normalized here.
10:25:21 SQL> 
10:25:21 SQL> BEGIN
10:25:21   2  	-- Perform missing value treatment for all predictors
10:25:21   3  	-- create miss tables
10:25:21   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:21   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:21   6  
10:25:21   7  	-- populate miss tables
10:25:21   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:21   9  	  miss_table_name => 'svmc_miss_num',
10:25:21  10  	  data_table_name => '&bldtable',
10:25:21  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:21  12  
10:25:21  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:21  14  	  miss_table_name => 'svmc_miss_cat',
10:25:21  15  	  data_table_name => '&bldtable',
10:25:21  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:21  17  
10:25:21  18  	-- xform input data to replace missing values
10:25:21  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:21  20  	  miss_table_name => 'svmc_miss_num',
10:25:21  21  	  data_table_name => '&bldtable',
10:25:21  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:21  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:21  24  	  miss_table_name => 'svmc_miss_cat',
10:25:21  25  	  data_table_name => '&bldtable',
10:25:21  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:21  27  
10:25:21  28  	-- Perform outlier treatment.
10:25:21  29  	-- create clip table
10:25:21  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:21  31  
10:25:21  32  	-- populate clip table
10:25:21  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:21  34  	  clip_table_name => 'svmc_clip',
10:25:21  35  	  data_table_name => '&bldtable',
10:25:21  36  	  tail_frac	  => 0.025,
10:25:21  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:21  38  
10:25:21  39  	-- xform input data to winsorized data
10:25:21  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:21  41  	  clip_table_name => 'svmc_clip',
10:25:21  42  	  data_table_name => '&bldtable',
10:25:21  43  	  xform_view_name => 'svmc_winsor');
10:25:21  44  
10:25:21  45  	-- create normalization table
10:25:21  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:21  47  
10:25:21  48  	-- populate normalization table based on winsorized data
10:25:21  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:21  50  	  norm_table_name => 'svmc_norm',
10:25:21  51  	  data_table_name => 'svmc_winsor',
10:25:21  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:21  53  
10:25:21  54  	-- normalize the original data
10:25:21  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:21  56  	  norm_table_name => 'svmc_norm',
10:25:21  57  	  data_table_name => '&bldtable',
10:25:21  58  	  xform_view_name => 'svmc_build_prep');
10:25:21  59  END;
10:25:21  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:25:22 SQL> 
10:25:22 SQL> ---------------------
10:25:22 SQL> -- CREATE A NEW MODEL
10:25:22 SQL> --
10:25:22 SQL> -- Cleanup old model with the same name for repeat runs
10:25:22 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:22   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.94
10:25:23 SQL> 
10:25:23 SQL> -- Build a new SVM Model
10:25:23 SQL> BEGIN
10:25:23   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:23   3  	  model_name	      => '&model_name',
10:25:23   4  	  mining_function     => dbms_data_mining.classification,
10:25:23   5  	  data_table_name     => 'svmc_build_prep',
10:25:23   6  	  case_id_column_name => '&case_id',
10:25:23   7  	  target_column_name  => '&target',
10:25:23   8  	  settings_table_name => 'svmc_settings');
10:25:23   9  END;
10:25:23  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.31
10:25:25 SQL> 
10:25:25 SQL> -----------------------------------------------------------------------
10:25:25 SQL> --			       APPLY/score THE MODEL
10:25:25 SQL> -----------------------------------------------------------------------
10:25:25 SQL> 
10:25:25 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:25 SQL> -----------------------
10:25:25 SQL> -- PREPARE SCORING DATA
10:25:25 SQL> --
10:25:25 SQL> -- If the data for model creation has been prepared, then the data
10:25:25 SQL> -- to be scored using the model must be prepared in the same manner
10:25:25 SQL> -- in order to obtain meaningful results.
10:25:25 SQL> --
10:25:25 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:25 SQL> -- 2. Normalization
10:25:25 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:25 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:25 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:25 SQL> --
10:25:25 SQL> BEGIN
10:25:25   2  	-- Xform Test data to replace missing values
10:25:25   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:25   4  	  miss_table_name => 'svmc_miss_num',
10:25:25   5  	  data_table_name => '&scoretable',
10:25:25   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:25   7  
10:25:25   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:25   9  	  miss_table_name => 'svmc_miss_cat',
10:25:25  10  	  data_table_name => '&scoretable',
10:25:25  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:25  12  
10:25:25  13  	-- Normalize the data to be scored
10:25:25  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:25  15  	  norm_table_name => 'svmc_norm',
10:25:25  16  	  data_table_name => '&scoretable',
10:25:25  17  	  xform_view_name => 'svmc_apply_prep');
10:25:25  18  END;
10:25:25  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.27
10:25:26 SQL> 
10:25:26 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:26 SQL> -- DELETE it if I did:
10:25:26 SQL> DELETE ystkscores
10:25:26   2  WHERE score > 0
10:25:26   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:26   4  -- I need to supply the target attribute name:
10:25:26   5  AND targ = '&1'
10:25:26   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:25:26 SQL> 
10:25:26 SQL> -- We do a drumroll here:
10:25:26 SQL> 
10:25:26 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:26   2  SELECT
10:25:26   3  tkrdate
10:25:26   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:26   5  ,sysdate
10:25:26   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:26   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:26   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:26   9  ,SUBSTR(tkrdate,-10)ydate
10:25:26  10  ,'&1'
10:25:26  11  FROM svmc_apply_prep
10:25:26  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:25:26 SQL> @score1_5min_gattn.sql	2010-02-26 TLT
10:25:26 SQL> --
10:25:26 SQL> -- score1_5min_gattn.sql
10:25:26 SQL> --
10:25:26 SQL> 
10:25:26 SQL> -- Demo:
10:25:26 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:25:26 SQL> 
10:25:26 SQL> CREATE OR REPLACE VIEW sme AS
10:25:26   2  SELECT
10:25:26   3  tkrdate
10:25:26   4  ,NULL gattn
10:25:26   5  ,g00
10:25:26   6  ,g01
10:25:26   7  ,g02
10:25:26   8  ,g03
10:25:26   9  ,g04
10:25:26  10  ,g05
10:25:26  11  ,g06
10:25:26  12  ,g07
10:25:26  13  ,g08
10:25:26  14  ,g09
10:25:26  15  ,g10
10:25:26  16  ,g11
10:25:26  17  ,g12
10:25:26  18  ,g13
10:25:26  19  ,g14
10:25:26  20  ,g15
10:25:26  21  ,g16
10:25:26  22  ,g17
10:25:26  23  ,g18
10:25:26  24  ,g19
10:25:26  25  ,g20
10:25:26  26  ,g21
10:25:26  27  ,g22
10:25:26  28  ,g23
10:25:26  29  ,g24
10:25:26  30  ,g25
10:25:26  31  ,g26
10:25:26  32  ,g27
10:25:26  33  ,g28
10:25:26  34  ,g29
10:25:26  35  FROM stk_ms
10:25:26  36  WHERE ydate = '&1'
10:25:26  37  AND tkr = '&2'
10:25:26  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-26'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.15
10:25:26 SQL> 
10:25:26 SQL> -- rpt
10:25:26 SQL> -- We should see just 1 row:
10:25:26 SQL> 
10:25:26 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:26   2  
10:25:26 SQL> -- Build the model:
10:25:26 SQL> CREATE OR REPLACE VIEW bme AS
10:25:26   2  SELECT
10:25:26   3  tkrdate
10:25:26   4  ,gattn
10:25:26   5  ,g00
10:25:26   6  ,g01
10:25:26   7  ,g02
10:25:26   8  ,g03
10:25:26   9  ,g04
10:25:26  10  ,g05
10:25:26  11  ,g06
10:25:26  12  ,g07
10:25:26  13  ,g08
10:25:26  14  ,g09
10:25:26  15  ,g10
10:25:26  16  ,g11
10:25:26  17  ,g12
10:25:26  18  ,g13
10:25:26  19  ,g14
10:25:26  20  ,g15
10:25:26  21  ,g16
10:25:26  22  ,g17
10:25:26  23  ,g18
10:25:26  24  ,g19
10:25:26  25  ,g20
10:25:26  26  ,g21
10:25:26  27  ,g22
10:25:26  28  ,g23
10:25:26  29  ,g24
10:25:26  30  ,g25
10:25:26  31  ,g26
10:25:26  32  ,g27
10:25:26  33  ,g28
10:25:26  34  ,g29
10:25:26  35  FROM stk_ms
10:25:26  36  WHERE gattn IN('nup','up')
10:25:26  37  -- Use only rows which are older than 1 day:
10:25:26  38  AND 1+ydate < '&1'
10:25:26  39  AND tkr = '&2'
10:25:26  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-26'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:26 SQL> 
10:25:26 SQL> -- rpt
10:25:26 SQL> 
10:25:26 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:25:26   2  
10:25:26 SQL> SELECT MAX(tkrdate) FROM bme
10:25:26   2  
10:25:26 SQL> -- Now build model from bme and score sme
10:25:26 SQL> @score1.sql gattn
10:25:26 SQL> -- score1.sql
10:25:26 SQL> 
10:25:26 SQL> -- I use this script to send 5 params to score.sql
10:25:26 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:26 SQL> -- Then at the very end of this script I use the model
10:25:26 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:26 SQL> 
10:25:26 SQL> -- I call this script from 2 other scripts:
10:25:26 SQL> -- score1_5min.sql
10:25:26 SQL> -- score1_5min_gattn.sql
10:25:26 SQL> 
10:25:26 SQL> -- The 1st param is the name of the target attribute.
10:25:26 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:26 SQL> 
10:25:26 SQL> -- Demo:
10:25:26 SQL> -- @score1.sql 'gatt'
10:25:26 SQL> -- @score1.sql 'gattn'
10:25:26 SQL> 
10:25:26 SQL> -- Now, I fill up svmc_apply_prep.
10:25:26 SQL> -- I use same model_name used in score.sql
10:25:26 SQL> DEFINE model_name = 'svmspy101'
10:25:26 SQL> DEFINE bldtable	= 'bme'
10:25:26 SQL> DEFINE scoretable = 'sme'
10:25:26 SQL> DEFINE case_id	= 'tkrdate'
10:25:26 SQL> -- Demo:
10:25:26 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:26 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:26 SQL> --
10:25:26 SQL> -- score.sql
10:25:26 SQL> --
10:25:26 SQL> 
10:25:26 SQL> -- usage: score.sql
10:25:26 SQL> 
10:25:26 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:26 SQL> 
10:25:26 SQL> -- DEFINE target	   = 'gatt'
10:25:26 SQL> -- DEFINE model_name = 'svmspy100'
10:25:26 SQL> -- DEFINE bldtable   = 'bme'
10:25:26 SQL> -- DEFINE scoretable = 'sme'
10:25:26 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:26 SQL> 
10:25:26 SQL> DEFINE target	= '&1'
10:25:26 SQL> DEFINE model_name = '&2'
10:25:26 SQL> DEFINE bldtable	= '&3'
10:25:26 SQL> DEFINE scoretable = '&4'
10:25:26 SQL> DEFINE case_id	= '&5'
10:25:26 SQL> 
10:25:26 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:26 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:26 SQL> 
10:25:26 SQL> -- Builds an SVM model using pl/sql.
10:25:26 SQL> 
10:25:26 SQL> -----------------------------------------------------------------------
10:25:26 SQL> --			    BUILD THE MODEL
10:25:26 SQL> -----------------------------------------------------------------------
10:25:26 SQL> 
10:25:26 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:26 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:26 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:25:26 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:26 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:26 SQL> 
10:25:26 SQL> 
10:25:26 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:26 SQL> --
10:25:26 SQL> -- DROP	TABLE svmc_settings ;
10:25:26 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:26 SQL> -- DELETE svmc_settings;
10:25:26 SQL> 
10:25:26 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:26 SQL> -- this choice to SVM using a settings table.
10:25:26 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:26 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:26 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:26 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:26 SQL> -- models.
10:25:26 SQL> --
10:25:26 SQL> 
10:25:26 SQL> -- Do this once and then comment it out.
10:25:26 SQL> -- That makes script go faster.
10:25:26 SQL> -- BEGIN
10:25:26 SQL> -- -- Populate settings table
10:25:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:26 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:26 SQL> --
10:25:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:26 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:26 SQL> --
10:25:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:26 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:26 SQL> --   COMMIT;
10:25:26 SQL> -- END;
10:25:26 SQL> -- /
10:25:26 SQL> 
10:25:26 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:26 SQL> 
10:25:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.29
10:25:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.23
10:25:26 SQL> 
10:25:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:26 SQL> 
10:25:26 SQL> --------------------------------
10:25:26 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:26 SQL> --
10:25:26 SQL> 
10:25:26 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:26 SQL> -- 2. Outlier Treatment and
10:25:26 SQL> -- 3. Normalization are performed below.
10:25:26 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:26 SQL> --    normalized here.
10:25:26 SQL> 
10:25:26 SQL> BEGIN
10:25:26   2  	-- Perform missing value treatment for all predictors
10:25:26   3  	-- create miss tables
10:25:26   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:26   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:26   6  
10:25:26   7  	-- populate miss tables
10:25:26   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:26   9  	  miss_table_name => 'svmc_miss_num',
10:25:26  10  	  data_table_name => '&bldtable',
10:25:26  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:26  12  
10:25:26  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:26  14  	  miss_table_name => 'svmc_miss_cat',
10:25:26  15  	  data_table_name => '&bldtable',
10:25:26  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:26  17  
10:25:26  18  	-- xform input data to replace missing values
10:25:26  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:26  20  	  miss_table_name => 'svmc_miss_num',
10:25:26  21  	  data_table_name => '&bldtable',
10:25:26  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:26  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:26  24  	  miss_table_name => 'svmc_miss_cat',
10:25:26  25  	  data_table_name => '&bldtable',
10:25:26  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:26  27  
10:25:26  28  	-- Perform outlier treatment.
10:25:26  29  	-- create clip table
10:25:26  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:26  31  
10:25:26  32  	-- populate clip table
10:25:26  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:26  34  	  clip_table_name => 'svmc_clip',
10:25:26  35  	  data_table_name => '&bldtable',
10:25:26  36  	  tail_frac	  => 0.025,
10:25:26  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:26  38  
10:25:26  39  	-- xform input data to winsorized data
10:25:26  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:26  41  	  clip_table_name => 'svmc_clip',
10:25:26  42  	  data_table_name => '&bldtable',
10:25:26  43  	  xform_view_name => 'svmc_winsor');
10:25:26  44  
10:25:26  45  	-- create normalization table
10:25:26  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:26  47  
10:25:26  48  	-- populate normalization table based on winsorized data
10:25:26  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:26  50  	  norm_table_name => 'svmc_norm',
10:25:26  51  	  data_table_name => 'svmc_winsor',
10:25:26  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:26  53  
10:25:26  54  	-- normalize the original data
10:25:26  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:26  56  	  norm_table_name => 'svmc_norm',
10:25:26  57  	  data_table_name => '&bldtable',
10:25:26  58  	  xform_view_name => 'svmc_build_prep');
10:25:26  59  END;
10:25:26  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:25:27 SQL> 
10:25:27 SQL> ---------------------
10:25:27 SQL> -- CREATE A NEW MODEL
10:25:27 SQL> --
10:25:27 SQL> -- Cleanup old model with the same name for repeat runs
10:25:27 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:27   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.05
10:25:28 SQL> 
10:25:28 SQL> -- Build a new SVM Model
10:25:28 SQL> BEGIN
10:25:28   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:28   3  	  model_name	      => '&model_name',
10:25:28   4  	  mining_function     => dbms_data_mining.classification,
10:25:28   5  	  data_table_name     => 'svmc_build_prep',
10:25:28   6  	  case_id_column_name => '&case_id',
10:25:28   7  	  target_column_name  => '&target',
10:25:28   8  	  settings_table_name => 'svmc_settings');
10:25:28   9  END;
10:25:28  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.99
10:25:30 SQL> 
10:25:30 SQL> -----------------------------------------------------------------------
10:25:30 SQL> --			       APPLY/score THE MODEL
10:25:30 SQL> -----------------------------------------------------------------------
10:25:30 SQL> 
10:25:30 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:30 SQL> -----------------------
10:25:30 SQL> -- PREPARE SCORING DATA
10:25:30 SQL> --
10:25:30 SQL> -- If the data for model creation has been prepared, then the data
10:25:30 SQL> -- to be scored using the model must be prepared in the same manner
10:25:30 SQL> -- in order to obtain meaningful results.
10:25:30 SQL> --
10:25:30 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:30 SQL> -- 2. Normalization
10:25:30 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:30 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:30 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:30 SQL> --
10:25:30 SQL> BEGIN
10:25:30   2  	-- Xform Test data to replace missing values
10:25:30   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:30   4  	  miss_table_name => 'svmc_miss_num',
10:25:30   5  	  data_table_name => '&scoretable',
10:25:30   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:30   7  
10:25:30   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:30   9  	  miss_table_name => 'svmc_miss_cat',
10:25:30  10  	  data_table_name => '&scoretable',
10:25:30  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:30  12  
10:25:30  13  	-- Normalize the data to be scored
10:25:30  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:30  15  	  norm_table_name => 'svmc_norm',
10:25:30  16  	  data_table_name => '&scoretable',
10:25:30  17  	  xform_view_name => 'svmc_apply_prep');
10:25:30  18  END;
10:25:30  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:25:30 SQL> 
10:25:30 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:30 SQL> -- DELETE it if I did:
10:25:30 SQL> DELETE ystkscores
10:25:30   2  WHERE score > 0
10:25:30   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:30   4  -- I need to supply the target attribute name:
10:25:30   5  AND targ = '&1'
10:25:30   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:25:30 SQL> 
10:25:30 SQL> -- We do a drumroll here:
10:25:30 SQL> 
10:25:30 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:30   2  SELECT
10:25:30   3  tkrdate
10:25:30   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:30   5  ,sysdate
10:25:30   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:30   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:30   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:30   9  ,SUBSTR(tkrdate,-10)ydate
10:25:30  10  ,'&1'
10:25:30  11  FROM svmc_apply_prep
10:25:30  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:25:30 SQL> @score1_5min_gattn.sql	2009-12-14 TLT
10:25:30 SQL> --
10:25:30 SQL> -- score1_5min_gattn.sql
10:25:30 SQL> --
10:25:30 SQL> 
10:25:30 SQL> -- Demo:
10:25:30 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:25:30 SQL> 
10:25:30 SQL> CREATE OR REPLACE VIEW sme AS
10:25:30   2  SELECT
10:25:30   3  tkrdate
10:25:30   4  ,NULL gattn
10:25:30   5  ,g00
10:25:30   6  ,g01
10:25:30   7  ,g02
10:25:30   8  ,g03
10:25:30   9  ,g04
10:25:30  10  ,g05
10:25:30  11  ,g06
10:25:30  12  ,g07
10:25:30  13  ,g08
10:25:30  14  ,g09
10:25:30  15  ,g10
10:25:30  16  ,g11
10:25:30  17  ,g12
10:25:30  18  ,g13
10:25:30  19  ,g14
10:25:30  20  ,g15
10:25:30  21  ,g16
10:25:30  22  ,g17
10:25:30  23  ,g18
10:25:30  24  ,g19
10:25:30  25  ,g20
10:25:30  26  ,g21
10:25:30  27  ,g22
10:25:30  28  ,g23
10:25:30  29  ,g24
10:25:30  30  ,g25
10:25:30  31  ,g26
10:25:30  32  ,g27
10:25:30  33  ,g28
10:25:30  34  ,g29
10:25:30  35  FROM stk_ms
10:25:30  36  WHERE ydate = '&1'
10:25:30  37  AND tkr = '&2'
10:25:30  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-14'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:30 SQL> 
10:25:30 SQL> -- rpt
10:25:30 SQL> -- We should see just 1 row:
10:25:30 SQL> 
10:25:30 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:30   2  
10:25:30 SQL> -- Build the model:
10:25:30 SQL> CREATE OR REPLACE VIEW bme AS
10:25:30   2  SELECT
10:25:30   3  tkrdate
10:25:30   4  ,gattn
10:25:30   5  ,g00
10:25:30   6  ,g01
10:25:30   7  ,g02
10:25:30   8  ,g03
10:25:30   9  ,g04
10:25:30  10  ,g05
10:25:30  11  ,g06
10:25:30  12  ,g07
10:25:30  13  ,g08
10:25:30  14  ,g09
10:25:30  15  ,g10
10:25:30  16  ,g11
10:25:30  17  ,g12
10:25:30  18  ,g13
10:25:30  19  ,g14
10:25:30  20  ,g15
10:25:30  21  ,g16
10:25:30  22  ,g17
10:25:30  23  ,g18
10:25:30  24  ,g19
10:25:30  25  ,g20
10:25:30  26  ,g21
10:25:30  27  ,g22
10:25:30  28  ,g23
10:25:30  29  ,g24
10:25:30  30  ,g25
10:25:30  31  ,g26
10:25:30  32  ,g27
10:25:30  33  ,g28
10:25:30  34  ,g29
10:25:30  35  FROM stk_ms
10:25:30  36  WHERE gattn IN('nup','up')
10:25:30  37  -- Use only rows which are older than 1 day:
10:25:30  38  AND 1+ydate < '&1'
10:25:30  39  AND tkr = '&2'
10:25:30  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-14'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:30 SQL> 
10:25:30 SQL> -- rpt
10:25:30 SQL> 
10:25:30 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:25:30   2  
10:25:30 SQL> SELECT MAX(tkrdate) FROM bme
10:25:30   2  
10:25:30 SQL> -- Now build model from bme and score sme
10:25:30 SQL> @score1.sql gattn
10:25:30 SQL> -- score1.sql
10:25:30 SQL> 
10:25:30 SQL> -- I use this script to send 5 params to score.sql
10:25:30 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:30 SQL> -- Then at the very end of this script I use the model
10:25:30 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:30 SQL> 
10:25:30 SQL> -- I call this script from 2 other scripts:
10:25:30 SQL> -- score1_5min.sql
10:25:30 SQL> -- score1_5min_gattn.sql
10:25:30 SQL> 
10:25:30 SQL> -- The 1st param is the name of the target attribute.
10:25:30 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:30 SQL> 
10:25:30 SQL> -- Demo:
10:25:30 SQL> -- @score1.sql 'gatt'
10:25:30 SQL> -- @score1.sql 'gattn'
10:25:30 SQL> 
10:25:30 SQL> -- Now, I fill up svmc_apply_prep.
10:25:30 SQL> -- I use same model_name used in score.sql
10:25:30 SQL> DEFINE model_name = 'svmspy101'
10:25:30 SQL> DEFINE bldtable	= 'bme'
10:25:30 SQL> DEFINE scoretable = 'sme'
10:25:30 SQL> DEFINE case_id	= 'tkrdate'
10:25:30 SQL> -- Demo:
10:25:30 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:30 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:30 SQL> --
10:25:30 SQL> -- score.sql
10:25:30 SQL> --
10:25:30 SQL> 
10:25:30 SQL> -- usage: score.sql
10:25:30 SQL> 
10:25:30 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:30 SQL> 
10:25:30 SQL> -- DEFINE target	   = 'gatt'
10:25:30 SQL> -- DEFINE model_name = 'svmspy100'
10:25:30 SQL> -- DEFINE bldtable   = 'bme'
10:25:30 SQL> -- DEFINE scoretable = 'sme'
10:25:30 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:30 SQL> 
10:25:30 SQL> DEFINE target	= '&1'
10:25:30 SQL> DEFINE model_name = '&2'
10:25:30 SQL> DEFINE bldtable	= '&3'
10:25:30 SQL> DEFINE scoretable = '&4'
10:25:30 SQL> DEFINE case_id	= '&5'
10:25:30 SQL> 
10:25:30 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:30 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:30 SQL> 
10:25:30 SQL> -- Builds an SVM model using pl/sql.
10:25:30 SQL> 
10:25:30 SQL> -----------------------------------------------------------------------
10:25:30 SQL> --			    BUILD THE MODEL
10:25:30 SQL> -----------------------------------------------------------------------
10:25:30 SQL> 
10:25:30 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:30 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:30 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:30 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:30 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:30 SQL> 
10:25:30 SQL> 
10:25:30 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:30 SQL> --
10:25:30 SQL> -- DROP	TABLE svmc_settings ;
10:25:30 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:30 SQL> -- DELETE svmc_settings;
10:25:30 SQL> 
10:25:30 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:30 SQL> -- this choice to SVM using a settings table.
10:25:30 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:30 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:30 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:30 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:30 SQL> -- models.
10:25:30 SQL> --
10:25:30 SQL> 
10:25:30 SQL> -- Do this once and then comment it out.
10:25:30 SQL> -- That makes script go faster.
10:25:30 SQL> -- BEGIN
10:25:30 SQL> -- -- Populate settings table
10:25:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:30 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:30 SQL> --
10:25:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:30 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:30 SQL> --
10:25:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:30 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:30 SQL> --   COMMIT;
10:25:30 SQL> -- END;
10:25:30 SQL> -- /
10:25:30 SQL> 
10:25:30 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:25:31 SQL> 
10:25:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:31 SQL> 
10:25:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:31 SQL> 
10:25:31 SQL> --------------------------------
10:25:31 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:31 SQL> --
10:25:31 SQL> 
10:25:31 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:31 SQL> -- 2. Outlier Treatment and
10:25:31 SQL> -- 3. Normalization are performed below.
10:25:31 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:31 SQL> --    normalized here.
10:25:31 SQL> 
10:25:31 SQL> BEGIN
10:25:31   2  	-- Perform missing value treatment for all predictors
10:25:31   3  	-- create miss tables
10:25:31   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:31   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:31   6  
10:25:31   7  	-- populate miss tables
10:25:31   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:31   9  	  miss_table_name => 'svmc_miss_num',
10:25:31  10  	  data_table_name => '&bldtable',
10:25:31  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:31  12  
10:25:31  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:31  14  	  miss_table_name => 'svmc_miss_cat',
10:25:31  15  	  data_table_name => '&bldtable',
10:25:31  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:31  17  
10:25:31  18  	-- xform input data to replace missing values
10:25:31  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:31  20  	  miss_table_name => 'svmc_miss_num',
10:25:31  21  	  data_table_name => '&bldtable',
10:25:31  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:31  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:31  24  	  miss_table_name => 'svmc_miss_cat',
10:25:31  25  	  data_table_name => '&bldtable',
10:25:31  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:31  27  
10:25:31  28  	-- Perform outlier treatment.
10:25:31  29  	-- create clip table
10:25:31  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:31  31  
10:25:31  32  	-- populate clip table
10:25:31  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:31  34  	  clip_table_name => 'svmc_clip',
10:25:31  35  	  data_table_name => '&bldtable',
10:25:31  36  	  tail_frac	  => 0.025,
10:25:31  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:31  38  
10:25:31  39  	-- xform input data to winsorized data
10:25:31  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:31  41  	  clip_table_name => 'svmc_clip',
10:25:31  42  	  data_table_name => '&bldtable',
10:25:31  43  	  xform_view_name => 'svmc_winsor');
10:25:31  44  
10:25:31  45  	-- create normalization table
10:25:31  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:31  47  
10:25:31  48  	-- populate normalization table based on winsorized data
10:25:31  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:31  50  	  norm_table_name => 'svmc_norm',
10:25:31  51  	  data_table_name => 'svmc_winsor',
10:25:31  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:31  53  
10:25:31  54  	-- normalize the original data
10:25:31  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:31  56  	  norm_table_name => 'svmc_norm',
10:25:31  57  	  data_table_name => '&bldtable',
10:25:31  58  	  xform_view_name => 'svmc_build_prep');
10:25:31  59  END;
10:25:31  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:25:31 SQL> 
10:25:31 SQL> ---------------------
10:25:31 SQL> -- CREATE A NEW MODEL
10:25:31 SQL> --
10:25:31 SQL> -- Cleanup old model with the same name for repeat runs
10:25:31 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:31   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.93
10:25:33 SQL> 
10:25:33 SQL> -- Build a new SVM Model
10:25:33 SQL> BEGIN
10:25:33   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:33   3  	  model_name	      => '&model_name',
10:25:33   4  	  mining_function     => dbms_data_mining.classification,
10:25:33   5  	  data_table_name     => 'svmc_build_prep',
10:25:33   6  	  case_id_column_name => '&case_id',
10:25:33   7  	  target_column_name  => '&target',
10:25:33   8  	  settings_table_name => 'svmc_settings');
10:25:33   9  END;
10:25:33  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.96
10:25:35 SQL> 
10:25:35 SQL> -----------------------------------------------------------------------
10:25:35 SQL> --			       APPLY/score THE MODEL
10:25:35 SQL> -----------------------------------------------------------------------
10:25:35 SQL> 
10:25:35 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:35 SQL> -----------------------
10:25:35 SQL> -- PREPARE SCORING DATA
10:25:35 SQL> --
10:25:35 SQL> -- If the data for model creation has been prepared, then the data
10:25:35 SQL> -- to be scored using the model must be prepared in the same manner
10:25:35 SQL> -- in order to obtain meaningful results.
10:25:35 SQL> --
10:25:35 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:35 SQL> -- 2. Normalization
10:25:35 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:35 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:35 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:35 SQL> --
10:25:35 SQL> BEGIN
10:25:35   2  	-- Xform Test data to replace missing values
10:25:35   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:35   4  	  miss_table_name => 'svmc_miss_num',
10:25:35   5  	  data_table_name => '&scoretable',
10:25:35   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:35   7  
10:25:35   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:35   9  	  miss_table_name => 'svmc_miss_cat',
10:25:35  10  	  data_table_name => '&scoretable',
10:25:35  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:35  12  
10:25:35  13  	-- Normalize the data to be scored
10:25:35  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:35  15  	  norm_table_name => 'svmc_norm',
10:25:35  16  	  data_table_name => '&scoretable',
10:25:35  17  	  xform_view_name => 'svmc_apply_prep');
10:25:35  18  END;
10:25:35  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:25:35 SQL> 
10:25:35 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:35 SQL> -- DELETE it if I did:
10:25:35 SQL> DELETE ystkscores
10:25:35   2  WHERE score > 0
10:25:35   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:35   4  -- I need to supply the target attribute name:
10:25:35   5  AND targ = '&1'
10:25:35   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:35 SQL> 
10:25:35 SQL> -- We do a drumroll here:
10:25:35 SQL> 
10:25:35 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:35   2  SELECT
10:25:35   3  tkrdate
10:25:35   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:35   5  ,sysdate
10:25:35   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:35   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:35   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:35   9  ,SUBSTR(tkrdate,-10)ydate
10:25:35  10  ,'&1'
10:25:35  11  FROM svmc_apply_prep
10:25:35  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:25:35 SQL> @score1_5min.sql	      2010-04-22 TLT
10:25:35 SQL> --
10:25:35 SQL> -- score1_5min.sql
10:25:35 SQL> --
10:25:35 SQL> 
10:25:35 SQL> -- Demo:
10:25:35 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:35 SQL> 
10:25:35 SQL> CREATE OR REPLACE VIEW sme AS
10:25:35   2  SELECT
10:25:35   3  tkrdate
10:25:35   4  ,NULL gatt
10:25:35   5  ,g00
10:25:35   6  ,g01
10:25:35   7  ,g02
10:25:35   8  ,g03
10:25:35   9  ,g04
10:25:35  10  ,g05
10:25:35  11  ,g06
10:25:35  12  ,g07
10:25:35  13  ,g08
10:25:35  14  ,g09
10:25:35  15  ,g10
10:25:35  16  ,g11
10:25:35  17  ,g12
10:25:35  18  ,g13
10:25:35  19  ,g14
10:25:35  20  ,g15
10:25:35  21  ,g16
10:25:35  22  ,g17
10:25:35  23  ,g18
10:25:35  24  ,g19
10:25:35  25  ,g20
10:25:35  26  ,g21
10:25:35  27  ,g22
10:25:35  28  ,g23
10:25:35  29  ,g24
10:25:35  30  ,g25
10:25:35  31  ,g26
10:25:35  32  ,g27
10:25:35  33  ,g28
10:25:35  34  ,g29
10:25:35  35  FROM stk_ms
10:25:35  36  WHERE ydate = '&1'
10:25:35  37  AND tkr = '&2'
10:25:35  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-22'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:35 SQL> 
10:25:35 SQL> -- rpt
10:25:35 SQL> -- We should see just 1 row:
10:25:35 SQL> 
10:25:35 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:35   2  
10:25:35 SQL> -- Build the model:
10:25:35 SQL> CREATE OR REPLACE VIEW bme AS
10:25:35   2  SELECT
10:25:35   3  tkrdate
10:25:35   4  ,gatt
10:25:35   5  ,g00
10:25:35   6  ,g01
10:25:35   7  ,g02
10:25:35   8  ,g03
10:25:35   9  ,g04
10:25:35  10  ,g05
10:25:35  11  ,g06
10:25:35  12  ,g07
10:25:35  13  ,g08
10:25:35  14  ,g09
10:25:35  15  ,g10
10:25:35  16  ,g11
10:25:35  17  ,g12
10:25:35  18  ,g13
10:25:35  19  ,g14
10:25:35  20  ,g15
10:25:35  21  ,g16
10:25:35  22  ,g17
10:25:35  23  ,g18
10:25:35  24  ,g19
10:25:35  25  ,g20
10:25:35  26  ,g21
10:25:35  27  ,g22
10:25:35  28  ,g23
10:25:35  29  ,g24
10:25:35  30  ,g25
10:25:35  31  ,g26
10:25:35  32  ,g27
10:25:35  33  ,g28
10:25:35  34  ,g29
10:25:35  35  FROM stk_ms
10:25:35  36  WHERE gatt IN('nup','up')
10:25:35  37  -- Use only rows which are older than 1 day:
10:25:35  38  AND 1+ydate < '&1'
10:25:35  39  AND tkr = '&2'
10:25:35  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-22'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:36 SQL> 
10:25:36 SQL> -- rpt
10:25:36 SQL> 
10:25:36 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:36   2  
10:25:36 SQL> SELECT MAX(tkrdate) FROM bme
10:25:36   2  
10:25:36 SQL> -- Now build model from bme and score sme
10:25:36 SQL> @score1.sql gatt
10:25:36 SQL> -- score1.sql
10:25:36 SQL> 
10:25:36 SQL> -- I use this script to send 5 params to score.sql
10:25:36 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:36 SQL> -- Then at the very end of this script I use the model
10:25:36 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:36 SQL> 
10:25:36 SQL> -- I call this script from 2 other scripts:
10:25:36 SQL> -- score1_5min.sql
10:25:36 SQL> -- score1_5min_gattn.sql
10:25:36 SQL> 
10:25:36 SQL> -- The 1st param is the name of the target attribute.
10:25:36 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:36 SQL> 
10:25:36 SQL> -- Demo:
10:25:36 SQL> -- @score1.sql 'gatt'
10:25:36 SQL> -- @score1.sql 'gattn'
10:25:36 SQL> 
10:25:36 SQL> -- Now, I fill up svmc_apply_prep.
10:25:36 SQL> -- I use same model_name used in score.sql
10:25:36 SQL> DEFINE model_name = 'svmspy101'
10:25:36 SQL> DEFINE bldtable	= 'bme'
10:25:36 SQL> DEFINE scoretable = 'sme'
10:25:36 SQL> DEFINE case_id	= 'tkrdate'
10:25:36 SQL> -- Demo:
10:25:36 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:36 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:36 SQL> --
10:25:36 SQL> -- score.sql
10:25:36 SQL> --
10:25:36 SQL> 
10:25:36 SQL> -- usage: score.sql
10:25:36 SQL> 
10:25:36 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:36 SQL> 
10:25:36 SQL> -- DEFINE target	   = 'gatt'
10:25:36 SQL> -- DEFINE model_name = 'svmspy100'
10:25:36 SQL> -- DEFINE bldtable   = 'bme'
10:25:36 SQL> -- DEFINE scoretable = 'sme'
10:25:36 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:36 SQL> 
10:25:36 SQL> DEFINE target	= '&1'
10:25:36 SQL> DEFINE model_name = '&2'
10:25:36 SQL> DEFINE bldtable	= '&3'
10:25:36 SQL> DEFINE scoretable = '&4'
10:25:36 SQL> DEFINE case_id	= '&5'
10:25:36 SQL> 
10:25:36 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:36 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:36 SQL> 
10:25:36 SQL> -- Builds an SVM model using pl/sql.
10:25:36 SQL> 
10:25:36 SQL> -----------------------------------------------------------------------
10:25:36 SQL> --			    BUILD THE MODEL
10:25:36 SQL> -----------------------------------------------------------------------
10:25:36 SQL> 
10:25:36 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:36 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:36 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:25:36 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:36 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:36 SQL> 
10:25:36 SQL> 
10:25:36 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:36 SQL> --
10:25:36 SQL> -- DROP	TABLE svmc_settings ;
10:25:36 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:36 SQL> -- DELETE svmc_settings;
10:25:36 SQL> 
10:25:36 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:36 SQL> -- this choice to SVM using a settings table.
10:25:36 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:36 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:36 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:36 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:36 SQL> -- models.
10:25:36 SQL> --
10:25:36 SQL> 
10:25:36 SQL> -- Do this once and then comment it out.
10:25:36 SQL> -- That makes script go faster.
10:25:36 SQL> -- BEGIN
10:25:36 SQL> -- -- Populate settings table
10:25:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:36 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:36 SQL> --
10:25:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:36 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:36 SQL> --
10:25:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:36 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:36 SQL> --   COMMIT;
10:25:36 SQL> -- END;
10:25:36 SQL> -- /
10:25:36 SQL> 
10:25:36 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:36 SQL> 
10:25:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:36 SQL> 
10:25:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:36 SQL> 
10:25:36 SQL> --------------------------------
10:25:36 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:36 SQL> --
10:25:36 SQL> 
10:25:36 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:36 SQL> -- 2. Outlier Treatment and
10:25:36 SQL> -- 3. Normalization are performed below.
10:25:36 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:36 SQL> --    normalized here.
10:25:36 SQL> 
10:25:36 SQL> BEGIN
10:25:36   2  	-- Perform missing value treatment for all predictors
10:25:36   3  	-- create miss tables
10:25:36   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:36   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:36   6  
10:25:36   7  	-- populate miss tables
10:25:36   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:36   9  	  miss_table_name => 'svmc_miss_num',
10:25:36  10  	  data_table_name => '&bldtable',
10:25:36  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:36  12  
10:25:36  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:36  14  	  miss_table_name => 'svmc_miss_cat',
10:25:36  15  	  data_table_name => '&bldtable',
10:25:36  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:36  17  
10:25:36  18  	-- xform input data to replace missing values
10:25:36  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:36  20  	  miss_table_name => 'svmc_miss_num',
10:25:36  21  	  data_table_name => '&bldtable',
10:25:36  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:36  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:36  24  	  miss_table_name => 'svmc_miss_cat',
10:25:36  25  	  data_table_name => '&bldtable',
10:25:36  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:36  27  
10:25:36  28  	-- Perform outlier treatment.
10:25:36  29  	-- create clip table
10:25:36  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:36  31  
10:25:36  32  	-- populate clip table
10:25:36  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:36  34  	  clip_table_name => 'svmc_clip',
10:25:36  35  	  data_table_name => '&bldtable',
10:25:36  36  	  tail_frac	  => 0.025,
10:25:36  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:36  38  
10:25:36  39  	-- xform input data to winsorized data
10:25:36  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:36  41  	  clip_table_name => 'svmc_clip',
10:25:36  42  	  data_table_name => '&bldtable',
10:25:36  43  	  xform_view_name => 'svmc_winsor');
10:25:36  44  
10:25:36  45  	-- create normalization table
10:25:36  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:36  47  
10:25:36  48  	-- populate normalization table based on winsorized data
10:25:36  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:36  50  	  norm_table_name => 'svmc_norm',
10:25:36  51  	  data_table_name => 'svmc_winsor',
10:25:36  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:36  53  
10:25:36  54  	-- normalize the original data
10:25:36  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:36  56  	  norm_table_name => 'svmc_norm',
10:25:36  57  	  data_table_name => '&bldtable',
10:25:36  58  	  xform_view_name => 'svmc_build_prep');
10:25:36  59  END;
10:25:36  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:25:36 SQL> 
10:25:36 SQL> ---------------------
10:25:36 SQL> -- CREATE A NEW MODEL
10:25:36 SQL> --
10:25:36 SQL> -- Cleanup old model with the same name for repeat runs
10:25:36 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:36   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.98
10:25:37 SQL> 
10:25:37 SQL> -- Build a new SVM Model
10:25:37 SQL> BEGIN
10:25:37   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:37   3  	  model_name	      => '&model_name',
10:25:37   4  	  mining_function     => dbms_data_mining.classification,
10:25:37   5  	  data_table_name     => 'svmc_build_prep',
10:25:37   6  	  case_id_column_name => '&case_id',
10:25:37   7  	  target_column_name  => '&target',
10:25:37   8  	  settings_table_name => 'svmc_settings');
10:25:37   9  END;
10:25:37  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.42
10:25:40 SQL> 
10:25:40 SQL> -----------------------------------------------------------------------
10:25:40 SQL> --			       APPLY/score THE MODEL
10:25:40 SQL> -----------------------------------------------------------------------
10:25:40 SQL> 
10:25:40 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:40 SQL> -----------------------
10:25:40 SQL> -- PREPARE SCORING DATA
10:25:40 SQL> --
10:25:40 SQL> -- If the data for model creation has been prepared, then the data
10:25:40 SQL> -- to be scored using the model must be prepared in the same manner
10:25:40 SQL> -- in order to obtain meaningful results.
10:25:40 SQL> --
10:25:40 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:40 SQL> -- 2. Normalization
10:25:40 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:40 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:40 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:40 SQL> --
10:25:40 SQL> BEGIN
10:25:40   2  	-- Xform Test data to replace missing values
10:25:40   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:40   4  	  miss_table_name => 'svmc_miss_num',
10:25:40   5  	  data_table_name => '&scoretable',
10:25:40   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:40   7  
10:25:40   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:40   9  	  miss_table_name => 'svmc_miss_cat',
10:25:40  10  	  data_table_name => '&scoretable',
10:25:40  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:40  12  
10:25:40  13  	-- Normalize the data to be scored
10:25:40  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:40  15  	  norm_table_name => 'svmc_norm',
10:25:40  16  	  data_table_name => '&scoretable',
10:25:40  17  	  xform_view_name => 'svmc_apply_prep');
10:25:40  18  END;
10:25:40  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:25:40 SQL> 
10:25:40 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:40 SQL> -- DELETE it if I did:
10:25:40 SQL> DELETE ystkscores
10:25:40   2  WHERE score > 0
10:25:40   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:40   4  -- I need to supply the target attribute name:
10:25:40   5  AND targ = '&1'
10:25:40   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:25:40 SQL> 
10:25:40 SQL> -- We do a drumroll here:
10:25:40 SQL> 
10:25:40 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:40   2  SELECT
10:25:40   3  tkrdate
10:25:40   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:40   5  ,sysdate
10:25:40   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:40   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:40   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:40   9  ,SUBSTR(tkrdate,-10)ydate
10:25:40  10  ,'&1'
10:25:40  11  FROM svmc_apply_prep
10:25:40  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:25:40 SQL> @score1_5min.sql	      2010-08-04 TLT
10:25:40 SQL> --
10:25:40 SQL> -- score1_5min.sql
10:25:40 SQL> --
10:25:40 SQL> 
10:25:40 SQL> -- Demo:
10:25:40 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:40 SQL> 
10:25:40 SQL> CREATE OR REPLACE VIEW sme AS
10:25:40   2  SELECT
10:25:40   3  tkrdate
10:25:40   4  ,NULL gatt
10:25:40   5  ,g00
10:25:40   6  ,g01
10:25:40   7  ,g02
10:25:40   8  ,g03
10:25:40   9  ,g04
10:25:40  10  ,g05
10:25:40  11  ,g06
10:25:40  12  ,g07
10:25:40  13  ,g08
10:25:40  14  ,g09
10:25:40  15  ,g10
10:25:40  16  ,g11
10:25:40  17  ,g12
10:25:40  18  ,g13
10:25:40  19  ,g14
10:25:40  20  ,g15
10:25:40  21  ,g16
10:25:40  22  ,g17
10:25:40  23  ,g18
10:25:40  24  ,g19
10:25:40  25  ,g20
10:25:40  26  ,g21
10:25:40  27  ,g22
10:25:40  28  ,g23
10:25:40  29  ,g24
10:25:40  30  ,g25
10:25:40  31  ,g26
10:25:40  32  ,g27
10:25:40  33  ,g28
10:25:40  34  ,g29
10:25:40  35  FROM stk_ms
10:25:40  36  WHERE ydate = '&1'
10:25:40  37  AND tkr = '&2'
10:25:40  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-04'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:40 SQL> 
10:25:40 SQL> -- rpt
10:25:40 SQL> -- We should see just 1 row:
10:25:40 SQL> 
10:25:40 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:40   2  
10:25:40 SQL> -- Build the model:
10:25:40 SQL> CREATE OR REPLACE VIEW bme AS
10:25:40   2  SELECT
10:25:40   3  tkrdate
10:25:40   4  ,gatt
10:25:40   5  ,g00
10:25:40   6  ,g01
10:25:40   7  ,g02
10:25:40   8  ,g03
10:25:40   9  ,g04
10:25:40  10  ,g05
10:25:40  11  ,g06
10:25:40  12  ,g07
10:25:40  13  ,g08
10:25:40  14  ,g09
10:25:40  15  ,g10
10:25:40  16  ,g11
10:25:40  17  ,g12
10:25:40  18  ,g13
10:25:40  19  ,g14
10:25:40  20  ,g15
10:25:40  21  ,g16
10:25:40  22  ,g17
10:25:40  23  ,g18
10:25:40  24  ,g19
10:25:40  25  ,g20
10:25:40  26  ,g21
10:25:40  27  ,g22
10:25:40  28  ,g23
10:25:40  29  ,g24
10:25:40  30  ,g25
10:25:40  31  ,g26
10:25:40  32  ,g27
10:25:40  33  ,g28
10:25:40  34  ,g29
10:25:40  35  FROM stk_ms
10:25:40  36  WHERE gatt IN('nup','up')
10:25:40  37  -- Use only rows which are older than 1 day:
10:25:40  38  AND 1+ydate < '&1'
10:25:40  39  AND tkr = '&2'
10:25:40  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-04'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:40 SQL> 
10:25:40 SQL> -- rpt
10:25:40 SQL> 
10:25:40 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:40   2  
10:25:40 SQL> SELECT MAX(tkrdate) FROM bme
10:25:40   2  
10:25:40 SQL> -- Now build model from bme and score sme
10:25:40 SQL> @score1.sql gatt
10:25:40 SQL> -- score1.sql
10:25:40 SQL> 
10:25:40 SQL> -- I use this script to send 5 params to score.sql
10:25:40 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:40 SQL> -- Then at the very end of this script I use the model
10:25:40 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:40 SQL> 
10:25:40 SQL> -- I call this script from 2 other scripts:
10:25:40 SQL> -- score1_5min.sql
10:25:40 SQL> -- score1_5min_gattn.sql
10:25:40 SQL> 
10:25:40 SQL> -- The 1st param is the name of the target attribute.
10:25:40 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:40 SQL> 
10:25:40 SQL> -- Demo:
10:25:40 SQL> -- @score1.sql 'gatt'
10:25:40 SQL> -- @score1.sql 'gattn'
10:25:40 SQL> 
10:25:40 SQL> -- Now, I fill up svmc_apply_prep.
10:25:40 SQL> -- I use same model_name used in score.sql
10:25:40 SQL> DEFINE model_name = 'svmspy101'
10:25:40 SQL> DEFINE bldtable	= 'bme'
10:25:40 SQL> DEFINE scoretable = 'sme'
10:25:40 SQL> DEFINE case_id	= 'tkrdate'
10:25:40 SQL> -- Demo:
10:25:40 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:40 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:40 SQL> --
10:25:40 SQL> -- score.sql
10:25:40 SQL> --
10:25:40 SQL> 
10:25:40 SQL> -- usage: score.sql
10:25:40 SQL> 
10:25:40 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:40 SQL> 
10:25:40 SQL> -- DEFINE target	   = 'gatt'
10:25:40 SQL> -- DEFINE model_name = 'svmspy100'
10:25:40 SQL> -- DEFINE bldtable   = 'bme'
10:25:40 SQL> -- DEFINE scoretable = 'sme'
10:25:40 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:40 SQL> 
10:25:40 SQL> DEFINE target	= '&1'
10:25:40 SQL> DEFINE model_name = '&2'
10:25:40 SQL> DEFINE bldtable	= '&3'
10:25:40 SQL> DEFINE scoretable = '&4'
10:25:40 SQL> DEFINE case_id	= '&5'
10:25:40 SQL> 
10:25:40 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:40 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:40 SQL> 
10:25:40 SQL> -- Builds an SVM model using pl/sql.
10:25:40 SQL> 
10:25:40 SQL> -----------------------------------------------------------------------
10:25:40 SQL> --			    BUILD THE MODEL
10:25:40 SQL> -----------------------------------------------------------------------
10:25:40 SQL> 
10:25:40 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:40 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:40 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:40 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:40 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:40 SQL> 
10:25:40 SQL> 
10:25:40 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:40 SQL> --
10:25:40 SQL> -- DROP	TABLE svmc_settings ;
10:25:40 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:40 SQL> -- DELETE svmc_settings;
10:25:40 SQL> 
10:25:40 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:40 SQL> -- this choice to SVM using a settings table.
10:25:40 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:40 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:40 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:40 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:40 SQL> -- models.
10:25:40 SQL> --
10:25:40 SQL> 
10:25:40 SQL> -- Do this once and then comment it out.
10:25:40 SQL> -- That makes script go faster.
10:25:40 SQL> -- BEGIN
10:25:40 SQL> -- -- Populate settings table
10:25:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:40 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:40 SQL> --
10:25:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:40 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:40 SQL> --
10:25:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:40 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:40 SQL> --   COMMIT;
10:25:40 SQL> -- END;
10:25:40 SQL> -- /
10:25:40 SQL> 
10:25:40 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:40 SQL> 
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.28
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:40 SQL> 
10:25:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
10:25:41 SQL> 
10:25:41 SQL> --------------------------------
10:25:41 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:41 SQL> --
10:25:41 SQL> 
10:25:41 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:41 SQL> -- 2. Outlier Treatment and
10:25:41 SQL> -- 3. Normalization are performed below.
10:25:41 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:41 SQL> --    normalized here.
10:25:41 SQL> 
10:25:41 SQL> BEGIN
10:25:41   2  	-- Perform missing value treatment for all predictors
10:25:41   3  	-- create miss tables
10:25:41   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:41   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:41   6  
10:25:41   7  	-- populate miss tables
10:25:41   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:41   9  	  miss_table_name => 'svmc_miss_num',
10:25:41  10  	  data_table_name => '&bldtable',
10:25:41  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:41  12  
10:25:41  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:41  14  	  miss_table_name => 'svmc_miss_cat',
10:25:41  15  	  data_table_name => '&bldtable',
10:25:41  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:41  17  
10:25:41  18  	-- xform input data to replace missing values
10:25:41  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:41  20  	  miss_table_name => 'svmc_miss_num',
10:25:41  21  	  data_table_name => '&bldtable',
10:25:41  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:41  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:41  24  	  miss_table_name => 'svmc_miss_cat',
10:25:41  25  	  data_table_name => '&bldtable',
10:25:41  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:41  27  
10:25:41  28  	-- Perform outlier treatment.
10:25:41  29  	-- create clip table
10:25:41  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:41  31  
10:25:41  32  	-- populate clip table
10:25:41  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:41  34  	  clip_table_name => 'svmc_clip',
10:25:41  35  	  data_table_name => '&bldtable',
10:25:41  36  	  tail_frac	  => 0.025,
10:25:41  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:41  38  
10:25:41  39  	-- xform input data to winsorized data
10:25:41  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:41  41  	  clip_table_name => 'svmc_clip',
10:25:41  42  	  data_table_name => '&bldtable',
10:25:41  43  	  xform_view_name => 'svmc_winsor');
10:25:41  44  
10:25:41  45  	-- create normalization table
10:25:41  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:41  47  
10:25:41  48  	-- populate normalization table based on winsorized data
10:25:41  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:41  50  	  norm_table_name => 'svmc_norm',
10:25:41  51  	  data_table_name => 'svmc_winsor',
10:25:41  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:41  53  
10:25:41  54  	-- normalize the original data
10:25:41  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:41  56  	  norm_table_name => 'svmc_norm',
10:25:41  57  	  data_table_name => '&bldtable',
10:25:41  58  	  xform_view_name => 'svmc_build_prep');
10:25:41  59  END;
10:25:41  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:25:41 SQL> 
10:25:41 SQL> ---------------------
10:25:41 SQL> -- CREATE A NEW MODEL
10:25:41 SQL> --
10:25:41 SQL> -- Cleanup old model with the same name for repeat runs
10:25:41 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:41   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.08
10:25:42 SQL> 
10:25:42 SQL> -- Build a new SVM Model
10:25:42 SQL> BEGIN
10:25:42   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:42   3  	  model_name	      => '&model_name',
10:25:42   4  	  mining_function     => dbms_data_mining.classification,
10:25:42   5  	  data_table_name     => 'svmc_build_prep',
10:25:42   6  	  case_id_column_name => '&case_id',
10:25:42   7  	  target_column_name  => '&target',
10:25:42   8  	  settings_table_name => 'svmc_settings');
10:25:42   9  END;
10:25:42  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.22
10:25:44 SQL> 
10:25:44 SQL> -----------------------------------------------------------------------
10:25:44 SQL> --			       APPLY/score THE MODEL
10:25:44 SQL> -----------------------------------------------------------------------
10:25:44 SQL> 
10:25:44 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:45 SQL> -----------------------
10:25:45 SQL> -- PREPARE SCORING DATA
10:25:45 SQL> --
10:25:45 SQL> -- If the data for model creation has been prepared, then the data
10:25:45 SQL> -- to be scored using the model must be prepared in the same manner
10:25:45 SQL> -- in order to obtain meaningful results.
10:25:45 SQL> --
10:25:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:45 SQL> -- 2. Normalization
10:25:45 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:45 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:45 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:45 SQL> --
10:25:45 SQL> BEGIN
10:25:45   2  	-- Xform Test data to replace missing values
10:25:45   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:45   4  	  miss_table_name => 'svmc_miss_num',
10:25:45   5  	  data_table_name => '&scoretable',
10:25:45   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:45   7  
10:25:45   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:45   9  	  miss_table_name => 'svmc_miss_cat',
10:25:45  10  	  data_table_name => '&scoretable',
10:25:45  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:45  12  
10:25:45  13  	-- Normalize the data to be scored
10:25:45  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:45  15  	  norm_table_name => 'svmc_norm',
10:25:45  16  	  data_table_name => '&scoretable',
10:25:45  17  	  xform_view_name => 'svmc_apply_prep');
10:25:45  18  END;
10:25:45  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:25:45 SQL> 
10:25:45 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:45 SQL> -- DELETE it if I did:
10:25:45 SQL> DELETE ystkscores
10:25:45   2  WHERE score > 0
10:25:45   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:45   4  -- I need to supply the target attribute name:
10:25:45   5  AND targ = '&1'
10:25:45   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:45 SQL> 
10:25:45 SQL> -- We do a drumroll here:
10:25:45 SQL> 
10:25:45 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:45   2  SELECT
10:25:45   3  tkrdate
10:25:45   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:45   5  ,sysdate
10:25:45   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:45   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:45   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:45   9  ,SUBSTR(tkrdate,-10)ydate
10:25:45  10  ,'&1'
10:25:45  11  FROM svmc_apply_prep
10:25:45  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:25:45 SQL> @score1_5min.sql	      2010-01-29 TLT
10:25:45 SQL> --
10:25:45 SQL> -- score1_5min.sql
10:25:45 SQL> --
10:25:45 SQL> 
10:25:45 SQL> -- Demo:
10:25:45 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:45 SQL> 
10:25:45 SQL> CREATE OR REPLACE VIEW sme AS
10:25:45   2  SELECT
10:25:45   3  tkrdate
10:25:45   4  ,NULL gatt
10:25:45   5  ,g00
10:25:45   6  ,g01
10:25:45   7  ,g02
10:25:45   8  ,g03
10:25:45   9  ,g04
10:25:45  10  ,g05
10:25:45  11  ,g06
10:25:45  12  ,g07
10:25:45  13  ,g08
10:25:45  14  ,g09
10:25:45  15  ,g10
10:25:45  16  ,g11
10:25:45  17  ,g12
10:25:45  18  ,g13
10:25:45  19  ,g14
10:25:45  20  ,g15
10:25:45  21  ,g16
10:25:45  22  ,g17
10:25:45  23  ,g18
10:25:45  24  ,g19
10:25:45  25  ,g20
10:25:45  26  ,g21
10:25:45  27  ,g22
10:25:45  28  ,g23
10:25:45  29  ,g24
10:25:45  30  ,g25
10:25:45  31  ,g26
10:25:45  32  ,g27
10:25:45  33  ,g28
10:25:45  34  ,g29
10:25:45  35  FROM stk_ms
10:25:45  36  WHERE ydate = '&1'
10:25:45  37  AND tkr = '&2'
10:25:45  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-29'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:45 SQL> 
10:25:45 SQL> -- rpt
10:25:45 SQL> -- We should see just 1 row:
10:25:45 SQL> 
10:25:45 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:45   2  
10:25:45 SQL> -- Build the model:
10:25:45 SQL> CREATE OR REPLACE VIEW bme AS
10:25:45   2  SELECT
10:25:45   3  tkrdate
10:25:45   4  ,gatt
10:25:45   5  ,g00
10:25:45   6  ,g01
10:25:45   7  ,g02
10:25:45   8  ,g03
10:25:45   9  ,g04
10:25:45  10  ,g05
10:25:45  11  ,g06
10:25:45  12  ,g07
10:25:45  13  ,g08
10:25:45  14  ,g09
10:25:45  15  ,g10
10:25:45  16  ,g11
10:25:45  17  ,g12
10:25:45  18  ,g13
10:25:45  19  ,g14
10:25:45  20  ,g15
10:25:45  21  ,g16
10:25:45  22  ,g17
10:25:45  23  ,g18
10:25:45  24  ,g19
10:25:45  25  ,g20
10:25:45  26  ,g21
10:25:45  27  ,g22
10:25:45  28  ,g23
10:25:45  29  ,g24
10:25:45  30  ,g25
10:25:45  31  ,g26
10:25:45  32  ,g27
10:25:45  33  ,g28
10:25:45  34  ,g29
10:25:45  35  FROM stk_ms
10:25:45  36  WHERE gatt IN('nup','up')
10:25:45  37  -- Use only rows which are older than 1 day:
10:25:45  38  AND 1+ydate < '&1'
10:25:45  39  AND tkr = '&2'
10:25:45  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-29'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:45 SQL> 
10:25:45 SQL> -- rpt
10:25:45 SQL> 
10:25:45 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:45   2  
10:25:45 SQL> SELECT MAX(tkrdate) FROM bme
10:25:45   2  
10:25:45 SQL> -- Now build model from bme and score sme
10:25:45 SQL> @score1.sql gatt
10:25:45 SQL> -- score1.sql
10:25:45 SQL> 
10:25:45 SQL> -- I use this script to send 5 params to score.sql
10:25:45 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:45 SQL> -- Then at the very end of this script I use the model
10:25:45 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:45 SQL> 
10:25:45 SQL> -- I call this script from 2 other scripts:
10:25:45 SQL> -- score1_5min.sql
10:25:45 SQL> -- score1_5min_gattn.sql
10:25:45 SQL> 
10:25:45 SQL> -- The 1st param is the name of the target attribute.
10:25:45 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:45 SQL> 
10:25:45 SQL> -- Demo:
10:25:45 SQL> -- @score1.sql 'gatt'
10:25:45 SQL> -- @score1.sql 'gattn'
10:25:45 SQL> 
10:25:45 SQL> -- Now, I fill up svmc_apply_prep.
10:25:45 SQL> -- I use same model_name used in score.sql
10:25:45 SQL> DEFINE model_name = 'svmspy101'
10:25:45 SQL> DEFINE bldtable	= 'bme'
10:25:45 SQL> DEFINE scoretable = 'sme'
10:25:45 SQL> DEFINE case_id	= 'tkrdate'
10:25:45 SQL> -- Demo:
10:25:45 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:45 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:45 SQL> --
10:25:45 SQL> -- score.sql
10:25:45 SQL> --
10:25:45 SQL> 
10:25:45 SQL> -- usage: score.sql
10:25:45 SQL> 
10:25:45 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:45 SQL> 
10:25:45 SQL> -- DEFINE target	   = 'gatt'
10:25:45 SQL> -- DEFINE model_name = 'svmspy100'
10:25:45 SQL> -- DEFINE bldtable   = 'bme'
10:25:45 SQL> -- DEFINE scoretable = 'sme'
10:25:45 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:45 SQL> 
10:25:45 SQL> DEFINE target	= '&1'
10:25:45 SQL> DEFINE model_name = '&2'
10:25:45 SQL> DEFINE bldtable	= '&3'
10:25:45 SQL> DEFINE scoretable = '&4'
10:25:45 SQL> DEFINE case_id	= '&5'
10:25:45 SQL> 
10:25:45 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:45 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:45 SQL> 
10:25:45 SQL> -- Builds an SVM model using pl/sql.
10:25:45 SQL> 
10:25:45 SQL> -----------------------------------------------------------------------
10:25:45 SQL> --			    BUILD THE MODEL
10:25:45 SQL> -----------------------------------------------------------------------
10:25:45 SQL> 
10:25:45 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:45 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:45 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:25:45 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:45 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:45 SQL> 
10:25:45 SQL> 
10:25:45 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:45 SQL> --
10:25:45 SQL> -- DROP	TABLE svmc_settings ;
10:25:45 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:45 SQL> -- DELETE svmc_settings;
10:25:45 SQL> 
10:25:45 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:45 SQL> -- this choice to SVM using a settings table.
10:25:45 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:45 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:45 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:45 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:45 SQL> -- models.
10:25:45 SQL> --
10:25:45 SQL> 
10:25:45 SQL> -- Do this once and then comment it out.
10:25:45 SQL> -- That makes script go faster.
10:25:45 SQL> -- BEGIN
10:25:45 SQL> -- -- Populate settings table
10:25:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:45 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:45 SQL> --
10:25:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:45 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:45 SQL> --
10:25:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:45 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:45 SQL> --   COMMIT;
10:25:45 SQL> -- END;
10:25:45 SQL> -- /
10:25:45 SQL> 
10:25:45 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:25:45 SQL> 
10:25:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:25:45 SQL> 
10:25:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:45 SQL> 
10:25:45 SQL> --------------------------------
10:25:45 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:45 SQL> --
10:25:45 SQL> 
10:25:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:45 SQL> -- 2. Outlier Treatment and
10:25:45 SQL> -- 3. Normalization are performed below.
10:25:45 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:45 SQL> --    normalized here.
10:25:45 SQL> 
10:25:45 SQL> BEGIN
10:25:45   2  	-- Perform missing value treatment for all predictors
10:25:45   3  	-- create miss tables
10:25:45   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:45   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:45   6  
10:25:45   7  	-- populate miss tables
10:25:45   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:45   9  	  miss_table_name => 'svmc_miss_num',
10:25:45  10  	  data_table_name => '&bldtable',
10:25:45  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:45  12  
10:25:45  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:45  14  	  miss_table_name => 'svmc_miss_cat',
10:25:45  15  	  data_table_name => '&bldtable',
10:25:45  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:45  17  
10:25:45  18  	-- xform input data to replace missing values
10:25:45  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:45  20  	  miss_table_name => 'svmc_miss_num',
10:25:45  21  	  data_table_name => '&bldtable',
10:25:45  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:45  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:45  24  	  miss_table_name => 'svmc_miss_cat',
10:25:45  25  	  data_table_name => '&bldtable',
10:25:45  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:45  27  
10:25:45  28  	-- Perform outlier treatment.
10:25:45  29  	-- create clip table
10:25:45  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:45  31  
10:25:45  32  	-- populate clip table
10:25:45  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:45  34  	  clip_table_name => 'svmc_clip',
10:25:45  35  	  data_table_name => '&bldtable',
10:25:45  36  	  tail_frac	  => 0.025,
10:25:45  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:45  38  
10:25:45  39  	-- xform input data to winsorized data
10:25:45  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:45  41  	  clip_table_name => 'svmc_clip',
10:25:45  42  	  data_table_name => '&bldtable',
10:25:45  43  	  xform_view_name => 'svmc_winsor');
10:25:45  44  
10:25:45  45  	-- create normalization table
10:25:45  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:45  47  
10:25:45  48  	-- populate normalization table based on winsorized data
10:25:45  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:45  50  	  norm_table_name => 'svmc_norm',
10:25:45  51  	  data_table_name => 'svmc_winsor',
10:25:45  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:45  53  
10:25:45  54  	-- normalize the original data
10:25:45  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:45  56  	  norm_table_name => 'svmc_norm',
10:25:45  57  	  data_table_name => '&bldtable',
10:25:45  58  	  xform_view_name => 'svmc_build_prep');
10:25:45  59  END;
10:25:45  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:25:46 SQL> 
10:25:46 SQL> ---------------------
10:25:46 SQL> -- CREATE A NEW MODEL
10:25:46 SQL> --
10:25:46 SQL> -- Cleanup old model with the same name for repeat runs
10:25:46 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:46   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.31
10:25:47 SQL> 
10:25:47 SQL> -- Build a new SVM Model
10:25:47 SQL> BEGIN
10:25:47   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:47   3  	  model_name	      => '&model_name',
10:25:47   4  	  mining_function     => dbms_data_mining.classification,
10:25:47   5  	  data_table_name     => 'svmc_build_prep',
10:25:47   6  	  case_id_column_name => '&case_id',
10:25:47   7  	  target_column_name  => '&target',
10:25:47   8  	  settings_table_name => 'svmc_settings');
10:25:47   9  END;
10:25:47  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.15
10:25:49 SQL> 
10:25:49 SQL> -----------------------------------------------------------------------
10:25:49 SQL> --			       APPLY/score THE MODEL
10:25:49 SQL> -----------------------------------------------------------------------
10:25:49 SQL> 
10:25:49 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:49 SQL> -----------------------
10:25:49 SQL> -- PREPARE SCORING DATA
10:25:49 SQL> --
10:25:49 SQL> -- If the data for model creation has been prepared, then the data
10:25:49 SQL> -- to be scored using the model must be prepared in the same manner
10:25:49 SQL> -- in order to obtain meaningful results.
10:25:49 SQL> --
10:25:49 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:49 SQL> -- 2. Normalization
10:25:49 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:49 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:49 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:49 SQL> --
10:25:49 SQL> BEGIN
10:25:49   2  	-- Xform Test data to replace missing values
10:25:49   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:49   4  	  miss_table_name => 'svmc_miss_num',
10:25:49   5  	  data_table_name => '&scoretable',
10:25:49   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:49   7  
10:25:49   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:49   9  	  miss_table_name => 'svmc_miss_cat',
10:25:49  10  	  data_table_name => '&scoretable',
10:25:49  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:49  12  
10:25:49  13  	-- Normalize the data to be scored
10:25:49  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:49  15  	  norm_table_name => 'svmc_norm',
10:25:49  16  	  data_table_name => '&scoretable',
10:25:49  17  	  xform_view_name => 'svmc_apply_prep');
10:25:49  18  END;
10:25:49  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:25:49 SQL> 
10:25:49 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:49 SQL> -- DELETE it if I did:
10:25:49 SQL> DELETE ystkscores
10:25:49   2  WHERE score > 0
10:25:49   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:49   4  -- I need to supply the target attribute name:
10:25:49   5  AND targ = '&1'
10:25:49   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:25:49 SQL> 
10:25:49 SQL> -- We do a drumroll here:
10:25:49 SQL> 
10:25:49 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:49   2  SELECT
10:25:49   3  tkrdate
10:25:49   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:49   5  ,sysdate
10:25:49   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:49   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:49   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:49   9  ,SUBSTR(tkrdate,-10)ydate
10:25:49  10  ,'&1'
10:25:49  11  FROM svmc_apply_prep
10:25:49  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:25:49 SQL> @score1_5min.sql	      2010-06-28 TLT
10:25:49 SQL> --
10:25:49 SQL> -- score1_5min.sql
10:25:49 SQL> --
10:25:49 SQL> 
10:25:49 SQL> -- Demo:
10:25:49 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:25:49 SQL> 
10:25:49 SQL> CREATE OR REPLACE VIEW sme AS
10:25:49   2  SELECT
10:25:49   3  tkrdate
10:25:49   4  ,NULL gatt
10:25:49   5  ,g00
10:25:49   6  ,g01
10:25:49   7  ,g02
10:25:49   8  ,g03
10:25:49   9  ,g04
10:25:49  10  ,g05
10:25:49  11  ,g06
10:25:49  12  ,g07
10:25:49  13  ,g08
10:25:49  14  ,g09
10:25:49  15  ,g10
10:25:49  16  ,g11
10:25:49  17  ,g12
10:25:49  18  ,g13
10:25:49  19  ,g14
10:25:49  20  ,g15
10:25:49  21  ,g16
10:25:49  22  ,g17
10:25:49  23  ,g18
10:25:49  24  ,g19
10:25:49  25  ,g20
10:25:49  26  ,g21
10:25:49  27  ,g22
10:25:49  28  ,g23
10:25:49  29  ,g24
10:25:49  30  ,g25
10:25:49  31  ,g26
10:25:49  32  ,g27
10:25:49  33  ,g28
10:25:49  34  ,g29
10:25:49  35  FROM stk_ms
10:25:49  36  WHERE ydate = '&1'
10:25:49  37  AND tkr = '&2'
10:25:49  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-28'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:50 SQL> 
10:25:50 SQL> -- rpt
10:25:50 SQL> -- We should see just 1 row:
10:25:50 SQL> 
10:25:50 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:50   2  
10:25:50 SQL> -- Build the model:
10:25:50 SQL> CREATE OR REPLACE VIEW bme AS
10:25:50   2  SELECT
10:25:50   3  tkrdate
10:25:50   4  ,gatt
10:25:50   5  ,g00
10:25:50   6  ,g01
10:25:50   7  ,g02
10:25:50   8  ,g03
10:25:50   9  ,g04
10:25:50  10  ,g05
10:25:50  11  ,g06
10:25:50  12  ,g07
10:25:50  13  ,g08
10:25:50  14  ,g09
10:25:50  15  ,g10
10:25:50  16  ,g11
10:25:50  17  ,g12
10:25:50  18  ,g13
10:25:50  19  ,g14
10:25:50  20  ,g15
10:25:50  21  ,g16
10:25:50  22  ,g17
10:25:50  23  ,g18
10:25:50  24  ,g19
10:25:50  25  ,g20
10:25:50  26  ,g21
10:25:50  27  ,g22
10:25:50  28  ,g23
10:25:50  29  ,g24
10:25:50  30  ,g25
10:25:50  31  ,g26
10:25:50  32  ,g27
10:25:50  33  ,g28
10:25:50  34  ,g29
10:25:50  35  FROM stk_ms
10:25:50  36  WHERE gatt IN('nup','up')
10:25:50  37  -- Use only rows which are older than 1 day:
10:25:50  38  AND 1+ydate < '&1'
10:25:50  39  AND tkr = '&2'
10:25:50  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-28'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:50 SQL> 
10:25:50 SQL> -- rpt
10:25:50 SQL> 
10:25:50 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:25:50   2  
10:25:50 SQL> SELECT MAX(tkrdate) FROM bme
10:25:50   2  
10:25:50 SQL> -- Now build model from bme and score sme
10:25:50 SQL> @score1.sql gatt
10:25:50 SQL> -- score1.sql
10:25:50 SQL> 
10:25:50 SQL> -- I use this script to send 5 params to score.sql
10:25:50 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:50 SQL> -- Then at the very end of this script I use the model
10:25:50 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:50 SQL> 
10:25:50 SQL> -- I call this script from 2 other scripts:
10:25:50 SQL> -- score1_5min.sql
10:25:50 SQL> -- score1_5min_gattn.sql
10:25:50 SQL> 
10:25:50 SQL> -- The 1st param is the name of the target attribute.
10:25:50 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:50 SQL> 
10:25:50 SQL> -- Demo:
10:25:50 SQL> -- @score1.sql 'gatt'
10:25:50 SQL> -- @score1.sql 'gattn'
10:25:50 SQL> 
10:25:50 SQL> -- Now, I fill up svmc_apply_prep.
10:25:50 SQL> -- I use same model_name used in score.sql
10:25:50 SQL> DEFINE model_name = 'svmspy101'
10:25:50 SQL> DEFINE bldtable	= 'bme'
10:25:50 SQL> DEFINE scoretable = 'sme'
10:25:50 SQL> DEFINE case_id	= 'tkrdate'
10:25:50 SQL> -- Demo:
10:25:50 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:50 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:50 SQL> --
10:25:50 SQL> -- score.sql
10:25:50 SQL> --
10:25:50 SQL> 
10:25:50 SQL> -- usage: score.sql
10:25:50 SQL> 
10:25:50 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:50 SQL> 
10:25:50 SQL> -- DEFINE target	   = 'gatt'
10:25:50 SQL> -- DEFINE model_name = 'svmspy100'
10:25:50 SQL> -- DEFINE bldtable   = 'bme'
10:25:50 SQL> -- DEFINE scoretable = 'sme'
10:25:50 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:50 SQL> 
10:25:50 SQL> DEFINE target	= '&1'
10:25:50 SQL> DEFINE model_name = '&2'
10:25:50 SQL> DEFINE bldtable	= '&3'
10:25:50 SQL> DEFINE scoretable = '&4'
10:25:50 SQL> DEFINE case_id	= '&5'
10:25:50 SQL> 
10:25:50 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:50 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:50 SQL> 
10:25:50 SQL> -- Builds an SVM model using pl/sql.
10:25:50 SQL> 
10:25:50 SQL> -----------------------------------------------------------------------
10:25:50 SQL> --			    BUILD THE MODEL
10:25:50 SQL> -----------------------------------------------------------------------
10:25:50 SQL> 
10:25:50 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:50 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:50 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:50 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:50 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:50 SQL> 
10:25:50 SQL> 
10:25:50 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:50 SQL> --
10:25:50 SQL> -- DROP	TABLE svmc_settings ;
10:25:50 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:50 SQL> -- DELETE svmc_settings;
10:25:50 SQL> 
10:25:50 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:50 SQL> -- this choice to SVM using a settings table.
10:25:50 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:50 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:50 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:50 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:50 SQL> -- models.
10:25:50 SQL> --
10:25:50 SQL> 
10:25:50 SQL> -- Do this once and then comment it out.
10:25:50 SQL> -- That makes script go faster.
10:25:50 SQL> -- BEGIN
10:25:50 SQL> -- -- Populate settings table
10:25:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:50 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:50 SQL> --
10:25:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:50 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:50 SQL> --
10:25:50 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:50 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:50 SQL> --   COMMIT;
10:25:50 SQL> -- END;
10:25:50 SQL> -- /
10:25:50 SQL> 
10:25:50 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:50 SQL> 
10:25:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:50 SQL> 
10:25:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:50 SQL> 
10:25:50 SQL> --------------------------------
10:25:50 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:50 SQL> --
10:25:50 SQL> 
10:25:50 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:50 SQL> -- 2. Outlier Treatment and
10:25:50 SQL> -- 3. Normalization are performed below.
10:25:50 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:50 SQL> --    normalized here.
10:25:50 SQL> 
10:25:50 SQL> BEGIN
10:25:50   2  	-- Perform missing value treatment for all predictors
10:25:50   3  	-- create miss tables
10:25:50   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:50   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:50   6  
10:25:50   7  	-- populate miss tables
10:25:50   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:50   9  	  miss_table_name => 'svmc_miss_num',
10:25:50  10  	  data_table_name => '&bldtable',
10:25:50  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:50  12  
10:25:50  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:50  14  	  miss_table_name => 'svmc_miss_cat',
10:25:50  15  	  data_table_name => '&bldtable',
10:25:50  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:50  17  
10:25:50  18  	-- xform input data to replace missing values
10:25:50  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:50  20  	  miss_table_name => 'svmc_miss_num',
10:25:50  21  	  data_table_name => '&bldtable',
10:25:50  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:50  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:50  24  	  miss_table_name => 'svmc_miss_cat',
10:25:50  25  	  data_table_name => '&bldtable',
10:25:50  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:50  27  
10:25:50  28  	-- Perform outlier treatment.
10:25:50  29  	-- create clip table
10:25:50  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:50  31  
10:25:50  32  	-- populate clip table
10:25:50  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:50  34  	  clip_table_name => 'svmc_clip',
10:25:50  35  	  data_table_name => '&bldtable',
10:25:50  36  	  tail_frac	  => 0.025,
10:25:50  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:50  38  
10:25:50  39  	-- xform input data to winsorized data
10:25:50  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:50  41  	  clip_table_name => 'svmc_clip',
10:25:50  42  	  data_table_name => '&bldtable',
10:25:50  43  	  xform_view_name => 'svmc_winsor');
10:25:50  44  
10:25:50  45  	-- create normalization table
10:25:50  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:50  47  
10:25:50  48  	-- populate normalization table based on winsorized data
10:25:50  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:50  50  	  norm_table_name => 'svmc_norm',
10:25:50  51  	  data_table_name => 'svmc_winsor',
10:25:50  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:50  53  
10:25:50  54  	-- normalize the original data
10:25:50  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:50  56  	  norm_table_name => 'svmc_norm',
10:25:50  57  	  data_table_name => '&bldtable',
10:25:50  58  	  xform_view_name => 'svmc_build_prep');
10:25:50  59  END;
10:25:50  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:25:50 SQL> 
10:25:50 SQL> ---------------------
10:25:50 SQL> -- CREATE A NEW MODEL
10:25:50 SQL> --
10:25:50 SQL> -- Cleanup old model with the same name for repeat runs
10:25:50 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:50   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.99
10:25:51 SQL> 
10:25:51 SQL> -- Build a new SVM Model
10:25:51 SQL> BEGIN
10:25:51   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:51   3  	  model_name	      => '&model_name',
10:25:51   4  	  mining_function     => dbms_data_mining.classification,
10:25:51   5  	  data_table_name     => 'svmc_build_prep',
10:25:51   6  	  case_id_column_name => '&case_id',
10:25:51   7  	  target_column_name  => '&target',
10:25:51   8  	  settings_table_name => 'svmc_settings');
10:25:51   9  END;
10:25:51  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.06
10:25:53 SQL> 
10:25:53 SQL> -----------------------------------------------------------------------
10:25:53 SQL> --			       APPLY/score THE MODEL
10:25:53 SQL> -----------------------------------------------------------------------
10:25:53 SQL> 
10:25:53 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.15
10:25:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:54 SQL> -----------------------
10:25:54 SQL> -- PREPARE SCORING DATA
10:25:54 SQL> --
10:25:54 SQL> -- If the data for model creation has been prepared, then the data
10:25:54 SQL> -- to be scored using the model must be prepared in the same manner
10:25:54 SQL> -- in order to obtain meaningful results.
10:25:54 SQL> --
10:25:54 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:54 SQL> -- 2. Normalization
10:25:54 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:54 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:54 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:54 SQL> --
10:25:54 SQL> BEGIN
10:25:54   2  	-- Xform Test data to replace missing values
10:25:54   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:54   4  	  miss_table_name => 'svmc_miss_num',
10:25:54   5  	  data_table_name => '&scoretable',
10:25:54   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:54   7  
10:25:54   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:54   9  	  miss_table_name => 'svmc_miss_cat',
10:25:54  10  	  data_table_name => '&scoretable',
10:25:54  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:54  12  
10:25:54  13  	-- Normalize the data to be scored
10:25:54  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:54  15  	  norm_table_name => 'svmc_norm',
10:25:54  16  	  data_table_name => '&scoretable',
10:25:54  17  	  xform_view_name => 'svmc_apply_prep');
10:25:54  18  END;
10:25:54  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.24
10:25:54 SQL> 
10:25:54 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:54 SQL> -- DELETE it if I did:
10:25:54 SQL> DELETE ystkscores
10:25:54   2  WHERE score > 0
10:25:54   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:54   4  -- I need to supply the target attribute name:
10:25:54   5  AND targ = '&1'
10:25:54   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:25:54 SQL> 
10:25:54 SQL> -- We do a drumroll here:
10:25:54 SQL> 
10:25:54 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:54   2  SELECT
10:25:54   3  tkrdate
10:25:54   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:54   5  ,sysdate
10:25:54   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:54   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:54   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:54   9  ,SUBSTR(tkrdate,-10)ydate
10:25:54  10  ,'&1'
10:25:54  11  FROM svmc_apply_prep
10:25:54  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:25:54 SQL> @score1_5min_gattn.sql	2010-09-17 TLT
10:25:54 SQL> --
10:25:54 SQL> -- score1_5min_gattn.sql
10:25:54 SQL> --
10:25:54 SQL> 
10:25:54 SQL> -- Demo:
10:25:54 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:25:54 SQL> 
10:25:54 SQL> CREATE OR REPLACE VIEW sme AS
10:25:54   2  SELECT
10:25:54   3  tkrdate
10:25:54   4  ,NULL gattn
10:25:54   5  ,g00
10:25:54   6  ,g01
10:25:54   7  ,g02
10:25:54   8  ,g03
10:25:54   9  ,g04
10:25:54  10  ,g05
10:25:54  11  ,g06
10:25:54  12  ,g07
10:25:54  13  ,g08
10:25:54  14  ,g09
10:25:54  15  ,g10
10:25:54  16  ,g11
10:25:54  17  ,g12
10:25:54  18  ,g13
10:25:54  19  ,g14
10:25:54  20  ,g15
10:25:54  21  ,g16
10:25:54  22  ,g17
10:25:54  23  ,g18
10:25:54  24  ,g19
10:25:54  25  ,g20
10:25:54  26  ,g21
10:25:54  27  ,g22
10:25:54  28  ,g23
10:25:54  29  ,g24
10:25:54  30  ,g25
10:25:54  31  ,g26
10:25:54  32  ,g27
10:25:54  33  ,g28
10:25:54  34  ,g29
10:25:54  35  FROM stk_ms
10:25:54  36  WHERE ydate = '&1'
10:25:54  37  AND tkr = '&2'
10:25:54  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-09-17'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.10
10:25:54 SQL> 
10:25:54 SQL> -- rpt
10:25:54 SQL> -- We should see just 1 row:
10:25:54 SQL> 
10:25:54 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:54   2  
10:25:54 SQL> -- Build the model:
10:25:54 SQL> CREATE OR REPLACE VIEW bme AS
10:25:54   2  SELECT
10:25:54   3  tkrdate
10:25:54   4  ,gattn
10:25:54   5  ,g00
10:25:54   6  ,g01
10:25:54   7  ,g02
10:25:54   8  ,g03
10:25:54   9  ,g04
10:25:54  10  ,g05
10:25:54  11  ,g06
10:25:54  12  ,g07
10:25:54  13  ,g08
10:25:54  14  ,g09
10:25:54  15  ,g10
10:25:54  16  ,g11
10:25:54  17  ,g12
10:25:54  18  ,g13
10:25:54  19  ,g14
10:25:54  20  ,g15
10:25:54  21  ,g16
10:25:54  22  ,g17
10:25:54  23  ,g18
10:25:54  24  ,g19
10:25:54  25  ,g20
10:25:54  26  ,g21
10:25:54  27  ,g22
10:25:54  28  ,g23
10:25:54  29  ,g24
10:25:54  30  ,g25
10:25:54  31  ,g26
10:25:54  32  ,g27
10:25:54  33  ,g28
10:25:54  34  ,g29
10:25:54  35  FROM stk_ms
10:25:54  36  WHERE gattn IN('nup','up')
10:25:54  37  -- Use only rows which are older than 1 day:
10:25:54  38  AND 1+ydate < '&1'
10:25:54  39  AND tkr = '&2'
10:25:54  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-09-17'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:25:54 SQL> 
10:25:54 SQL> -- rpt
10:25:54 SQL> 
10:25:54 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:25:54   2  
10:25:54 SQL> SELECT MAX(tkrdate) FROM bme
10:25:54   2  
10:25:54 SQL> -- Now build model from bme and score sme
10:25:54 SQL> @score1.sql gattn
10:25:54 SQL> -- score1.sql
10:25:54 SQL> 
10:25:54 SQL> -- I use this script to send 5 params to score.sql
10:25:54 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:54 SQL> -- Then at the very end of this script I use the model
10:25:54 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:54 SQL> 
10:25:54 SQL> -- I call this script from 2 other scripts:
10:25:54 SQL> -- score1_5min.sql
10:25:54 SQL> -- score1_5min_gattn.sql
10:25:54 SQL> 
10:25:54 SQL> -- The 1st param is the name of the target attribute.
10:25:54 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:54 SQL> 
10:25:54 SQL> -- Demo:
10:25:54 SQL> -- @score1.sql 'gatt'
10:25:54 SQL> -- @score1.sql 'gattn'
10:25:54 SQL> 
10:25:54 SQL> -- Now, I fill up svmc_apply_prep.
10:25:54 SQL> -- I use same model_name used in score.sql
10:25:54 SQL> DEFINE model_name = 'svmspy101'
10:25:54 SQL> DEFINE bldtable	= 'bme'
10:25:54 SQL> DEFINE scoretable = 'sme'
10:25:54 SQL> DEFINE case_id	= 'tkrdate'
10:25:54 SQL> -- Demo:
10:25:54 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:54 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:54 SQL> --
10:25:54 SQL> -- score.sql
10:25:54 SQL> --
10:25:54 SQL> 
10:25:54 SQL> -- usage: score.sql
10:25:54 SQL> 
10:25:54 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:54 SQL> 
10:25:54 SQL> -- DEFINE target	   = 'gatt'
10:25:54 SQL> -- DEFINE model_name = 'svmspy100'
10:25:54 SQL> -- DEFINE bldtable   = 'bme'
10:25:54 SQL> -- DEFINE scoretable = 'sme'
10:25:54 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:54 SQL> 
10:25:54 SQL> DEFINE target	= '&1'
10:25:54 SQL> DEFINE model_name = '&2'
10:25:54 SQL> DEFINE bldtable	= '&3'
10:25:54 SQL> DEFINE scoretable = '&4'
10:25:54 SQL> DEFINE case_id	= '&5'
10:25:54 SQL> 
10:25:54 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:54 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:54 SQL> 
10:25:54 SQL> -- Builds an SVM model using pl/sql.
10:25:54 SQL> 
10:25:54 SQL> -----------------------------------------------------------------------
10:25:54 SQL> --			    BUILD THE MODEL
10:25:54 SQL> -----------------------------------------------------------------------
10:25:54 SQL> 
10:25:54 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:54 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:54 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:54 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:54 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:54 SQL> 
10:25:54 SQL> 
10:25:54 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:54 SQL> --
10:25:54 SQL> -- DROP	TABLE svmc_settings ;
10:25:54 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:54 SQL> -- DELETE svmc_settings;
10:25:54 SQL> 
10:25:54 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:54 SQL> -- this choice to SVM using a settings table.
10:25:54 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:54 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:54 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:54 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:54 SQL> -- models.
10:25:54 SQL> --
10:25:54 SQL> 
10:25:54 SQL> -- Do this once and then comment it out.
10:25:54 SQL> -- That makes script go faster.
10:25:54 SQL> -- BEGIN
10:25:54 SQL> -- -- Populate settings table
10:25:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:54 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:54 SQL> --
10:25:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:54 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:54 SQL> --
10:25:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:54 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:54 SQL> --   COMMIT;
10:25:54 SQL> -- END;
10:25:54 SQL> -- /
10:25:54 SQL> 
10:25:54 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:54 SQL> 
10:25:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:25:54 SQL> 
10:25:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:25:54 SQL> 
10:25:54 SQL> --------------------------------
10:25:54 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:54 SQL> --
10:25:54 SQL> 
10:25:54 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:54 SQL> -- 2. Outlier Treatment and
10:25:54 SQL> -- 3. Normalization are performed below.
10:25:54 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:54 SQL> --    normalized here.
10:25:54 SQL> 
10:25:54 SQL> BEGIN
10:25:54   2  	-- Perform missing value treatment for all predictors
10:25:54   3  	-- create miss tables
10:25:54   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:54   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:54   6  
10:25:54   7  	-- populate miss tables
10:25:54   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:54   9  	  miss_table_name => 'svmc_miss_num',
10:25:54  10  	  data_table_name => '&bldtable',
10:25:54  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:54  12  
10:25:54  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:54  14  	  miss_table_name => 'svmc_miss_cat',
10:25:54  15  	  data_table_name => '&bldtable',
10:25:54  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:54  17  
10:25:54  18  	-- xform input data to replace missing values
10:25:54  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:54  20  	  miss_table_name => 'svmc_miss_num',
10:25:54  21  	  data_table_name => '&bldtable',
10:25:54  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:54  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:54  24  	  miss_table_name => 'svmc_miss_cat',
10:25:54  25  	  data_table_name => '&bldtable',
10:25:54  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:54  27  
10:25:54  28  	-- Perform outlier treatment.
10:25:54  29  	-- create clip table
10:25:54  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:54  31  
10:25:54  32  	-- populate clip table
10:25:54  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:54  34  	  clip_table_name => 'svmc_clip',
10:25:54  35  	  data_table_name => '&bldtable',
10:25:54  36  	  tail_frac	  => 0.025,
10:25:54  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:54  38  
10:25:54  39  	-- xform input data to winsorized data
10:25:54  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:54  41  	  clip_table_name => 'svmc_clip',
10:25:54  42  	  data_table_name => '&bldtable',
10:25:54  43  	  xform_view_name => 'svmc_winsor');
10:25:54  44  
10:25:54  45  	-- create normalization table
10:25:54  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:54  47  
10:25:54  48  	-- populate normalization table based on winsorized data
10:25:54  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:54  50  	  norm_table_name => 'svmc_norm',
10:25:54  51  	  data_table_name => 'svmc_winsor',
10:25:54  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:54  53  
10:25:54  54  	-- normalize the original data
10:25:54  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:54  56  	  norm_table_name => 'svmc_norm',
10:25:54  57  	  data_table_name => '&bldtable',
10:25:54  58  	  xform_view_name => 'svmc_build_prep');
10:25:54  59  END;
10:25:54  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.63
10:25:55 SQL> 
10:25:55 SQL> ---------------------
10:25:55 SQL> -- CREATE A NEW MODEL
10:25:55 SQL> --
10:25:55 SQL> -- Cleanup old model with the same name for repeat runs
10:25:55 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:55   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.93
10:25:56 SQL> 
10:25:56 SQL> -- Build a new SVM Model
10:25:56 SQL> BEGIN
10:25:56   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:25:56   3  	  model_name	      => '&model_name',
10:25:56   4  	  mining_function     => dbms_data_mining.classification,
10:25:56   5  	  data_table_name     => 'svmc_build_prep',
10:25:56   6  	  case_id_column_name => '&case_id',
10:25:56   7  	  target_column_name  => '&target',
10:25:56   8  	  settings_table_name => 'svmc_settings');
10:25:56   9  END;
10:25:56  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.93
10:25:58 SQL> 
10:25:58 SQL> -----------------------------------------------------------------------
10:25:58 SQL> --			       APPLY/score THE MODEL
10:25:58 SQL> -----------------------------------------------------------------------
10:25:58 SQL> 
10:25:58 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:58 SQL> -----------------------
10:25:58 SQL> -- PREPARE SCORING DATA
10:25:58 SQL> --
10:25:58 SQL> -- If the data for model creation has been prepared, then the data
10:25:58 SQL> -- to be scored using the model must be prepared in the same manner
10:25:58 SQL> -- in order to obtain meaningful results.
10:25:58 SQL> --
10:25:58 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:58 SQL> -- 2. Normalization
10:25:58 SQL> -- No outlier treatment will be performed during test and apply. The
10:25:58 SQL> -- normalization step is sufficient, since the normalization parameters
10:25:58 SQL> -- already capture the effects of outlier treatment done with build data.
10:25:58 SQL> --
10:25:58 SQL> BEGIN
10:25:58   2  	-- Xform Test data to replace missing values
10:25:58   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:58   4  	  miss_table_name => 'svmc_miss_num',
10:25:58   5  	  data_table_name => '&scoretable',
10:25:58   6  	  xform_view_name => 'xformed_apply_miss_num');
10:25:58   7  
10:25:58   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:58   9  	  miss_table_name => 'svmc_miss_cat',
10:25:58  10  	  data_table_name => '&scoretable',
10:25:58  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:25:58  12  
10:25:58  13  	-- Normalize the data to be scored
10:25:58  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:58  15  	  norm_table_name => 'svmc_norm',
10:25:58  16  	  data_table_name => '&scoretable',
10:25:58  17  	  xform_view_name => 'svmc_apply_prep');
10:25:58  18  END;
10:25:58  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.33
10:25:58 SQL> 
10:25:58 SQL> -- Maybe I already collected a score for this tkrdate.
10:25:58 SQL> -- DELETE it if I did:
10:25:58 SQL> DELETE ystkscores
10:25:58   2  WHERE score > 0
10:25:58   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:25:58   4  -- I need to supply the target attribute name:
10:25:58   5  AND targ = '&1'
10:25:58   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:25:58 SQL> 
10:25:58 SQL> -- We do a drumroll here:
10:25:58 SQL> 
10:25:58 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:25:58   2  SELECT
10:25:58   3  tkrdate
10:25:58   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:25:58   5  ,sysdate
10:25:58   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:25:58   7  -- rluck/oracle_sql_demos/substr.sql :
10:25:58   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:25:58   9  ,SUBSTR(tkrdate,-10)ydate
10:25:58  10  ,'&1'
10:25:58  11  FROM svmc_apply_prep
10:25:58  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:25:58 SQL> @score1_5min_gattn.sql	2010-04-22 TLT
10:25:58 SQL> --
10:25:58 SQL> -- score1_5min_gattn.sql
10:25:58 SQL> --
10:25:58 SQL> 
10:25:58 SQL> -- Demo:
10:25:58 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:25:58 SQL> 
10:25:58 SQL> CREATE OR REPLACE VIEW sme AS
10:25:58   2  SELECT
10:25:58   3  tkrdate
10:25:58   4  ,NULL gattn
10:25:58   5  ,g00
10:25:58   6  ,g01
10:25:58   7  ,g02
10:25:58   8  ,g03
10:25:58   9  ,g04
10:25:58  10  ,g05
10:25:58  11  ,g06
10:25:58  12  ,g07
10:25:58  13  ,g08
10:25:58  14  ,g09
10:25:58  15  ,g10
10:25:58  16  ,g11
10:25:58  17  ,g12
10:25:58  18  ,g13
10:25:58  19  ,g14
10:25:58  20  ,g15
10:25:58  21  ,g16
10:25:58  22  ,g17
10:25:58  23  ,g18
10:25:58  24  ,g19
10:25:58  25  ,g20
10:25:58  26  ,g21
10:25:58  27  ,g22
10:25:58  28  ,g23
10:25:58  29  ,g24
10:25:58  30  ,g25
10:25:58  31  ,g26
10:25:58  32  ,g27
10:25:58  33  ,g28
10:25:58  34  ,g29
10:25:58  35  FROM stk_ms
10:25:58  36  WHERE ydate = '&1'
10:25:58  37  AND tkr = '&2'
10:25:58  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-22'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:58 SQL> 
10:25:58 SQL> -- rpt
10:25:58 SQL> -- We should see just 1 row:
10:25:58 SQL> 
10:25:58 SQL> SELECT COUNT(tkrdate) FROM sme
10:25:58   2  
10:25:58 SQL> -- Build the model:
10:25:58 SQL> CREATE OR REPLACE VIEW bme AS
10:25:58   2  SELECT
10:25:58   3  tkrdate
10:25:58   4  ,gattn
10:25:58   5  ,g00
10:25:58   6  ,g01
10:25:58   7  ,g02
10:25:58   8  ,g03
10:25:58   9  ,g04
10:25:58  10  ,g05
10:25:58  11  ,g06
10:25:58  12  ,g07
10:25:58  13  ,g08
10:25:58  14  ,g09
10:25:58  15  ,g10
10:25:58  16  ,g11
10:25:58  17  ,g12
10:25:58  18  ,g13
10:25:58  19  ,g14
10:25:58  20  ,g15
10:25:58  21  ,g16
10:25:58  22  ,g17
10:25:58  23  ,g18
10:25:58  24  ,g19
10:25:58  25  ,g20
10:25:58  26  ,g21
10:25:58  27  ,g22
10:25:58  28  ,g23
10:25:58  29  ,g24
10:25:58  30  ,g25
10:25:58  31  ,g26
10:25:58  32  ,g27
10:25:58  33  ,g28
10:25:58  34  ,g29
10:25:58  35  FROM stk_ms
10:25:58  36  WHERE gattn IN('nup','up')
10:25:58  37  -- Use only rows which are older than 1 day:
10:25:58  38  AND 1+ydate < '&1'
10:25:58  39  AND tkr = '&2'
10:25:58  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-22'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:25:58 SQL> 
10:25:58 SQL> -- rpt
10:25:58 SQL> 
10:25:58 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:25:58   2  
10:25:58 SQL> SELECT MAX(tkrdate) FROM bme
10:25:58   2  
10:25:58 SQL> -- Now build model from bme and score sme
10:25:58 SQL> @score1.sql gattn
10:25:58 SQL> -- score1.sql
10:25:58 SQL> 
10:25:58 SQL> -- I use this script to send 5 params to score.sql
10:25:58 SQL> -- which does the heavy lifting of creating an SVM model.
10:25:58 SQL> -- Then at the very end of this script I use the model
10:25:58 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:25:58 SQL> 
10:25:58 SQL> -- I call this script from 2 other scripts:
10:25:58 SQL> -- score1_5min.sql
10:25:58 SQL> -- score1_5min_gattn.sql
10:25:58 SQL> 
10:25:58 SQL> -- The 1st param is the name of the target attribute.
10:25:58 SQL> -- I like to call my target attributes either gatt or gattn.
10:25:58 SQL> 
10:25:58 SQL> -- Demo:
10:25:58 SQL> -- @score1.sql 'gatt'
10:25:58 SQL> -- @score1.sql 'gattn'
10:25:58 SQL> 
10:25:58 SQL> -- Now, I fill up svmc_apply_prep.
10:25:58 SQL> -- I use same model_name used in score.sql
10:25:58 SQL> DEFINE model_name = 'svmspy101'
10:25:58 SQL> DEFINE bldtable	= 'bme'
10:25:58 SQL> DEFINE scoretable = 'sme'
10:25:58 SQL> DEFINE case_id	= 'tkrdate'
10:25:58 SQL> -- Demo:
10:25:58 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:25:58 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:25:58 SQL> --
10:25:58 SQL> -- score.sql
10:25:58 SQL> --
10:25:58 SQL> 
10:25:58 SQL> -- usage: score.sql
10:25:58 SQL> 
10:25:58 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:25:58 SQL> 
10:25:58 SQL> -- DEFINE target	   = 'gatt'
10:25:58 SQL> -- DEFINE model_name = 'svmspy100'
10:25:58 SQL> -- DEFINE bldtable   = 'bme'
10:25:58 SQL> -- DEFINE scoretable = 'sme'
10:25:58 SQL> -- DEFINE case_id    = 'tkrdate'
10:25:58 SQL> 
10:25:58 SQL> DEFINE target	= '&1'
10:25:58 SQL> DEFINE model_name = '&2'
10:25:58 SQL> DEFINE bldtable	= '&3'
10:25:58 SQL> DEFINE scoretable = '&4'
10:25:58 SQL> DEFINE case_id	= '&5'
10:25:58 SQL> 
10:25:58 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:25:58 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:25:58 SQL> 
10:25:58 SQL> -- Builds an SVM model using pl/sql.
10:25:58 SQL> 
10:25:58 SQL> -----------------------------------------------------------------------
10:25:58 SQL> --			    BUILD THE MODEL
10:25:58 SQL> -----------------------------------------------------------------------
10:25:58 SQL> 
10:25:58 SQL> -- Cleanup old build data preparation objects for repeat runs
10:25:58 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:58 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:25:58 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:25:58 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:25:58 SQL> 
10:25:58 SQL> 
10:25:58 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:25:58 SQL> --
10:25:58 SQL> -- DROP	TABLE svmc_settings ;
10:25:58 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:25:58 SQL> -- DELETE svmc_settings;
10:25:58 SQL> 
10:25:58 SQL> -- The default classification algorithm is Naive Bayes. So override
10:25:58 SQL> -- this choice to SVM using a settings table.
10:25:58 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:25:58 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:25:58 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:25:58 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:25:58 SQL> -- models.
10:25:58 SQL> --
10:25:58 SQL> 
10:25:58 SQL> -- Do this once and then comment it out.
10:25:58 SQL> -- That makes script go faster.
10:25:58 SQL> -- BEGIN
10:25:58 SQL> -- -- Populate settings table
10:25:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:58 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:25:58 SQL> --
10:25:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:58 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:25:58 SQL> --
10:25:58 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:25:58 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:25:58 SQL> --   COMMIT;
10:25:58 SQL> -- END;
10:25:58 SQL> -- /
10:25:58 SQL> 
10:25:58 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:25:58 SQL> 
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:25:58 SQL> 
10:25:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:25:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
10:25:58 SQL> 
10:25:58 SQL> --------------------------------
10:25:58 SQL> -- PREPARE BUILD (TRAINING) DATA
10:25:58 SQL> --
10:25:58 SQL> 
10:25:58 SQL> -- 1. Missing Value treatment for all Predictors and
10:25:58 SQL> -- 2. Outlier Treatment and
10:25:58 SQL> -- 3. Normalization are performed below.
10:25:58 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:25:58 SQL> --    normalized here.
10:25:58 SQL> 
10:25:58 SQL> BEGIN
10:25:58   2  	-- Perform missing value treatment for all predictors
10:25:58   3  	-- create miss tables
10:25:58   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:25:58   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:25:58   6  
10:25:58   7  	-- populate miss tables
10:25:58   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:25:58   9  	  miss_table_name => 'svmc_miss_num',
10:25:58  10  	  data_table_name => '&bldtable',
10:25:58  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:58  12  
10:25:58  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:25:58  14  	  miss_table_name => 'svmc_miss_cat',
10:25:58  15  	  data_table_name => '&bldtable',
10:25:58  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:58  17  
10:25:58  18  	-- xform input data to replace missing values
10:25:58  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:25:58  20  	  miss_table_name => 'svmc_miss_num',
10:25:58  21  	  data_table_name => '&bldtable',
10:25:58  22  	  xform_view_name => 'xformed_build_miss_num');
10:25:58  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:25:58  24  	  miss_table_name => 'svmc_miss_cat',
10:25:58  25  	  data_table_name => '&bldtable',
10:25:58  26  	  xform_view_name => 'xformed_build_miss_cat');
10:25:58  27  
10:25:58  28  	-- Perform outlier treatment.
10:25:58  29  	-- create clip table
10:25:58  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:25:58  31  
10:25:58  32  	-- populate clip table
10:25:58  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:25:58  34  	  clip_table_name => 'svmc_clip',
10:25:58  35  	  data_table_name => '&bldtable',
10:25:58  36  	  tail_frac	  => 0.025,
10:25:58  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:58  38  
10:25:58  39  	-- xform input data to winsorized data
10:25:58  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:25:58  41  	  clip_table_name => 'svmc_clip',
10:25:58  42  	  data_table_name => '&bldtable',
10:25:58  43  	  xform_view_name => 'svmc_winsor');
10:25:58  44  
10:25:58  45  	-- create normalization table
10:25:58  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:25:58  47  
10:25:58  48  	-- populate normalization table based on winsorized data
10:25:58  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:25:58  50  	  norm_table_name => 'svmc_norm',
10:25:58  51  	  data_table_name => 'svmc_winsor',
10:25:58  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:25:58  53  
10:25:58  54  	-- normalize the original data
10:25:58  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:25:58  56  	  norm_table_name => 'svmc_norm',
10:25:58  57  	  data_table_name => '&bldtable',
10:25:58  58  	  xform_view_name => 'svmc_build_prep');
10:25:58  59  END;
10:25:58  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:25:59 SQL> 
10:25:59 SQL> ---------------------
10:25:59 SQL> -- CREATE A NEW MODEL
10:25:59 SQL> --
10:25:59 SQL> -- Cleanup old model with the same name for repeat runs
10:25:59 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:25:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:25:59   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.31
10:26:00 SQL> 
10:26:00 SQL> -- Build a new SVM Model
10:26:00 SQL> BEGIN
10:26:00   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:00   3  	  model_name	      => '&model_name',
10:26:00   4  	  mining_function     => dbms_data_mining.classification,
10:26:00   5  	  data_table_name     => 'svmc_build_prep',
10:26:00   6  	  case_id_column_name => '&case_id',
10:26:00   7  	  target_column_name  => '&target',
10:26:00   8  	  settings_table_name => 'svmc_settings');
10:26:00   9  END;
10:26:00  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.97
10:26:02 SQL> 
10:26:02 SQL> -----------------------------------------------------------------------
10:26:02 SQL> --			       APPLY/score THE MODEL
10:26:02 SQL> -----------------------------------------------------------------------
10:26:02 SQL> 
10:26:02 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:02 SQL> -----------------------
10:26:02 SQL> -- PREPARE SCORING DATA
10:26:02 SQL> --
10:26:02 SQL> -- If the data for model creation has been prepared, then the data
10:26:02 SQL> -- to be scored using the model must be prepared in the same manner
10:26:02 SQL> -- in order to obtain meaningful results.
10:26:02 SQL> --
10:26:02 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:02 SQL> -- 2. Normalization
10:26:02 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:02 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:02 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:02 SQL> --
10:26:02 SQL> BEGIN
10:26:02   2  	-- Xform Test data to replace missing values
10:26:02   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:02   4  	  miss_table_name => 'svmc_miss_num',
10:26:02   5  	  data_table_name => '&scoretable',
10:26:02   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:02   7  
10:26:02   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:02   9  	  miss_table_name => 'svmc_miss_cat',
10:26:02  10  	  data_table_name => '&scoretable',
10:26:02  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:02  12  
10:26:02  13  	-- Normalize the data to be scored
10:26:02  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:02  15  	  norm_table_name => 'svmc_norm',
10:26:02  16  	  data_table_name => '&scoretable',
10:26:02  17  	  xform_view_name => 'svmc_apply_prep');
10:26:02  18  END;
10:26:02  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:03 SQL> 
10:26:03 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:03 SQL> -- DELETE it if I did:
10:26:03 SQL> DELETE ystkscores
10:26:03   2  WHERE score > 0
10:26:03   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:03   4  -- I need to supply the target attribute name:
10:26:03   5  AND targ = '&1'
10:26:03   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:03 SQL> 
10:26:03 SQL> -- We do a drumroll here:
10:26:03 SQL> 
10:26:03 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:03   2  SELECT
10:26:03   3  tkrdate
10:26:03   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:03   5  ,sysdate
10:26:03   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:03   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:03   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:03   9  ,SUBSTR(tkrdate,-10)ydate
10:26:03  10  ,'&1'
10:26:03  11  FROM svmc_apply_prep
10:26:03  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:26:03 SQL> @score1_5min_gattn.sql	2010-04-13 TLT
10:26:03 SQL> --
10:26:03 SQL> -- score1_5min_gattn.sql
10:26:03 SQL> --
10:26:03 SQL> 
10:26:03 SQL> -- Demo:
10:26:03 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:03 SQL> 
10:26:03 SQL> CREATE OR REPLACE VIEW sme AS
10:26:03   2  SELECT
10:26:03   3  tkrdate
10:26:03   4  ,NULL gattn
10:26:03   5  ,g00
10:26:03   6  ,g01
10:26:03   7  ,g02
10:26:03   8  ,g03
10:26:03   9  ,g04
10:26:03  10  ,g05
10:26:03  11  ,g06
10:26:03  12  ,g07
10:26:03  13  ,g08
10:26:03  14  ,g09
10:26:03  15  ,g10
10:26:03  16  ,g11
10:26:03  17  ,g12
10:26:03  18  ,g13
10:26:03  19  ,g14
10:26:03  20  ,g15
10:26:03  21  ,g16
10:26:03  22  ,g17
10:26:03  23  ,g18
10:26:03  24  ,g19
10:26:03  25  ,g20
10:26:03  26  ,g21
10:26:03  27  ,g22
10:26:03  28  ,g23
10:26:03  29  ,g24
10:26:03  30  ,g25
10:26:03  31  ,g26
10:26:03  32  ,g27
10:26:03  33  ,g28
10:26:03  34  ,g29
10:26:03  35  FROM stk_ms
10:26:03  36  WHERE ydate = '&1'
10:26:03  37  AND tkr = '&2'
10:26:03  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-13'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:26:03 SQL> 
10:26:03 SQL> -- rpt
10:26:03 SQL> -- We should see just 1 row:
10:26:03 SQL> 
10:26:03 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:03   2  
10:26:03 SQL> -- Build the model:
10:26:03 SQL> CREATE OR REPLACE VIEW bme AS
10:26:03   2  SELECT
10:26:03   3  tkrdate
10:26:03   4  ,gattn
10:26:03   5  ,g00
10:26:03   6  ,g01
10:26:03   7  ,g02
10:26:03   8  ,g03
10:26:03   9  ,g04
10:26:03  10  ,g05
10:26:03  11  ,g06
10:26:03  12  ,g07
10:26:03  13  ,g08
10:26:03  14  ,g09
10:26:03  15  ,g10
10:26:03  16  ,g11
10:26:03  17  ,g12
10:26:03  18  ,g13
10:26:03  19  ,g14
10:26:03  20  ,g15
10:26:03  21  ,g16
10:26:03  22  ,g17
10:26:03  23  ,g18
10:26:03  24  ,g19
10:26:03  25  ,g20
10:26:03  26  ,g21
10:26:03  27  ,g22
10:26:03  28  ,g23
10:26:03  29  ,g24
10:26:03  30  ,g25
10:26:03  31  ,g26
10:26:03  32  ,g27
10:26:03  33  ,g28
10:26:03  34  ,g29
10:26:03  35  FROM stk_ms
10:26:03  36  WHERE gattn IN('nup','up')
10:26:03  37  -- Use only rows which are older than 1 day:
10:26:03  38  AND 1+ydate < '&1'
10:26:03  39  AND tkr = '&2'
10:26:03  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-13'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:03 SQL> 
10:26:03 SQL> -- rpt
10:26:03 SQL> 
10:26:03 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:03   2  
10:26:03 SQL> SELECT MAX(tkrdate) FROM bme
10:26:03   2  
10:26:03 SQL> -- Now build model from bme and score sme
10:26:03 SQL> @score1.sql gattn
10:26:03 SQL> -- score1.sql
10:26:03 SQL> 
10:26:03 SQL> -- I use this script to send 5 params to score.sql
10:26:03 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:03 SQL> -- Then at the very end of this script I use the model
10:26:03 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:03 SQL> 
10:26:03 SQL> -- I call this script from 2 other scripts:
10:26:03 SQL> -- score1_5min.sql
10:26:03 SQL> -- score1_5min_gattn.sql
10:26:03 SQL> 
10:26:03 SQL> -- The 1st param is the name of the target attribute.
10:26:03 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:03 SQL> 
10:26:03 SQL> -- Demo:
10:26:03 SQL> -- @score1.sql 'gatt'
10:26:03 SQL> -- @score1.sql 'gattn'
10:26:03 SQL> 
10:26:03 SQL> -- Now, I fill up svmc_apply_prep.
10:26:03 SQL> -- I use same model_name used in score.sql
10:26:03 SQL> DEFINE model_name = 'svmspy101'
10:26:03 SQL> DEFINE bldtable	= 'bme'
10:26:03 SQL> DEFINE scoretable = 'sme'
10:26:03 SQL> DEFINE case_id	= 'tkrdate'
10:26:03 SQL> -- Demo:
10:26:03 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:03 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:03 SQL> --
10:26:03 SQL> -- score.sql
10:26:03 SQL> --
10:26:03 SQL> 
10:26:03 SQL> -- usage: score.sql
10:26:03 SQL> 
10:26:03 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:03 SQL> 
10:26:03 SQL> -- DEFINE target	   = 'gatt'
10:26:03 SQL> -- DEFINE model_name = 'svmspy100'
10:26:03 SQL> -- DEFINE bldtable   = 'bme'
10:26:03 SQL> -- DEFINE scoretable = 'sme'
10:26:03 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:03 SQL> 
10:26:03 SQL> DEFINE target	= '&1'
10:26:03 SQL> DEFINE model_name = '&2'
10:26:03 SQL> DEFINE bldtable	= '&3'
10:26:03 SQL> DEFINE scoretable = '&4'
10:26:03 SQL> DEFINE case_id	= '&5'
10:26:03 SQL> 
10:26:03 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:03 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:03 SQL> 
10:26:03 SQL> -- Builds an SVM model using pl/sql.
10:26:03 SQL> 
10:26:03 SQL> -----------------------------------------------------------------------
10:26:03 SQL> --			    BUILD THE MODEL
10:26:03 SQL> -----------------------------------------------------------------------
10:26:03 SQL> 
10:26:03 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:03 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:03 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:03 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:03 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:03 SQL> 
10:26:03 SQL> 
10:26:03 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:03 SQL> --
10:26:03 SQL> -- DROP	TABLE svmc_settings ;
10:26:03 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:03 SQL> -- DELETE svmc_settings;
10:26:03 SQL> 
10:26:03 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:03 SQL> -- this choice to SVM using a settings table.
10:26:03 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:03 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:03 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:03 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:03 SQL> -- models.
10:26:03 SQL> --
10:26:03 SQL> 
10:26:03 SQL> -- Do this once and then comment it out.
10:26:03 SQL> -- That makes script go faster.
10:26:03 SQL> -- BEGIN
10:26:03 SQL> -- -- Populate settings table
10:26:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:03 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:03 SQL> --
10:26:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:03 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:03 SQL> --
10:26:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:03 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:03 SQL> --   COMMIT;
10:26:03 SQL> -- END;
10:26:03 SQL> -- /
10:26:03 SQL> 
10:26:03 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:03 SQL> 
10:26:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:03 SQL> 
10:26:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:03 SQL> 
10:26:03 SQL> --------------------------------
10:26:03 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:03 SQL> --
10:26:03 SQL> 
10:26:03 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:03 SQL> -- 2. Outlier Treatment and
10:26:03 SQL> -- 3. Normalization are performed below.
10:26:03 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:03 SQL> --    normalized here.
10:26:03 SQL> 
10:26:03 SQL> BEGIN
10:26:03   2  	-- Perform missing value treatment for all predictors
10:26:03   3  	-- create miss tables
10:26:03   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:03   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:03   6  
10:26:03   7  	-- populate miss tables
10:26:03   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:03   9  	  miss_table_name => 'svmc_miss_num',
10:26:03  10  	  data_table_name => '&bldtable',
10:26:03  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:03  12  
10:26:03  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:03  14  	  miss_table_name => 'svmc_miss_cat',
10:26:03  15  	  data_table_name => '&bldtable',
10:26:03  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:03  17  
10:26:03  18  	-- xform input data to replace missing values
10:26:03  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:03  20  	  miss_table_name => 'svmc_miss_num',
10:26:03  21  	  data_table_name => '&bldtable',
10:26:03  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:03  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:03  24  	  miss_table_name => 'svmc_miss_cat',
10:26:03  25  	  data_table_name => '&bldtable',
10:26:03  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:03  27  
10:26:03  28  	-- Perform outlier treatment.
10:26:03  29  	-- create clip table
10:26:03  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:03  31  
10:26:03  32  	-- populate clip table
10:26:03  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:03  34  	  clip_table_name => 'svmc_clip',
10:26:03  35  	  data_table_name => '&bldtable',
10:26:03  36  	  tail_frac	  => 0.025,
10:26:03  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:03  38  
10:26:03  39  	-- xform input data to winsorized data
10:26:03  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:03  41  	  clip_table_name => 'svmc_clip',
10:26:03  42  	  data_table_name => '&bldtable',
10:26:03  43  	  xform_view_name => 'svmc_winsor');
10:26:03  44  
10:26:03  45  	-- create normalization table
10:26:03  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:03  47  
10:26:03  48  	-- populate normalization table based on winsorized data
10:26:03  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:03  50  	  norm_table_name => 'svmc_norm',
10:26:03  51  	  data_table_name => 'svmc_winsor',
10:26:03  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:03  53  
10:26:03  54  	-- normalize the original data
10:26:03  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:03  56  	  norm_table_name => 'svmc_norm',
10:26:03  57  	  data_table_name => '&bldtable',
10:26:03  58  	  xform_view_name => 'svmc_build_prep');
10:26:03  59  END;
10:26:03  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:26:03 SQL> 
10:26:03 SQL> ---------------------
10:26:03 SQL> -- CREATE A NEW MODEL
10:26:03 SQL> --
10:26:03 SQL> -- Cleanup old model with the same name for repeat runs
10:26:03 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:03   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.51
10:26:05 SQL> 
10:26:05 SQL> -- Build a new SVM Model
10:26:05 SQL> BEGIN
10:26:05   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:05   3  	  model_name	      => '&model_name',
10:26:05   4  	  mining_function     => dbms_data_mining.classification,
10:26:05   5  	  data_table_name     => 'svmc_build_prep',
10:26:05   6  	  case_id_column_name => '&case_id',
10:26:05   7  	  target_column_name  => '&target',
10:26:05   8  	  settings_table_name => 'svmc_settings');
10:26:05   9  END;
10:26:05  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.99
10:26:07 SQL> 
10:26:07 SQL> -----------------------------------------------------------------------
10:26:07 SQL> --			       APPLY/score THE MODEL
10:26:07 SQL> -----------------------------------------------------------------------
10:26:07 SQL> 
10:26:07 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:07 SQL> -----------------------
10:26:07 SQL> -- PREPARE SCORING DATA
10:26:07 SQL> --
10:26:07 SQL> -- If the data for model creation has been prepared, then the data
10:26:07 SQL> -- to be scored using the model must be prepared in the same manner
10:26:07 SQL> -- in order to obtain meaningful results.
10:26:07 SQL> --
10:26:07 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:07 SQL> -- 2. Normalization
10:26:07 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:07 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:07 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:07 SQL> --
10:26:07 SQL> BEGIN
10:26:07   2  	-- Xform Test data to replace missing values
10:26:07   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:07   4  	  miss_table_name => 'svmc_miss_num',
10:26:07   5  	  data_table_name => '&scoretable',
10:26:07   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:07   7  
10:26:07   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:07   9  	  miss_table_name => 'svmc_miss_cat',
10:26:07  10  	  data_table_name => '&scoretable',
10:26:07  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:07  12  
10:26:07  13  	-- Normalize the data to be scored
10:26:07  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:07  15  	  norm_table_name => 'svmc_norm',
10:26:07  16  	  data_table_name => '&scoretable',
10:26:07  17  	  xform_view_name => 'svmc_apply_prep');
10:26:07  18  END;
10:26:07  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:07 SQL> 
10:26:07 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:07 SQL> -- DELETE it if I did:
10:26:07 SQL> DELETE ystkscores
10:26:07   2  WHERE score > 0
10:26:07   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:07   4  -- I need to supply the target attribute name:
10:26:07   5  AND targ = '&1'
10:26:07   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:07 SQL> 
10:26:07 SQL> -- We do a drumroll here:
10:26:07 SQL> 
10:26:07 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:07   2  SELECT
10:26:07   3  tkrdate
10:26:07   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:07   5  ,sysdate
10:26:07   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:07   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:07   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:07   9  ,SUBSTR(tkrdate,-10)ydate
10:26:07  10  ,'&1'
10:26:07  11  FROM svmc_apply_prep
10:26:07  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:26:07 SQL> @score1_5min.sql	      2010-03-22 TLT
10:26:07 SQL> --
10:26:07 SQL> -- score1_5min.sql
10:26:07 SQL> --
10:26:07 SQL> 
10:26:07 SQL> -- Demo:
10:26:07 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:26:07 SQL> 
10:26:07 SQL> CREATE OR REPLACE VIEW sme AS
10:26:07   2  SELECT
10:26:07   3  tkrdate
10:26:07   4  ,NULL gatt
10:26:07   5  ,g00
10:26:07   6  ,g01
10:26:07   7  ,g02
10:26:07   8  ,g03
10:26:07   9  ,g04
10:26:07  10  ,g05
10:26:07  11  ,g06
10:26:07  12  ,g07
10:26:07  13  ,g08
10:26:07  14  ,g09
10:26:07  15  ,g10
10:26:07  16  ,g11
10:26:07  17  ,g12
10:26:07  18  ,g13
10:26:07  19  ,g14
10:26:07  20  ,g15
10:26:07  21  ,g16
10:26:07  22  ,g17
10:26:07  23  ,g18
10:26:07  24  ,g19
10:26:07  25  ,g20
10:26:07  26  ,g21
10:26:07  27  ,g22
10:26:07  28  ,g23
10:26:07  29  ,g24
10:26:07  30  ,g25
10:26:07  31  ,g26
10:26:07  32  ,g27
10:26:07  33  ,g28
10:26:07  34  ,g29
10:26:07  35  FROM stk_ms
10:26:07  36  WHERE ydate = '&1'
10:26:07  37  AND tkr = '&2'
10:26:07  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-22'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:07 SQL> 
10:26:07 SQL> -- rpt
10:26:07 SQL> -- We should see just 1 row:
10:26:07 SQL> 
10:26:07 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:07   2  
10:26:07 SQL> -- Build the model:
10:26:07 SQL> CREATE OR REPLACE VIEW bme AS
10:26:07   2  SELECT
10:26:07   3  tkrdate
10:26:07   4  ,gatt
10:26:07   5  ,g00
10:26:07   6  ,g01
10:26:07   7  ,g02
10:26:07   8  ,g03
10:26:07   9  ,g04
10:26:07  10  ,g05
10:26:07  11  ,g06
10:26:07  12  ,g07
10:26:07  13  ,g08
10:26:07  14  ,g09
10:26:07  15  ,g10
10:26:07  16  ,g11
10:26:07  17  ,g12
10:26:07  18  ,g13
10:26:07  19  ,g14
10:26:07  20  ,g15
10:26:07  21  ,g16
10:26:07  22  ,g17
10:26:07  23  ,g18
10:26:07  24  ,g19
10:26:07  25  ,g20
10:26:07  26  ,g21
10:26:07  27  ,g22
10:26:07  28  ,g23
10:26:07  29  ,g24
10:26:07  30  ,g25
10:26:07  31  ,g26
10:26:07  32  ,g27
10:26:07  33  ,g28
10:26:07  34  ,g29
10:26:07  35  FROM stk_ms
10:26:07  36  WHERE gatt IN('nup','up')
10:26:07  37  -- Use only rows which are older than 1 day:
10:26:07  38  AND 1+ydate < '&1'
10:26:07  39  AND tkr = '&2'
10:26:07  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-22'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:07 SQL> 
10:26:07 SQL> -- rpt
10:26:07 SQL> 
10:26:07 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:26:07   2  
10:26:07 SQL> SELECT MAX(tkrdate) FROM bme
10:26:07   2  
10:26:07 SQL> -- Now build model from bme and score sme
10:26:07 SQL> @score1.sql gatt
10:26:07 SQL> -- score1.sql
10:26:07 SQL> 
10:26:07 SQL> -- I use this script to send 5 params to score.sql
10:26:07 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:07 SQL> -- Then at the very end of this script I use the model
10:26:07 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:07 SQL> 
10:26:07 SQL> -- I call this script from 2 other scripts:
10:26:07 SQL> -- score1_5min.sql
10:26:07 SQL> -- score1_5min_gattn.sql
10:26:07 SQL> 
10:26:07 SQL> -- The 1st param is the name of the target attribute.
10:26:07 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:07 SQL> 
10:26:07 SQL> -- Demo:
10:26:07 SQL> -- @score1.sql 'gatt'
10:26:07 SQL> -- @score1.sql 'gattn'
10:26:07 SQL> 
10:26:07 SQL> -- Now, I fill up svmc_apply_prep.
10:26:07 SQL> -- I use same model_name used in score.sql
10:26:07 SQL> DEFINE model_name = 'svmspy101'
10:26:07 SQL> DEFINE bldtable	= 'bme'
10:26:07 SQL> DEFINE scoretable = 'sme'
10:26:07 SQL> DEFINE case_id	= 'tkrdate'
10:26:07 SQL> -- Demo:
10:26:07 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:07 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:07 SQL> --
10:26:07 SQL> -- score.sql
10:26:07 SQL> --
10:26:07 SQL> 
10:26:07 SQL> -- usage: score.sql
10:26:07 SQL> 
10:26:07 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:07 SQL> 
10:26:07 SQL> -- DEFINE target	   = 'gatt'
10:26:07 SQL> -- DEFINE model_name = 'svmspy100'
10:26:07 SQL> -- DEFINE bldtable   = 'bme'
10:26:07 SQL> -- DEFINE scoretable = 'sme'
10:26:07 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:07 SQL> 
10:26:07 SQL> DEFINE target	= '&1'
10:26:07 SQL> DEFINE model_name = '&2'
10:26:07 SQL> DEFINE bldtable	= '&3'
10:26:07 SQL> DEFINE scoretable = '&4'
10:26:07 SQL> DEFINE case_id	= '&5'
10:26:07 SQL> 
10:26:07 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:07 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:07 SQL> 
10:26:07 SQL> -- Builds an SVM model using pl/sql.
10:26:07 SQL> 
10:26:07 SQL> -----------------------------------------------------------------------
10:26:07 SQL> --			    BUILD THE MODEL
10:26:07 SQL> -----------------------------------------------------------------------
10:26:07 SQL> 
10:26:07 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:07 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:07 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:07 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:07 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:07 SQL> 
10:26:07 SQL> 
10:26:07 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:07 SQL> --
10:26:07 SQL> -- DROP	TABLE svmc_settings ;
10:26:07 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:07 SQL> -- DELETE svmc_settings;
10:26:07 SQL> 
10:26:07 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:07 SQL> -- this choice to SVM using a settings table.
10:26:07 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:07 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:07 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:07 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:07 SQL> -- models.
10:26:07 SQL> --
10:26:07 SQL> 
10:26:07 SQL> -- Do this once and then comment it out.
10:26:07 SQL> -- That makes script go faster.
10:26:07 SQL> -- BEGIN
10:26:07 SQL> -- -- Populate settings table
10:26:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:07 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:07 SQL> --
10:26:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:07 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:07 SQL> --
10:26:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:07 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:07 SQL> --   COMMIT;
10:26:07 SQL> -- END;
10:26:07 SQL> -- /
10:26:07 SQL> 
10:26:07 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:07 SQL> 
10:26:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:26:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:08 SQL> 
10:26:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:08 SQL> 
10:26:08 SQL> --------------------------------
10:26:08 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:08 SQL> --
10:26:08 SQL> 
10:26:08 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:08 SQL> -- 2. Outlier Treatment and
10:26:08 SQL> -- 3. Normalization are performed below.
10:26:08 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:08 SQL> --    normalized here.
10:26:08 SQL> 
10:26:08 SQL> BEGIN
10:26:08   2  	-- Perform missing value treatment for all predictors
10:26:08   3  	-- create miss tables
10:26:08   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:08   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:08   6  
10:26:08   7  	-- populate miss tables
10:26:08   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:08   9  	  miss_table_name => 'svmc_miss_num',
10:26:08  10  	  data_table_name => '&bldtable',
10:26:08  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:08  12  
10:26:08  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:08  14  	  miss_table_name => 'svmc_miss_cat',
10:26:08  15  	  data_table_name => '&bldtable',
10:26:08  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:08  17  
10:26:08  18  	-- xform input data to replace missing values
10:26:08  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:08  20  	  miss_table_name => 'svmc_miss_num',
10:26:08  21  	  data_table_name => '&bldtable',
10:26:08  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:08  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:08  24  	  miss_table_name => 'svmc_miss_cat',
10:26:08  25  	  data_table_name => '&bldtable',
10:26:08  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:08  27  
10:26:08  28  	-- Perform outlier treatment.
10:26:08  29  	-- create clip table
10:26:08  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:08  31  
10:26:08  32  	-- populate clip table
10:26:08  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:08  34  	  clip_table_name => 'svmc_clip',
10:26:08  35  	  data_table_name => '&bldtable',
10:26:08  36  	  tail_frac	  => 0.025,
10:26:08  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:08  38  
10:26:08  39  	-- xform input data to winsorized data
10:26:08  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:08  41  	  clip_table_name => 'svmc_clip',
10:26:08  42  	  data_table_name => '&bldtable',
10:26:08  43  	  xform_view_name => 'svmc_winsor');
10:26:08  44  
10:26:08  45  	-- create normalization table
10:26:08  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:08  47  
10:26:08  48  	-- populate normalization table based on winsorized data
10:26:08  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:08  50  	  norm_table_name => 'svmc_norm',
10:26:08  51  	  data_table_name => 'svmc_winsor',
10:26:08  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:08  53  
10:26:08  54  	-- normalize the original data
10:26:08  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:08  56  	  norm_table_name => 'svmc_norm',
10:26:08  57  	  data_table_name => '&bldtable',
10:26:08  58  	  xform_view_name => 'svmc_build_prep');
10:26:08  59  END;
10:26:08  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.57
10:26:08 SQL> 
10:26:08 SQL> ---------------------
10:26:08 SQL> -- CREATE A NEW MODEL
10:26:08 SQL> --
10:26:08 SQL> -- Cleanup old model with the same name for repeat runs
10:26:08 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:08   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.01
10:26:09 SQL> 
10:26:09 SQL> -- Build a new SVM Model
10:26:09 SQL> BEGIN
10:26:09   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:09   3  	  model_name	      => '&model_name',
10:26:09   4  	  mining_function     => dbms_data_mining.classification,
10:26:09   5  	  data_table_name     => 'svmc_build_prep',
10:26:09   6  	  case_id_column_name => '&case_id',
10:26:09   7  	  target_column_name  => '&target',
10:26:09   8  	  settings_table_name => 'svmc_settings');
10:26:09   9  END;
10:26:09  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.35
10:26:12 SQL> 
10:26:12 SQL> -----------------------------------------------------------------------
10:26:12 SQL> --			       APPLY/score THE MODEL
10:26:12 SQL> -----------------------------------------------------------------------
10:26:12 SQL> 
10:26:12 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:12 SQL> -----------------------
10:26:12 SQL> -- PREPARE SCORING DATA
10:26:12 SQL> --
10:26:12 SQL> -- If the data for model creation has been prepared, then the data
10:26:12 SQL> -- to be scored using the model must be prepared in the same manner
10:26:12 SQL> -- in order to obtain meaningful results.
10:26:12 SQL> --
10:26:12 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:12 SQL> -- 2. Normalization
10:26:12 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:12 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:12 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:12 SQL> --
10:26:12 SQL> BEGIN
10:26:12   2  	-- Xform Test data to replace missing values
10:26:12   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:12   4  	  miss_table_name => 'svmc_miss_num',
10:26:12   5  	  data_table_name => '&scoretable',
10:26:12   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:12   7  
10:26:12   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:12   9  	  miss_table_name => 'svmc_miss_cat',
10:26:12  10  	  data_table_name => '&scoretable',
10:26:12  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:12  12  
10:26:12  13  	-- Normalize the data to be scored
10:26:12  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:12  15  	  norm_table_name => 'svmc_norm',
10:26:12  16  	  data_table_name => '&scoretable',
10:26:12  17  	  xform_view_name => 'svmc_apply_prep');
10:26:12  18  END;
10:26:12  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:26:12 SQL> 
10:26:12 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:12 SQL> -- DELETE it if I did:
10:26:12 SQL> DELETE ystkscores
10:26:12   2  WHERE score > 0
10:26:12   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:12   4  -- I need to supply the target attribute name:
10:26:12   5  AND targ = '&1'
10:26:12   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:26:12 SQL> 
10:26:12 SQL> -- We do a drumroll here:
10:26:12 SQL> 
10:26:12 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:12   2  SELECT
10:26:12   3  tkrdate
10:26:12   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:12   5  ,sysdate
10:26:12   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:12   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:12   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:12   9  ,SUBSTR(tkrdate,-10)ydate
10:26:12  10  ,'&1'
10:26:12  11  FROM svmc_apply_prep
10:26:12  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:26:12 SQL> @score1_5min.sql	      2010-11-18 TLT
10:26:12 SQL> --
10:26:12 SQL> -- score1_5min.sql
10:26:12 SQL> --
10:26:12 SQL> 
10:26:12 SQL> -- Demo:
10:26:12 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:26:12 SQL> 
10:26:12 SQL> CREATE OR REPLACE VIEW sme AS
10:26:12   2  SELECT
10:26:12   3  tkrdate
10:26:12   4  ,NULL gatt
10:26:12   5  ,g00
10:26:12   6  ,g01
10:26:12   7  ,g02
10:26:12   8  ,g03
10:26:12   9  ,g04
10:26:12  10  ,g05
10:26:12  11  ,g06
10:26:12  12  ,g07
10:26:12  13  ,g08
10:26:12  14  ,g09
10:26:12  15  ,g10
10:26:12  16  ,g11
10:26:12  17  ,g12
10:26:12  18  ,g13
10:26:12  19  ,g14
10:26:12  20  ,g15
10:26:12  21  ,g16
10:26:12  22  ,g17
10:26:12  23  ,g18
10:26:12  24  ,g19
10:26:12  25  ,g20
10:26:12  26  ,g21
10:26:12  27  ,g22
10:26:12  28  ,g23
10:26:12  29  ,g24
10:26:12  30  ,g25
10:26:12  31  ,g26
10:26:12  32  ,g27
10:26:12  33  ,g28
10:26:12  34  ,g29
10:26:12  35  FROM stk_ms
10:26:12  36  WHERE ydate = '&1'
10:26:12  37  AND tkr = '&2'
10:26:12  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-18'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:12 SQL> 
10:26:12 SQL> -- rpt
10:26:12 SQL> -- We should see just 1 row:
10:26:12 SQL> 
10:26:12 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:12   2  
10:26:12 SQL> -- Build the model:
10:26:12 SQL> CREATE OR REPLACE VIEW bme AS
10:26:12   2  SELECT
10:26:12   3  tkrdate
10:26:12   4  ,gatt
10:26:12   5  ,g00
10:26:12   6  ,g01
10:26:12   7  ,g02
10:26:12   8  ,g03
10:26:12   9  ,g04
10:26:12  10  ,g05
10:26:12  11  ,g06
10:26:12  12  ,g07
10:26:12  13  ,g08
10:26:12  14  ,g09
10:26:12  15  ,g10
10:26:12  16  ,g11
10:26:12  17  ,g12
10:26:12  18  ,g13
10:26:12  19  ,g14
10:26:12  20  ,g15
10:26:12  21  ,g16
10:26:12  22  ,g17
10:26:12  23  ,g18
10:26:12  24  ,g19
10:26:12  25  ,g20
10:26:12  26  ,g21
10:26:12  27  ,g22
10:26:12  28  ,g23
10:26:12  29  ,g24
10:26:12  30  ,g25
10:26:12  31  ,g26
10:26:12  32  ,g27
10:26:12  33  ,g28
10:26:12  34  ,g29
10:26:12  35  FROM stk_ms
10:26:12  36  WHERE gatt IN('nup','up')
10:26:12  37  -- Use only rows which are older than 1 day:
10:26:12  38  AND 1+ydate < '&1'
10:26:12  39  AND tkr = '&2'
10:26:12  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-18'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:12 SQL> 
10:26:12 SQL> -- rpt
10:26:12 SQL> 
10:26:12 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:26:12   2  
10:26:12 SQL> SELECT MAX(tkrdate) FROM bme
10:26:12   2  
10:26:12 SQL> -- Now build model from bme and score sme
10:26:12 SQL> @score1.sql gatt
10:26:12 SQL> -- score1.sql
10:26:12 SQL> 
10:26:12 SQL> -- I use this script to send 5 params to score.sql
10:26:12 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:12 SQL> -- Then at the very end of this script I use the model
10:26:12 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:12 SQL> 
10:26:12 SQL> -- I call this script from 2 other scripts:
10:26:12 SQL> -- score1_5min.sql
10:26:12 SQL> -- score1_5min_gattn.sql
10:26:12 SQL> 
10:26:12 SQL> -- The 1st param is the name of the target attribute.
10:26:12 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:12 SQL> 
10:26:12 SQL> -- Demo:
10:26:12 SQL> -- @score1.sql 'gatt'
10:26:12 SQL> -- @score1.sql 'gattn'
10:26:12 SQL> 
10:26:12 SQL> -- Now, I fill up svmc_apply_prep.
10:26:12 SQL> -- I use same model_name used in score.sql
10:26:12 SQL> DEFINE model_name = 'svmspy101'
10:26:12 SQL> DEFINE bldtable	= 'bme'
10:26:12 SQL> DEFINE scoretable = 'sme'
10:26:12 SQL> DEFINE case_id	= 'tkrdate'
10:26:12 SQL> -- Demo:
10:26:12 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:12 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:12 SQL> --
10:26:12 SQL> -- score.sql
10:26:12 SQL> --
10:26:12 SQL> 
10:26:12 SQL> -- usage: score.sql
10:26:12 SQL> 
10:26:12 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:12 SQL> 
10:26:12 SQL> -- DEFINE target	   = 'gatt'
10:26:12 SQL> -- DEFINE model_name = 'svmspy100'
10:26:12 SQL> -- DEFINE bldtable   = 'bme'
10:26:12 SQL> -- DEFINE scoretable = 'sme'
10:26:12 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:12 SQL> 
10:26:12 SQL> DEFINE target	= '&1'
10:26:12 SQL> DEFINE model_name = '&2'
10:26:12 SQL> DEFINE bldtable	= '&3'
10:26:12 SQL> DEFINE scoretable = '&4'
10:26:12 SQL> DEFINE case_id	= '&5'
10:26:12 SQL> 
10:26:12 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:12 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:12 SQL> 
10:26:12 SQL> -- Builds an SVM model using pl/sql.
10:26:12 SQL> 
10:26:12 SQL> -----------------------------------------------------------------------
10:26:12 SQL> --			    BUILD THE MODEL
10:26:12 SQL> -----------------------------------------------------------------------
10:26:12 SQL> 
10:26:12 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:12 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:12 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:12 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:12 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:12 SQL> 
10:26:12 SQL> 
10:26:12 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:12 SQL> --
10:26:12 SQL> -- DROP	TABLE svmc_settings ;
10:26:12 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:12 SQL> -- DELETE svmc_settings;
10:26:12 SQL> 
10:26:12 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:12 SQL> -- this choice to SVM using a settings table.
10:26:12 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:12 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:12 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:12 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:12 SQL> -- models.
10:26:12 SQL> --
10:26:12 SQL> 
10:26:12 SQL> -- Do this once and then comment it out.
10:26:12 SQL> -- That makes script go faster.
10:26:12 SQL> -- BEGIN
10:26:12 SQL> -- -- Populate settings table
10:26:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:12 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:12 SQL> --
10:26:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:12 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:12 SQL> --
10:26:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:12 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:12 SQL> --   COMMIT;
10:26:12 SQL> -- END;
10:26:12 SQL> -- /
10:26:12 SQL> 
10:26:12 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:12 SQL> 
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:12 SQL> 
10:26:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:12 SQL> 
10:26:12 SQL> --------------------------------
10:26:12 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:12 SQL> --
10:26:12 SQL> 
10:26:12 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:12 SQL> -- 2. Outlier Treatment and
10:26:12 SQL> -- 3. Normalization are performed below.
10:26:12 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:12 SQL> --    normalized here.
10:26:12 SQL> 
10:26:12 SQL> BEGIN
10:26:12   2  	-- Perform missing value treatment for all predictors
10:26:12   3  	-- create miss tables
10:26:12   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:12   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:12   6  
10:26:12   7  	-- populate miss tables
10:26:12   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:12   9  	  miss_table_name => 'svmc_miss_num',
10:26:12  10  	  data_table_name => '&bldtable',
10:26:12  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:12  12  
10:26:12  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:12  14  	  miss_table_name => 'svmc_miss_cat',
10:26:12  15  	  data_table_name => '&bldtable',
10:26:12  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:12  17  
10:26:12  18  	-- xform input data to replace missing values
10:26:12  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:12  20  	  miss_table_name => 'svmc_miss_num',
10:26:12  21  	  data_table_name => '&bldtable',
10:26:12  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:12  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:12  24  	  miss_table_name => 'svmc_miss_cat',
10:26:12  25  	  data_table_name => '&bldtable',
10:26:12  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:12  27  
10:26:12  28  	-- Perform outlier treatment.
10:26:12  29  	-- create clip table
10:26:12  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:12  31  
10:26:12  32  	-- populate clip table
10:26:12  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:12  34  	  clip_table_name => 'svmc_clip',
10:26:12  35  	  data_table_name => '&bldtable',
10:26:12  36  	  tail_frac	  => 0.025,
10:26:12  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:12  38  
10:26:12  39  	-- xform input data to winsorized data
10:26:12  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:12  41  	  clip_table_name => 'svmc_clip',
10:26:12  42  	  data_table_name => '&bldtable',
10:26:12  43  	  xform_view_name => 'svmc_winsor');
10:26:12  44  
10:26:12  45  	-- create normalization table
10:26:12  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:12  47  
10:26:12  48  	-- populate normalization table based on winsorized data
10:26:12  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:12  50  	  norm_table_name => 'svmc_norm',
10:26:12  51  	  data_table_name => 'svmc_winsor',
10:26:12  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:12  53  
10:26:12  54  	-- normalize the original data
10:26:12  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:12  56  	  norm_table_name => 'svmc_norm',
10:26:12  57  	  data_table_name => '&bldtable',
10:26:12  58  	  xform_view_name => 'svmc_build_prep');
10:26:12  59  END;
10:26:12  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:26:13 SQL> 
10:26:13 SQL> ---------------------
10:26:13 SQL> -- CREATE A NEW MODEL
10:26:13 SQL> --
10:26:13 SQL> -- Cleanup old model with the same name for repeat runs
10:26:13 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:13   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.90
10:26:14 SQL> 
10:26:14 SQL> -- Build a new SVM Model
10:26:14 SQL> BEGIN
10:26:14   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:14   3  	  model_name	      => '&model_name',
10:26:14   4  	  mining_function     => dbms_data_mining.classification,
10:26:14   5  	  data_table_name     => 'svmc_build_prep',
10:26:14   6  	  case_id_column_name => '&case_id',
10:26:14   7  	  target_column_name  => '&target',
10:26:14   8  	  settings_table_name => 'svmc_settings');
10:26:14   9  END;
10:26:14  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.27
10:26:16 SQL> 
10:26:16 SQL> -----------------------------------------------------------------------
10:26:16 SQL> --			       APPLY/score THE MODEL
10:26:16 SQL> -----------------------------------------------------------------------
10:26:16 SQL> 
10:26:16 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:16 SQL> -----------------------
10:26:16 SQL> -- PREPARE SCORING DATA
10:26:16 SQL> --
10:26:16 SQL> -- If the data for model creation has been prepared, then the data
10:26:16 SQL> -- to be scored using the model must be prepared in the same manner
10:26:16 SQL> -- in order to obtain meaningful results.
10:26:16 SQL> --
10:26:16 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:16 SQL> -- 2. Normalization
10:26:16 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:16 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:16 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:16 SQL> --
10:26:16 SQL> BEGIN
10:26:16   2  	-- Xform Test data to replace missing values
10:26:16   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:16   4  	  miss_table_name => 'svmc_miss_num',
10:26:16   5  	  data_table_name => '&scoretable',
10:26:16   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:16   7  
10:26:16   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:16   9  	  miss_table_name => 'svmc_miss_cat',
10:26:16  10  	  data_table_name => '&scoretable',
10:26:16  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:16  12  
10:26:16  13  	-- Normalize the data to be scored
10:26:16  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:16  15  	  norm_table_name => 'svmc_norm',
10:26:16  16  	  data_table_name => '&scoretable',
10:26:16  17  	  xform_view_name => 'svmc_apply_prep');
10:26:16  18  END;
10:26:16  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:16 SQL> 
10:26:16 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:16 SQL> -- DELETE it if I did:
10:26:16 SQL> DELETE ystkscores
10:26:16   2  WHERE score > 0
10:26:16   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:16   4  -- I need to supply the target attribute name:
10:26:16   5  AND targ = '&1'
10:26:16   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:26:16 SQL> 
10:26:16 SQL> -- We do a drumroll here:
10:26:16 SQL> 
10:26:16 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:16   2  SELECT
10:26:16   3  tkrdate
10:26:16   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:16   5  ,sysdate
10:26:16   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:16   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:16   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:16   9  ,SUBSTR(tkrdate,-10)ydate
10:26:16  10  ,'&1'
10:26:16  11  FROM svmc_apply_prep
10:26:16  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:26:16 SQL> @score1_5min_gattn.sql	2010-03-03 TLT
10:26:16 SQL> --
10:26:16 SQL> -- score1_5min_gattn.sql
10:26:16 SQL> --
10:26:16 SQL> 
10:26:16 SQL> -- Demo:
10:26:16 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:16 SQL> 
10:26:16 SQL> CREATE OR REPLACE VIEW sme AS
10:26:16   2  SELECT
10:26:16   3  tkrdate
10:26:16   4  ,NULL gattn
10:26:16   5  ,g00
10:26:16   6  ,g01
10:26:16   7  ,g02
10:26:16   8  ,g03
10:26:16   9  ,g04
10:26:16  10  ,g05
10:26:16  11  ,g06
10:26:16  12  ,g07
10:26:16  13  ,g08
10:26:16  14  ,g09
10:26:16  15  ,g10
10:26:16  16  ,g11
10:26:16  17  ,g12
10:26:16  18  ,g13
10:26:16  19  ,g14
10:26:16  20  ,g15
10:26:16  21  ,g16
10:26:16  22  ,g17
10:26:16  23  ,g18
10:26:16  24  ,g19
10:26:16  25  ,g20
10:26:16  26  ,g21
10:26:16  27  ,g22
10:26:16  28  ,g23
10:26:16  29  ,g24
10:26:16  30  ,g25
10:26:16  31  ,g26
10:26:16  32  ,g27
10:26:16  33  ,g28
10:26:16  34  ,g29
10:26:16  35  FROM stk_ms
10:26:16  36  WHERE ydate = '&1'
10:26:16  37  AND tkr = '&2'
10:26:16  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-03'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:16 SQL> 
10:26:16 SQL> -- rpt
10:26:16 SQL> -- We should see just 1 row:
10:26:16 SQL> 
10:26:16 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:16   2  
10:26:16 SQL> -- Build the model:
10:26:16 SQL> CREATE OR REPLACE VIEW bme AS
10:26:16   2  SELECT
10:26:16   3  tkrdate
10:26:16   4  ,gattn
10:26:16   5  ,g00
10:26:16   6  ,g01
10:26:16   7  ,g02
10:26:16   8  ,g03
10:26:16   9  ,g04
10:26:16  10  ,g05
10:26:16  11  ,g06
10:26:16  12  ,g07
10:26:16  13  ,g08
10:26:16  14  ,g09
10:26:16  15  ,g10
10:26:16  16  ,g11
10:26:16  17  ,g12
10:26:16  18  ,g13
10:26:16  19  ,g14
10:26:16  20  ,g15
10:26:16  21  ,g16
10:26:16  22  ,g17
10:26:16  23  ,g18
10:26:16  24  ,g19
10:26:16  25  ,g20
10:26:16  26  ,g21
10:26:16  27  ,g22
10:26:16  28  ,g23
10:26:16  29  ,g24
10:26:16  30  ,g25
10:26:16  31  ,g26
10:26:16  32  ,g27
10:26:16  33  ,g28
10:26:16  34  ,g29
10:26:16  35  FROM stk_ms
10:26:16  36  WHERE gattn IN('nup','up')
10:26:16  37  -- Use only rows which are older than 1 day:
10:26:16  38  AND 1+ydate < '&1'
10:26:16  39  AND tkr = '&2'
10:26:16  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-03'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:16 SQL> 
10:26:16 SQL> -- rpt
10:26:16 SQL> 
10:26:16 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:16   2  
10:26:16 SQL> SELECT MAX(tkrdate) FROM bme
10:26:16   2  
10:26:16 SQL> -- Now build model from bme and score sme
10:26:16 SQL> @score1.sql gattn
10:26:16 SQL> -- score1.sql
10:26:16 SQL> 
10:26:16 SQL> -- I use this script to send 5 params to score.sql
10:26:16 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:16 SQL> -- Then at the very end of this script I use the model
10:26:16 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:16 SQL> 
10:26:16 SQL> -- I call this script from 2 other scripts:
10:26:16 SQL> -- score1_5min.sql
10:26:16 SQL> -- score1_5min_gattn.sql
10:26:16 SQL> 
10:26:16 SQL> -- The 1st param is the name of the target attribute.
10:26:16 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:16 SQL> 
10:26:16 SQL> -- Demo:
10:26:16 SQL> -- @score1.sql 'gatt'
10:26:16 SQL> -- @score1.sql 'gattn'
10:26:16 SQL> 
10:26:16 SQL> -- Now, I fill up svmc_apply_prep.
10:26:16 SQL> -- I use same model_name used in score.sql
10:26:16 SQL> DEFINE model_name = 'svmspy101'
10:26:16 SQL> DEFINE bldtable	= 'bme'
10:26:16 SQL> DEFINE scoretable = 'sme'
10:26:16 SQL> DEFINE case_id	= 'tkrdate'
10:26:16 SQL> -- Demo:
10:26:16 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:16 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:16 SQL> --
10:26:16 SQL> -- score.sql
10:26:16 SQL> --
10:26:16 SQL> 
10:26:16 SQL> -- usage: score.sql
10:26:16 SQL> 
10:26:16 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:16 SQL> 
10:26:16 SQL> -- DEFINE target	   = 'gatt'
10:26:16 SQL> -- DEFINE model_name = 'svmspy100'
10:26:16 SQL> -- DEFINE bldtable   = 'bme'
10:26:16 SQL> -- DEFINE scoretable = 'sme'
10:26:16 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:16 SQL> 
10:26:16 SQL> DEFINE target	= '&1'
10:26:16 SQL> DEFINE model_name = '&2'
10:26:16 SQL> DEFINE bldtable	= '&3'
10:26:16 SQL> DEFINE scoretable = '&4'
10:26:16 SQL> DEFINE case_id	= '&5'
10:26:16 SQL> 
10:26:16 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:16 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:16 SQL> 
10:26:16 SQL> -- Builds an SVM model using pl/sql.
10:26:16 SQL> 
10:26:16 SQL> -----------------------------------------------------------------------
10:26:16 SQL> --			    BUILD THE MODEL
10:26:16 SQL> -----------------------------------------------------------------------
10:26:16 SQL> 
10:26:16 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:16 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:16 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:26:16 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:16 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:16 SQL> 
10:26:16 SQL> 
10:26:16 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:16 SQL> --
10:26:16 SQL> -- DROP	TABLE svmc_settings ;
10:26:16 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:16 SQL> -- DELETE svmc_settings;
10:26:16 SQL> 
10:26:16 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:16 SQL> -- this choice to SVM using a settings table.
10:26:16 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:16 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:16 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:16 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:16 SQL> -- models.
10:26:16 SQL> --
10:26:16 SQL> 
10:26:16 SQL> -- Do this once and then comment it out.
10:26:16 SQL> -- That makes script go faster.
10:26:16 SQL> -- BEGIN
10:26:16 SQL> -- -- Populate settings table
10:26:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:16 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:16 SQL> --
10:26:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:16 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:16 SQL> --
10:26:16 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:16 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:16 SQL> --   COMMIT;
10:26:16 SQL> -- END;
10:26:16 SQL> -- /
10:26:16 SQL> 
10:26:16 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:16 SQL> 
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:16 SQL> 
10:26:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:16 SQL> 
10:26:16 SQL> --------------------------------
10:26:16 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:16 SQL> --
10:26:16 SQL> 
10:26:16 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:16 SQL> -- 2. Outlier Treatment and
10:26:16 SQL> -- 3. Normalization are performed below.
10:26:16 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:16 SQL> --    normalized here.
10:26:16 SQL> 
10:26:16 SQL> BEGIN
10:26:16   2  	-- Perform missing value treatment for all predictors
10:26:16   3  	-- create miss tables
10:26:16   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:16   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:16   6  
10:26:16   7  	-- populate miss tables
10:26:16   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:16   9  	  miss_table_name => 'svmc_miss_num',
10:26:16  10  	  data_table_name => '&bldtable',
10:26:16  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:16  12  
10:26:16  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:16  14  	  miss_table_name => 'svmc_miss_cat',
10:26:16  15  	  data_table_name => '&bldtable',
10:26:16  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:16  17  
10:26:16  18  	-- xform input data to replace missing values
10:26:16  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:16  20  	  miss_table_name => 'svmc_miss_num',
10:26:16  21  	  data_table_name => '&bldtable',
10:26:16  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:16  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:16  24  	  miss_table_name => 'svmc_miss_cat',
10:26:16  25  	  data_table_name => '&bldtable',
10:26:16  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:16  27  
10:26:16  28  	-- Perform outlier treatment.
10:26:16  29  	-- create clip table
10:26:16  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:16  31  
10:26:16  32  	-- populate clip table
10:26:16  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:16  34  	  clip_table_name => 'svmc_clip',
10:26:16  35  	  data_table_name => '&bldtable',
10:26:16  36  	  tail_frac	  => 0.025,
10:26:16  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:16  38  
10:26:16  39  	-- xform input data to winsorized data
10:26:16  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:16  41  	  clip_table_name => 'svmc_clip',
10:26:16  42  	  data_table_name => '&bldtable',
10:26:16  43  	  xform_view_name => 'svmc_winsor');
10:26:16  44  
10:26:16  45  	-- create normalization table
10:26:16  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:16  47  
10:26:16  48  	-- populate normalization table based on winsorized data
10:26:16  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:16  50  	  norm_table_name => 'svmc_norm',
10:26:16  51  	  data_table_name => 'svmc_winsor',
10:26:16  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:16  53  
10:26:16  54  	-- normalize the original data
10:26:16  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:16  56  	  norm_table_name => 'svmc_norm',
10:26:16  57  	  data_table_name => '&bldtable',
10:26:16  58  	  xform_view_name => 'svmc_build_prep');
10:26:16  59  END;
10:26:16  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:26:17 SQL> 
10:26:17 SQL> ---------------------
10:26:17 SQL> -- CREATE A NEW MODEL
10:26:17 SQL> --
10:26:17 SQL> -- Cleanup old model with the same name for repeat runs
10:26:17 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:17   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.06
10:26:18 SQL> 
10:26:18 SQL> -- Build a new SVM Model
10:26:18 SQL> BEGIN
10:26:18   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:18   3  	  model_name	      => '&model_name',
10:26:18   4  	  mining_function     => dbms_data_mining.classification,
10:26:18   5  	  data_table_name     => 'svmc_build_prep',
10:26:18   6  	  case_id_column_name => '&case_id',
10:26:18   7  	  target_column_name  => '&target',
10:26:18   8  	  settings_table_name => 'svmc_settings');
10:26:18   9  END;
10:26:18  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.89
10:26:20 SQL> 
10:26:20 SQL> -----------------------------------------------------------------------
10:26:20 SQL> --			       APPLY/score THE MODEL
10:26:20 SQL> -----------------------------------------------------------------------
10:26:20 SQL> 
10:26:20 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.09
10:26:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:20 SQL> -----------------------
10:26:20 SQL> -- PREPARE SCORING DATA
10:26:20 SQL> --
10:26:20 SQL> -- If the data for model creation has been prepared, then the data
10:26:20 SQL> -- to be scored using the model must be prepared in the same manner
10:26:20 SQL> -- in order to obtain meaningful results.
10:26:20 SQL> --
10:26:20 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:20 SQL> -- 2. Normalization
10:26:20 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:20 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:20 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:20 SQL> --
10:26:20 SQL> BEGIN
10:26:20   2  	-- Xform Test data to replace missing values
10:26:20   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:20   4  	  miss_table_name => 'svmc_miss_num',
10:26:20   5  	  data_table_name => '&scoretable',
10:26:20   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:20   7  
10:26:20   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:20   9  	  miss_table_name => 'svmc_miss_cat',
10:26:20  10  	  data_table_name => '&scoretable',
10:26:20  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:20  12  
10:26:20  13  	-- Normalize the data to be scored
10:26:20  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:20  15  	  norm_table_name => 'svmc_norm',
10:26:20  16  	  data_table_name => '&scoretable',
10:26:20  17  	  xform_view_name => 'svmc_apply_prep');
10:26:20  18  END;
10:26:20  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.27
10:26:20 SQL> 
10:26:20 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:20 SQL> -- DELETE it if I did:
10:26:20 SQL> DELETE ystkscores
10:26:20   2  WHERE score > 0
10:26:20   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:20   4  -- I need to supply the target attribute name:
10:26:20   5  AND targ = '&1'
10:26:20   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:20 SQL> 
10:26:20 SQL> -- We do a drumroll here:
10:26:20 SQL> 
10:26:20 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:20   2  SELECT
10:26:20   3  tkrdate
10:26:20   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:20   5  ,sysdate
10:26:20   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:20   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:20   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:20   9  ,SUBSTR(tkrdate,-10)ydate
10:26:20  10  ,'&1'
10:26:20  11  FROM svmc_apply_prep
10:26:20  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:26:20 SQL> @score1_5min.sql	      2010-01-06 TLT
10:26:20 SQL> --
10:26:20 SQL> -- score1_5min.sql
10:26:20 SQL> --
10:26:20 SQL> 
10:26:20 SQL> -- Demo:
10:26:20 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:26:20 SQL> 
10:26:20 SQL> CREATE OR REPLACE VIEW sme AS
10:26:20   2  SELECT
10:26:20   3  tkrdate
10:26:20   4  ,NULL gatt
10:26:20   5  ,g00
10:26:20   6  ,g01
10:26:20   7  ,g02
10:26:20   8  ,g03
10:26:20   9  ,g04
10:26:20  10  ,g05
10:26:20  11  ,g06
10:26:20  12  ,g07
10:26:20  13  ,g08
10:26:20  14  ,g09
10:26:20  15  ,g10
10:26:20  16  ,g11
10:26:20  17  ,g12
10:26:20  18  ,g13
10:26:20  19  ,g14
10:26:20  20  ,g15
10:26:20  21  ,g16
10:26:20  22  ,g17
10:26:20  23  ,g18
10:26:20  24  ,g19
10:26:20  25  ,g20
10:26:20  26  ,g21
10:26:20  27  ,g22
10:26:20  28  ,g23
10:26:20  29  ,g24
10:26:20  30  ,g25
10:26:20  31  ,g26
10:26:20  32  ,g27
10:26:20  33  ,g28
10:26:20  34  ,g29
10:26:20  35  FROM stk_ms
10:26:20  36  WHERE ydate = '&1'
10:26:20  37  AND tkr = '&2'
10:26:20  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-06'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.08
10:26:21 SQL> 
10:26:21 SQL> -- rpt
10:26:21 SQL> -- We should see just 1 row:
10:26:21 SQL> 
10:26:21 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:21   2  
10:26:21 SQL> -- Build the model:
10:26:21 SQL> CREATE OR REPLACE VIEW bme AS
10:26:21   2  SELECT
10:26:21   3  tkrdate
10:26:21   4  ,gatt
10:26:21   5  ,g00
10:26:21   6  ,g01
10:26:21   7  ,g02
10:26:21   8  ,g03
10:26:21   9  ,g04
10:26:21  10  ,g05
10:26:21  11  ,g06
10:26:21  12  ,g07
10:26:21  13  ,g08
10:26:21  14  ,g09
10:26:21  15  ,g10
10:26:21  16  ,g11
10:26:21  17  ,g12
10:26:21  18  ,g13
10:26:21  19  ,g14
10:26:21  20  ,g15
10:26:21  21  ,g16
10:26:21  22  ,g17
10:26:21  23  ,g18
10:26:21  24  ,g19
10:26:21  25  ,g20
10:26:21  26  ,g21
10:26:21  27  ,g22
10:26:21  28  ,g23
10:26:21  29  ,g24
10:26:21  30  ,g25
10:26:21  31  ,g26
10:26:21  32  ,g27
10:26:21  33  ,g28
10:26:21  34  ,g29
10:26:21  35  FROM stk_ms
10:26:21  36  WHERE gatt IN('nup','up')
10:26:21  37  -- Use only rows which are older than 1 day:
10:26:21  38  AND 1+ydate < '&1'
10:26:21  39  AND tkr = '&2'
10:26:21  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-06'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:21 SQL> 
10:26:21 SQL> -- rpt
10:26:21 SQL> 
10:26:21 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:26:21   2  
10:26:21 SQL> SELECT MAX(tkrdate) FROM bme
10:26:21   2  
10:26:21 SQL> -- Now build model from bme and score sme
10:26:21 SQL> @score1.sql gatt
10:26:21 SQL> -- score1.sql
10:26:21 SQL> 
10:26:21 SQL> -- I use this script to send 5 params to score.sql
10:26:21 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:21 SQL> -- Then at the very end of this script I use the model
10:26:21 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:21 SQL> 
10:26:21 SQL> -- I call this script from 2 other scripts:
10:26:21 SQL> -- score1_5min.sql
10:26:21 SQL> -- score1_5min_gattn.sql
10:26:21 SQL> 
10:26:21 SQL> -- The 1st param is the name of the target attribute.
10:26:21 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:21 SQL> 
10:26:21 SQL> -- Demo:
10:26:21 SQL> -- @score1.sql 'gatt'
10:26:21 SQL> -- @score1.sql 'gattn'
10:26:21 SQL> 
10:26:21 SQL> -- Now, I fill up svmc_apply_prep.
10:26:21 SQL> -- I use same model_name used in score.sql
10:26:21 SQL> DEFINE model_name = 'svmspy101'
10:26:21 SQL> DEFINE bldtable	= 'bme'
10:26:21 SQL> DEFINE scoretable = 'sme'
10:26:21 SQL> DEFINE case_id	= 'tkrdate'
10:26:21 SQL> -- Demo:
10:26:21 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:21 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:21 SQL> --
10:26:21 SQL> -- score.sql
10:26:21 SQL> --
10:26:21 SQL> 
10:26:21 SQL> -- usage: score.sql
10:26:21 SQL> 
10:26:21 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:21 SQL> 
10:26:21 SQL> -- DEFINE target	   = 'gatt'
10:26:21 SQL> -- DEFINE model_name = 'svmspy100'
10:26:21 SQL> -- DEFINE bldtable   = 'bme'
10:26:21 SQL> -- DEFINE scoretable = 'sme'
10:26:21 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:21 SQL> 
10:26:21 SQL> DEFINE target	= '&1'
10:26:21 SQL> DEFINE model_name = '&2'
10:26:21 SQL> DEFINE bldtable	= '&3'
10:26:21 SQL> DEFINE scoretable = '&4'
10:26:21 SQL> DEFINE case_id	= '&5'
10:26:21 SQL> 
10:26:21 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:21 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:21 SQL> 
10:26:21 SQL> -- Builds an SVM model using pl/sql.
10:26:21 SQL> 
10:26:21 SQL> -----------------------------------------------------------------------
10:26:21 SQL> --			    BUILD THE MODEL
10:26:21 SQL> -----------------------------------------------------------------------
10:26:21 SQL> 
10:26:21 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:21 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:21 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:21 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:21 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:21 SQL> 
10:26:21 SQL> 
10:26:21 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:21 SQL> --
10:26:21 SQL> -- DROP	TABLE svmc_settings ;
10:26:21 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:21 SQL> -- DELETE svmc_settings;
10:26:21 SQL> 
10:26:21 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:21 SQL> -- this choice to SVM using a settings table.
10:26:21 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:21 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:21 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:21 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:21 SQL> -- models.
10:26:21 SQL> --
10:26:21 SQL> 
10:26:21 SQL> -- Do this once and then comment it out.
10:26:21 SQL> -- That makes script go faster.
10:26:21 SQL> -- BEGIN
10:26:21 SQL> -- -- Populate settings table
10:26:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:21 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:21 SQL> --
10:26:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:21 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:21 SQL> --
10:26:21 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:21 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:21 SQL> --   COMMIT;
10:26:21 SQL> -- END;
10:26:21 SQL> -- /
10:26:21 SQL> 
10:26:21 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:21 SQL> 
10:26:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:21 SQL> 
10:26:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:21 SQL> 
10:26:21 SQL> --------------------------------
10:26:21 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:21 SQL> --
10:26:21 SQL> 
10:26:21 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:21 SQL> -- 2. Outlier Treatment and
10:26:21 SQL> -- 3. Normalization are performed below.
10:26:21 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:21 SQL> --    normalized here.
10:26:21 SQL> 
10:26:21 SQL> BEGIN
10:26:21   2  	-- Perform missing value treatment for all predictors
10:26:21   3  	-- create miss tables
10:26:21   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:21   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:21   6  
10:26:21   7  	-- populate miss tables
10:26:21   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:21   9  	  miss_table_name => 'svmc_miss_num',
10:26:21  10  	  data_table_name => '&bldtable',
10:26:21  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:21  12  
10:26:21  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:21  14  	  miss_table_name => 'svmc_miss_cat',
10:26:21  15  	  data_table_name => '&bldtable',
10:26:21  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:21  17  
10:26:21  18  	-- xform input data to replace missing values
10:26:21  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:21  20  	  miss_table_name => 'svmc_miss_num',
10:26:21  21  	  data_table_name => '&bldtable',
10:26:21  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:21  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:21  24  	  miss_table_name => 'svmc_miss_cat',
10:26:21  25  	  data_table_name => '&bldtable',
10:26:21  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:21  27  
10:26:21  28  	-- Perform outlier treatment.
10:26:21  29  	-- create clip table
10:26:21  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:21  31  
10:26:21  32  	-- populate clip table
10:26:21  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:21  34  	  clip_table_name => 'svmc_clip',
10:26:21  35  	  data_table_name => '&bldtable',
10:26:21  36  	  tail_frac	  => 0.025,
10:26:21  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:21  38  
10:26:21  39  	-- xform input data to winsorized data
10:26:21  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:21  41  	  clip_table_name => 'svmc_clip',
10:26:21  42  	  data_table_name => '&bldtable',
10:26:21  43  	  xform_view_name => 'svmc_winsor');
10:26:21  44  
10:26:21  45  	-- create normalization table
10:26:21  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:21  47  
10:26:21  48  	-- populate normalization table based on winsorized data
10:26:21  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:21  50  	  norm_table_name => 'svmc_norm',
10:26:21  51  	  data_table_name => 'svmc_winsor',
10:26:21  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:21  53  
10:26:21  54  	-- normalize the original data
10:26:21  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:21  56  	  norm_table_name => 'svmc_norm',
10:26:21  57  	  data_table_name => '&bldtable',
10:26:21  58  	  xform_view_name => 'svmc_build_prep');
10:26:21  59  END;
10:26:21  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:26:21 SQL> 
10:26:21 SQL> ---------------------
10:26:21 SQL> -- CREATE A NEW MODEL
10:26:21 SQL> --
10:26:21 SQL> -- Cleanup old model with the same name for repeat runs
10:26:21 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:21   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.01
10:26:22 SQL> 
10:26:22 SQL> -- Build a new SVM Model
10:26:22 SQL> BEGIN
10:26:22   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:22   3  	  model_name	      => '&model_name',
10:26:22   4  	  mining_function     => dbms_data_mining.classification,
10:26:22   5  	  data_table_name     => 'svmc_build_prep',
10:26:22   6  	  case_id_column_name => '&case_id',
10:26:22   7  	  target_column_name  => '&target',
10:26:22   8  	  settings_table_name => 'svmc_settings');
10:26:22   9  END;
10:26:22  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.83
10:26:25 SQL> 
10:26:25 SQL> -----------------------------------------------------------------------
10:26:25 SQL> --			       APPLY/score THE MODEL
10:26:25 SQL> -----------------------------------------------------------------------
10:26:25 SQL> 
10:26:25 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:25 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:25   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:25 SQL> -----------------------
10:26:25 SQL> -- PREPARE SCORING DATA
10:26:25 SQL> --
10:26:25 SQL> -- If the data for model creation has been prepared, then the data
10:26:25 SQL> -- to be scored using the model must be prepared in the same manner
10:26:25 SQL> -- in order to obtain meaningful results.
10:26:25 SQL> --
10:26:25 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:25 SQL> -- 2. Normalization
10:26:25 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:25 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:25 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:25 SQL> --
10:26:25 SQL> BEGIN
10:26:25   2  	-- Xform Test data to replace missing values
10:26:25   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:25   4  	  miss_table_name => 'svmc_miss_num',
10:26:25   5  	  data_table_name => '&scoretable',
10:26:25   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:25   7  
10:26:25   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:25   9  	  miss_table_name => 'svmc_miss_cat',
10:26:25  10  	  data_table_name => '&scoretable',
10:26:25  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:25  12  
10:26:25  13  	-- Normalize the data to be scored
10:26:25  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:25  15  	  norm_table_name => 'svmc_norm',
10:26:25  16  	  data_table_name => '&scoretable',
10:26:25  17  	  xform_view_name => 'svmc_apply_prep');
10:26:25  18  END;
10:26:25  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:25 SQL> 
10:26:25 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:25 SQL> -- DELETE it if I did:
10:26:25 SQL> DELETE ystkscores
10:26:25   2  WHERE score > 0
10:26:25   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:25   4  -- I need to supply the target attribute name:
10:26:25   5  AND targ = '&1'
10:26:25   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:26 SQL> 
10:26:26 SQL> -- We do a drumroll here:
10:26:26 SQL> 
10:26:26 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:26   2  SELECT
10:26:26   3  tkrdate
10:26:26   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:26   5  ,sysdate
10:26:26   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:26   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:26   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:26   9  ,SUBSTR(tkrdate,-10)ydate
10:26:26  10  ,'&1'
10:26:26  11  FROM svmc_apply_prep
10:26:26  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:26:26 SQL> @score1_5min_gattn.sql	2009-12-29 TLT
10:26:26 SQL> --
10:26:26 SQL> -- score1_5min_gattn.sql
10:26:26 SQL> --
10:26:26 SQL> 
10:26:26 SQL> -- Demo:
10:26:26 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:26 SQL> 
10:26:26 SQL> CREATE OR REPLACE VIEW sme AS
10:26:26   2  SELECT
10:26:26   3  tkrdate
10:26:26   4  ,NULL gattn
10:26:26   5  ,g00
10:26:26   6  ,g01
10:26:26   7  ,g02
10:26:26   8  ,g03
10:26:26   9  ,g04
10:26:26  10  ,g05
10:26:26  11  ,g06
10:26:26  12  ,g07
10:26:26  13  ,g08
10:26:26  14  ,g09
10:26:26  15  ,g10
10:26:26  16  ,g11
10:26:26  17  ,g12
10:26:26  18  ,g13
10:26:26  19  ,g14
10:26:26  20  ,g15
10:26:26  21  ,g16
10:26:26  22  ,g17
10:26:26  23  ,g18
10:26:26  24  ,g19
10:26:26  25  ,g20
10:26:26  26  ,g21
10:26:26  27  ,g22
10:26:26  28  ,g23
10:26:26  29  ,g24
10:26:26  30  ,g25
10:26:26  31  ,g26
10:26:26  32  ,g27
10:26:26  33  ,g28
10:26:26  34  ,g29
10:26:26  35  FROM stk_ms
10:26:26  36  WHERE ydate = '&1'
10:26:26  37  AND tkr = '&2'
10:26:26  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-29'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:26 SQL> 
10:26:26 SQL> -- rpt
10:26:26 SQL> -- We should see just 1 row:
10:26:26 SQL> 
10:26:26 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:26   2  
10:26:26 SQL> -- Build the model:
10:26:26 SQL> CREATE OR REPLACE VIEW bme AS
10:26:26   2  SELECT
10:26:26   3  tkrdate
10:26:26   4  ,gattn
10:26:26   5  ,g00
10:26:26   6  ,g01
10:26:26   7  ,g02
10:26:26   8  ,g03
10:26:26   9  ,g04
10:26:26  10  ,g05
10:26:26  11  ,g06
10:26:26  12  ,g07
10:26:26  13  ,g08
10:26:26  14  ,g09
10:26:26  15  ,g10
10:26:26  16  ,g11
10:26:26  17  ,g12
10:26:26  18  ,g13
10:26:26  19  ,g14
10:26:26  20  ,g15
10:26:26  21  ,g16
10:26:26  22  ,g17
10:26:26  23  ,g18
10:26:26  24  ,g19
10:26:26  25  ,g20
10:26:26  26  ,g21
10:26:26  27  ,g22
10:26:26  28  ,g23
10:26:26  29  ,g24
10:26:26  30  ,g25
10:26:26  31  ,g26
10:26:26  32  ,g27
10:26:26  33  ,g28
10:26:26  34  ,g29
10:26:26  35  FROM stk_ms
10:26:26  36  WHERE gattn IN('nup','up')
10:26:26  37  -- Use only rows which are older than 1 day:
10:26:26  38  AND 1+ydate < '&1'
10:26:26  39  AND tkr = '&2'
10:26:26  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-29'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:26 SQL> 
10:26:26 SQL> -- rpt
10:26:26 SQL> 
10:26:26 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:26   2  
10:26:26 SQL> SELECT MAX(tkrdate) FROM bme
10:26:26   2  
10:26:26 SQL> -- Now build model from bme and score sme
10:26:26 SQL> @score1.sql gattn
10:26:26 SQL> -- score1.sql
10:26:26 SQL> 
10:26:26 SQL> -- I use this script to send 5 params to score.sql
10:26:26 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:26 SQL> -- Then at the very end of this script I use the model
10:26:26 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:26 SQL> 
10:26:26 SQL> -- I call this script from 2 other scripts:
10:26:26 SQL> -- score1_5min.sql
10:26:26 SQL> -- score1_5min_gattn.sql
10:26:26 SQL> 
10:26:26 SQL> -- The 1st param is the name of the target attribute.
10:26:26 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:26 SQL> 
10:26:26 SQL> -- Demo:
10:26:26 SQL> -- @score1.sql 'gatt'
10:26:26 SQL> -- @score1.sql 'gattn'
10:26:26 SQL> 
10:26:26 SQL> -- Now, I fill up svmc_apply_prep.
10:26:26 SQL> -- I use same model_name used in score.sql
10:26:26 SQL> DEFINE model_name = 'svmspy101'
10:26:26 SQL> DEFINE bldtable	= 'bme'
10:26:26 SQL> DEFINE scoretable = 'sme'
10:26:26 SQL> DEFINE case_id	= 'tkrdate'
10:26:26 SQL> -- Demo:
10:26:26 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:26 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:26 SQL> --
10:26:26 SQL> -- score.sql
10:26:26 SQL> --
10:26:26 SQL> 
10:26:26 SQL> -- usage: score.sql
10:26:26 SQL> 
10:26:26 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:26 SQL> 
10:26:26 SQL> -- DEFINE target	   = 'gatt'
10:26:26 SQL> -- DEFINE model_name = 'svmspy100'
10:26:26 SQL> -- DEFINE bldtable   = 'bme'
10:26:26 SQL> -- DEFINE scoretable = 'sme'
10:26:26 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:26 SQL> 
10:26:26 SQL> DEFINE target	= '&1'
10:26:26 SQL> DEFINE model_name = '&2'
10:26:26 SQL> DEFINE bldtable	= '&3'
10:26:26 SQL> DEFINE scoretable = '&4'
10:26:26 SQL> DEFINE case_id	= '&5'
10:26:26 SQL> 
10:26:26 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:26 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:26 SQL> 
10:26:26 SQL> -- Builds an SVM model using pl/sql.
10:26:26 SQL> 
10:26:26 SQL> -----------------------------------------------------------------------
10:26:26 SQL> --			    BUILD THE MODEL
10:26:26 SQL> -----------------------------------------------------------------------
10:26:26 SQL> 
10:26:26 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:26 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:26 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:26 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:26 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:26 SQL> 
10:26:26 SQL> 
10:26:26 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:26 SQL> --
10:26:26 SQL> -- DROP	TABLE svmc_settings ;
10:26:26 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:26 SQL> -- DELETE svmc_settings;
10:26:26 SQL> 
10:26:26 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:26 SQL> -- this choice to SVM using a settings table.
10:26:26 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:26 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:26 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:26 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:26 SQL> -- models.
10:26:26 SQL> --
10:26:26 SQL> 
10:26:26 SQL> -- Do this once and then comment it out.
10:26:26 SQL> -- That makes script go faster.
10:26:26 SQL> -- BEGIN
10:26:26 SQL> -- -- Populate settings table
10:26:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:26 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:26 SQL> --
10:26:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:26 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:26 SQL> --
10:26:26 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:26 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:26 SQL> --   COMMIT;
10:26:26 SQL> -- END;
10:26:26 SQL> -- /
10:26:26 SQL> 
10:26:26 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:26 SQL> 
10:26:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:26:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:26 SQL> 
10:26:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:26 SQL> 
10:26:26 SQL> --------------------------------
10:26:26 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:26 SQL> --
10:26:26 SQL> 
10:26:26 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:26 SQL> -- 2. Outlier Treatment and
10:26:26 SQL> -- 3. Normalization are performed below.
10:26:26 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:26 SQL> --    normalized here.
10:26:26 SQL> 
10:26:26 SQL> BEGIN
10:26:26   2  	-- Perform missing value treatment for all predictors
10:26:26   3  	-- create miss tables
10:26:26   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:26   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:26   6  
10:26:26   7  	-- populate miss tables
10:26:26   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:26   9  	  miss_table_name => 'svmc_miss_num',
10:26:26  10  	  data_table_name => '&bldtable',
10:26:26  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:26  12  
10:26:26  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:26  14  	  miss_table_name => 'svmc_miss_cat',
10:26:26  15  	  data_table_name => '&bldtable',
10:26:26  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:26  17  
10:26:26  18  	-- xform input data to replace missing values
10:26:26  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:26  20  	  miss_table_name => 'svmc_miss_num',
10:26:26  21  	  data_table_name => '&bldtable',
10:26:26  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:26  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:26  24  	  miss_table_name => 'svmc_miss_cat',
10:26:26  25  	  data_table_name => '&bldtable',
10:26:26  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:26  27  
10:26:26  28  	-- Perform outlier treatment.
10:26:26  29  	-- create clip table
10:26:26  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:26  31  
10:26:26  32  	-- populate clip table
10:26:26  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:26  34  	  clip_table_name => 'svmc_clip',
10:26:26  35  	  data_table_name => '&bldtable',
10:26:26  36  	  tail_frac	  => 0.025,
10:26:26  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:26  38  
10:26:26  39  	-- xform input data to winsorized data
10:26:26  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:26  41  	  clip_table_name => 'svmc_clip',
10:26:26  42  	  data_table_name => '&bldtable',
10:26:26  43  	  xform_view_name => 'svmc_winsor');
10:26:26  44  
10:26:26  45  	-- create normalization table
10:26:26  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:26  47  
10:26:26  48  	-- populate normalization table based on winsorized data
10:26:26  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:26  50  	  norm_table_name => 'svmc_norm',
10:26:26  51  	  data_table_name => 'svmc_winsor',
10:26:26  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:26  53  
10:26:26  54  	-- normalize the original data
10:26:26  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:26  56  	  norm_table_name => 'svmc_norm',
10:26:26  57  	  data_table_name => '&bldtable',
10:26:26  58  	  xform_view_name => 'svmc_build_prep');
10:26:26  59  END;
10:26:26  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:26:26 SQL> 
10:26:26 SQL> ---------------------
10:26:26 SQL> -- CREATE A NEW MODEL
10:26:26 SQL> --
10:26:26 SQL> -- Cleanup old model with the same name for repeat runs
10:26:26 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:26   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.90
10:26:27 SQL> 
10:26:27 SQL> -- Build a new SVM Model
10:26:27 SQL> BEGIN
10:26:27   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:27   3  	  model_name	      => '&model_name',
10:26:27   4  	  mining_function     => dbms_data_mining.classification,
10:26:27   5  	  data_table_name     => 'svmc_build_prep',
10:26:27   6  	  case_id_column_name => '&case_id',
10:26:27   7  	  target_column_name  => '&target',
10:26:27   8  	  settings_table_name => 'svmc_settings');
10:26:27   9  END;
10:26:27  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.85
10:26:29 SQL> 
10:26:29 SQL> -----------------------------------------------------------------------
10:26:29 SQL> --			       APPLY/score THE MODEL
10:26:29 SQL> -----------------------------------------------------------------------
10:26:29 SQL> 
10:26:29 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.28
10:26:29 SQL> -----------------------
10:26:29 SQL> -- PREPARE SCORING DATA
10:26:29 SQL> --
10:26:29 SQL> -- If the data for model creation has been prepared, then the data
10:26:29 SQL> -- to be scored using the model must be prepared in the same manner
10:26:29 SQL> -- in order to obtain meaningful results.
10:26:29 SQL> --
10:26:29 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:29 SQL> -- 2. Normalization
10:26:29 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:29 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:29 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:29 SQL> --
10:26:29 SQL> BEGIN
10:26:29   2  	-- Xform Test data to replace missing values
10:26:29   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:29   4  	  miss_table_name => 'svmc_miss_num',
10:26:29   5  	  data_table_name => '&scoretable',
10:26:29   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:29   7  
10:26:29   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:29   9  	  miss_table_name => 'svmc_miss_cat',
10:26:29  10  	  data_table_name => '&scoretable',
10:26:29  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:29  12  
10:26:29  13  	-- Normalize the data to be scored
10:26:29  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:29  15  	  norm_table_name => 'svmc_norm',
10:26:29  16  	  data_table_name => '&scoretable',
10:26:29  17  	  xform_view_name => 'svmc_apply_prep');
10:26:29  18  END;
10:26:29  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.30
10:26:30 SQL> 
10:26:30 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:30 SQL> -- DELETE it if I did:
10:26:30 SQL> DELETE ystkscores
10:26:30   2  WHERE score > 0
10:26:30   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:30   4  -- I need to supply the target attribute name:
10:26:30   5  AND targ = '&1'
10:26:30   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:30 SQL> 
10:26:30 SQL> -- We do a drumroll here:
10:26:30 SQL> 
10:26:30 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:30   2  SELECT
10:26:30   3  tkrdate
10:26:30   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:30   5  ,sysdate
10:26:30   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:30   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:30   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:30   9  ,SUBSTR(tkrdate,-10)ydate
10:26:30  10  ,'&1'
10:26:30  11  FROM svmc_apply_prep
10:26:30  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:26:30 SQL> @score1_5min_gattn.sql	2009-12-18 TLT
10:26:30 SQL> --
10:26:30 SQL> -- score1_5min_gattn.sql
10:26:30 SQL> --
10:26:30 SQL> 
10:26:30 SQL> -- Demo:
10:26:30 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:30 SQL> 
10:26:30 SQL> CREATE OR REPLACE VIEW sme AS
10:26:30   2  SELECT
10:26:30   3  tkrdate
10:26:30   4  ,NULL gattn
10:26:30   5  ,g00
10:26:30   6  ,g01
10:26:30   7  ,g02
10:26:30   8  ,g03
10:26:30   9  ,g04
10:26:30  10  ,g05
10:26:30  11  ,g06
10:26:30  12  ,g07
10:26:30  13  ,g08
10:26:30  14  ,g09
10:26:30  15  ,g10
10:26:30  16  ,g11
10:26:30  17  ,g12
10:26:30  18  ,g13
10:26:30  19  ,g14
10:26:30  20  ,g15
10:26:30  21  ,g16
10:26:30  22  ,g17
10:26:30  23  ,g18
10:26:30  24  ,g19
10:26:30  25  ,g20
10:26:30  26  ,g21
10:26:30  27  ,g22
10:26:30  28  ,g23
10:26:30  29  ,g24
10:26:30  30  ,g25
10:26:30  31  ,g26
10:26:30  32  ,g27
10:26:30  33  ,g28
10:26:30  34  ,g29
10:26:30  35  FROM stk_ms
10:26:30  36  WHERE ydate = '&1'
10:26:30  37  AND tkr = '&2'
10:26:30  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-18'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.29
10:26:30 SQL> 
10:26:30 SQL> -- rpt
10:26:30 SQL> -- We should see just 1 row:
10:26:30 SQL> 
10:26:30 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:30   2  
10:26:30 SQL> -- Build the model:
10:26:30 SQL> CREATE OR REPLACE VIEW bme AS
10:26:30   2  SELECT
10:26:30   3  tkrdate
10:26:30   4  ,gattn
10:26:30   5  ,g00
10:26:30   6  ,g01
10:26:30   7  ,g02
10:26:30   8  ,g03
10:26:30   9  ,g04
10:26:30  10  ,g05
10:26:30  11  ,g06
10:26:30  12  ,g07
10:26:30  13  ,g08
10:26:30  14  ,g09
10:26:30  15  ,g10
10:26:30  16  ,g11
10:26:30  17  ,g12
10:26:30  18  ,g13
10:26:30  19  ,g14
10:26:30  20  ,g15
10:26:30  21  ,g16
10:26:30  22  ,g17
10:26:30  23  ,g18
10:26:30  24  ,g19
10:26:30  25  ,g20
10:26:30  26  ,g21
10:26:30  27  ,g22
10:26:30  28  ,g23
10:26:30  29  ,g24
10:26:30  30  ,g25
10:26:30  31  ,g26
10:26:30  32  ,g27
10:26:30  33  ,g28
10:26:30  34  ,g29
10:26:30  35  FROM stk_ms
10:26:30  36  WHERE gattn IN('nup','up')
10:26:30  37  -- Use only rows which are older than 1 day:
10:26:30  38  AND 1+ydate < '&1'
10:26:30  39  AND tkr = '&2'
10:26:30  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-18'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.15
10:26:30 SQL> 
10:26:30 SQL> -- rpt
10:26:30 SQL> 
10:26:30 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:30   2  
10:26:30 SQL> SELECT MAX(tkrdate) FROM bme
10:26:30   2  
10:26:30 SQL> -- Now build model from bme and score sme
10:26:30 SQL> @score1.sql gattn
10:26:30 SQL> -- score1.sql
10:26:30 SQL> 
10:26:30 SQL> -- I use this script to send 5 params to score.sql
10:26:30 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:30 SQL> -- Then at the very end of this script I use the model
10:26:30 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:30 SQL> 
10:26:30 SQL> -- I call this script from 2 other scripts:
10:26:30 SQL> -- score1_5min.sql
10:26:30 SQL> -- score1_5min_gattn.sql
10:26:30 SQL> 
10:26:30 SQL> -- The 1st param is the name of the target attribute.
10:26:30 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:30 SQL> 
10:26:30 SQL> -- Demo:
10:26:30 SQL> -- @score1.sql 'gatt'
10:26:30 SQL> -- @score1.sql 'gattn'
10:26:30 SQL> 
10:26:30 SQL> -- Now, I fill up svmc_apply_prep.
10:26:30 SQL> -- I use same model_name used in score.sql
10:26:30 SQL> DEFINE model_name = 'svmspy101'
10:26:30 SQL> DEFINE bldtable	= 'bme'
10:26:30 SQL> DEFINE scoretable = 'sme'
10:26:30 SQL> DEFINE case_id	= 'tkrdate'
10:26:30 SQL> -- Demo:
10:26:30 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:30 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:30 SQL> --
10:26:30 SQL> -- score.sql
10:26:30 SQL> --
10:26:30 SQL> 
10:26:30 SQL> -- usage: score.sql
10:26:30 SQL> 
10:26:30 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:30 SQL> 
10:26:30 SQL> -- DEFINE target	   = 'gatt'
10:26:30 SQL> -- DEFINE model_name = 'svmspy100'
10:26:30 SQL> -- DEFINE bldtable   = 'bme'
10:26:30 SQL> -- DEFINE scoretable = 'sme'
10:26:30 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:30 SQL> 
10:26:30 SQL> DEFINE target	= '&1'
10:26:30 SQL> DEFINE model_name = '&2'
10:26:30 SQL> DEFINE bldtable	= '&3'
10:26:30 SQL> DEFINE scoretable = '&4'
10:26:30 SQL> DEFINE case_id	= '&5'
10:26:30 SQL> 
10:26:30 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:30 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:30 SQL> 
10:26:30 SQL> -- Builds an SVM model using pl/sql.
10:26:30 SQL> 
10:26:30 SQL> -----------------------------------------------------------------------
10:26:30 SQL> --			    BUILD THE MODEL
10:26:30 SQL> -----------------------------------------------------------------------
10:26:30 SQL> 
10:26:30 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:30 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:30 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:30 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:30 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:30 SQL> 
10:26:30 SQL> 
10:26:30 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:30 SQL> --
10:26:30 SQL> -- DROP	TABLE svmc_settings ;
10:26:30 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:30 SQL> -- DELETE svmc_settings;
10:26:30 SQL> 
10:26:30 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:30 SQL> -- this choice to SVM using a settings table.
10:26:30 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:30 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:30 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:30 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:30 SQL> -- models.
10:26:30 SQL> --
10:26:30 SQL> 
10:26:30 SQL> -- Do this once and then comment it out.
10:26:30 SQL> -- That makes script go faster.
10:26:30 SQL> -- BEGIN
10:26:30 SQL> -- -- Populate settings table
10:26:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:30 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:30 SQL> --
10:26:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:30 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:30 SQL> --
10:26:30 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:30 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:30 SQL> --   COMMIT;
10:26:30 SQL> -- END;
10:26:30 SQL> -- /
10:26:30 SQL> 
10:26:30 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:30 SQL> 
10:26:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:30 SQL> 
10:26:30 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:30   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:30 SQL> 
10:26:30 SQL> --------------------------------
10:26:30 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:30 SQL> --
10:26:30 SQL> 
10:26:30 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:30 SQL> -- 2. Outlier Treatment and
10:26:30 SQL> -- 3. Normalization are performed below.
10:26:30 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:30 SQL> --    normalized here.
10:26:30 SQL> 
10:26:30 SQL> BEGIN
10:26:30   2  	-- Perform missing value treatment for all predictors
10:26:30   3  	-- create miss tables
10:26:30   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:30   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:30   6  
10:26:30   7  	-- populate miss tables
10:26:30   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:30   9  	  miss_table_name => 'svmc_miss_num',
10:26:30  10  	  data_table_name => '&bldtable',
10:26:30  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:30  12  
10:26:30  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:30  14  	  miss_table_name => 'svmc_miss_cat',
10:26:30  15  	  data_table_name => '&bldtable',
10:26:30  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:30  17  
10:26:30  18  	-- xform input data to replace missing values
10:26:30  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:30  20  	  miss_table_name => 'svmc_miss_num',
10:26:30  21  	  data_table_name => '&bldtable',
10:26:30  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:30  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:30  24  	  miss_table_name => 'svmc_miss_cat',
10:26:30  25  	  data_table_name => '&bldtable',
10:26:30  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:30  27  
10:26:30  28  	-- Perform outlier treatment.
10:26:30  29  	-- create clip table
10:26:30  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:30  31  
10:26:30  32  	-- populate clip table
10:26:30  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:30  34  	  clip_table_name => 'svmc_clip',
10:26:30  35  	  data_table_name => '&bldtable',
10:26:30  36  	  tail_frac	  => 0.025,
10:26:30  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:30  38  
10:26:30  39  	-- xform input data to winsorized data
10:26:30  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:30  41  	  clip_table_name => 'svmc_clip',
10:26:30  42  	  data_table_name => '&bldtable',
10:26:30  43  	  xform_view_name => 'svmc_winsor');
10:26:30  44  
10:26:30  45  	-- create normalization table
10:26:30  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:30  47  
10:26:30  48  	-- populate normalization table based on winsorized data
10:26:30  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:30  50  	  norm_table_name => 'svmc_norm',
10:26:30  51  	  data_table_name => 'svmc_winsor',
10:26:30  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:30  53  
10:26:30  54  	-- normalize the original data
10:26:30  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:30  56  	  norm_table_name => 'svmc_norm',
10:26:30  57  	  data_table_name => '&bldtable',
10:26:30  58  	  xform_view_name => 'svmc_build_prep');
10:26:30  59  END;
10:26:30  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:26:31 SQL> 
10:26:31 SQL> ---------------------
10:26:31 SQL> -- CREATE A NEW MODEL
10:26:31 SQL> --
10:26:31 SQL> -- Cleanup old model with the same name for repeat runs
10:26:31 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:31   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.98
10:26:32 SQL> 
10:26:32 SQL> -- Build a new SVM Model
10:26:32 SQL> BEGIN
10:26:32   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:32   3  	  model_name	      => '&model_name',
10:26:32   4  	  mining_function     => dbms_data_mining.classification,
10:26:32   5  	  data_table_name     => 'svmc_build_prep',
10:26:32   6  	  case_id_column_name => '&case_id',
10:26:32   7  	  target_column_name  => '&target',
10:26:32   8  	  settings_table_name => 'svmc_settings');
10:26:32   9  END;
10:26:32  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.92
10:26:34 SQL> 
10:26:34 SQL> -----------------------------------------------------------------------
10:26:34 SQL> --			       APPLY/score THE MODEL
10:26:34 SQL> -----------------------------------------------------------------------
10:26:34 SQL> 
10:26:34 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:34 SQL> -----------------------
10:26:34 SQL> -- PREPARE SCORING DATA
10:26:34 SQL> --
10:26:34 SQL> -- If the data for model creation has been prepared, then the data
10:26:34 SQL> -- to be scored using the model must be prepared in the same manner
10:26:34 SQL> -- in order to obtain meaningful results.
10:26:34 SQL> --
10:26:34 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:34 SQL> -- 2. Normalization
10:26:34 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:34 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:34 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:34 SQL> --
10:26:34 SQL> BEGIN
10:26:34   2  	-- Xform Test data to replace missing values
10:26:34   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:34   4  	  miss_table_name => 'svmc_miss_num',
10:26:34   5  	  data_table_name => '&scoretable',
10:26:34   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:34   7  
10:26:34   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:34   9  	  miss_table_name => 'svmc_miss_cat',
10:26:34  10  	  data_table_name => '&scoretable',
10:26:34  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:34  12  
10:26:34  13  	-- Normalize the data to be scored
10:26:34  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:34  15  	  norm_table_name => 'svmc_norm',
10:26:34  16  	  data_table_name => '&scoretable',
10:26:34  17  	  xform_view_name => 'svmc_apply_prep');
10:26:34  18  END;
10:26:34  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:34 SQL> 
10:26:34 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:34 SQL> -- DELETE it if I did:
10:26:34 SQL> DELETE ystkscores
10:26:34   2  WHERE score > 0
10:26:34   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:34   4  -- I need to supply the target attribute name:
10:26:34   5  AND targ = '&1'
10:26:34   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:34 SQL> 
10:26:34 SQL> -- We do a drumroll here:
10:26:34 SQL> 
10:26:34 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:34   2  SELECT
10:26:34   3  tkrdate
10:26:34   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:34   5  ,sysdate
10:26:34   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:34   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:34   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:34   9  ,SUBSTR(tkrdate,-10)ydate
10:26:34  10  ,'&1'
10:26:34  11  FROM svmc_apply_prep
10:26:34  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:26:34 SQL> @score1_5min.sql	      2010-08-24 TLT
10:26:34 SQL> --
10:26:34 SQL> -- score1_5min.sql
10:26:34 SQL> --
10:26:34 SQL> 
10:26:34 SQL> -- Demo:
10:26:34 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:26:34 SQL> 
10:26:34 SQL> CREATE OR REPLACE VIEW sme AS
10:26:34   2  SELECT
10:26:34   3  tkrdate
10:26:34   4  ,NULL gatt
10:26:34   5  ,g00
10:26:34   6  ,g01
10:26:34   7  ,g02
10:26:34   8  ,g03
10:26:34   9  ,g04
10:26:34  10  ,g05
10:26:34  11  ,g06
10:26:34  12  ,g07
10:26:34  13  ,g08
10:26:34  14  ,g09
10:26:34  15  ,g10
10:26:34  16  ,g11
10:26:34  17  ,g12
10:26:34  18  ,g13
10:26:34  19  ,g14
10:26:34  20  ,g15
10:26:34  21  ,g16
10:26:34  22  ,g17
10:26:34  23  ,g18
10:26:34  24  ,g19
10:26:34  25  ,g20
10:26:34  26  ,g21
10:26:34  27  ,g22
10:26:34  28  ,g23
10:26:34  29  ,g24
10:26:34  30  ,g25
10:26:34  31  ,g26
10:26:34  32  ,g27
10:26:34  33  ,g28
10:26:34  34  ,g29
10:26:34  35  FROM stk_ms
10:26:34  36  WHERE ydate = '&1'
10:26:34  37  AND tkr = '&2'
10:26:34  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-24'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:26:34 SQL> 
10:26:34 SQL> -- rpt
10:26:34 SQL> -- We should see just 1 row:
10:26:34 SQL> 
10:26:34 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:34   2  
10:26:34 SQL> -- Build the model:
10:26:34 SQL> CREATE OR REPLACE VIEW bme AS
10:26:34   2  SELECT
10:26:34   3  tkrdate
10:26:34   4  ,gatt
10:26:34   5  ,g00
10:26:34   6  ,g01
10:26:34   7  ,g02
10:26:34   8  ,g03
10:26:34   9  ,g04
10:26:34  10  ,g05
10:26:34  11  ,g06
10:26:34  12  ,g07
10:26:34  13  ,g08
10:26:34  14  ,g09
10:26:34  15  ,g10
10:26:34  16  ,g11
10:26:34  17  ,g12
10:26:34  18  ,g13
10:26:34  19  ,g14
10:26:34  20  ,g15
10:26:34  21  ,g16
10:26:34  22  ,g17
10:26:34  23  ,g18
10:26:34  24  ,g19
10:26:34  25  ,g20
10:26:34  26  ,g21
10:26:34  27  ,g22
10:26:34  28  ,g23
10:26:34  29  ,g24
10:26:34  30  ,g25
10:26:34  31  ,g26
10:26:34  32  ,g27
10:26:34  33  ,g28
10:26:34  34  ,g29
10:26:34  35  FROM stk_ms
10:26:34  36  WHERE gatt IN('nup','up')
10:26:34  37  -- Use only rows which are older than 1 day:
10:26:34  38  AND 1+ydate < '&1'
10:26:34  39  AND tkr = '&2'
10:26:34  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-24'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:34 SQL> 
10:26:34 SQL> -- rpt
10:26:34 SQL> 
10:26:34 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:26:34   2  
10:26:34 SQL> SELECT MAX(tkrdate) FROM bme
10:26:34   2  
10:26:34 SQL> -- Now build model from bme and score sme
10:26:34 SQL> @score1.sql gatt
10:26:34 SQL> -- score1.sql
10:26:34 SQL> 
10:26:34 SQL> -- I use this script to send 5 params to score.sql
10:26:34 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:34 SQL> -- Then at the very end of this script I use the model
10:26:34 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:34 SQL> 
10:26:34 SQL> -- I call this script from 2 other scripts:
10:26:34 SQL> -- score1_5min.sql
10:26:34 SQL> -- score1_5min_gattn.sql
10:26:34 SQL> 
10:26:34 SQL> -- The 1st param is the name of the target attribute.
10:26:34 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:34 SQL> 
10:26:34 SQL> -- Demo:
10:26:34 SQL> -- @score1.sql 'gatt'
10:26:34 SQL> -- @score1.sql 'gattn'
10:26:34 SQL> 
10:26:34 SQL> -- Now, I fill up svmc_apply_prep.
10:26:34 SQL> -- I use same model_name used in score.sql
10:26:34 SQL> DEFINE model_name = 'svmspy101'
10:26:34 SQL> DEFINE bldtable	= 'bme'
10:26:34 SQL> DEFINE scoretable = 'sme'
10:26:34 SQL> DEFINE case_id	= 'tkrdate'
10:26:34 SQL> -- Demo:
10:26:34 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:34 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:34 SQL> --
10:26:34 SQL> -- score.sql
10:26:34 SQL> --
10:26:34 SQL> 
10:26:34 SQL> -- usage: score.sql
10:26:34 SQL> 
10:26:34 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:34 SQL> 
10:26:34 SQL> -- DEFINE target	   = 'gatt'
10:26:34 SQL> -- DEFINE model_name = 'svmspy100'
10:26:34 SQL> -- DEFINE bldtable   = 'bme'
10:26:34 SQL> -- DEFINE scoretable = 'sme'
10:26:34 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:34 SQL> 
10:26:34 SQL> DEFINE target	= '&1'
10:26:34 SQL> DEFINE model_name = '&2'
10:26:34 SQL> DEFINE bldtable	= '&3'
10:26:34 SQL> DEFINE scoretable = '&4'
10:26:34 SQL> DEFINE case_id	= '&5'
10:26:34 SQL> 
10:26:34 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:34 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:34 SQL> 
10:26:34 SQL> -- Builds an SVM model using pl/sql.
10:26:34 SQL> 
10:26:34 SQL> -----------------------------------------------------------------------
10:26:34 SQL> --			    BUILD THE MODEL
10:26:34 SQL> -----------------------------------------------------------------------
10:26:34 SQL> 
10:26:34 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:34 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:34 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:34 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:34 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:34 SQL> 
10:26:34 SQL> 
10:26:34 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:34 SQL> --
10:26:34 SQL> -- DROP	TABLE svmc_settings ;
10:26:34 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:34 SQL> -- DELETE svmc_settings;
10:26:34 SQL> 
10:26:34 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:34 SQL> -- this choice to SVM using a settings table.
10:26:34 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:34 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:34 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:34 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:34 SQL> -- models.
10:26:34 SQL> --
10:26:34 SQL> 
10:26:34 SQL> -- Do this once and then comment it out.
10:26:34 SQL> -- That makes script go faster.
10:26:34 SQL> -- BEGIN
10:26:34 SQL> -- -- Populate settings table
10:26:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:34 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:34 SQL> --
10:26:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:34 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:34 SQL> --
10:26:34 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:34 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:34 SQL> --   COMMIT;
10:26:34 SQL> -- END;
10:26:34 SQL> -- /
10:26:34 SQL> 
10:26:34 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:34 SQL> 
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:34 SQL> 
10:26:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:35 SQL> 
10:26:35 SQL> --------------------------------
10:26:35 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:35 SQL> --
10:26:35 SQL> 
10:26:35 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:35 SQL> -- 2. Outlier Treatment and
10:26:35 SQL> -- 3. Normalization are performed below.
10:26:35 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:35 SQL> --    normalized here.
10:26:35 SQL> 
10:26:35 SQL> BEGIN
10:26:35   2  	-- Perform missing value treatment for all predictors
10:26:35   3  	-- create miss tables
10:26:35   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:35   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:35   6  
10:26:35   7  	-- populate miss tables
10:26:35   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:35   9  	  miss_table_name => 'svmc_miss_num',
10:26:35  10  	  data_table_name => '&bldtable',
10:26:35  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:35  12  
10:26:35  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:35  14  	  miss_table_name => 'svmc_miss_cat',
10:26:35  15  	  data_table_name => '&bldtable',
10:26:35  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:35  17  
10:26:35  18  	-- xform input data to replace missing values
10:26:35  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:35  20  	  miss_table_name => 'svmc_miss_num',
10:26:35  21  	  data_table_name => '&bldtable',
10:26:35  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:35  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:35  24  	  miss_table_name => 'svmc_miss_cat',
10:26:35  25  	  data_table_name => '&bldtable',
10:26:35  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:35  27  
10:26:35  28  	-- Perform outlier treatment.
10:26:35  29  	-- create clip table
10:26:35  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:35  31  
10:26:35  32  	-- populate clip table
10:26:35  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:35  34  	  clip_table_name => 'svmc_clip',
10:26:35  35  	  data_table_name => '&bldtable',
10:26:35  36  	  tail_frac	  => 0.025,
10:26:35  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:35  38  
10:26:35  39  	-- xform input data to winsorized data
10:26:35  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:35  41  	  clip_table_name => 'svmc_clip',
10:26:35  42  	  data_table_name => '&bldtable',
10:26:35  43  	  xform_view_name => 'svmc_winsor');
10:26:35  44  
10:26:35  45  	-- create normalization table
10:26:35  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:35  47  
10:26:35  48  	-- populate normalization table based on winsorized data
10:26:35  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:35  50  	  norm_table_name => 'svmc_norm',
10:26:35  51  	  data_table_name => 'svmc_winsor',
10:26:35  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:35  53  
10:26:35  54  	-- normalize the original data
10:26:35  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:35  56  	  norm_table_name => 'svmc_norm',
10:26:35  57  	  data_table_name => '&bldtable',
10:26:35  58  	  xform_view_name => 'svmc_build_prep');
10:26:35  59  END;
10:26:35  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:26:35 SQL> 
10:26:35 SQL> ---------------------
10:26:35 SQL> -- CREATE A NEW MODEL
10:26:35 SQL> --
10:26:35 SQL> -- Cleanup old model with the same name for repeat runs
10:26:35 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:35   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.31
10:26:36 SQL> 
10:26:36 SQL> -- Build a new SVM Model
10:26:36 SQL> BEGIN
10:26:36   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:36   3  	  model_name	      => '&model_name',
10:26:36   4  	  mining_function     => dbms_data_mining.classification,
10:26:36   5  	  data_table_name     => 'svmc_build_prep',
10:26:36   6  	  case_id_column_name => '&case_id',
10:26:36   7  	  target_column_name  => '&target',
10:26:36   8  	  settings_table_name => 'svmc_settings');
10:26:36   9  END;
10:26:36  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.33
10:26:39 SQL> 
10:26:39 SQL> -----------------------------------------------------------------------
10:26:39 SQL> --			       APPLY/score THE MODEL
10:26:39 SQL> -----------------------------------------------------------------------
10:26:39 SQL> 
10:26:39 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:39 SQL> -----------------------
10:26:39 SQL> -- PREPARE SCORING DATA
10:26:39 SQL> --
10:26:39 SQL> -- If the data for model creation has been prepared, then the data
10:26:39 SQL> -- to be scored using the model must be prepared in the same manner
10:26:39 SQL> -- in order to obtain meaningful results.
10:26:39 SQL> --
10:26:39 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:39 SQL> -- 2. Normalization
10:26:39 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:39 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:39 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:39 SQL> --
10:26:39 SQL> BEGIN
10:26:39   2  	-- Xform Test data to replace missing values
10:26:39   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:39   4  	  miss_table_name => 'svmc_miss_num',
10:26:39   5  	  data_table_name => '&scoretable',
10:26:39   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:39   7  
10:26:39   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:39   9  	  miss_table_name => 'svmc_miss_cat',
10:26:39  10  	  data_table_name => '&scoretable',
10:26:39  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:39  12  
10:26:39  13  	-- Normalize the data to be scored
10:26:39  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:39  15  	  norm_table_name => 'svmc_norm',
10:26:39  16  	  data_table_name => '&scoretable',
10:26:39  17  	  xform_view_name => 'svmc_apply_prep');
10:26:39  18  END;
10:26:39  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:39 SQL> 
10:26:39 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:39 SQL> -- DELETE it if I did:
10:26:39 SQL> DELETE ystkscores
10:26:39   2  WHERE score > 0
10:26:39   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:39   4  -- I need to supply the target attribute name:
10:26:39   5  AND targ = '&1'
10:26:39   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:26:39 SQL> 
10:26:39 SQL> -- We do a drumroll here:
10:26:39 SQL> 
10:26:39 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:39   2  SELECT
10:26:39   3  tkrdate
10:26:39   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:39   5  ,sysdate
10:26:39   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:39   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:39   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:39   9  ,SUBSTR(tkrdate,-10)ydate
10:26:39  10  ,'&1'
10:26:39  11  FROM svmc_apply_prep
10:26:39  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:26:39 SQL> @score1_5min.sql	      2010-08-26 TLT
10:26:39 SQL> --
10:26:39 SQL> -- score1_5min.sql
10:26:39 SQL> --
10:26:39 SQL> 
10:26:39 SQL> -- Demo:
10:26:39 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:26:39 SQL> 
10:26:39 SQL> CREATE OR REPLACE VIEW sme AS
10:26:39   2  SELECT
10:26:39   3  tkrdate
10:26:39   4  ,NULL gatt
10:26:39   5  ,g00
10:26:39   6  ,g01
10:26:39   7  ,g02
10:26:39   8  ,g03
10:26:39   9  ,g04
10:26:39  10  ,g05
10:26:39  11  ,g06
10:26:39  12  ,g07
10:26:39  13  ,g08
10:26:39  14  ,g09
10:26:39  15  ,g10
10:26:39  16  ,g11
10:26:39  17  ,g12
10:26:39  18  ,g13
10:26:39  19  ,g14
10:26:39  20  ,g15
10:26:39  21  ,g16
10:26:39  22  ,g17
10:26:39  23  ,g18
10:26:39  24  ,g19
10:26:39  25  ,g20
10:26:39  26  ,g21
10:26:39  27  ,g22
10:26:39  28  ,g23
10:26:39  29  ,g24
10:26:39  30  ,g25
10:26:39  31  ,g26
10:26:39  32  ,g27
10:26:39  33  ,g28
10:26:39  34  ,g29
10:26:39  35  FROM stk_ms
10:26:39  36  WHERE ydate = '&1'
10:26:39  37  AND tkr = '&2'
10:26:39  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-26'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:26:39 SQL> 
10:26:39 SQL> -- rpt
10:26:39 SQL> -- We should see just 1 row:
10:26:39 SQL> 
10:26:39 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:39   2  
10:26:39 SQL> -- Build the model:
10:26:39 SQL> CREATE OR REPLACE VIEW bme AS
10:26:39   2  SELECT
10:26:39   3  tkrdate
10:26:39   4  ,gatt
10:26:39   5  ,g00
10:26:39   6  ,g01
10:26:39   7  ,g02
10:26:39   8  ,g03
10:26:39   9  ,g04
10:26:39  10  ,g05
10:26:39  11  ,g06
10:26:39  12  ,g07
10:26:39  13  ,g08
10:26:39  14  ,g09
10:26:39  15  ,g10
10:26:39  16  ,g11
10:26:39  17  ,g12
10:26:39  18  ,g13
10:26:39  19  ,g14
10:26:39  20  ,g15
10:26:39  21  ,g16
10:26:39  22  ,g17
10:26:39  23  ,g18
10:26:39  24  ,g19
10:26:39  25  ,g20
10:26:39  26  ,g21
10:26:39  27  ,g22
10:26:39  28  ,g23
10:26:39  29  ,g24
10:26:39  30  ,g25
10:26:39  31  ,g26
10:26:39  32  ,g27
10:26:39  33  ,g28
10:26:39  34  ,g29
10:26:39  35  FROM stk_ms
10:26:39  36  WHERE gatt IN('nup','up')
10:26:39  37  -- Use only rows which are older than 1 day:
10:26:39  38  AND 1+ydate < '&1'
10:26:39  39  AND tkr = '&2'
10:26:39  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-26'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:26:39 SQL> 
10:26:39 SQL> -- rpt
10:26:39 SQL> 
10:26:39 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:26:39   2  
10:26:39 SQL> SELECT MAX(tkrdate) FROM bme
10:26:39   2  
10:26:39 SQL> -- Now build model from bme and score sme
10:26:39 SQL> @score1.sql gatt
10:26:39 SQL> -- score1.sql
10:26:39 SQL> 
10:26:39 SQL> -- I use this script to send 5 params to score.sql
10:26:39 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:39 SQL> -- Then at the very end of this script I use the model
10:26:39 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:39 SQL> 
10:26:39 SQL> -- I call this script from 2 other scripts:
10:26:39 SQL> -- score1_5min.sql
10:26:39 SQL> -- score1_5min_gattn.sql
10:26:39 SQL> 
10:26:39 SQL> -- The 1st param is the name of the target attribute.
10:26:39 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:39 SQL> 
10:26:39 SQL> -- Demo:
10:26:39 SQL> -- @score1.sql 'gatt'
10:26:39 SQL> -- @score1.sql 'gattn'
10:26:39 SQL> 
10:26:39 SQL> -- Now, I fill up svmc_apply_prep.
10:26:39 SQL> -- I use same model_name used in score.sql
10:26:39 SQL> DEFINE model_name = 'svmspy101'
10:26:39 SQL> DEFINE bldtable	= 'bme'
10:26:39 SQL> DEFINE scoretable = 'sme'
10:26:39 SQL> DEFINE case_id	= 'tkrdate'
10:26:39 SQL> -- Demo:
10:26:39 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:39 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:39 SQL> --
10:26:39 SQL> -- score.sql
10:26:39 SQL> --
10:26:39 SQL> 
10:26:39 SQL> -- usage: score.sql
10:26:39 SQL> 
10:26:39 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:39 SQL> 
10:26:39 SQL> -- DEFINE target	   = 'gatt'
10:26:39 SQL> -- DEFINE model_name = 'svmspy100'
10:26:39 SQL> -- DEFINE bldtable   = 'bme'
10:26:39 SQL> -- DEFINE scoretable = 'sme'
10:26:39 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:39 SQL> 
10:26:39 SQL> DEFINE target	= '&1'
10:26:39 SQL> DEFINE model_name = '&2'
10:26:39 SQL> DEFINE bldtable	= '&3'
10:26:39 SQL> DEFINE scoretable = '&4'
10:26:39 SQL> DEFINE case_id	= '&5'
10:26:39 SQL> 
10:26:39 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:39 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:39 SQL> 
10:26:39 SQL> -- Builds an SVM model using pl/sql.
10:26:39 SQL> 
10:26:39 SQL> -----------------------------------------------------------------------
10:26:39 SQL> --			    BUILD THE MODEL
10:26:39 SQL> -----------------------------------------------------------------------
10:26:39 SQL> 
10:26:39 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:39 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:39 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:39 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:39 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:39 SQL> 
10:26:39 SQL> 
10:26:39 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:39 SQL> --
10:26:39 SQL> -- DROP	TABLE svmc_settings ;
10:26:39 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:39 SQL> -- DELETE svmc_settings;
10:26:39 SQL> 
10:26:39 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:39 SQL> -- this choice to SVM using a settings table.
10:26:39 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:39 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:39 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:39 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:39 SQL> -- models.
10:26:39 SQL> --
10:26:39 SQL> 
10:26:39 SQL> -- Do this once and then comment it out.
10:26:39 SQL> -- That makes script go faster.
10:26:39 SQL> -- BEGIN
10:26:39 SQL> -- -- Populate settings table
10:26:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:39 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:39 SQL> --
10:26:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:39 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:39 SQL> --
10:26:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:39 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:39 SQL> --   COMMIT;
10:26:39 SQL> -- END;
10:26:39 SQL> -- /
10:26:39 SQL> 
10:26:39 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:39 SQL> 
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:39 SQL> 
10:26:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:39 SQL> 
10:26:39 SQL> --------------------------------
10:26:39 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:39 SQL> --
10:26:39 SQL> 
10:26:39 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:39 SQL> -- 2. Outlier Treatment and
10:26:39 SQL> -- 3. Normalization are performed below.
10:26:39 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:39 SQL> --    normalized here.
10:26:39 SQL> 
10:26:39 SQL> BEGIN
10:26:39   2  	-- Perform missing value treatment for all predictors
10:26:39   3  	-- create miss tables
10:26:39   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:39   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:39   6  
10:26:39   7  	-- populate miss tables
10:26:39   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:39   9  	  miss_table_name => 'svmc_miss_num',
10:26:39  10  	  data_table_name => '&bldtable',
10:26:39  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:39  12  
10:26:39  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:39  14  	  miss_table_name => 'svmc_miss_cat',
10:26:39  15  	  data_table_name => '&bldtable',
10:26:39  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:39  17  
10:26:39  18  	-- xform input data to replace missing values
10:26:39  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:39  20  	  miss_table_name => 'svmc_miss_num',
10:26:39  21  	  data_table_name => '&bldtable',
10:26:39  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:39  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:39  24  	  miss_table_name => 'svmc_miss_cat',
10:26:39  25  	  data_table_name => '&bldtable',
10:26:39  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:39  27  
10:26:39  28  	-- Perform outlier treatment.
10:26:39  29  	-- create clip table
10:26:39  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:39  31  
10:26:39  32  	-- populate clip table
10:26:39  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:39  34  	  clip_table_name => 'svmc_clip',
10:26:39  35  	  data_table_name => '&bldtable',
10:26:39  36  	  tail_frac	  => 0.025,
10:26:39  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:39  38  
10:26:39  39  	-- xform input data to winsorized data
10:26:39  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:39  41  	  clip_table_name => 'svmc_clip',
10:26:39  42  	  data_table_name => '&bldtable',
10:26:39  43  	  xform_view_name => 'svmc_winsor');
10:26:39  44  
10:26:39  45  	-- create normalization table
10:26:39  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:39  47  
10:26:39  48  	-- populate normalization table based on winsorized data
10:26:39  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:39  50  	  norm_table_name => 'svmc_norm',
10:26:39  51  	  data_table_name => 'svmc_winsor',
10:26:39  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:39  53  
10:26:39  54  	-- normalize the original data
10:26:39  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:39  56  	  norm_table_name => 'svmc_norm',
10:26:39  57  	  data_table_name => '&bldtable',
10:26:39  58  	  xform_view_name => 'svmc_build_prep');
10:26:39  59  END;
10:26:39  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:26:40 SQL> 
10:26:40 SQL> ---------------------
10:26:40 SQL> -- CREATE A NEW MODEL
10:26:40 SQL> --
10:26:40 SQL> -- Cleanup old model with the same name for repeat runs
10:26:40 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:40   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.77
10:26:42 SQL> 
10:26:42 SQL> -- Build a new SVM Model
10:26:42 SQL> BEGIN
10:26:42   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:42   3  	  model_name	      => '&model_name',
10:26:42   4  	  mining_function     => dbms_data_mining.classification,
10:26:42   5  	  data_table_name     => 'svmc_build_prep',
10:26:42   6  	  case_id_column_name => '&case_id',
10:26:42   7  	  target_column_name  => '&target',
10:26:42   8  	  settings_table_name => 'svmc_settings');
10:26:42   9  END;
10:26:42  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.11
10:26:45 SQL> 
10:26:45 SQL> -----------------------------------------------------------------------
10:26:45 SQL> --			       APPLY/score THE MODEL
10:26:45 SQL> -----------------------------------------------------------------------
10:26:45 SQL> 
10:26:45 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:45 SQL> -----------------------
10:26:45 SQL> -- PREPARE SCORING DATA
10:26:45 SQL> --
10:26:45 SQL> -- If the data for model creation has been prepared, then the data
10:26:45 SQL> -- to be scored using the model must be prepared in the same manner
10:26:45 SQL> -- in order to obtain meaningful results.
10:26:45 SQL> --
10:26:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:45 SQL> -- 2. Normalization
10:26:45 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:45 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:45 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:45 SQL> --
10:26:45 SQL> BEGIN
10:26:45   2  	-- Xform Test data to replace missing values
10:26:45   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:45   4  	  miss_table_name => 'svmc_miss_num',
10:26:45   5  	  data_table_name => '&scoretable',
10:26:45   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:45   7  
10:26:45   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:45   9  	  miss_table_name => 'svmc_miss_cat',
10:26:45  10  	  data_table_name => '&scoretable',
10:26:45  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:45  12  
10:26:45  13  	-- Normalize the data to be scored
10:26:45  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:45  15  	  norm_table_name => 'svmc_norm',
10:26:45  16  	  data_table_name => '&scoretable',
10:26:45  17  	  xform_view_name => 'svmc_apply_prep');
10:26:45  18  END;
10:26:45  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:26:45 SQL> 
10:26:45 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:45 SQL> -- DELETE it if I did:
10:26:45 SQL> DELETE ystkscores
10:26:45   2  WHERE score > 0
10:26:45   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:45   4  -- I need to supply the target attribute name:
10:26:45   5  AND targ = '&1'
10:26:45   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:26:45 SQL> 
10:26:45 SQL> -- We do a drumroll here:
10:26:45 SQL> 
10:26:45 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:45   2  SELECT
10:26:45   3  tkrdate
10:26:45   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:45   5  ,sysdate
10:26:45   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:45   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:45   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:45   9  ,SUBSTR(tkrdate,-10)ydate
10:26:45  10  ,'&1'
10:26:45  11  FROM svmc_apply_prep
10:26:45  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:26:45 SQL> @score1_5min_gattn.sql	2010-01-25 TLT
10:26:45 SQL> --
10:26:45 SQL> -- score1_5min_gattn.sql
10:26:45 SQL> --
10:26:45 SQL> 
10:26:45 SQL> -- Demo:
10:26:45 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:45 SQL> 
10:26:45 SQL> CREATE OR REPLACE VIEW sme AS
10:26:45   2  SELECT
10:26:45   3  tkrdate
10:26:45   4  ,NULL gattn
10:26:45   5  ,g00
10:26:45   6  ,g01
10:26:45   7  ,g02
10:26:45   8  ,g03
10:26:45   9  ,g04
10:26:45  10  ,g05
10:26:45  11  ,g06
10:26:45  12  ,g07
10:26:45  13  ,g08
10:26:45  14  ,g09
10:26:45  15  ,g10
10:26:45  16  ,g11
10:26:45  17  ,g12
10:26:45  18  ,g13
10:26:45  19  ,g14
10:26:45  20  ,g15
10:26:45  21  ,g16
10:26:45  22  ,g17
10:26:45  23  ,g18
10:26:45  24  ,g19
10:26:45  25  ,g20
10:26:45  26  ,g21
10:26:45  27  ,g22
10:26:45  28  ,g23
10:26:45  29  ,g24
10:26:45  30  ,g25
10:26:45  31  ,g26
10:26:45  32  ,g27
10:26:45  33  ,g28
10:26:45  34  ,g29
10:26:45  35  FROM stk_ms
10:26:45  36  WHERE ydate = '&1'
10:26:45  37  AND tkr = '&2'
10:26:45  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-25'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:26:45 SQL> 
10:26:45 SQL> -- rpt
10:26:45 SQL> -- We should see just 1 row:
10:26:45 SQL> 
10:26:45 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:45   2  
10:26:45 SQL> -- Build the model:
10:26:45 SQL> CREATE OR REPLACE VIEW bme AS
10:26:45   2  SELECT
10:26:45   3  tkrdate
10:26:45   4  ,gattn
10:26:45   5  ,g00
10:26:45   6  ,g01
10:26:45   7  ,g02
10:26:45   8  ,g03
10:26:45   9  ,g04
10:26:45  10  ,g05
10:26:45  11  ,g06
10:26:45  12  ,g07
10:26:45  13  ,g08
10:26:45  14  ,g09
10:26:45  15  ,g10
10:26:45  16  ,g11
10:26:45  17  ,g12
10:26:45  18  ,g13
10:26:45  19  ,g14
10:26:45  20  ,g15
10:26:45  21  ,g16
10:26:45  22  ,g17
10:26:45  23  ,g18
10:26:45  24  ,g19
10:26:45  25  ,g20
10:26:45  26  ,g21
10:26:45  27  ,g22
10:26:45  28  ,g23
10:26:45  29  ,g24
10:26:45  30  ,g25
10:26:45  31  ,g26
10:26:45  32  ,g27
10:26:45  33  ,g28
10:26:45  34  ,g29
10:26:45  35  FROM stk_ms
10:26:45  36  WHERE gattn IN('nup','up')
10:26:45  37  -- Use only rows which are older than 1 day:
10:26:45  38  AND 1+ydate < '&1'
10:26:45  39  AND tkr = '&2'
10:26:45  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-25'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:45 SQL> 
10:26:45 SQL> -- rpt
10:26:45 SQL> 
10:26:45 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:45   2  
10:26:45 SQL> SELECT MAX(tkrdate) FROM bme
10:26:45   2  
10:26:45 SQL> -- Now build model from bme and score sme
10:26:45 SQL> @score1.sql gattn
10:26:45 SQL> -- score1.sql
10:26:45 SQL> 
10:26:45 SQL> -- I use this script to send 5 params to score.sql
10:26:45 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:45 SQL> -- Then at the very end of this script I use the model
10:26:45 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:45 SQL> 
10:26:45 SQL> -- I call this script from 2 other scripts:
10:26:45 SQL> -- score1_5min.sql
10:26:45 SQL> -- score1_5min_gattn.sql
10:26:45 SQL> 
10:26:45 SQL> -- The 1st param is the name of the target attribute.
10:26:45 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:45 SQL> 
10:26:45 SQL> -- Demo:
10:26:45 SQL> -- @score1.sql 'gatt'
10:26:45 SQL> -- @score1.sql 'gattn'
10:26:45 SQL> 
10:26:45 SQL> -- Now, I fill up svmc_apply_prep.
10:26:45 SQL> -- I use same model_name used in score.sql
10:26:45 SQL> DEFINE model_name = 'svmspy101'
10:26:45 SQL> DEFINE bldtable	= 'bme'
10:26:45 SQL> DEFINE scoretable = 'sme'
10:26:45 SQL> DEFINE case_id	= 'tkrdate'
10:26:45 SQL> -- Demo:
10:26:45 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:45 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:45 SQL> --
10:26:45 SQL> -- score.sql
10:26:45 SQL> --
10:26:45 SQL> 
10:26:45 SQL> -- usage: score.sql
10:26:45 SQL> 
10:26:45 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:45 SQL> 
10:26:45 SQL> -- DEFINE target	   = 'gatt'
10:26:45 SQL> -- DEFINE model_name = 'svmspy100'
10:26:45 SQL> -- DEFINE bldtable   = 'bme'
10:26:45 SQL> -- DEFINE scoretable = 'sme'
10:26:45 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:45 SQL> 
10:26:45 SQL> DEFINE target	= '&1'
10:26:45 SQL> DEFINE model_name = '&2'
10:26:45 SQL> DEFINE bldtable	= '&3'
10:26:45 SQL> DEFINE scoretable = '&4'
10:26:45 SQL> DEFINE case_id	= '&5'
10:26:45 SQL> 
10:26:45 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:45 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:45 SQL> 
10:26:45 SQL> -- Builds an SVM model using pl/sql.
10:26:45 SQL> 
10:26:45 SQL> -----------------------------------------------------------------------
10:26:45 SQL> --			    BUILD THE MODEL
10:26:45 SQL> -----------------------------------------------------------------------
10:26:45 SQL> 
10:26:45 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:45 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:45 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:45 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:45 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:45 SQL> 
10:26:45 SQL> 
10:26:45 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:45 SQL> --
10:26:45 SQL> -- DROP	TABLE svmc_settings ;
10:26:45 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:45 SQL> -- DELETE svmc_settings;
10:26:45 SQL> 
10:26:45 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:45 SQL> -- this choice to SVM using a settings table.
10:26:45 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:45 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:45 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:45 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:45 SQL> -- models.
10:26:45 SQL> --
10:26:45 SQL> 
10:26:45 SQL> -- Do this once and then comment it out.
10:26:45 SQL> -- That makes script go faster.
10:26:45 SQL> -- BEGIN
10:26:45 SQL> -- -- Populate settings table
10:26:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:45 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:45 SQL> --
10:26:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:45 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:45 SQL> --
10:26:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:45 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:45 SQL> --   COMMIT;
10:26:45 SQL> -- END;
10:26:45 SQL> -- /
10:26:45 SQL> 
10:26:45 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:45 SQL> 
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:45 SQL> 
10:26:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:26:45 SQL> 
10:26:45 SQL> --------------------------------
10:26:45 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:45 SQL> --
10:26:45 SQL> 
10:26:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:45 SQL> -- 2. Outlier Treatment and
10:26:45 SQL> -- 3. Normalization are performed below.
10:26:45 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:45 SQL> --    normalized here.
10:26:45 SQL> 
10:26:45 SQL> BEGIN
10:26:45   2  	-- Perform missing value treatment for all predictors
10:26:45   3  	-- create miss tables
10:26:45   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:45   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:45   6  
10:26:45   7  	-- populate miss tables
10:26:45   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:45   9  	  miss_table_name => 'svmc_miss_num',
10:26:45  10  	  data_table_name => '&bldtable',
10:26:45  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:45  12  
10:26:45  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:45  14  	  miss_table_name => 'svmc_miss_cat',
10:26:45  15  	  data_table_name => '&bldtable',
10:26:45  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:45  17  
10:26:45  18  	-- xform input data to replace missing values
10:26:45  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:45  20  	  miss_table_name => 'svmc_miss_num',
10:26:45  21  	  data_table_name => '&bldtable',
10:26:45  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:45  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:45  24  	  miss_table_name => 'svmc_miss_cat',
10:26:45  25  	  data_table_name => '&bldtable',
10:26:45  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:45  27  
10:26:45  28  	-- Perform outlier treatment.
10:26:45  29  	-- create clip table
10:26:45  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:45  31  
10:26:45  32  	-- populate clip table
10:26:45  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:45  34  	  clip_table_name => 'svmc_clip',
10:26:45  35  	  data_table_name => '&bldtable',
10:26:45  36  	  tail_frac	  => 0.025,
10:26:45  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:45  38  
10:26:45  39  	-- xform input data to winsorized data
10:26:45  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:45  41  	  clip_table_name => 'svmc_clip',
10:26:45  42  	  data_table_name => '&bldtable',
10:26:45  43  	  xform_view_name => 'svmc_winsor');
10:26:45  44  
10:26:45  45  	-- create normalization table
10:26:45  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:45  47  
10:26:45  48  	-- populate normalization table based on winsorized data
10:26:45  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:45  50  	  norm_table_name => 'svmc_norm',
10:26:45  51  	  data_table_name => 'svmc_winsor',
10:26:45  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:45  53  
10:26:45  54  	-- normalize the original data
10:26:45  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:45  56  	  norm_table_name => 'svmc_norm',
10:26:45  57  	  data_table_name => '&bldtable',
10:26:45  58  	  xform_view_name => 'svmc_build_prep');
10:26:45  59  END;
10:26:45  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:26:46 SQL> 
10:26:46 SQL> ---------------------
10:26:46 SQL> -- CREATE A NEW MODEL
10:26:46 SQL> --
10:26:46 SQL> -- Cleanup old model with the same name for repeat runs
10:26:46 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:46   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.02
10:26:47 SQL> 
10:26:47 SQL> -- Build a new SVM Model
10:26:47 SQL> BEGIN
10:26:47   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:47   3  	  model_name	      => '&model_name',
10:26:47   4  	  mining_function     => dbms_data_mining.classification,
10:26:47   5  	  data_table_name     => 'svmc_build_prep',
10:26:47   6  	  case_id_column_name => '&case_id',
10:26:47   7  	  target_column_name  => '&target',
10:26:47   8  	  settings_table_name => 'svmc_settings');
10:26:47   9  END;
10:26:47  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.92
10:26:49 SQL> 
10:26:49 SQL> -----------------------------------------------------------------------
10:26:49 SQL> --			       APPLY/score THE MODEL
10:26:49 SQL> -----------------------------------------------------------------------
10:26:49 SQL> 
10:26:49 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:49 SQL> -----------------------
10:26:49 SQL> -- PREPARE SCORING DATA
10:26:49 SQL> --
10:26:49 SQL> -- If the data for model creation has been prepared, then the data
10:26:49 SQL> -- to be scored using the model must be prepared in the same manner
10:26:49 SQL> -- in order to obtain meaningful results.
10:26:49 SQL> --
10:26:49 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:49 SQL> -- 2. Normalization
10:26:49 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:49 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:49 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:49 SQL> --
10:26:49 SQL> BEGIN
10:26:49   2  	-- Xform Test data to replace missing values
10:26:49   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:49   4  	  miss_table_name => 'svmc_miss_num',
10:26:49   5  	  data_table_name => '&scoretable',
10:26:49   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:49   7  
10:26:49   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:49   9  	  miss_table_name => 'svmc_miss_cat',
10:26:49  10  	  data_table_name => '&scoretable',
10:26:49  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:49  12  
10:26:49  13  	-- Normalize the data to be scored
10:26:49  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:49  15  	  norm_table_name => 'svmc_norm',
10:26:49  16  	  data_table_name => '&scoretable',
10:26:49  17  	  xform_view_name => 'svmc_apply_prep');
10:26:49  18  END;
10:26:49  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:26:49 SQL> 
10:26:49 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:49 SQL> -- DELETE it if I did:
10:26:49 SQL> DELETE ystkscores
10:26:49   2  WHERE score > 0
10:26:49   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:49   4  -- I need to supply the target attribute name:
10:26:49   5  AND targ = '&1'
10:26:49   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:26:49 SQL> 
10:26:49 SQL> -- We do a drumroll here:
10:26:49 SQL> 
10:26:49 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:49   2  SELECT
10:26:49   3  tkrdate
10:26:49   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:49   5  ,sysdate
10:26:49   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:49   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:49   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:49   9  ,SUBSTR(tkrdate,-10)ydate
10:26:49  10  ,'&1'
10:26:49  11  FROM svmc_apply_prep
10:26:49  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:26:49 SQL> @score1_5min.sql	      2010-11-26 TLT
10:26:49 SQL> --
10:26:49 SQL> -- score1_5min.sql
10:26:49 SQL> --
10:26:49 SQL> 
10:26:49 SQL> -- Demo:
10:26:49 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:26:49 SQL> 
10:26:49 SQL> CREATE OR REPLACE VIEW sme AS
10:26:49   2  SELECT
10:26:49   3  tkrdate
10:26:49   4  ,NULL gatt
10:26:49   5  ,g00
10:26:49   6  ,g01
10:26:49   7  ,g02
10:26:49   8  ,g03
10:26:49   9  ,g04
10:26:49  10  ,g05
10:26:49  11  ,g06
10:26:49  12  ,g07
10:26:49  13  ,g08
10:26:49  14  ,g09
10:26:49  15  ,g10
10:26:49  16  ,g11
10:26:49  17  ,g12
10:26:49  18  ,g13
10:26:49  19  ,g14
10:26:49  20  ,g15
10:26:49  21  ,g16
10:26:49  22  ,g17
10:26:49  23  ,g18
10:26:49  24  ,g19
10:26:49  25  ,g20
10:26:49  26  ,g21
10:26:49  27  ,g22
10:26:49  28  ,g23
10:26:49  29  ,g24
10:26:49  30  ,g25
10:26:49  31  ,g26
10:26:49  32  ,g27
10:26:49  33  ,g28
10:26:49  34  ,g29
10:26:49  35  FROM stk_ms
10:26:49  36  WHERE ydate = '&1'
10:26:49  37  AND tkr = '&2'
10:26:49  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-26'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:49 SQL> 
10:26:49 SQL> -- rpt
10:26:49 SQL> -- We should see just 1 row:
10:26:49 SQL> 
10:26:49 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:49   2  
10:26:49 SQL> -- Build the model:
10:26:49 SQL> CREATE OR REPLACE VIEW bme AS
10:26:49   2  SELECT
10:26:49   3  tkrdate
10:26:49   4  ,gatt
10:26:49   5  ,g00
10:26:49   6  ,g01
10:26:49   7  ,g02
10:26:49   8  ,g03
10:26:49   9  ,g04
10:26:49  10  ,g05
10:26:49  11  ,g06
10:26:49  12  ,g07
10:26:49  13  ,g08
10:26:49  14  ,g09
10:26:49  15  ,g10
10:26:49  16  ,g11
10:26:49  17  ,g12
10:26:49  18  ,g13
10:26:49  19  ,g14
10:26:49  20  ,g15
10:26:49  21  ,g16
10:26:49  22  ,g17
10:26:49  23  ,g18
10:26:49  24  ,g19
10:26:49  25  ,g20
10:26:49  26  ,g21
10:26:49  27  ,g22
10:26:49  28  ,g23
10:26:49  29  ,g24
10:26:49  30  ,g25
10:26:49  31  ,g26
10:26:49  32  ,g27
10:26:49  33  ,g28
10:26:49  34  ,g29
10:26:49  35  FROM stk_ms
10:26:49  36  WHERE gatt IN('nup','up')
10:26:49  37  -- Use only rows which are older than 1 day:
10:26:49  38  AND 1+ydate < '&1'
10:26:49  39  AND tkr = '&2'
10:26:49  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-26'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:49 SQL> 
10:26:49 SQL> -- rpt
10:26:49 SQL> 
10:26:49 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:26:49   2  
10:26:49 SQL> SELECT MAX(tkrdate) FROM bme
10:26:49   2  
10:26:49 SQL> -- Now build model from bme and score sme
10:26:49 SQL> @score1.sql gatt
10:26:49 SQL> -- score1.sql
10:26:49 SQL> 
10:26:49 SQL> -- I use this script to send 5 params to score.sql
10:26:49 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:49 SQL> -- Then at the very end of this script I use the model
10:26:49 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:49 SQL> 
10:26:49 SQL> -- I call this script from 2 other scripts:
10:26:49 SQL> -- score1_5min.sql
10:26:49 SQL> -- score1_5min_gattn.sql
10:26:49 SQL> 
10:26:49 SQL> -- The 1st param is the name of the target attribute.
10:26:49 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:49 SQL> 
10:26:49 SQL> -- Demo:
10:26:49 SQL> -- @score1.sql 'gatt'
10:26:49 SQL> -- @score1.sql 'gattn'
10:26:49 SQL> 
10:26:49 SQL> -- Now, I fill up svmc_apply_prep.
10:26:49 SQL> -- I use same model_name used in score.sql
10:26:49 SQL> DEFINE model_name = 'svmspy101'
10:26:49 SQL> DEFINE bldtable	= 'bme'
10:26:49 SQL> DEFINE scoretable = 'sme'
10:26:49 SQL> DEFINE case_id	= 'tkrdate'
10:26:49 SQL> -- Demo:
10:26:49 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:49 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:49 SQL> --
10:26:49 SQL> -- score.sql
10:26:49 SQL> --
10:26:49 SQL> 
10:26:49 SQL> -- usage: score.sql
10:26:49 SQL> 
10:26:49 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:49 SQL> 
10:26:49 SQL> -- DEFINE target	   = 'gatt'
10:26:49 SQL> -- DEFINE model_name = 'svmspy100'
10:26:49 SQL> -- DEFINE bldtable   = 'bme'
10:26:49 SQL> -- DEFINE scoretable = 'sme'
10:26:49 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:49 SQL> 
10:26:49 SQL> DEFINE target	= '&1'
10:26:49 SQL> DEFINE model_name = '&2'
10:26:49 SQL> DEFINE bldtable	= '&3'
10:26:49 SQL> DEFINE scoretable = '&4'
10:26:49 SQL> DEFINE case_id	= '&5'
10:26:49 SQL> 
10:26:49 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:49 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:49 SQL> 
10:26:49 SQL> -- Builds an SVM model using pl/sql.
10:26:49 SQL> 
10:26:49 SQL> -----------------------------------------------------------------------
10:26:49 SQL> --			    BUILD THE MODEL
10:26:49 SQL> -----------------------------------------------------------------------
10:26:49 SQL> 
10:26:49 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:49 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:49 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:26:49 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:49 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:49 SQL> 
10:26:49 SQL> 
10:26:49 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:49 SQL> --
10:26:49 SQL> -- DROP	TABLE svmc_settings ;
10:26:49 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:49 SQL> -- DELETE svmc_settings;
10:26:49 SQL> 
10:26:49 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:49 SQL> -- this choice to SVM using a settings table.
10:26:49 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:49 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:49 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:49 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:49 SQL> -- models.
10:26:49 SQL> --
10:26:49 SQL> 
10:26:49 SQL> -- Do this once and then comment it out.
10:26:49 SQL> -- That makes script go faster.
10:26:49 SQL> -- BEGIN
10:26:49 SQL> -- -- Populate settings table
10:26:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:49 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:49 SQL> --
10:26:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:49 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:49 SQL> --
10:26:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:49 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:49 SQL> --   COMMIT;
10:26:49 SQL> -- END;
10:26:49 SQL> -- /
10:26:49 SQL> 
10:26:49 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:49 SQL> 
10:26:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:50 SQL> 
10:26:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:50 SQL> 
10:26:50 SQL> --------------------------------
10:26:50 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:50 SQL> --
10:26:50 SQL> 
10:26:50 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:50 SQL> -- 2. Outlier Treatment and
10:26:50 SQL> -- 3. Normalization are performed below.
10:26:50 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:50 SQL> --    normalized here.
10:26:50 SQL> 
10:26:50 SQL> BEGIN
10:26:50   2  	-- Perform missing value treatment for all predictors
10:26:50   3  	-- create miss tables
10:26:50   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:50   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:50   6  
10:26:50   7  	-- populate miss tables
10:26:50   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:50   9  	  miss_table_name => 'svmc_miss_num',
10:26:50  10  	  data_table_name => '&bldtable',
10:26:50  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:50  12  
10:26:50  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:50  14  	  miss_table_name => 'svmc_miss_cat',
10:26:50  15  	  data_table_name => '&bldtable',
10:26:50  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:50  17  
10:26:50  18  	-- xform input data to replace missing values
10:26:50  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:50  20  	  miss_table_name => 'svmc_miss_num',
10:26:50  21  	  data_table_name => '&bldtable',
10:26:50  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:50  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:50  24  	  miss_table_name => 'svmc_miss_cat',
10:26:50  25  	  data_table_name => '&bldtable',
10:26:50  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:50  27  
10:26:50  28  	-- Perform outlier treatment.
10:26:50  29  	-- create clip table
10:26:50  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:50  31  
10:26:50  32  	-- populate clip table
10:26:50  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:50  34  	  clip_table_name => 'svmc_clip',
10:26:50  35  	  data_table_name => '&bldtable',
10:26:50  36  	  tail_frac	  => 0.025,
10:26:50  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:50  38  
10:26:50  39  	-- xform input data to winsorized data
10:26:50  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:50  41  	  clip_table_name => 'svmc_clip',
10:26:50  42  	  data_table_name => '&bldtable',
10:26:50  43  	  xform_view_name => 'svmc_winsor');
10:26:50  44  
10:26:50  45  	-- create normalization table
10:26:50  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:50  47  
10:26:50  48  	-- populate normalization table based on winsorized data
10:26:50  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:50  50  	  norm_table_name => 'svmc_norm',
10:26:50  51  	  data_table_name => 'svmc_winsor',
10:26:50  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:50  53  
10:26:50  54  	-- normalize the original data
10:26:50  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:50  56  	  norm_table_name => 'svmc_norm',
10:26:50  57  	  data_table_name => '&bldtable',
10:26:50  58  	  xform_view_name => 'svmc_build_prep');
10:26:50  59  END;
10:26:50  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:26:50 SQL> 
10:26:50 SQL> ---------------------
10:26:50 SQL> -- CREATE A NEW MODEL
10:26:50 SQL> --
10:26:50 SQL> -- Cleanup old model with the same name for repeat runs
10:26:50 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:50   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.05
10:26:51 SQL> 
10:26:51 SQL> -- Build a new SVM Model
10:26:51 SQL> BEGIN
10:26:51   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:51   3  	  model_name	      => '&model_name',
10:26:51   4  	  mining_function     => dbms_data_mining.classification,
10:26:51   5  	  data_table_name     => 'svmc_build_prep',
10:26:51   6  	  case_id_column_name => '&case_id',
10:26:51   7  	  target_column_name  => '&target',
10:26:51   8  	  settings_table_name => 'svmc_settings');
10:26:51   9  END;
10:26:51  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.90
10:26:53 SQL> 
10:26:53 SQL> -----------------------------------------------------------------------
10:26:53 SQL> --			       APPLY/score THE MODEL
10:26:53 SQL> -----------------------------------------------------------------------
10:26:53 SQL> 
10:26:53 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:53 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:53   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:53   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:53 SQL> -----------------------
10:26:53 SQL> -- PREPARE SCORING DATA
10:26:53 SQL> --
10:26:53 SQL> -- If the data for model creation has been prepared, then the data
10:26:53 SQL> -- to be scored using the model must be prepared in the same manner
10:26:53 SQL> -- in order to obtain meaningful results.
10:26:53 SQL> --
10:26:53 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:53 SQL> -- 2. Normalization
10:26:53 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:53 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:53 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:53 SQL> --
10:26:53 SQL> BEGIN
10:26:53   2  	-- Xform Test data to replace missing values
10:26:53   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:53   4  	  miss_table_name => 'svmc_miss_num',
10:26:53   5  	  data_table_name => '&scoretable',
10:26:53   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:53   7  
10:26:53   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:53   9  	  miss_table_name => 'svmc_miss_cat',
10:26:53  10  	  data_table_name => '&scoretable',
10:26:53  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:53  12  
10:26:53  13  	-- Normalize the data to be scored
10:26:53  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:53  15  	  norm_table_name => 'svmc_norm',
10:26:53  16  	  data_table_name => '&scoretable',
10:26:53  17  	  xform_view_name => 'svmc_apply_prep');
10:26:53  18  END;
10:26:53  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:26:53 SQL> 
10:26:53 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:53 SQL> -- DELETE it if I did:
10:26:53 SQL> DELETE ystkscores
10:26:53   2  WHERE score > 0
10:26:53   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:53   4  -- I need to supply the target attribute name:
10:26:53   5  AND targ = '&1'
10:26:53   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:26:53 SQL> 
10:26:53 SQL> -- We do a drumroll here:
10:26:53 SQL> 
10:26:53 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:53   2  SELECT
10:26:53   3  tkrdate
10:26:53   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:53   5  ,sysdate
10:26:53   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:53   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:53   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:53   9  ,SUBSTR(tkrdate,-10)ydate
10:26:53  10  ,'&1'
10:26:53  11  FROM svmc_apply_prep
10:26:53  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:26:53 SQL> @score1_5min_gattn.sql	2010-02-18 TLT
10:26:53 SQL> --
10:26:53 SQL> -- score1_5min_gattn.sql
10:26:53 SQL> --
10:26:53 SQL> 
10:26:53 SQL> -- Demo:
10:26:53 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:53 SQL> 
10:26:53 SQL> CREATE OR REPLACE VIEW sme AS
10:26:53   2  SELECT
10:26:53   3  tkrdate
10:26:53   4  ,NULL gattn
10:26:53   5  ,g00
10:26:53   6  ,g01
10:26:53   7  ,g02
10:26:53   8  ,g03
10:26:53   9  ,g04
10:26:53  10  ,g05
10:26:53  11  ,g06
10:26:53  12  ,g07
10:26:53  13  ,g08
10:26:53  14  ,g09
10:26:53  15  ,g10
10:26:53  16  ,g11
10:26:53  17  ,g12
10:26:53  18  ,g13
10:26:53  19  ,g14
10:26:53  20  ,g15
10:26:53  21  ,g16
10:26:53  22  ,g17
10:26:53  23  ,g18
10:26:53  24  ,g19
10:26:53  25  ,g20
10:26:53  26  ,g21
10:26:53  27  ,g22
10:26:53  28  ,g23
10:26:53  29  ,g24
10:26:53  30  ,g25
10:26:53  31  ,g26
10:26:53  32  ,g27
10:26:53  33  ,g28
10:26:53  34  ,g29
10:26:53  35  FROM stk_ms
10:26:53  36  WHERE ydate = '&1'
10:26:53  37  AND tkr = '&2'
10:26:53  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-18'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:26:53 SQL> 
10:26:53 SQL> -- rpt
10:26:53 SQL> -- We should see just 1 row:
10:26:53 SQL> 
10:26:53 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:53   2  
10:26:53 SQL> -- Build the model:
10:26:53 SQL> CREATE OR REPLACE VIEW bme AS
10:26:53   2  SELECT
10:26:53   3  tkrdate
10:26:53   4  ,gattn
10:26:53   5  ,g00
10:26:53   6  ,g01
10:26:53   7  ,g02
10:26:53   8  ,g03
10:26:53   9  ,g04
10:26:53  10  ,g05
10:26:53  11  ,g06
10:26:53  12  ,g07
10:26:53  13  ,g08
10:26:53  14  ,g09
10:26:53  15  ,g10
10:26:53  16  ,g11
10:26:53  17  ,g12
10:26:53  18  ,g13
10:26:53  19  ,g14
10:26:53  20  ,g15
10:26:53  21  ,g16
10:26:53  22  ,g17
10:26:53  23  ,g18
10:26:53  24  ,g19
10:26:53  25  ,g20
10:26:53  26  ,g21
10:26:53  27  ,g22
10:26:53  28  ,g23
10:26:53  29  ,g24
10:26:53  30  ,g25
10:26:53  31  ,g26
10:26:53  32  ,g27
10:26:53  33  ,g28
10:26:53  34  ,g29
10:26:53  35  FROM stk_ms
10:26:53  36  WHERE gattn IN('nup','up')
10:26:53  37  -- Use only rows which are older than 1 day:
10:26:53  38  AND 1+ydate < '&1'
10:26:53  39  AND tkr = '&2'
10:26:53  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-18'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:54 SQL> 
10:26:54 SQL> -- rpt
10:26:54 SQL> 
10:26:54 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:54   2  
10:26:54 SQL> SELECT MAX(tkrdate) FROM bme
10:26:54   2  
10:26:54 SQL> -- Now build model from bme and score sme
10:26:54 SQL> @score1.sql gattn
10:26:54 SQL> -- score1.sql
10:26:54 SQL> 
10:26:54 SQL> -- I use this script to send 5 params to score.sql
10:26:54 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:54 SQL> -- Then at the very end of this script I use the model
10:26:54 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:54 SQL> 
10:26:54 SQL> -- I call this script from 2 other scripts:
10:26:54 SQL> -- score1_5min.sql
10:26:54 SQL> -- score1_5min_gattn.sql
10:26:54 SQL> 
10:26:54 SQL> -- The 1st param is the name of the target attribute.
10:26:54 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:54 SQL> 
10:26:54 SQL> -- Demo:
10:26:54 SQL> -- @score1.sql 'gatt'
10:26:54 SQL> -- @score1.sql 'gattn'
10:26:54 SQL> 
10:26:54 SQL> -- Now, I fill up svmc_apply_prep.
10:26:54 SQL> -- I use same model_name used in score.sql
10:26:54 SQL> DEFINE model_name = 'svmspy101'
10:26:54 SQL> DEFINE bldtable	= 'bme'
10:26:54 SQL> DEFINE scoretable = 'sme'
10:26:54 SQL> DEFINE case_id	= 'tkrdate'
10:26:54 SQL> -- Demo:
10:26:54 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:54 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:54 SQL> --
10:26:54 SQL> -- score.sql
10:26:54 SQL> --
10:26:54 SQL> 
10:26:54 SQL> -- usage: score.sql
10:26:54 SQL> 
10:26:54 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:54 SQL> 
10:26:54 SQL> -- DEFINE target	   = 'gatt'
10:26:54 SQL> -- DEFINE model_name = 'svmspy100'
10:26:54 SQL> -- DEFINE bldtable   = 'bme'
10:26:54 SQL> -- DEFINE scoretable = 'sme'
10:26:54 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:54 SQL> 
10:26:54 SQL> DEFINE target	= '&1'
10:26:54 SQL> DEFINE model_name = '&2'
10:26:54 SQL> DEFINE bldtable	= '&3'
10:26:54 SQL> DEFINE scoretable = '&4'
10:26:54 SQL> DEFINE case_id	= '&5'
10:26:54 SQL> 
10:26:54 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:54 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:54 SQL> 
10:26:54 SQL> -- Builds an SVM model using pl/sql.
10:26:54 SQL> 
10:26:54 SQL> -----------------------------------------------------------------------
10:26:54 SQL> --			    BUILD THE MODEL
10:26:54 SQL> -----------------------------------------------------------------------
10:26:54 SQL> 
10:26:54 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:54 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:54 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:54 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:54 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:54 SQL> 
10:26:54 SQL> 
10:26:54 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:54 SQL> --
10:26:54 SQL> -- DROP	TABLE svmc_settings ;
10:26:54 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:54 SQL> -- DELETE svmc_settings;
10:26:54 SQL> 
10:26:54 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:54 SQL> -- this choice to SVM using a settings table.
10:26:54 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:54 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:54 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:54 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:54 SQL> -- models.
10:26:54 SQL> --
10:26:54 SQL> 
10:26:54 SQL> -- Do this once and then comment it out.
10:26:54 SQL> -- That makes script go faster.
10:26:54 SQL> -- BEGIN
10:26:54 SQL> -- -- Populate settings table
10:26:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:54 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:54 SQL> --
10:26:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:54 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:54 SQL> --
10:26:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:54 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:54 SQL> --   COMMIT;
10:26:54 SQL> -- END;
10:26:54 SQL> -- /
10:26:54 SQL> 
10:26:54 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:26:54 SQL> 
10:26:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:26:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:54 SQL> 
10:26:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:54 SQL> 
10:26:54 SQL> --------------------------------
10:26:54 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:54 SQL> --
10:26:54 SQL> 
10:26:54 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:54 SQL> -- 2. Outlier Treatment and
10:26:54 SQL> -- 3. Normalization are performed below.
10:26:54 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:54 SQL> --    normalized here.
10:26:54 SQL> 
10:26:54 SQL> BEGIN
10:26:54   2  	-- Perform missing value treatment for all predictors
10:26:54   3  	-- create miss tables
10:26:54   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:54   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:54   6  
10:26:54   7  	-- populate miss tables
10:26:54   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:54   9  	  miss_table_name => 'svmc_miss_num',
10:26:54  10  	  data_table_name => '&bldtable',
10:26:54  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:54  12  
10:26:54  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:54  14  	  miss_table_name => 'svmc_miss_cat',
10:26:54  15  	  data_table_name => '&bldtable',
10:26:54  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:54  17  
10:26:54  18  	-- xform input data to replace missing values
10:26:54  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:54  20  	  miss_table_name => 'svmc_miss_num',
10:26:54  21  	  data_table_name => '&bldtable',
10:26:54  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:54  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:54  24  	  miss_table_name => 'svmc_miss_cat',
10:26:54  25  	  data_table_name => '&bldtable',
10:26:54  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:54  27  
10:26:54  28  	-- Perform outlier treatment.
10:26:54  29  	-- create clip table
10:26:54  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:54  31  
10:26:54  32  	-- populate clip table
10:26:54  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:54  34  	  clip_table_name => 'svmc_clip',
10:26:54  35  	  data_table_name => '&bldtable',
10:26:54  36  	  tail_frac	  => 0.025,
10:26:54  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:54  38  
10:26:54  39  	-- xform input data to winsorized data
10:26:54  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:54  41  	  clip_table_name => 'svmc_clip',
10:26:54  42  	  data_table_name => '&bldtable',
10:26:54  43  	  xform_view_name => 'svmc_winsor');
10:26:54  44  
10:26:54  45  	-- create normalization table
10:26:54  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:54  47  
10:26:54  48  	-- populate normalization table based on winsorized data
10:26:54  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:54  50  	  norm_table_name => 'svmc_norm',
10:26:54  51  	  data_table_name => 'svmc_winsor',
10:26:54  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:54  53  
10:26:54  54  	-- normalize the original data
10:26:54  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:54  56  	  norm_table_name => 'svmc_norm',
10:26:54  57  	  data_table_name => '&bldtable',
10:26:54  58  	  xform_view_name => 'svmc_build_prep');
10:26:54  59  END;
10:26:54  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:26:54 SQL> 
10:26:54 SQL> ---------------------
10:26:54 SQL> -- CREATE A NEW MODEL
10:26:54 SQL> --
10:26:54 SQL> -- Cleanup old model with the same name for repeat runs
10:26:54 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:54   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.38
10:26:56 SQL> 
10:26:56 SQL> -- Build a new SVM Model
10:26:56 SQL> BEGIN
10:26:56   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:26:56   3  	  model_name	      => '&model_name',
10:26:56   4  	  mining_function     => dbms_data_mining.classification,
10:26:56   5  	  data_table_name     => 'svmc_build_prep',
10:26:56   6  	  case_id_column_name => '&case_id',
10:26:56   7  	  target_column_name  => '&target',
10:26:56   8  	  settings_table_name => 'svmc_settings');
10:26:56   9  END;
10:26:56  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.50
10:26:58 SQL> 
10:26:58 SQL> -----------------------------------------------------------------------
10:26:58 SQL> --			       APPLY/score THE MODEL
10:26:58 SQL> -----------------------------------------------------------------------
10:26:58 SQL> 
10:26:58 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:26:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:26:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:26:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:26:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:26:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:26:58 SQL> -----------------------
10:26:58 SQL> -- PREPARE SCORING DATA
10:26:58 SQL> --
10:26:58 SQL> -- If the data for model creation has been prepared, then the data
10:26:58 SQL> -- to be scored using the model must be prepared in the same manner
10:26:58 SQL> -- in order to obtain meaningful results.
10:26:58 SQL> --
10:26:58 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:58 SQL> -- 2. Normalization
10:26:58 SQL> -- No outlier treatment will be performed during test and apply. The
10:26:58 SQL> -- normalization step is sufficient, since the normalization parameters
10:26:58 SQL> -- already capture the effects of outlier treatment done with build data.
10:26:58 SQL> --
10:26:58 SQL> BEGIN
10:26:58   2  	-- Xform Test data to replace missing values
10:26:58   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:58   4  	  miss_table_name => 'svmc_miss_num',
10:26:58   5  	  data_table_name => '&scoretable',
10:26:58   6  	  xform_view_name => 'xformed_apply_miss_num');
10:26:58   7  
10:26:58   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:58   9  	  miss_table_name => 'svmc_miss_cat',
10:26:58  10  	  data_table_name => '&scoretable',
10:26:58  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:26:58  12  
10:26:58  13  	-- Normalize the data to be scored
10:26:58  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:58  15  	  norm_table_name => 'svmc_norm',
10:26:58  16  	  data_table_name => '&scoretable',
10:26:58  17  	  xform_view_name => 'svmc_apply_prep');
10:26:58  18  END;
10:26:58  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:26:58 SQL> 
10:26:58 SQL> -- Maybe I already collected a score for this tkrdate.
10:26:58 SQL> -- DELETE it if I did:
10:26:58 SQL> DELETE ystkscores
10:26:58   2  WHERE score > 0
10:26:58   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:26:58   4  -- I need to supply the target attribute name:
10:26:58   5  AND targ = '&1'
10:26:58   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:26:58 SQL> 
10:26:58 SQL> -- We do a drumroll here:
10:26:58 SQL> 
10:26:58 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:26:58   2  SELECT
10:26:58   3  tkrdate
10:26:58   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:26:58   5  ,sysdate
10:26:58   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:26:58   7  -- rluck/oracle_sql_demos/substr.sql :
10:26:58   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:26:58   9  ,SUBSTR(tkrdate,-10)ydate
10:26:58  10  ,'&1'
10:26:58  11  FROM svmc_apply_prep
10:26:58  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:26:59 SQL> @score1_5min_gattn.sql	2010-09-16 TLT
10:26:59 SQL> --
10:26:59 SQL> -- score1_5min_gattn.sql
10:26:59 SQL> --
10:26:59 SQL> 
10:26:59 SQL> -- Demo:
10:26:59 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:26:59 SQL> 
10:26:59 SQL> CREATE OR REPLACE VIEW sme AS
10:26:59   2  SELECT
10:26:59   3  tkrdate
10:26:59   4  ,NULL gattn
10:26:59   5  ,g00
10:26:59   6  ,g01
10:26:59   7  ,g02
10:26:59   8  ,g03
10:26:59   9  ,g04
10:26:59  10  ,g05
10:26:59  11  ,g06
10:26:59  12  ,g07
10:26:59  13  ,g08
10:26:59  14  ,g09
10:26:59  15  ,g10
10:26:59  16  ,g11
10:26:59  17  ,g12
10:26:59  18  ,g13
10:26:59  19  ,g14
10:26:59  20  ,g15
10:26:59  21  ,g16
10:26:59  22  ,g17
10:26:59  23  ,g18
10:26:59  24  ,g19
10:26:59  25  ,g20
10:26:59  26  ,g21
10:26:59  27  ,g22
10:26:59  28  ,g23
10:26:59  29  ,g24
10:26:59  30  ,g25
10:26:59  31  ,g26
10:26:59  32  ,g27
10:26:59  33  ,g28
10:26:59  34  ,g29
10:26:59  35  FROM stk_ms
10:26:59  36  WHERE ydate = '&1'
10:26:59  37  AND tkr = '&2'
10:26:59  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-09-16'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:26:59 SQL> 
10:26:59 SQL> -- rpt
10:26:59 SQL> -- We should see just 1 row:
10:26:59 SQL> 
10:26:59 SQL> SELECT COUNT(tkrdate) FROM sme
10:26:59   2  
10:26:59 SQL> -- Build the model:
10:26:59 SQL> CREATE OR REPLACE VIEW bme AS
10:26:59   2  SELECT
10:26:59   3  tkrdate
10:26:59   4  ,gattn
10:26:59   5  ,g00
10:26:59   6  ,g01
10:26:59   7  ,g02
10:26:59   8  ,g03
10:26:59   9  ,g04
10:26:59  10  ,g05
10:26:59  11  ,g06
10:26:59  12  ,g07
10:26:59  13  ,g08
10:26:59  14  ,g09
10:26:59  15  ,g10
10:26:59  16  ,g11
10:26:59  17  ,g12
10:26:59  18  ,g13
10:26:59  19  ,g14
10:26:59  20  ,g15
10:26:59  21  ,g16
10:26:59  22  ,g17
10:26:59  23  ,g18
10:26:59  24  ,g19
10:26:59  25  ,g20
10:26:59  26  ,g21
10:26:59  27  ,g22
10:26:59  28  ,g23
10:26:59  29  ,g24
10:26:59  30  ,g25
10:26:59  31  ,g26
10:26:59  32  ,g27
10:26:59  33  ,g28
10:26:59  34  ,g29
10:26:59  35  FROM stk_ms
10:26:59  36  WHERE gattn IN('nup','up')
10:26:59  37  -- Use only rows which are older than 1 day:
10:26:59  38  AND 1+ydate < '&1'
10:26:59  39  AND tkr = '&2'
10:26:59  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-09-16'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:26:59 SQL> 
10:26:59 SQL> -- rpt
10:26:59 SQL> 
10:26:59 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:26:59   2  
10:26:59 SQL> SELECT MAX(tkrdate) FROM bme
10:26:59   2  
10:26:59 SQL> -- Now build model from bme and score sme
10:26:59 SQL> @score1.sql gattn
10:26:59 SQL> -- score1.sql
10:26:59 SQL> 
10:26:59 SQL> -- I use this script to send 5 params to score.sql
10:26:59 SQL> -- which does the heavy lifting of creating an SVM model.
10:26:59 SQL> -- Then at the very end of this script I use the model
10:26:59 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:26:59 SQL> 
10:26:59 SQL> -- I call this script from 2 other scripts:
10:26:59 SQL> -- score1_5min.sql
10:26:59 SQL> -- score1_5min_gattn.sql
10:26:59 SQL> 
10:26:59 SQL> -- The 1st param is the name of the target attribute.
10:26:59 SQL> -- I like to call my target attributes either gatt or gattn.
10:26:59 SQL> 
10:26:59 SQL> -- Demo:
10:26:59 SQL> -- @score1.sql 'gatt'
10:26:59 SQL> -- @score1.sql 'gattn'
10:26:59 SQL> 
10:26:59 SQL> -- Now, I fill up svmc_apply_prep.
10:26:59 SQL> -- I use same model_name used in score.sql
10:26:59 SQL> DEFINE model_name = 'svmspy101'
10:26:59 SQL> DEFINE bldtable	= 'bme'
10:26:59 SQL> DEFINE scoretable = 'sme'
10:26:59 SQL> DEFINE case_id	= 'tkrdate'
10:26:59 SQL> -- Demo:
10:26:59 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:26:59 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:26:59 SQL> --
10:26:59 SQL> -- score.sql
10:26:59 SQL> --
10:26:59 SQL> 
10:26:59 SQL> -- usage: score.sql
10:26:59 SQL> 
10:26:59 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:26:59 SQL> 
10:26:59 SQL> -- DEFINE target	   = 'gatt'
10:26:59 SQL> -- DEFINE model_name = 'svmspy100'
10:26:59 SQL> -- DEFINE bldtable   = 'bme'
10:26:59 SQL> -- DEFINE scoretable = 'sme'
10:26:59 SQL> -- DEFINE case_id    = 'tkrdate'
10:26:59 SQL> 
10:26:59 SQL> DEFINE target	= '&1'
10:26:59 SQL> DEFINE model_name = '&2'
10:26:59 SQL> DEFINE bldtable	= '&3'
10:26:59 SQL> DEFINE scoretable = '&4'
10:26:59 SQL> DEFINE case_id	= '&5'
10:26:59 SQL> 
10:26:59 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:26:59 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:26:59 SQL> 
10:26:59 SQL> -- Builds an SVM model using pl/sql.
10:26:59 SQL> 
10:26:59 SQL> -----------------------------------------------------------------------
10:26:59 SQL> --			    BUILD THE MODEL
10:26:59 SQL> -----------------------------------------------------------------------
10:26:59 SQL> 
10:26:59 SQL> -- Cleanup old build data preparation objects for repeat runs
10:26:59 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:26:59 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:26:59 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:59 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:26:59 SQL> 
10:26:59 SQL> 
10:26:59 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:26:59 SQL> --
10:26:59 SQL> -- DROP	TABLE svmc_settings ;
10:26:59 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:26:59 SQL> -- DELETE svmc_settings;
10:26:59 SQL> 
10:26:59 SQL> -- The default classification algorithm is Naive Bayes. So override
10:26:59 SQL> -- this choice to SVM using a settings table.
10:26:59 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:26:59 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:26:59 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:26:59 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:26:59 SQL> -- models.
10:26:59 SQL> --
10:26:59 SQL> 
10:26:59 SQL> -- Do this once and then comment it out.
10:26:59 SQL> -- That makes script go faster.
10:26:59 SQL> -- BEGIN
10:26:59 SQL> -- -- Populate settings table
10:26:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:59 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:26:59 SQL> --
10:26:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:59 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:26:59 SQL> --
10:26:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:26:59 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:26:59 SQL> --   COMMIT;
10:26:59 SQL> -- END;
10:26:59 SQL> -- /
10:26:59 SQL> 
10:26:59 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:26:59 SQL> 
10:26:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:26:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:26:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:26:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:59 SQL> 
10:26:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:26:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:26:59 SQL> 
10:26:59 SQL> --------------------------------
10:26:59 SQL> -- PREPARE BUILD (TRAINING) DATA
10:26:59 SQL> --
10:26:59 SQL> 
10:26:59 SQL> -- 1. Missing Value treatment for all Predictors and
10:26:59 SQL> -- 2. Outlier Treatment and
10:26:59 SQL> -- 3. Normalization are performed below.
10:26:59 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:26:59 SQL> --    normalized here.
10:26:59 SQL> 
10:26:59 SQL> BEGIN
10:26:59   2  	-- Perform missing value treatment for all predictors
10:26:59   3  	-- create miss tables
10:26:59   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:26:59   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:26:59   6  
10:26:59   7  	-- populate miss tables
10:26:59   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:26:59   9  	  miss_table_name => 'svmc_miss_num',
10:26:59  10  	  data_table_name => '&bldtable',
10:26:59  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:59  12  
10:26:59  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:26:59  14  	  miss_table_name => 'svmc_miss_cat',
10:26:59  15  	  data_table_name => '&bldtable',
10:26:59  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:59  17  
10:26:59  18  	-- xform input data to replace missing values
10:26:59  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:26:59  20  	  miss_table_name => 'svmc_miss_num',
10:26:59  21  	  data_table_name => '&bldtable',
10:26:59  22  	  xform_view_name => 'xformed_build_miss_num');
10:26:59  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:26:59  24  	  miss_table_name => 'svmc_miss_cat',
10:26:59  25  	  data_table_name => '&bldtable',
10:26:59  26  	  xform_view_name => 'xformed_build_miss_cat');
10:26:59  27  
10:26:59  28  	-- Perform outlier treatment.
10:26:59  29  	-- create clip table
10:26:59  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:26:59  31  
10:26:59  32  	-- populate clip table
10:26:59  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:26:59  34  	  clip_table_name => 'svmc_clip',
10:26:59  35  	  data_table_name => '&bldtable',
10:26:59  36  	  tail_frac	  => 0.025,
10:26:59  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:59  38  
10:26:59  39  	-- xform input data to winsorized data
10:26:59  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:26:59  41  	  clip_table_name => 'svmc_clip',
10:26:59  42  	  data_table_name => '&bldtable',
10:26:59  43  	  xform_view_name => 'svmc_winsor');
10:26:59  44  
10:26:59  45  	-- create normalization table
10:26:59  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:26:59  47  
10:26:59  48  	-- populate normalization table based on winsorized data
10:26:59  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:26:59  50  	  norm_table_name => 'svmc_norm',
10:26:59  51  	  data_table_name => 'svmc_winsor',
10:26:59  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:26:59  53  
10:26:59  54  	-- normalize the original data
10:26:59  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:26:59  56  	  norm_table_name => 'svmc_norm',
10:26:59  57  	  data_table_name => '&bldtable',
10:26:59  58  	  xform_view_name => 'svmc_build_prep');
10:26:59  59  END;
10:26:59  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:26:59 SQL> 
10:26:59 SQL> ---------------------
10:26:59 SQL> -- CREATE A NEW MODEL
10:26:59 SQL> --
10:26:59 SQL> -- Cleanup old model with the same name for repeat runs
10:26:59 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:26:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:26:59   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.95
10:27:00 SQL> 
10:27:00 SQL> -- Build a new SVM Model
10:27:00 SQL> BEGIN
10:27:00   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:00   3  	  model_name	      => '&model_name',
10:27:00   4  	  mining_function     => dbms_data_mining.classification,
10:27:00   5  	  data_table_name     => 'svmc_build_prep',
10:27:00   6  	  case_id_column_name => '&case_id',
10:27:00   7  	  target_column_name  => '&target',
10:27:00   8  	  settings_table_name => 'svmc_settings');
10:27:00   9  END;
10:27:00  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.17
10:27:02 SQL> 
10:27:02 SQL> -----------------------------------------------------------------------
10:27:02 SQL> --			       APPLY/score THE MODEL
10:27:02 SQL> -----------------------------------------------------------------------
10:27:02 SQL> 
10:27:02 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:02 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:02   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:02   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:03 SQL> -----------------------
10:27:03 SQL> -- PREPARE SCORING DATA
10:27:03 SQL> --
10:27:03 SQL> -- If the data for model creation has been prepared, then the data
10:27:03 SQL> -- to be scored using the model must be prepared in the same manner
10:27:03 SQL> -- in order to obtain meaningful results.
10:27:03 SQL> --
10:27:03 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:03 SQL> -- 2. Normalization
10:27:03 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:03 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:03 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:03 SQL> --
10:27:03 SQL> BEGIN
10:27:03   2  	-- Xform Test data to replace missing values
10:27:03   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:03   4  	  miss_table_name => 'svmc_miss_num',
10:27:03   5  	  data_table_name => '&scoretable',
10:27:03   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:03   7  
10:27:03   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:03   9  	  miss_table_name => 'svmc_miss_cat',
10:27:03  10  	  data_table_name => '&scoretable',
10:27:03  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:03  12  
10:27:03  13  	-- Normalize the data to be scored
10:27:03  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:03  15  	  norm_table_name => 'svmc_norm',
10:27:03  16  	  data_table_name => '&scoretable',
10:27:03  17  	  xform_view_name => 'svmc_apply_prep');
10:27:03  18  END;
10:27:03  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.33
10:27:03 SQL> 
10:27:03 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:03 SQL> -- DELETE it if I did:
10:27:03 SQL> DELETE ystkscores
10:27:03   2  WHERE score > 0
10:27:03   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:03   4  -- I need to supply the target attribute name:
10:27:03   5  AND targ = '&1'
10:27:03   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:03 SQL> 
10:27:03 SQL> -- We do a drumroll here:
10:27:03 SQL> 
10:27:03 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:03   2  SELECT
10:27:03   3  tkrdate
10:27:03   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:03   5  ,sysdate
10:27:03   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:03   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:03   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:03   9  ,SUBSTR(tkrdate,-10)ydate
10:27:03  10  ,'&1'
10:27:03  11  FROM svmc_apply_prep
10:27:03  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:27:03 SQL> @score1_5min.sql	      2010-02-26 TLT
10:27:03 SQL> --
10:27:03 SQL> -- score1_5min.sql
10:27:03 SQL> --
10:27:03 SQL> 
10:27:03 SQL> -- Demo:
10:27:03 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:03 SQL> 
10:27:03 SQL> CREATE OR REPLACE VIEW sme AS
10:27:03   2  SELECT
10:27:03   3  tkrdate
10:27:03   4  ,NULL gatt
10:27:03   5  ,g00
10:27:03   6  ,g01
10:27:03   7  ,g02
10:27:03   8  ,g03
10:27:03   9  ,g04
10:27:03  10  ,g05
10:27:03  11  ,g06
10:27:03  12  ,g07
10:27:03  13  ,g08
10:27:03  14  ,g09
10:27:03  15  ,g10
10:27:03  16  ,g11
10:27:03  17  ,g12
10:27:03  18  ,g13
10:27:03  19  ,g14
10:27:03  20  ,g15
10:27:03  21  ,g16
10:27:03  22  ,g17
10:27:03  23  ,g18
10:27:03  24  ,g19
10:27:03  25  ,g20
10:27:03  26  ,g21
10:27:03  27  ,g22
10:27:03  28  ,g23
10:27:03  29  ,g24
10:27:03  30  ,g25
10:27:03  31  ,g26
10:27:03  32  ,g27
10:27:03  33  ,g28
10:27:03  34  ,g29
10:27:03  35  FROM stk_ms
10:27:03  36  WHERE ydate = '&1'
10:27:03  37  AND tkr = '&2'
10:27:03  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-26'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.09
10:27:03 SQL> 
10:27:03 SQL> -- rpt
10:27:03 SQL> -- We should see just 1 row:
10:27:03 SQL> 
10:27:03 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:03   2  
10:27:03 SQL> -- Build the model:
10:27:03 SQL> CREATE OR REPLACE VIEW bme AS
10:27:03   2  SELECT
10:27:03   3  tkrdate
10:27:03   4  ,gatt
10:27:03   5  ,g00
10:27:03   6  ,g01
10:27:03   7  ,g02
10:27:03   8  ,g03
10:27:03   9  ,g04
10:27:03  10  ,g05
10:27:03  11  ,g06
10:27:03  12  ,g07
10:27:03  13  ,g08
10:27:03  14  ,g09
10:27:03  15  ,g10
10:27:03  16  ,g11
10:27:03  17  ,g12
10:27:03  18  ,g13
10:27:03  19  ,g14
10:27:03  20  ,g15
10:27:03  21  ,g16
10:27:03  22  ,g17
10:27:03  23  ,g18
10:27:03  24  ,g19
10:27:03  25  ,g20
10:27:03  26  ,g21
10:27:03  27  ,g22
10:27:03  28  ,g23
10:27:03  29  ,g24
10:27:03  30  ,g25
10:27:03  31  ,g26
10:27:03  32  ,g27
10:27:03  33  ,g28
10:27:03  34  ,g29
10:27:03  35  FROM stk_ms
10:27:03  36  WHERE gatt IN('nup','up')
10:27:03  37  -- Use only rows which are older than 1 day:
10:27:03  38  AND 1+ydate < '&1'
10:27:03  39  AND tkr = '&2'
10:27:03  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-26'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:03 SQL> 
10:27:03 SQL> -- rpt
10:27:03 SQL> 
10:27:03 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:03   2  
10:27:03 SQL> SELECT MAX(tkrdate) FROM bme
10:27:03   2  
10:27:03 SQL> -- Now build model from bme and score sme
10:27:03 SQL> @score1.sql gatt
10:27:03 SQL> -- score1.sql
10:27:03 SQL> 
10:27:03 SQL> -- I use this script to send 5 params to score.sql
10:27:03 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:03 SQL> -- Then at the very end of this script I use the model
10:27:03 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:03 SQL> 
10:27:03 SQL> -- I call this script from 2 other scripts:
10:27:03 SQL> -- score1_5min.sql
10:27:03 SQL> -- score1_5min_gattn.sql
10:27:03 SQL> 
10:27:03 SQL> -- The 1st param is the name of the target attribute.
10:27:03 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:03 SQL> 
10:27:03 SQL> -- Demo:
10:27:03 SQL> -- @score1.sql 'gatt'
10:27:03 SQL> -- @score1.sql 'gattn'
10:27:03 SQL> 
10:27:03 SQL> -- Now, I fill up svmc_apply_prep.
10:27:03 SQL> -- I use same model_name used in score.sql
10:27:03 SQL> DEFINE model_name = 'svmspy101'
10:27:03 SQL> DEFINE bldtable	= 'bme'
10:27:03 SQL> DEFINE scoretable = 'sme'
10:27:03 SQL> DEFINE case_id	= 'tkrdate'
10:27:03 SQL> -- Demo:
10:27:03 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:03 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:03 SQL> --
10:27:03 SQL> -- score.sql
10:27:03 SQL> --
10:27:03 SQL> 
10:27:03 SQL> -- usage: score.sql
10:27:03 SQL> 
10:27:03 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:03 SQL> 
10:27:03 SQL> -- DEFINE target	   = 'gatt'
10:27:03 SQL> -- DEFINE model_name = 'svmspy100'
10:27:03 SQL> -- DEFINE bldtable   = 'bme'
10:27:03 SQL> -- DEFINE scoretable = 'sme'
10:27:03 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:03 SQL> 
10:27:03 SQL> DEFINE target	= '&1'
10:27:03 SQL> DEFINE model_name = '&2'
10:27:03 SQL> DEFINE bldtable	= '&3'
10:27:03 SQL> DEFINE scoretable = '&4'
10:27:03 SQL> DEFINE case_id	= '&5'
10:27:03 SQL> 
10:27:03 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:03 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:03 SQL> 
10:27:03 SQL> -- Builds an SVM model using pl/sql.
10:27:03 SQL> 
10:27:03 SQL> -----------------------------------------------------------------------
10:27:03 SQL> --			    BUILD THE MODEL
10:27:03 SQL> -----------------------------------------------------------------------
10:27:03 SQL> 
10:27:03 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:03 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:27:03 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:03 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:03 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:03 SQL> 
10:27:03 SQL> 
10:27:03 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:03 SQL> --
10:27:03 SQL> -- DROP	TABLE svmc_settings ;
10:27:03 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:03 SQL> -- DELETE svmc_settings;
10:27:03 SQL> 
10:27:03 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:03 SQL> -- this choice to SVM using a settings table.
10:27:03 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:03 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:03 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:03 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:03 SQL> -- models.
10:27:03 SQL> --
10:27:03 SQL> 
10:27:03 SQL> -- Do this once and then comment it out.
10:27:03 SQL> -- That makes script go faster.
10:27:03 SQL> -- BEGIN
10:27:03 SQL> -- -- Populate settings table
10:27:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:03 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:03 SQL> --
10:27:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:03 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:03 SQL> --
10:27:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:03 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:03 SQL> --   COMMIT;
10:27:03 SQL> -- END;
10:27:03 SQL> -- /
10:27:03 SQL> 
10:27:03 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:03 SQL> 
10:27:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:03 SQL> 
10:27:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:03 SQL> 
10:27:03 SQL> --------------------------------
10:27:03 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:03 SQL> --
10:27:03 SQL> 
10:27:03 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:03 SQL> -- 2. Outlier Treatment and
10:27:03 SQL> -- 3. Normalization are performed below.
10:27:03 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:03 SQL> --    normalized here.
10:27:03 SQL> 
10:27:03 SQL> BEGIN
10:27:03   2  	-- Perform missing value treatment for all predictors
10:27:03   3  	-- create miss tables
10:27:03   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:03   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:03   6  
10:27:03   7  	-- populate miss tables
10:27:03   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:03   9  	  miss_table_name => 'svmc_miss_num',
10:27:03  10  	  data_table_name => '&bldtable',
10:27:03  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:03  12  
10:27:03  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:03  14  	  miss_table_name => 'svmc_miss_cat',
10:27:03  15  	  data_table_name => '&bldtable',
10:27:03  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:03  17  
10:27:03  18  	-- xform input data to replace missing values
10:27:03  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:03  20  	  miss_table_name => 'svmc_miss_num',
10:27:03  21  	  data_table_name => '&bldtable',
10:27:03  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:03  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:03  24  	  miss_table_name => 'svmc_miss_cat',
10:27:03  25  	  data_table_name => '&bldtable',
10:27:03  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:03  27  
10:27:03  28  	-- Perform outlier treatment.
10:27:03  29  	-- create clip table
10:27:03  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:03  31  
10:27:03  32  	-- populate clip table
10:27:03  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:03  34  	  clip_table_name => 'svmc_clip',
10:27:03  35  	  data_table_name => '&bldtable',
10:27:03  36  	  tail_frac	  => 0.025,
10:27:03  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:03  38  
10:27:03  39  	-- xform input data to winsorized data
10:27:03  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:03  41  	  clip_table_name => 'svmc_clip',
10:27:03  42  	  data_table_name => '&bldtable',
10:27:03  43  	  xform_view_name => 'svmc_winsor');
10:27:03  44  
10:27:03  45  	-- create normalization table
10:27:03  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:03  47  
10:27:03  48  	-- populate normalization table based on winsorized data
10:27:03  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:03  50  	  norm_table_name => 'svmc_norm',
10:27:03  51  	  data_table_name => 'svmc_winsor',
10:27:03  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:03  53  
10:27:03  54  	-- normalize the original data
10:27:03  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:03  56  	  norm_table_name => 'svmc_norm',
10:27:03  57  	  data_table_name => '&bldtable',
10:27:03  58  	  xform_view_name => 'svmc_build_prep');
10:27:03  59  END;
10:27:03  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:27:04 SQL> 
10:27:04 SQL> ---------------------
10:27:04 SQL> -- CREATE A NEW MODEL
10:27:04 SQL> --
10:27:04 SQL> -- Cleanup old model with the same name for repeat runs
10:27:04 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:04   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.02
10:27:05 SQL> 
10:27:05 SQL> -- Build a new SVM Model
10:27:05 SQL> BEGIN
10:27:05   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:05   3  	  model_name	      => '&model_name',
10:27:05   4  	  mining_function     => dbms_data_mining.classification,
10:27:05   5  	  data_table_name     => 'svmc_build_prep',
10:27:05   6  	  case_id_column_name => '&case_id',
10:27:05   7  	  target_column_name  => '&target',
10:27:05   8  	  settings_table_name => 'svmc_settings');
10:27:05   9  END;
10:27:05  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.40
10:27:07 SQL> 
10:27:07 SQL> -----------------------------------------------------------------------
10:27:07 SQL> --			       APPLY/score THE MODEL
10:27:07 SQL> -----------------------------------------------------------------------
10:27:07 SQL> 
10:27:07 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:07 SQL> -----------------------
10:27:07 SQL> -- PREPARE SCORING DATA
10:27:07 SQL> --
10:27:07 SQL> -- If the data for model creation has been prepared, then the data
10:27:07 SQL> -- to be scored using the model must be prepared in the same manner
10:27:07 SQL> -- in order to obtain meaningful results.
10:27:07 SQL> --
10:27:07 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:07 SQL> -- 2. Normalization
10:27:07 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:07 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:07 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:07 SQL> --
10:27:07 SQL> BEGIN
10:27:07   2  	-- Xform Test data to replace missing values
10:27:07   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:07   4  	  miss_table_name => 'svmc_miss_num',
10:27:07   5  	  data_table_name => '&scoretable',
10:27:07   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:07   7  
10:27:07   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:07   9  	  miss_table_name => 'svmc_miss_cat',
10:27:07  10  	  data_table_name => '&scoretable',
10:27:07  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:07  12  
10:27:07  13  	-- Normalize the data to be scored
10:27:07  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:07  15  	  norm_table_name => 'svmc_norm',
10:27:07  16  	  data_table_name => '&scoretable',
10:27:07  17  	  xform_view_name => 'svmc_apply_prep');
10:27:07  18  END;
10:27:07  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:27:08 SQL> 
10:27:08 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:08 SQL> -- DELETE it if I did:
10:27:08 SQL> DELETE ystkscores
10:27:08   2  WHERE score > 0
10:27:08   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:08   4  -- I need to supply the target attribute name:
10:27:08   5  AND targ = '&1'
10:27:08   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:08 SQL> 
10:27:08 SQL> -- We do a drumroll here:
10:27:08 SQL> 
10:27:08 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:08   2  SELECT
10:27:08   3  tkrdate
10:27:08   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:08   5  ,sysdate
10:27:08   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:08   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:08   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:08   9  ,SUBSTR(tkrdate,-10)ydate
10:27:08  10  ,'&1'
10:27:08  11  FROM svmc_apply_prep
10:27:08  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:27:08 SQL> @score1_5min_gattn.sql	2010-09-10 TLT
10:27:08 SQL> --
10:27:08 SQL> -- score1_5min_gattn.sql
10:27:08 SQL> --
10:27:08 SQL> 
10:27:08 SQL> -- Demo:
10:27:08 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:27:08 SQL> 
10:27:08 SQL> CREATE OR REPLACE VIEW sme AS
10:27:08   2  SELECT
10:27:08   3  tkrdate
10:27:08   4  ,NULL gattn
10:27:08   5  ,g00
10:27:08   6  ,g01
10:27:08   7  ,g02
10:27:08   8  ,g03
10:27:08   9  ,g04
10:27:08  10  ,g05
10:27:08  11  ,g06
10:27:08  12  ,g07
10:27:08  13  ,g08
10:27:08  14  ,g09
10:27:08  15  ,g10
10:27:08  16  ,g11
10:27:08  17  ,g12
10:27:08  18  ,g13
10:27:08  19  ,g14
10:27:08  20  ,g15
10:27:08  21  ,g16
10:27:08  22  ,g17
10:27:08  23  ,g18
10:27:08  24  ,g19
10:27:08  25  ,g20
10:27:08  26  ,g21
10:27:08  27  ,g22
10:27:08  28  ,g23
10:27:08  29  ,g24
10:27:08  30  ,g25
10:27:08  31  ,g26
10:27:08  32  ,g27
10:27:08  33  ,g28
10:27:08  34  ,g29
10:27:08  35  FROM stk_ms
10:27:08  36  WHERE ydate = '&1'
10:27:08  37  AND tkr = '&2'
10:27:08  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-09-10'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:08 SQL> 
10:27:08 SQL> -- rpt
10:27:08 SQL> -- We should see just 1 row:
10:27:08 SQL> 
10:27:08 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:08   2  
10:27:08 SQL> -- Build the model:
10:27:08 SQL> CREATE OR REPLACE VIEW bme AS
10:27:08   2  SELECT
10:27:08   3  tkrdate
10:27:08   4  ,gattn
10:27:08   5  ,g00
10:27:08   6  ,g01
10:27:08   7  ,g02
10:27:08   8  ,g03
10:27:08   9  ,g04
10:27:08  10  ,g05
10:27:08  11  ,g06
10:27:08  12  ,g07
10:27:08  13  ,g08
10:27:08  14  ,g09
10:27:08  15  ,g10
10:27:08  16  ,g11
10:27:08  17  ,g12
10:27:08  18  ,g13
10:27:08  19  ,g14
10:27:08  20  ,g15
10:27:08  21  ,g16
10:27:08  22  ,g17
10:27:08  23  ,g18
10:27:08  24  ,g19
10:27:08  25  ,g20
10:27:08  26  ,g21
10:27:08  27  ,g22
10:27:08  28  ,g23
10:27:08  29  ,g24
10:27:08  30  ,g25
10:27:08  31  ,g26
10:27:08  32  ,g27
10:27:08  33  ,g28
10:27:08  34  ,g29
10:27:08  35  FROM stk_ms
10:27:08  36  WHERE gattn IN('nup','up')
10:27:08  37  -- Use only rows which are older than 1 day:
10:27:08  38  AND 1+ydate < '&1'
10:27:08  39  AND tkr = '&2'
10:27:08  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-09-10'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:08 SQL> 
10:27:08 SQL> -- rpt
10:27:08 SQL> 
10:27:08 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:27:08   2  
10:27:08 SQL> SELECT MAX(tkrdate) FROM bme
10:27:08   2  
10:27:08 SQL> -- Now build model from bme and score sme
10:27:08 SQL> @score1.sql gattn
10:27:08 SQL> -- score1.sql
10:27:08 SQL> 
10:27:08 SQL> -- I use this script to send 5 params to score.sql
10:27:08 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:08 SQL> -- Then at the very end of this script I use the model
10:27:08 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:08 SQL> 
10:27:08 SQL> -- I call this script from 2 other scripts:
10:27:08 SQL> -- score1_5min.sql
10:27:08 SQL> -- score1_5min_gattn.sql
10:27:08 SQL> 
10:27:08 SQL> -- The 1st param is the name of the target attribute.
10:27:08 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:08 SQL> 
10:27:08 SQL> -- Demo:
10:27:08 SQL> -- @score1.sql 'gatt'
10:27:08 SQL> -- @score1.sql 'gattn'
10:27:08 SQL> 
10:27:08 SQL> -- Now, I fill up svmc_apply_prep.
10:27:08 SQL> -- I use same model_name used in score.sql
10:27:08 SQL> DEFINE model_name = 'svmspy101'
10:27:08 SQL> DEFINE bldtable	= 'bme'
10:27:08 SQL> DEFINE scoretable = 'sme'
10:27:08 SQL> DEFINE case_id	= 'tkrdate'
10:27:08 SQL> -- Demo:
10:27:08 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:08 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:08 SQL> --
10:27:08 SQL> -- score.sql
10:27:08 SQL> --
10:27:08 SQL> 
10:27:08 SQL> -- usage: score.sql
10:27:08 SQL> 
10:27:08 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:08 SQL> 
10:27:08 SQL> -- DEFINE target	   = 'gatt'
10:27:08 SQL> -- DEFINE model_name = 'svmspy100'
10:27:08 SQL> -- DEFINE bldtable   = 'bme'
10:27:08 SQL> -- DEFINE scoretable = 'sme'
10:27:08 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:08 SQL> 
10:27:08 SQL> DEFINE target	= '&1'
10:27:08 SQL> DEFINE model_name = '&2'
10:27:08 SQL> DEFINE bldtable	= '&3'
10:27:08 SQL> DEFINE scoretable = '&4'
10:27:08 SQL> DEFINE case_id	= '&5'
10:27:08 SQL> 
10:27:08 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:08 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:08 SQL> 
10:27:08 SQL> -- Builds an SVM model using pl/sql.
10:27:08 SQL> 
10:27:08 SQL> -----------------------------------------------------------------------
10:27:08 SQL> --			    BUILD THE MODEL
10:27:08 SQL> -----------------------------------------------------------------------
10:27:08 SQL> 
10:27:08 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:08 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:27:08 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:08 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:08 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:08 SQL> 
10:27:08 SQL> 
10:27:08 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:08 SQL> --
10:27:08 SQL> -- DROP	TABLE svmc_settings ;
10:27:08 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:08 SQL> -- DELETE svmc_settings;
10:27:08 SQL> 
10:27:08 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:08 SQL> -- this choice to SVM using a settings table.
10:27:08 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:08 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:08 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:08 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:08 SQL> -- models.
10:27:08 SQL> --
10:27:08 SQL> 
10:27:08 SQL> -- Do this once and then comment it out.
10:27:08 SQL> -- That makes script go faster.
10:27:08 SQL> -- BEGIN
10:27:08 SQL> -- -- Populate settings table
10:27:08 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:08 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:08 SQL> --
10:27:08 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:08 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:08 SQL> --
10:27:08 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:08 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:08 SQL> --   COMMIT;
10:27:08 SQL> -- END;
10:27:08 SQL> -- /
10:27:08 SQL> 
10:27:08 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:27:08 SQL> 
10:27:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:08 SQL> 
10:27:08 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:08   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.13
10:27:08 SQL> 
10:27:08 SQL> --------------------------------
10:27:08 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:08 SQL> --
10:27:08 SQL> 
10:27:08 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:08 SQL> -- 2. Outlier Treatment and
10:27:08 SQL> -- 3. Normalization are performed below.
10:27:08 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:08 SQL> --    normalized here.
10:27:08 SQL> 
10:27:08 SQL> BEGIN
10:27:08   2  	-- Perform missing value treatment for all predictors
10:27:08   3  	-- create miss tables
10:27:08   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:08   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:08   6  
10:27:08   7  	-- populate miss tables
10:27:08   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:08   9  	  miss_table_name => 'svmc_miss_num',
10:27:08  10  	  data_table_name => '&bldtable',
10:27:08  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:08  12  
10:27:08  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:08  14  	  miss_table_name => 'svmc_miss_cat',
10:27:08  15  	  data_table_name => '&bldtable',
10:27:08  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:08  17  
10:27:08  18  	-- xform input data to replace missing values
10:27:08  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:08  20  	  miss_table_name => 'svmc_miss_num',
10:27:08  21  	  data_table_name => '&bldtable',
10:27:08  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:08  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:08  24  	  miss_table_name => 'svmc_miss_cat',
10:27:08  25  	  data_table_name => '&bldtable',
10:27:08  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:08  27  
10:27:08  28  	-- Perform outlier treatment.
10:27:08  29  	-- create clip table
10:27:08  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:08  31  
10:27:08  32  	-- populate clip table
10:27:08  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:08  34  	  clip_table_name => 'svmc_clip',
10:27:08  35  	  data_table_name => '&bldtable',
10:27:08  36  	  tail_frac	  => 0.025,
10:27:08  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:08  38  
10:27:08  39  	-- xform input data to winsorized data
10:27:08  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:08  41  	  clip_table_name => 'svmc_clip',
10:27:08  42  	  data_table_name => '&bldtable',
10:27:08  43  	  xform_view_name => 'svmc_winsor');
10:27:08  44  
10:27:08  45  	-- create normalization table
10:27:08  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:08  47  
10:27:08  48  	-- populate normalization table based on winsorized data
10:27:08  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:08  50  	  norm_table_name => 'svmc_norm',
10:27:08  51  	  data_table_name => 'svmc_winsor',
10:27:08  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:08  53  
10:27:08  54  	-- normalize the original data
10:27:08  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:08  56  	  norm_table_name => 'svmc_norm',
10:27:08  57  	  data_table_name => '&bldtable',
10:27:08  58  	  xform_view_name => 'svmc_build_prep');
10:27:08  59  END;
10:27:08  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:27:09 SQL> 
10:27:09 SQL> ---------------------
10:27:09 SQL> -- CREATE A NEW MODEL
10:27:09 SQL> --
10:27:09 SQL> -- Cleanup old model with the same name for repeat runs
10:27:09 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:09   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.95
10:27:09 SQL> 
10:27:09 SQL> -- Build a new SVM Model
10:27:09 SQL> BEGIN
10:27:09   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:09   3  	  model_name	      => '&model_name',
10:27:09   4  	  mining_function     => dbms_data_mining.classification,
10:27:09   5  	  data_table_name     => 'svmc_build_prep',
10:27:09   6  	  case_id_column_name => '&case_id',
10:27:09   7  	  target_column_name  => '&target',
10:27:09   8  	  settings_table_name => 'svmc_settings');
10:27:09   9  END;
10:27:09  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.44
10:27:12 SQL> 
10:27:12 SQL> -----------------------------------------------------------------------
10:27:12 SQL> --			       APPLY/score THE MODEL
10:27:12 SQL> -----------------------------------------------------------------------
10:27:12 SQL> 
10:27:12 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:12 SQL> -----------------------
10:27:12 SQL> -- PREPARE SCORING DATA
10:27:12 SQL> --
10:27:12 SQL> -- If the data for model creation has been prepared, then the data
10:27:12 SQL> -- to be scored using the model must be prepared in the same manner
10:27:12 SQL> -- in order to obtain meaningful results.
10:27:12 SQL> --
10:27:12 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:12 SQL> -- 2. Normalization
10:27:12 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:12 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:12 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:12 SQL> --
10:27:12 SQL> BEGIN
10:27:12   2  	-- Xform Test data to replace missing values
10:27:12   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:12   4  	  miss_table_name => 'svmc_miss_num',
10:27:12   5  	  data_table_name => '&scoretable',
10:27:12   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:12   7  
10:27:12   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:12   9  	  miss_table_name => 'svmc_miss_cat',
10:27:12  10  	  data_table_name => '&scoretable',
10:27:12  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:12  12  
10:27:12  13  	-- Normalize the data to be scored
10:27:12  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:12  15  	  norm_table_name => 'svmc_norm',
10:27:12  16  	  data_table_name => '&scoretable',
10:27:12  17  	  xform_view_name => 'svmc_apply_prep');
10:27:12  18  END;
10:27:12  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:12 SQL> 
10:27:12 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:12 SQL> -- DELETE it if I did:
10:27:12 SQL> DELETE ystkscores
10:27:12   2  WHERE score > 0
10:27:12   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:12   4  -- I need to supply the target attribute name:
10:27:12   5  AND targ = '&1'
10:27:12   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:27:12 SQL> 
10:27:12 SQL> -- We do a drumroll here:
10:27:12 SQL> 
10:27:12 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:12   2  SELECT
10:27:12   3  tkrdate
10:27:12   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:12   5  ,sysdate
10:27:12   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:12   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:12   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:12   9  ,SUBSTR(tkrdate,-10)ydate
10:27:12  10  ,'&1'
10:27:12  11  FROM svmc_apply_prep
10:27:12  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:27:12 SQL> @score1_5min.sql	      2009-12-16 TLT
10:27:12 SQL> --
10:27:12 SQL> -- score1_5min.sql
10:27:12 SQL> --
10:27:12 SQL> 
10:27:12 SQL> -- Demo:
10:27:12 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:12 SQL> 
10:27:12 SQL> CREATE OR REPLACE VIEW sme AS
10:27:12   2  SELECT
10:27:12   3  tkrdate
10:27:12   4  ,NULL gatt
10:27:12   5  ,g00
10:27:12   6  ,g01
10:27:12   7  ,g02
10:27:12   8  ,g03
10:27:12   9  ,g04
10:27:12  10  ,g05
10:27:12  11  ,g06
10:27:12  12  ,g07
10:27:12  13  ,g08
10:27:12  14  ,g09
10:27:12  15  ,g10
10:27:12  16  ,g11
10:27:12  17  ,g12
10:27:12  18  ,g13
10:27:12  19  ,g14
10:27:12  20  ,g15
10:27:12  21  ,g16
10:27:12  22  ,g17
10:27:12  23  ,g18
10:27:12  24  ,g19
10:27:12  25  ,g20
10:27:12  26  ,g21
10:27:12  27  ,g22
10:27:12  28  ,g23
10:27:12  29  ,g24
10:27:12  30  ,g25
10:27:12  31  ,g26
10:27:12  32  ,g27
10:27:12  33  ,g28
10:27:12  34  ,g29
10:27:12  35  FROM stk_ms
10:27:12  36  WHERE ydate = '&1'
10:27:12  37  AND tkr = '&2'
10:27:12  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-16'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:12 SQL> 
10:27:12 SQL> -- rpt
10:27:12 SQL> -- We should see just 1 row:
10:27:12 SQL> 
10:27:12 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:12   2  
10:27:12 SQL> -- Build the model:
10:27:12 SQL> CREATE OR REPLACE VIEW bme AS
10:27:12   2  SELECT
10:27:12   3  tkrdate
10:27:12   4  ,gatt
10:27:12   5  ,g00
10:27:12   6  ,g01
10:27:12   7  ,g02
10:27:12   8  ,g03
10:27:12   9  ,g04
10:27:12  10  ,g05
10:27:12  11  ,g06
10:27:12  12  ,g07
10:27:12  13  ,g08
10:27:12  14  ,g09
10:27:12  15  ,g10
10:27:12  16  ,g11
10:27:12  17  ,g12
10:27:12  18  ,g13
10:27:12  19  ,g14
10:27:12  20  ,g15
10:27:12  21  ,g16
10:27:12  22  ,g17
10:27:12  23  ,g18
10:27:12  24  ,g19
10:27:12  25  ,g20
10:27:12  26  ,g21
10:27:12  27  ,g22
10:27:12  28  ,g23
10:27:12  29  ,g24
10:27:12  30  ,g25
10:27:12  31  ,g26
10:27:12  32  ,g27
10:27:12  33  ,g28
10:27:12  34  ,g29
10:27:12  35  FROM stk_ms
10:27:12  36  WHERE gatt IN('nup','up')
10:27:12  37  -- Use only rows which are older than 1 day:
10:27:12  38  AND 1+ydate < '&1'
10:27:12  39  AND tkr = '&2'
10:27:12  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-16'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:12 SQL> 
10:27:12 SQL> -- rpt
10:27:12 SQL> 
10:27:12 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:12   2  
10:27:12 SQL> SELECT MAX(tkrdate) FROM bme
10:27:12   2  
10:27:12 SQL> -- Now build model from bme and score sme
10:27:12 SQL> @score1.sql gatt
10:27:12 SQL> -- score1.sql
10:27:12 SQL> 
10:27:12 SQL> -- I use this script to send 5 params to score.sql
10:27:12 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:12 SQL> -- Then at the very end of this script I use the model
10:27:12 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:12 SQL> 
10:27:12 SQL> -- I call this script from 2 other scripts:
10:27:12 SQL> -- score1_5min.sql
10:27:12 SQL> -- score1_5min_gattn.sql
10:27:12 SQL> 
10:27:12 SQL> -- The 1st param is the name of the target attribute.
10:27:12 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:12 SQL> 
10:27:12 SQL> -- Demo:
10:27:12 SQL> -- @score1.sql 'gatt'
10:27:12 SQL> -- @score1.sql 'gattn'
10:27:12 SQL> 
10:27:12 SQL> -- Now, I fill up svmc_apply_prep.
10:27:12 SQL> -- I use same model_name used in score.sql
10:27:12 SQL> DEFINE model_name = 'svmspy101'
10:27:12 SQL> DEFINE bldtable	= 'bme'
10:27:12 SQL> DEFINE scoretable = 'sme'
10:27:12 SQL> DEFINE case_id	= 'tkrdate'
10:27:12 SQL> -- Demo:
10:27:12 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:12 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:12 SQL> --
10:27:12 SQL> -- score.sql
10:27:12 SQL> --
10:27:12 SQL> 
10:27:12 SQL> -- usage: score.sql
10:27:12 SQL> 
10:27:12 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:12 SQL> 
10:27:12 SQL> -- DEFINE target	   = 'gatt'
10:27:12 SQL> -- DEFINE model_name = 'svmspy100'
10:27:12 SQL> -- DEFINE bldtable   = 'bme'
10:27:12 SQL> -- DEFINE scoretable = 'sme'
10:27:12 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:12 SQL> 
10:27:12 SQL> DEFINE target	= '&1'
10:27:12 SQL> DEFINE model_name = '&2'
10:27:12 SQL> DEFINE bldtable	= '&3'
10:27:12 SQL> DEFINE scoretable = '&4'
10:27:12 SQL> DEFINE case_id	= '&5'
10:27:12 SQL> 
10:27:12 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:12 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:12 SQL> 
10:27:12 SQL> -- Builds an SVM model using pl/sql.
10:27:12 SQL> 
10:27:12 SQL> -----------------------------------------------------------------------
10:27:12 SQL> --			    BUILD THE MODEL
10:27:12 SQL> -----------------------------------------------------------------------
10:27:12 SQL> 
10:27:12 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:12 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:12 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:12 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:12 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:12 SQL> 
10:27:12 SQL> 
10:27:12 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:12 SQL> --
10:27:12 SQL> -- DROP	TABLE svmc_settings ;
10:27:12 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:12 SQL> -- DELETE svmc_settings;
10:27:12 SQL> 
10:27:12 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:12 SQL> -- this choice to SVM using a settings table.
10:27:12 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:12 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:12 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:12 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:12 SQL> -- models.
10:27:12 SQL> --
10:27:12 SQL> 
10:27:12 SQL> -- Do this once and then comment it out.
10:27:12 SQL> -- That makes script go faster.
10:27:12 SQL> -- BEGIN
10:27:12 SQL> -- -- Populate settings table
10:27:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:12 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:12 SQL> --
10:27:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:12 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:12 SQL> --
10:27:12 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:12 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:12 SQL> --   COMMIT;
10:27:12 SQL> -- END;
10:27:12 SQL> -- /
10:27:12 SQL> 
10:27:12 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:12 SQL> 
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:12 SQL> 
10:27:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:13 SQL> 
10:27:13 SQL> --------------------------------
10:27:13 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:13 SQL> --
10:27:13 SQL> 
10:27:13 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:13 SQL> -- 2. Outlier Treatment and
10:27:13 SQL> -- 3. Normalization are performed below.
10:27:13 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:13 SQL> --    normalized here.
10:27:13 SQL> 
10:27:13 SQL> BEGIN
10:27:13   2  	-- Perform missing value treatment for all predictors
10:27:13   3  	-- create miss tables
10:27:13   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:13   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:13   6  
10:27:13   7  	-- populate miss tables
10:27:13   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:13   9  	  miss_table_name => 'svmc_miss_num',
10:27:13  10  	  data_table_name => '&bldtable',
10:27:13  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:13  12  
10:27:13  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:13  14  	  miss_table_name => 'svmc_miss_cat',
10:27:13  15  	  data_table_name => '&bldtable',
10:27:13  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:13  17  
10:27:13  18  	-- xform input data to replace missing values
10:27:13  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:13  20  	  miss_table_name => 'svmc_miss_num',
10:27:13  21  	  data_table_name => '&bldtable',
10:27:13  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:13  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:13  24  	  miss_table_name => 'svmc_miss_cat',
10:27:13  25  	  data_table_name => '&bldtable',
10:27:13  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:13  27  
10:27:13  28  	-- Perform outlier treatment.
10:27:13  29  	-- create clip table
10:27:13  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:13  31  
10:27:13  32  	-- populate clip table
10:27:13  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:13  34  	  clip_table_name => 'svmc_clip',
10:27:13  35  	  data_table_name => '&bldtable',
10:27:13  36  	  tail_frac	  => 0.025,
10:27:13  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:13  38  
10:27:13  39  	-- xform input data to winsorized data
10:27:13  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:13  41  	  clip_table_name => 'svmc_clip',
10:27:13  42  	  data_table_name => '&bldtable',
10:27:13  43  	  xform_view_name => 'svmc_winsor');
10:27:13  44  
10:27:13  45  	-- create normalization table
10:27:13  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:13  47  
10:27:13  48  	-- populate normalization table based on winsorized data
10:27:13  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:13  50  	  norm_table_name => 'svmc_norm',
10:27:13  51  	  data_table_name => 'svmc_winsor',
10:27:13  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:13  53  
10:27:13  54  	-- normalize the original data
10:27:13  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:13  56  	  norm_table_name => 'svmc_norm',
10:27:13  57  	  data_table_name => '&bldtable',
10:27:13  58  	  xform_view_name => 'svmc_build_prep');
10:27:13  59  END;
10:27:13  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:27:13 SQL> 
10:27:13 SQL> ---------------------
10:27:13 SQL> -- CREATE A NEW MODEL
10:27:13 SQL> --
10:27:13 SQL> -- Cleanup old model with the same name for repeat runs
10:27:13 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:13   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.99
10:27:14 SQL> 
10:27:14 SQL> -- Build a new SVM Model
10:27:14 SQL> BEGIN
10:27:14   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:14   3  	  model_name	      => '&model_name',
10:27:14   4  	  mining_function     => dbms_data_mining.classification,
10:27:14   5  	  data_table_name     => 'svmc_build_prep',
10:27:14   6  	  case_id_column_name => '&case_id',
10:27:14   7  	  target_column_name  => '&target',
10:27:14   8  	  settings_table_name => 'svmc_settings');
10:27:14   9  END;
10:27:14  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.17
10:27:16 SQL> 
10:27:16 SQL> -----------------------------------------------------------------------
10:27:16 SQL> --			       APPLY/score THE MODEL
10:27:16 SQL> -----------------------------------------------------------------------
10:27:16 SQL> 
10:27:16 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:16 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:16   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:16   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:16 SQL> -----------------------
10:27:16 SQL> -- PREPARE SCORING DATA
10:27:16 SQL> --
10:27:16 SQL> -- If the data for model creation has been prepared, then the data
10:27:16 SQL> -- to be scored using the model must be prepared in the same manner
10:27:16 SQL> -- in order to obtain meaningful results.
10:27:16 SQL> --
10:27:16 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:16 SQL> -- 2. Normalization
10:27:16 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:16 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:16 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:16 SQL> --
10:27:16 SQL> BEGIN
10:27:16   2  	-- Xform Test data to replace missing values
10:27:16   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:16   4  	  miss_table_name => 'svmc_miss_num',
10:27:16   5  	  data_table_name => '&scoretable',
10:27:16   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:16   7  
10:27:16   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:16   9  	  miss_table_name => 'svmc_miss_cat',
10:27:16  10  	  data_table_name => '&scoretable',
10:27:16  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:16  12  
10:27:16  13  	-- Normalize the data to be scored
10:27:16  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:16  15  	  norm_table_name => 'svmc_norm',
10:27:16  16  	  data_table_name => '&scoretable',
10:27:16  17  	  xform_view_name => 'svmc_apply_prep');
10:27:16  18  END;
10:27:16  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:27:17 SQL> 
10:27:17 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:17 SQL> -- DELETE it if I did:
10:27:17 SQL> DELETE ystkscores
10:27:17   2  WHERE score > 0
10:27:17   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:17   4  -- I need to supply the target attribute name:
10:27:17   5  AND targ = '&1'
10:27:17   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:27:17 SQL> 
10:27:17 SQL> -- We do a drumroll here:
10:27:17 SQL> 
10:27:17 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:17   2  SELECT
10:27:17   3  tkrdate
10:27:17   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:17   5  ,sysdate
10:27:17   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:17   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:17   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:17   9  ,SUBSTR(tkrdate,-10)ydate
10:27:17  10  ,'&1'
10:27:17  11  FROM svmc_apply_prep
10:27:17  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:27:17 SQL> @score1_5min_gattn.sql	2010-05-11 TLT
10:27:17 SQL> --
10:27:17 SQL> -- score1_5min_gattn.sql
10:27:17 SQL> --
10:27:17 SQL> 
10:27:17 SQL> -- Demo:
10:27:17 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:27:17 SQL> 
10:27:17 SQL> CREATE OR REPLACE VIEW sme AS
10:27:17   2  SELECT
10:27:17   3  tkrdate
10:27:17   4  ,NULL gattn
10:27:17   5  ,g00
10:27:17   6  ,g01
10:27:17   7  ,g02
10:27:17   8  ,g03
10:27:17   9  ,g04
10:27:17  10  ,g05
10:27:17  11  ,g06
10:27:17  12  ,g07
10:27:17  13  ,g08
10:27:17  14  ,g09
10:27:17  15  ,g10
10:27:17  16  ,g11
10:27:17  17  ,g12
10:27:17  18  ,g13
10:27:17  19  ,g14
10:27:17  20  ,g15
10:27:17  21  ,g16
10:27:17  22  ,g17
10:27:17  23  ,g18
10:27:17  24  ,g19
10:27:17  25  ,g20
10:27:17  26  ,g21
10:27:17  27  ,g22
10:27:17  28  ,g23
10:27:17  29  ,g24
10:27:17  30  ,g25
10:27:17  31  ,g26
10:27:17  32  ,g27
10:27:17  33  ,g28
10:27:17  34  ,g29
10:27:17  35  FROM stk_ms
10:27:17  36  WHERE ydate = '&1'
10:27:17  37  AND tkr = '&2'
10:27:17  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-05-11'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:17 SQL> 
10:27:17 SQL> -- rpt
10:27:17 SQL> -- We should see just 1 row:
10:27:17 SQL> 
10:27:17 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:17   2  
10:27:17 SQL> -- Build the model:
10:27:17 SQL> CREATE OR REPLACE VIEW bme AS
10:27:17   2  SELECT
10:27:17   3  tkrdate
10:27:17   4  ,gattn
10:27:17   5  ,g00
10:27:17   6  ,g01
10:27:17   7  ,g02
10:27:17   8  ,g03
10:27:17   9  ,g04
10:27:17  10  ,g05
10:27:17  11  ,g06
10:27:17  12  ,g07
10:27:17  13  ,g08
10:27:17  14  ,g09
10:27:17  15  ,g10
10:27:17  16  ,g11
10:27:17  17  ,g12
10:27:17  18  ,g13
10:27:17  19  ,g14
10:27:17  20  ,g15
10:27:17  21  ,g16
10:27:17  22  ,g17
10:27:17  23  ,g18
10:27:17  24  ,g19
10:27:17  25  ,g20
10:27:17  26  ,g21
10:27:17  27  ,g22
10:27:17  28  ,g23
10:27:17  29  ,g24
10:27:17  30  ,g25
10:27:17  31  ,g26
10:27:17  32  ,g27
10:27:17  33  ,g28
10:27:17  34  ,g29
10:27:17  35  FROM stk_ms
10:27:17  36  WHERE gattn IN('nup','up')
10:27:17  37  -- Use only rows which are older than 1 day:
10:27:17  38  AND 1+ydate < '&1'
10:27:17  39  AND tkr = '&2'
10:27:17  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-05-11'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.07
10:27:17 SQL> 
10:27:17 SQL> -- rpt
10:27:17 SQL> 
10:27:17 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:27:17   2  
10:27:17 SQL> SELECT MAX(tkrdate) FROM bme
10:27:17   2  
10:27:17 SQL> -- Now build model from bme and score sme
10:27:17 SQL> @score1.sql gattn
10:27:17 SQL> -- score1.sql
10:27:17 SQL> 
10:27:17 SQL> -- I use this script to send 5 params to score.sql
10:27:17 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:17 SQL> -- Then at the very end of this script I use the model
10:27:17 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:17 SQL> 
10:27:17 SQL> -- I call this script from 2 other scripts:
10:27:17 SQL> -- score1_5min.sql
10:27:17 SQL> -- score1_5min_gattn.sql
10:27:17 SQL> 
10:27:17 SQL> -- The 1st param is the name of the target attribute.
10:27:17 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:17 SQL> 
10:27:17 SQL> -- Demo:
10:27:17 SQL> -- @score1.sql 'gatt'
10:27:17 SQL> -- @score1.sql 'gattn'
10:27:17 SQL> 
10:27:17 SQL> -- Now, I fill up svmc_apply_prep.
10:27:17 SQL> -- I use same model_name used in score.sql
10:27:17 SQL> DEFINE model_name = 'svmspy101'
10:27:17 SQL> DEFINE bldtable	= 'bme'
10:27:17 SQL> DEFINE scoretable = 'sme'
10:27:17 SQL> DEFINE case_id	= 'tkrdate'
10:27:17 SQL> -- Demo:
10:27:17 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:17 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:17 SQL> --
10:27:17 SQL> -- score.sql
10:27:17 SQL> --
10:27:17 SQL> 
10:27:17 SQL> -- usage: score.sql
10:27:17 SQL> 
10:27:17 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:17 SQL> 
10:27:17 SQL> -- DEFINE target	   = 'gatt'
10:27:17 SQL> -- DEFINE model_name = 'svmspy100'
10:27:17 SQL> -- DEFINE bldtable   = 'bme'
10:27:17 SQL> -- DEFINE scoretable = 'sme'
10:27:17 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:17 SQL> 
10:27:17 SQL> DEFINE target	= '&1'
10:27:17 SQL> DEFINE model_name = '&2'
10:27:17 SQL> DEFINE bldtable	= '&3'
10:27:17 SQL> DEFINE scoretable = '&4'
10:27:17 SQL> DEFINE case_id	= '&5'
10:27:17 SQL> 
10:27:17 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:17 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:17 SQL> 
10:27:17 SQL> -- Builds an SVM model using pl/sql.
10:27:17 SQL> 
10:27:17 SQL> -----------------------------------------------------------------------
10:27:17 SQL> --			    BUILD THE MODEL
10:27:17 SQL> -----------------------------------------------------------------------
10:27:17 SQL> 
10:27:17 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:17 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:17 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:17 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:17 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:17 SQL> 
10:27:17 SQL> 
10:27:17 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:17 SQL> --
10:27:17 SQL> -- DROP	TABLE svmc_settings ;
10:27:17 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:17 SQL> -- DELETE svmc_settings;
10:27:17 SQL> 
10:27:17 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:17 SQL> -- this choice to SVM using a settings table.
10:27:17 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:17 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:17 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:17 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:17 SQL> -- models.
10:27:17 SQL> --
10:27:17 SQL> 
10:27:17 SQL> -- Do this once and then comment it out.
10:27:17 SQL> -- That makes script go faster.
10:27:17 SQL> -- BEGIN
10:27:17 SQL> -- -- Populate settings table
10:27:17 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:17 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:17 SQL> --
10:27:17 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:17 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:17 SQL> --
10:27:17 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:17 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:17 SQL> --   COMMIT;
10:27:17 SQL> -- END;
10:27:17 SQL> -- /
10:27:17 SQL> 
10:27:17 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:17 SQL> 
10:27:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:27:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:17 SQL> 
10:27:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:17 SQL> 
10:27:17 SQL> --------------------------------
10:27:17 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:17 SQL> --
10:27:17 SQL> 
10:27:17 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:17 SQL> -- 2. Outlier Treatment and
10:27:17 SQL> -- 3. Normalization are performed below.
10:27:17 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:17 SQL> --    normalized here.
10:27:17 SQL> 
10:27:17 SQL> BEGIN
10:27:17   2  	-- Perform missing value treatment for all predictors
10:27:17   3  	-- create miss tables
10:27:17   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:17   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:17   6  
10:27:17   7  	-- populate miss tables
10:27:17   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:17   9  	  miss_table_name => 'svmc_miss_num',
10:27:17  10  	  data_table_name => '&bldtable',
10:27:17  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:17  12  
10:27:17  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:17  14  	  miss_table_name => 'svmc_miss_cat',
10:27:17  15  	  data_table_name => '&bldtable',
10:27:17  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:17  17  
10:27:17  18  	-- xform input data to replace missing values
10:27:17  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:17  20  	  miss_table_name => 'svmc_miss_num',
10:27:17  21  	  data_table_name => '&bldtable',
10:27:17  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:17  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:17  24  	  miss_table_name => 'svmc_miss_cat',
10:27:17  25  	  data_table_name => '&bldtable',
10:27:17  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:17  27  
10:27:17  28  	-- Perform outlier treatment.
10:27:17  29  	-- create clip table
10:27:17  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:17  31  
10:27:17  32  	-- populate clip table
10:27:17  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:17  34  	  clip_table_name => 'svmc_clip',
10:27:17  35  	  data_table_name => '&bldtable',
10:27:17  36  	  tail_frac	  => 0.025,
10:27:17  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:17  38  
10:27:17  39  	-- xform input data to winsorized data
10:27:17  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:17  41  	  clip_table_name => 'svmc_clip',
10:27:17  42  	  data_table_name => '&bldtable',
10:27:17  43  	  xform_view_name => 'svmc_winsor');
10:27:17  44  
10:27:17  45  	-- create normalization table
10:27:17  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:17  47  
10:27:17  48  	-- populate normalization table based on winsorized data
10:27:17  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:17  50  	  norm_table_name => 'svmc_norm',
10:27:17  51  	  data_table_name => 'svmc_winsor',
10:27:17  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:17  53  
10:27:17  54  	-- normalize the original data
10:27:17  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:17  56  	  norm_table_name => 'svmc_norm',
10:27:17  57  	  data_table_name => '&bldtable',
10:27:17  58  	  xform_view_name => 'svmc_build_prep');
10:27:17  59  END;
10:27:17  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:27:18 SQL> 
10:27:18 SQL> ---------------------
10:27:18 SQL> -- CREATE A NEW MODEL
10:27:18 SQL> --
10:27:18 SQL> -- Cleanup old model with the same name for repeat runs
10:27:18 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:18   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.72
10:27:19 SQL> 
10:27:19 SQL> -- Build a new SVM Model
10:27:19 SQL> BEGIN
10:27:19   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:19   3  	  model_name	      => '&model_name',
10:27:19   4  	  mining_function     => dbms_data_mining.classification,
10:27:19   5  	  data_table_name     => 'svmc_build_prep',
10:27:19   6  	  case_id_column_name => '&case_id',
10:27:19   7  	  target_column_name  => '&target',
10:27:19   8  	  settings_table_name => 'svmc_settings');
10:27:19   9  END;
10:27:19  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.98
10:27:21 SQL> 
10:27:21 SQL> -----------------------------------------------------------------------
10:27:21 SQL> --			       APPLY/score THE MODEL
10:27:21 SQL> -----------------------------------------------------------------------
10:27:21 SQL> 
10:27:21 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:21 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:21   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:21   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:21 SQL> -----------------------
10:27:21 SQL> -- PREPARE SCORING DATA
10:27:21 SQL> --
10:27:21 SQL> -- If the data for model creation has been prepared, then the data
10:27:21 SQL> -- to be scored using the model must be prepared in the same manner
10:27:21 SQL> -- in order to obtain meaningful results.
10:27:21 SQL> --
10:27:21 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:21 SQL> -- 2. Normalization
10:27:21 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:21 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:21 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:21 SQL> --
10:27:21 SQL> BEGIN
10:27:21   2  	-- Xform Test data to replace missing values
10:27:21   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:21   4  	  miss_table_name => 'svmc_miss_num',
10:27:21   5  	  data_table_name => '&scoretable',
10:27:21   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:21   7  
10:27:21   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:21   9  	  miss_table_name => 'svmc_miss_cat',
10:27:21  10  	  data_table_name => '&scoretable',
10:27:21  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:21  12  
10:27:21  13  	-- Normalize the data to be scored
10:27:21  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:21  15  	  norm_table_name => 'svmc_norm',
10:27:21  16  	  data_table_name => '&scoretable',
10:27:21  17  	  xform_view_name => 'svmc_apply_prep');
10:27:21  18  END;
10:27:21  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:22 SQL> 
10:27:22 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:22 SQL> -- DELETE it if I did:
10:27:22 SQL> DELETE ystkscores
10:27:22   2  WHERE score > 0
10:27:22   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:22   4  -- I need to supply the target attribute name:
10:27:22   5  AND targ = '&1'
10:27:22   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:22 SQL> 
10:27:22 SQL> -- We do a drumroll here:
10:27:22 SQL> 
10:27:22 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:22   2  SELECT
10:27:22   3  tkrdate
10:27:22   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:22   5  ,sysdate
10:27:22   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:22   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:22   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:22   9  ,SUBSTR(tkrdate,-10)ydate
10:27:22  10  ,'&1'
10:27:22  11  FROM svmc_apply_prep
10:27:22  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:27:22 SQL> @score1_5min.sql	      2010-06-07 TLT
10:27:22 SQL> --
10:27:22 SQL> -- score1_5min.sql
10:27:22 SQL> --
10:27:22 SQL> 
10:27:22 SQL> -- Demo:
10:27:22 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:22 SQL> 
10:27:22 SQL> CREATE OR REPLACE VIEW sme AS
10:27:22   2  SELECT
10:27:22   3  tkrdate
10:27:22   4  ,NULL gatt
10:27:22   5  ,g00
10:27:22   6  ,g01
10:27:22   7  ,g02
10:27:22   8  ,g03
10:27:22   9  ,g04
10:27:22  10  ,g05
10:27:22  11  ,g06
10:27:22  12  ,g07
10:27:22  13  ,g08
10:27:22  14  ,g09
10:27:22  15  ,g10
10:27:22  16  ,g11
10:27:22  17  ,g12
10:27:22  18  ,g13
10:27:22  19  ,g14
10:27:22  20  ,g15
10:27:22  21  ,g16
10:27:22  22  ,g17
10:27:22  23  ,g18
10:27:22  24  ,g19
10:27:22  25  ,g20
10:27:22  26  ,g21
10:27:22  27  ,g22
10:27:22  28  ,g23
10:27:22  29  ,g24
10:27:22  30  ,g25
10:27:22  31  ,g26
10:27:22  32  ,g27
10:27:22  33  ,g28
10:27:22  34  ,g29
10:27:22  35  FROM stk_ms
10:27:22  36  WHERE ydate = '&1'
10:27:22  37  AND tkr = '&2'
10:27:22  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-07'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:22 SQL> 
10:27:22 SQL> -- rpt
10:27:22 SQL> -- We should see just 1 row:
10:27:22 SQL> 
10:27:22 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:22   2  
10:27:22 SQL> -- Build the model:
10:27:22 SQL> CREATE OR REPLACE VIEW bme AS
10:27:22   2  SELECT
10:27:22   3  tkrdate
10:27:22   4  ,gatt
10:27:22   5  ,g00
10:27:22   6  ,g01
10:27:22   7  ,g02
10:27:22   8  ,g03
10:27:22   9  ,g04
10:27:22  10  ,g05
10:27:22  11  ,g06
10:27:22  12  ,g07
10:27:22  13  ,g08
10:27:22  14  ,g09
10:27:22  15  ,g10
10:27:22  16  ,g11
10:27:22  17  ,g12
10:27:22  18  ,g13
10:27:22  19  ,g14
10:27:22  20  ,g15
10:27:22  21  ,g16
10:27:22  22  ,g17
10:27:22  23  ,g18
10:27:22  24  ,g19
10:27:22  25  ,g20
10:27:22  26  ,g21
10:27:22  27  ,g22
10:27:22  28  ,g23
10:27:22  29  ,g24
10:27:22  30  ,g25
10:27:22  31  ,g26
10:27:22  32  ,g27
10:27:22  33  ,g28
10:27:22  34  ,g29
10:27:22  35  FROM stk_ms
10:27:22  36  WHERE gatt IN('nup','up')
10:27:22  37  -- Use only rows which are older than 1 day:
10:27:22  38  AND 1+ydate < '&1'
10:27:22  39  AND tkr = '&2'
10:27:22  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-07'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.07
10:27:22 SQL> 
10:27:22 SQL> -- rpt
10:27:22 SQL> 
10:27:22 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:22   2  
10:27:22 SQL> SELECT MAX(tkrdate) FROM bme
10:27:22   2  
10:27:22 SQL> -- Now build model from bme and score sme
10:27:22 SQL> @score1.sql gatt
10:27:22 SQL> -- score1.sql
10:27:22 SQL> 
10:27:22 SQL> -- I use this script to send 5 params to score.sql
10:27:22 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:22 SQL> -- Then at the very end of this script I use the model
10:27:22 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:22 SQL> 
10:27:22 SQL> -- I call this script from 2 other scripts:
10:27:22 SQL> -- score1_5min.sql
10:27:22 SQL> -- score1_5min_gattn.sql
10:27:22 SQL> 
10:27:22 SQL> -- The 1st param is the name of the target attribute.
10:27:22 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:22 SQL> 
10:27:22 SQL> -- Demo:
10:27:22 SQL> -- @score1.sql 'gatt'
10:27:22 SQL> -- @score1.sql 'gattn'
10:27:22 SQL> 
10:27:22 SQL> -- Now, I fill up svmc_apply_prep.
10:27:22 SQL> -- I use same model_name used in score.sql
10:27:22 SQL> DEFINE model_name = 'svmspy101'
10:27:22 SQL> DEFINE bldtable	= 'bme'
10:27:22 SQL> DEFINE scoretable = 'sme'
10:27:22 SQL> DEFINE case_id	= 'tkrdate'
10:27:22 SQL> -- Demo:
10:27:22 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:22 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:22 SQL> --
10:27:22 SQL> -- score.sql
10:27:22 SQL> --
10:27:22 SQL> 
10:27:22 SQL> -- usage: score.sql
10:27:22 SQL> 
10:27:22 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:22 SQL> 
10:27:22 SQL> -- DEFINE target	   = 'gatt'
10:27:22 SQL> -- DEFINE model_name = 'svmspy100'
10:27:22 SQL> -- DEFINE bldtable   = 'bme'
10:27:22 SQL> -- DEFINE scoretable = 'sme'
10:27:22 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:22 SQL> 
10:27:22 SQL> DEFINE target	= '&1'
10:27:22 SQL> DEFINE model_name = '&2'
10:27:22 SQL> DEFINE bldtable	= '&3'
10:27:22 SQL> DEFINE scoretable = '&4'
10:27:22 SQL> DEFINE case_id	= '&5'
10:27:22 SQL> 
10:27:22 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:22 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:22 SQL> 
10:27:22 SQL> -- Builds an SVM model using pl/sql.
10:27:22 SQL> 
10:27:22 SQL> -----------------------------------------------------------------------
10:27:22 SQL> --			    BUILD THE MODEL
10:27:22 SQL> -----------------------------------------------------------------------
10:27:22 SQL> 
10:27:22 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:22 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:22 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:22 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:22 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:27:22 SQL> 
10:27:22 SQL> 
10:27:22 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:22 SQL> --
10:27:22 SQL> -- DROP	TABLE svmc_settings ;
10:27:22 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:22 SQL> -- DELETE svmc_settings;
10:27:22 SQL> 
10:27:22 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:22 SQL> -- this choice to SVM using a settings table.
10:27:22 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:22 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:22 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:22 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:22 SQL> -- models.
10:27:22 SQL> --
10:27:22 SQL> 
10:27:22 SQL> -- Do this once and then comment it out.
10:27:22 SQL> -- That makes script go faster.
10:27:22 SQL> -- BEGIN
10:27:22 SQL> -- -- Populate settings table
10:27:22 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:22 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:22 SQL> --
10:27:22 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:22 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:22 SQL> --
10:27:22 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:22 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:22 SQL> --   COMMIT;
10:27:22 SQL> -- END;
10:27:22 SQL> -- /
10:27:22 SQL> 
10:27:22 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:22 SQL> 
10:27:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:22 SQL> 
10:27:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:22 SQL> 
10:27:22 SQL> --------------------------------
10:27:22 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:22 SQL> --
10:27:22 SQL> 
10:27:22 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:22 SQL> -- 2. Outlier Treatment and
10:27:22 SQL> -- 3. Normalization are performed below.
10:27:22 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:22 SQL> --    normalized here.
10:27:22 SQL> 
10:27:22 SQL> BEGIN
10:27:22   2  	-- Perform missing value treatment for all predictors
10:27:22   3  	-- create miss tables
10:27:22   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:22   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:22   6  
10:27:22   7  	-- populate miss tables
10:27:22   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:22   9  	  miss_table_name => 'svmc_miss_num',
10:27:22  10  	  data_table_name => '&bldtable',
10:27:22  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:22  12  
10:27:22  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:22  14  	  miss_table_name => 'svmc_miss_cat',
10:27:22  15  	  data_table_name => '&bldtable',
10:27:22  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:22  17  
10:27:22  18  	-- xform input data to replace missing values
10:27:22  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:22  20  	  miss_table_name => 'svmc_miss_num',
10:27:22  21  	  data_table_name => '&bldtable',
10:27:22  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:22  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:22  24  	  miss_table_name => 'svmc_miss_cat',
10:27:22  25  	  data_table_name => '&bldtable',
10:27:22  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:22  27  
10:27:22  28  	-- Perform outlier treatment.
10:27:22  29  	-- create clip table
10:27:22  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:22  31  
10:27:22  32  	-- populate clip table
10:27:22  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:22  34  	  clip_table_name => 'svmc_clip',
10:27:22  35  	  data_table_name => '&bldtable',
10:27:22  36  	  tail_frac	  => 0.025,
10:27:22  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:22  38  
10:27:22  39  	-- xform input data to winsorized data
10:27:22  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:22  41  	  clip_table_name => 'svmc_clip',
10:27:22  42  	  data_table_name => '&bldtable',
10:27:22  43  	  xform_view_name => 'svmc_winsor');
10:27:22  44  
10:27:22  45  	-- create normalization table
10:27:22  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:22  47  
10:27:22  48  	-- populate normalization table based on winsorized data
10:27:22  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:22  50  	  norm_table_name => 'svmc_norm',
10:27:22  51  	  data_table_name => 'svmc_winsor',
10:27:22  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:22  53  
10:27:22  54  	-- normalize the original data
10:27:22  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:22  56  	  norm_table_name => 'svmc_norm',
10:27:22  57  	  data_table_name => '&bldtable',
10:27:22  58  	  xform_view_name => 'svmc_build_prep');
10:27:22  59  END;
10:27:22  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:27:22 SQL> 
10:27:22 SQL> ---------------------
10:27:22 SQL> -- CREATE A NEW MODEL
10:27:22 SQL> --
10:27:22 SQL> -- Cleanup old model with the same name for repeat runs
10:27:22 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:22   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.60
10:27:24 SQL> 
10:27:24 SQL> -- Build a new SVM Model
10:27:24 SQL> BEGIN
10:27:24   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:24   3  	  model_name	      => '&model_name',
10:27:24   4  	  mining_function     => dbms_data_mining.classification,
10:27:24   5  	  data_table_name     => 'svmc_build_prep',
10:27:24   6  	  case_id_column_name => '&case_id',
10:27:24   7  	  target_column_name  => '&target',
10:27:24   8  	  settings_table_name => 'svmc_settings');
10:27:24   9  END;
10:27:24  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.24
10:27:26 SQL> 
10:27:26 SQL> -----------------------------------------------------------------------
10:27:26 SQL> --			       APPLY/score THE MODEL
10:27:26 SQL> -----------------------------------------------------------------------
10:27:26 SQL> 
10:27:26 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:26 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:26   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:26   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:26 SQL> -----------------------
10:27:26 SQL> -- PREPARE SCORING DATA
10:27:26 SQL> --
10:27:26 SQL> -- If the data for model creation has been prepared, then the data
10:27:26 SQL> -- to be scored using the model must be prepared in the same manner
10:27:26 SQL> -- in order to obtain meaningful results.
10:27:26 SQL> --
10:27:26 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:26 SQL> -- 2. Normalization
10:27:26 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:26 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:26 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:26 SQL> --
10:27:26 SQL> BEGIN
10:27:26   2  	-- Xform Test data to replace missing values
10:27:26   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:26   4  	  miss_table_name => 'svmc_miss_num',
10:27:26   5  	  data_table_name => '&scoretable',
10:27:26   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:26   7  
10:27:26   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:26   9  	  miss_table_name => 'svmc_miss_cat',
10:27:26  10  	  data_table_name => '&scoretable',
10:27:26  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:26  12  
10:27:26  13  	-- Normalize the data to be scored
10:27:26  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:26  15  	  norm_table_name => 'svmc_norm',
10:27:26  16  	  data_table_name => '&scoretable',
10:27:26  17  	  xform_view_name => 'svmc_apply_prep');
10:27:26  18  END;
10:27:26  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
10:27:27 SQL> 
10:27:27 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:27 SQL> -- DELETE it if I did:
10:27:27 SQL> DELETE ystkscores
10:27:27   2  WHERE score > 0
10:27:27   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:27   4  -- I need to supply the target attribute name:
10:27:27   5  AND targ = '&1'
10:27:27   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:27 SQL> 
10:27:27 SQL> -- We do a drumroll here:
10:27:27 SQL> 
10:27:27 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:27   2  SELECT
10:27:27   3  tkrdate
10:27:27   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:27   5  ,sysdate
10:27:27   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:27   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:27   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:27   9  ,SUBSTR(tkrdate,-10)ydate
10:27:27  10  ,'&1'
10:27:27  11  FROM svmc_apply_prep
10:27:27  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:27:27 SQL> @score1_5min.sql	      2010-04-20 TLT
10:27:27 SQL> --
10:27:27 SQL> -- score1_5min.sql
10:27:27 SQL> --
10:27:27 SQL> 
10:27:27 SQL> -- Demo:
10:27:27 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:27 SQL> 
10:27:27 SQL> CREATE OR REPLACE VIEW sme AS
10:27:27   2  SELECT
10:27:27   3  tkrdate
10:27:27   4  ,NULL gatt
10:27:27   5  ,g00
10:27:27   6  ,g01
10:27:27   7  ,g02
10:27:27   8  ,g03
10:27:27   9  ,g04
10:27:27  10  ,g05
10:27:27  11  ,g06
10:27:27  12  ,g07
10:27:27  13  ,g08
10:27:27  14  ,g09
10:27:27  15  ,g10
10:27:27  16  ,g11
10:27:27  17  ,g12
10:27:27  18  ,g13
10:27:27  19  ,g14
10:27:27  20  ,g15
10:27:27  21  ,g16
10:27:27  22  ,g17
10:27:27  23  ,g18
10:27:27  24  ,g19
10:27:27  25  ,g20
10:27:27  26  ,g21
10:27:27  27  ,g22
10:27:27  28  ,g23
10:27:27  29  ,g24
10:27:27  30  ,g25
10:27:27  31  ,g26
10:27:27  32  ,g27
10:27:27  33  ,g28
10:27:27  34  ,g29
10:27:27  35  FROM stk_ms
10:27:27  36  WHERE ydate = '&1'
10:27:27  37  AND tkr = '&2'
10:27:27  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-20'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.09
10:27:27 SQL> 
10:27:27 SQL> -- rpt
10:27:27 SQL> -- We should see just 1 row:
10:27:27 SQL> 
10:27:27 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:27   2  
10:27:27 SQL> -- Build the model:
10:27:27 SQL> CREATE OR REPLACE VIEW bme AS
10:27:27   2  SELECT
10:27:27   3  tkrdate
10:27:27   4  ,gatt
10:27:27   5  ,g00
10:27:27   6  ,g01
10:27:27   7  ,g02
10:27:27   8  ,g03
10:27:27   9  ,g04
10:27:27  10  ,g05
10:27:27  11  ,g06
10:27:27  12  ,g07
10:27:27  13  ,g08
10:27:27  14  ,g09
10:27:27  15  ,g10
10:27:27  16  ,g11
10:27:27  17  ,g12
10:27:27  18  ,g13
10:27:27  19  ,g14
10:27:27  20  ,g15
10:27:27  21  ,g16
10:27:27  22  ,g17
10:27:27  23  ,g18
10:27:27  24  ,g19
10:27:27  25  ,g20
10:27:27  26  ,g21
10:27:27  27  ,g22
10:27:27  28  ,g23
10:27:27  29  ,g24
10:27:27  30  ,g25
10:27:27  31  ,g26
10:27:27  32  ,g27
10:27:27  33  ,g28
10:27:27  34  ,g29
10:27:27  35  FROM stk_ms
10:27:27  36  WHERE gatt IN('nup','up')
10:27:27  37  -- Use only rows which are older than 1 day:
10:27:27  38  AND 1+ydate < '&1'
10:27:27  39  AND tkr = '&2'
10:27:27  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-20'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:27 SQL> 
10:27:27 SQL> -- rpt
10:27:27 SQL> 
10:27:27 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:27   2  
10:27:27 SQL> SELECT MAX(tkrdate) FROM bme
10:27:27   2  
10:27:27 SQL> -- Now build model from bme and score sme
10:27:27 SQL> @score1.sql gatt
10:27:27 SQL> -- score1.sql
10:27:27 SQL> 
10:27:27 SQL> -- I use this script to send 5 params to score.sql
10:27:27 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:27 SQL> -- Then at the very end of this script I use the model
10:27:27 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:27 SQL> 
10:27:27 SQL> -- I call this script from 2 other scripts:
10:27:27 SQL> -- score1_5min.sql
10:27:27 SQL> -- score1_5min_gattn.sql
10:27:27 SQL> 
10:27:27 SQL> -- The 1st param is the name of the target attribute.
10:27:27 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:27 SQL> 
10:27:27 SQL> -- Demo:
10:27:27 SQL> -- @score1.sql 'gatt'
10:27:27 SQL> -- @score1.sql 'gattn'
10:27:27 SQL> 
10:27:27 SQL> -- Now, I fill up svmc_apply_prep.
10:27:27 SQL> -- I use same model_name used in score.sql
10:27:27 SQL> DEFINE model_name = 'svmspy101'
10:27:27 SQL> DEFINE bldtable	= 'bme'
10:27:27 SQL> DEFINE scoretable = 'sme'
10:27:27 SQL> DEFINE case_id	= 'tkrdate'
10:27:27 SQL> -- Demo:
10:27:27 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:27 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:27 SQL> --
10:27:27 SQL> -- score.sql
10:27:27 SQL> --
10:27:27 SQL> 
10:27:27 SQL> -- usage: score.sql
10:27:27 SQL> 
10:27:27 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:27 SQL> 
10:27:27 SQL> -- DEFINE target	   = 'gatt'
10:27:27 SQL> -- DEFINE model_name = 'svmspy100'
10:27:27 SQL> -- DEFINE bldtable   = 'bme'
10:27:27 SQL> -- DEFINE scoretable = 'sme'
10:27:27 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:27 SQL> 
10:27:27 SQL> DEFINE target	= '&1'
10:27:27 SQL> DEFINE model_name = '&2'
10:27:27 SQL> DEFINE bldtable	= '&3'
10:27:27 SQL> DEFINE scoretable = '&4'
10:27:27 SQL> DEFINE case_id	= '&5'
10:27:27 SQL> 
10:27:27 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:27 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:27 SQL> 
10:27:27 SQL> -- Builds an SVM model using pl/sql.
10:27:27 SQL> 
10:27:27 SQL> -----------------------------------------------------------------------
10:27:27 SQL> --			    BUILD THE MODEL
10:27:27 SQL> -----------------------------------------------------------------------
10:27:27 SQL> 
10:27:27 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:27 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:27:27 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:27 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:27 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:27 SQL> 
10:27:27 SQL> 
10:27:27 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:27 SQL> --
10:27:27 SQL> -- DROP	TABLE svmc_settings ;
10:27:27 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:27 SQL> -- DELETE svmc_settings;
10:27:27 SQL> 
10:27:27 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:27 SQL> -- this choice to SVM using a settings table.
10:27:27 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:27 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:27 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:27 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:27 SQL> -- models.
10:27:27 SQL> --
10:27:27 SQL> 
10:27:27 SQL> -- Do this once and then comment it out.
10:27:27 SQL> -- That makes script go faster.
10:27:27 SQL> -- BEGIN
10:27:27 SQL> -- -- Populate settings table
10:27:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:27 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:27 SQL> --
10:27:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:27 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:27 SQL> --
10:27:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:27 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:27 SQL> --   COMMIT;
10:27:27 SQL> -- END;
10:27:27 SQL> -- /
10:27:27 SQL> 
10:27:27 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:27 SQL> 
10:27:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:27:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:27 SQL> 
10:27:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:27 SQL> 
10:27:27 SQL> --------------------------------
10:27:27 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:27 SQL> --
10:27:27 SQL> 
10:27:27 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:27 SQL> -- 2. Outlier Treatment and
10:27:27 SQL> -- 3. Normalization are performed below.
10:27:27 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:27 SQL> --    normalized here.
10:27:27 SQL> 
10:27:27 SQL> BEGIN
10:27:27   2  	-- Perform missing value treatment for all predictors
10:27:27   3  	-- create miss tables
10:27:27   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:27   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:27   6  
10:27:27   7  	-- populate miss tables
10:27:27   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:27   9  	  miss_table_name => 'svmc_miss_num',
10:27:27  10  	  data_table_name => '&bldtable',
10:27:27  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:27  12  
10:27:27  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:27  14  	  miss_table_name => 'svmc_miss_cat',
10:27:27  15  	  data_table_name => '&bldtable',
10:27:27  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:27  17  
10:27:27  18  	-- xform input data to replace missing values
10:27:27  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:27  20  	  miss_table_name => 'svmc_miss_num',
10:27:27  21  	  data_table_name => '&bldtable',
10:27:27  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:27  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:27  24  	  miss_table_name => 'svmc_miss_cat',
10:27:27  25  	  data_table_name => '&bldtable',
10:27:27  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:27  27  
10:27:27  28  	-- Perform outlier treatment.
10:27:27  29  	-- create clip table
10:27:27  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:27  31  
10:27:27  32  	-- populate clip table
10:27:27  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:27  34  	  clip_table_name => 'svmc_clip',
10:27:27  35  	  data_table_name => '&bldtable',
10:27:27  36  	  tail_frac	  => 0.025,
10:27:27  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:27  38  
10:27:27  39  	-- xform input data to winsorized data
10:27:27  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:27  41  	  clip_table_name => 'svmc_clip',
10:27:27  42  	  data_table_name => '&bldtable',
10:27:27  43  	  xform_view_name => 'svmc_winsor');
10:27:27  44  
10:27:27  45  	-- create normalization table
10:27:27  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:27  47  
10:27:27  48  	-- populate normalization table based on winsorized data
10:27:27  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:27  50  	  norm_table_name => 'svmc_norm',
10:27:27  51  	  data_table_name => 'svmc_winsor',
10:27:27  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:27  53  
10:27:27  54  	-- normalize the original data
10:27:27  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:27  56  	  norm_table_name => 'svmc_norm',
10:27:27  57  	  data_table_name => '&bldtable',
10:27:27  58  	  xform_view_name => 'svmc_build_prep');
10:27:27  59  END;
10:27:27  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:27:28 SQL> 
10:27:28 SQL> ---------------------
10:27:28 SQL> -- CREATE A NEW MODEL
10:27:28 SQL> --
10:27:28 SQL> -- Cleanup old model with the same name for repeat runs
10:27:28 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:28   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.07
10:27:29 SQL> 
10:27:29 SQL> -- Build a new SVM Model
10:27:29 SQL> BEGIN
10:27:29   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:29   3  	  model_name	      => '&model_name',
10:27:29   4  	  mining_function     => dbms_data_mining.classification,
10:27:29   5  	  data_table_name     => 'svmc_build_prep',
10:27:29   6  	  case_id_column_name => '&case_id',
10:27:29   7  	  target_column_name  => '&target',
10:27:29   8  	  settings_table_name => 'svmc_settings');
10:27:29   9  END;
10:27:29  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.17
10:27:31 SQL> 
10:27:31 SQL> -----------------------------------------------------------------------
10:27:31 SQL> --			       APPLY/score THE MODEL
10:27:31 SQL> -----------------------------------------------------------------------
10:27:31 SQL> 
10:27:31 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:31 SQL> -----------------------
10:27:31 SQL> -- PREPARE SCORING DATA
10:27:31 SQL> --
10:27:31 SQL> -- If the data for model creation has been prepared, then the data
10:27:31 SQL> -- to be scored using the model must be prepared in the same manner
10:27:31 SQL> -- in order to obtain meaningful results.
10:27:31 SQL> --
10:27:31 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:31 SQL> -- 2. Normalization
10:27:31 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:31 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:31 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:31 SQL> --
10:27:31 SQL> BEGIN
10:27:31   2  	-- Xform Test data to replace missing values
10:27:31   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:31   4  	  miss_table_name => 'svmc_miss_num',
10:27:31   5  	  data_table_name => '&scoretable',
10:27:31   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:31   7  
10:27:31   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:31   9  	  miss_table_name => 'svmc_miss_cat',
10:27:31  10  	  data_table_name => '&scoretable',
10:27:31  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:31  12  
10:27:31  13  	-- Normalize the data to be scored
10:27:31  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:31  15  	  norm_table_name => 'svmc_norm',
10:27:31  16  	  data_table_name => '&scoretable',
10:27:31  17  	  xform_view_name => 'svmc_apply_prep');
10:27:31  18  END;
10:27:31  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:27:31 SQL> 
10:27:31 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:31 SQL> -- DELETE it if I did:
10:27:31 SQL> DELETE ystkscores
10:27:31   2  WHERE score > 0
10:27:31   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:31   4  -- I need to supply the target attribute name:
10:27:31   5  AND targ = '&1'
10:27:31   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:27:31 SQL> 
10:27:31 SQL> -- We do a drumroll here:
10:27:31 SQL> 
10:27:31 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:31   2  SELECT
10:27:31   3  tkrdate
10:27:31   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:31   5  ,sysdate
10:27:31   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:31   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:31   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:31   9  ,SUBSTR(tkrdate,-10)ydate
10:27:31  10  ,'&1'
10:27:31  11  FROM svmc_apply_prep
10:27:31  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:27:31 SQL> @score1_5min_gattn.sql	2010-06-01 TLT
10:27:31 SQL> --
10:27:31 SQL> -- score1_5min_gattn.sql
10:27:31 SQL> --
10:27:31 SQL> 
10:27:31 SQL> -- Demo:
10:27:31 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:27:31 SQL> 
10:27:31 SQL> CREATE OR REPLACE VIEW sme AS
10:27:31   2  SELECT
10:27:31   3  tkrdate
10:27:31   4  ,NULL gattn
10:27:31   5  ,g00
10:27:31   6  ,g01
10:27:31   7  ,g02
10:27:31   8  ,g03
10:27:31   9  ,g04
10:27:31  10  ,g05
10:27:31  11  ,g06
10:27:31  12  ,g07
10:27:31  13  ,g08
10:27:31  14  ,g09
10:27:31  15  ,g10
10:27:31  16  ,g11
10:27:31  17  ,g12
10:27:31  18  ,g13
10:27:31  19  ,g14
10:27:31  20  ,g15
10:27:31  21  ,g16
10:27:31  22  ,g17
10:27:31  23  ,g18
10:27:31  24  ,g19
10:27:31  25  ,g20
10:27:31  26  ,g21
10:27:31  27  ,g22
10:27:31  28  ,g23
10:27:31  29  ,g24
10:27:31  30  ,g25
10:27:31  31  ,g26
10:27:31  32  ,g27
10:27:31  33  ,g28
10:27:31  34  ,g29
10:27:31  35  FROM stk_ms
10:27:31  36  WHERE ydate = '&1'
10:27:31  37  AND tkr = '&2'
10:27:31  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-01'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:27:31 SQL> 
10:27:31 SQL> -- rpt
10:27:31 SQL> -- We should see just 1 row:
10:27:31 SQL> 
10:27:31 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:31   2  
10:27:31 SQL> -- Build the model:
10:27:31 SQL> CREATE OR REPLACE VIEW bme AS
10:27:31   2  SELECT
10:27:31   3  tkrdate
10:27:31   4  ,gattn
10:27:31   5  ,g00
10:27:31   6  ,g01
10:27:31   7  ,g02
10:27:31   8  ,g03
10:27:31   9  ,g04
10:27:31  10  ,g05
10:27:31  11  ,g06
10:27:31  12  ,g07
10:27:31  13  ,g08
10:27:31  14  ,g09
10:27:31  15  ,g10
10:27:31  16  ,g11
10:27:31  17  ,g12
10:27:31  18  ,g13
10:27:31  19  ,g14
10:27:31  20  ,g15
10:27:31  21  ,g16
10:27:31  22  ,g17
10:27:31  23  ,g18
10:27:31  24  ,g19
10:27:31  25  ,g20
10:27:31  26  ,g21
10:27:31  27  ,g22
10:27:31  28  ,g23
10:27:31  29  ,g24
10:27:31  30  ,g25
10:27:31  31  ,g26
10:27:31  32  ,g27
10:27:31  33  ,g28
10:27:31  34  ,g29
10:27:31  35  FROM stk_ms
10:27:31  36  WHERE gattn IN('nup','up')
10:27:31  37  -- Use only rows which are older than 1 day:
10:27:31  38  AND 1+ydate < '&1'
10:27:31  39  AND tkr = '&2'
10:27:31  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-01'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:31 SQL> 
10:27:31 SQL> -- rpt
10:27:31 SQL> 
10:27:31 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:27:31   2  
10:27:31 SQL> SELECT MAX(tkrdate) FROM bme
10:27:31   2  
10:27:31 SQL> -- Now build model from bme and score sme
10:27:31 SQL> @score1.sql gattn
10:27:31 SQL> -- score1.sql
10:27:31 SQL> 
10:27:31 SQL> -- I use this script to send 5 params to score.sql
10:27:31 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:31 SQL> -- Then at the very end of this script I use the model
10:27:31 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:31 SQL> 
10:27:31 SQL> -- I call this script from 2 other scripts:
10:27:31 SQL> -- score1_5min.sql
10:27:31 SQL> -- score1_5min_gattn.sql
10:27:31 SQL> 
10:27:31 SQL> -- The 1st param is the name of the target attribute.
10:27:31 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:31 SQL> 
10:27:31 SQL> -- Demo:
10:27:31 SQL> -- @score1.sql 'gatt'
10:27:31 SQL> -- @score1.sql 'gattn'
10:27:31 SQL> 
10:27:31 SQL> -- Now, I fill up svmc_apply_prep.
10:27:31 SQL> -- I use same model_name used in score.sql
10:27:31 SQL> DEFINE model_name = 'svmspy101'
10:27:31 SQL> DEFINE bldtable	= 'bme'
10:27:31 SQL> DEFINE scoretable = 'sme'
10:27:31 SQL> DEFINE case_id	= 'tkrdate'
10:27:31 SQL> -- Demo:
10:27:31 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:31 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:31 SQL> --
10:27:31 SQL> -- score.sql
10:27:31 SQL> --
10:27:31 SQL> 
10:27:31 SQL> -- usage: score.sql
10:27:31 SQL> 
10:27:31 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:31 SQL> 
10:27:31 SQL> -- DEFINE target	   = 'gatt'
10:27:31 SQL> -- DEFINE model_name = 'svmspy100'
10:27:31 SQL> -- DEFINE bldtable   = 'bme'
10:27:31 SQL> -- DEFINE scoretable = 'sme'
10:27:31 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:31 SQL> 
10:27:31 SQL> DEFINE target	= '&1'
10:27:31 SQL> DEFINE model_name = '&2'
10:27:31 SQL> DEFINE bldtable	= '&3'
10:27:31 SQL> DEFINE scoretable = '&4'
10:27:31 SQL> DEFINE case_id	= '&5'
10:27:31 SQL> 
10:27:31 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:31 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:31 SQL> 
10:27:31 SQL> -- Builds an SVM model using pl/sql.
10:27:31 SQL> 
10:27:31 SQL> -----------------------------------------------------------------------
10:27:31 SQL> --			    BUILD THE MODEL
10:27:31 SQL> -----------------------------------------------------------------------
10:27:31 SQL> 
10:27:31 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:31 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:31 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:31 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:31 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:31 SQL> 
10:27:31 SQL> 
10:27:31 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:31 SQL> --
10:27:31 SQL> -- DROP	TABLE svmc_settings ;
10:27:31 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:31 SQL> -- DELETE svmc_settings;
10:27:31 SQL> 
10:27:31 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:31 SQL> -- this choice to SVM using a settings table.
10:27:31 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:31 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:31 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:31 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:31 SQL> -- models.
10:27:31 SQL> --
10:27:31 SQL> 
10:27:31 SQL> -- Do this once and then comment it out.
10:27:31 SQL> -- That makes script go faster.
10:27:31 SQL> -- BEGIN
10:27:31 SQL> -- -- Populate settings table
10:27:31 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:31 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:31 SQL> --
10:27:31 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:31 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:31 SQL> --
10:27:31 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:31 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:31 SQL> --   COMMIT;
10:27:31 SQL> -- END;
10:27:31 SQL> -- /
10:27:31 SQL> 
10:27:31 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:31 SQL> 
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:31 SQL> 
10:27:31 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:31   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:31   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:31 SQL> 
10:27:31 SQL> --------------------------------
10:27:31 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:31 SQL> --
10:27:31 SQL> 
10:27:31 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:31 SQL> -- 2. Outlier Treatment and
10:27:31 SQL> -- 3. Normalization are performed below.
10:27:31 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:31 SQL> --    normalized here.
10:27:31 SQL> 
10:27:31 SQL> BEGIN
10:27:31   2  	-- Perform missing value treatment for all predictors
10:27:31   3  	-- create miss tables
10:27:31   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:31   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:31   6  
10:27:31   7  	-- populate miss tables
10:27:31   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:31   9  	  miss_table_name => 'svmc_miss_num',
10:27:31  10  	  data_table_name => '&bldtable',
10:27:31  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:31  12  
10:27:31  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:31  14  	  miss_table_name => 'svmc_miss_cat',
10:27:31  15  	  data_table_name => '&bldtable',
10:27:31  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:31  17  
10:27:31  18  	-- xform input data to replace missing values
10:27:31  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:31  20  	  miss_table_name => 'svmc_miss_num',
10:27:31  21  	  data_table_name => '&bldtable',
10:27:31  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:31  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:31  24  	  miss_table_name => 'svmc_miss_cat',
10:27:31  25  	  data_table_name => '&bldtable',
10:27:31  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:31  27  
10:27:31  28  	-- Perform outlier treatment.
10:27:31  29  	-- create clip table
10:27:31  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:31  31  
10:27:31  32  	-- populate clip table
10:27:31  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:31  34  	  clip_table_name => 'svmc_clip',
10:27:31  35  	  data_table_name => '&bldtable',
10:27:31  36  	  tail_frac	  => 0.025,
10:27:31  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:31  38  
10:27:31  39  	-- xform input data to winsorized data
10:27:31  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:31  41  	  clip_table_name => 'svmc_clip',
10:27:31  42  	  data_table_name => '&bldtable',
10:27:31  43  	  xform_view_name => 'svmc_winsor');
10:27:31  44  
10:27:31  45  	-- create normalization table
10:27:31  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:31  47  
10:27:31  48  	-- populate normalization table based on winsorized data
10:27:31  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:31  50  	  norm_table_name => 'svmc_norm',
10:27:31  51  	  data_table_name => 'svmc_winsor',
10:27:31  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:31  53  
10:27:31  54  	-- normalize the original data
10:27:31  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:31  56  	  norm_table_name => 'svmc_norm',
10:27:31  57  	  data_table_name => '&bldtable',
10:27:31  58  	  xform_view_name => 'svmc_build_prep');
10:27:31  59  END;
10:27:31  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:27:32 SQL> 
10:27:32 SQL> ---------------------
10:27:32 SQL> -- CREATE A NEW MODEL
10:27:32 SQL> --
10:27:32 SQL> -- Cleanup old model with the same name for repeat runs
10:27:32 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:32   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.08
10:27:33 SQL> 
10:27:33 SQL> -- Build a new SVM Model
10:27:33 SQL> BEGIN
10:27:33   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:33   3  	  model_name	      => '&model_name',
10:27:33   4  	  mining_function     => dbms_data_mining.classification,
10:27:33   5  	  data_table_name     => 'svmc_build_prep',
10:27:33   6  	  case_id_column_name => '&case_id',
10:27:33   7  	  target_column_name  => '&target',
10:27:33   8  	  settings_table_name => 'svmc_settings');
10:27:33   9  END;
10:27:33  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.24
10:27:35 SQL> 
10:27:35 SQL> -----------------------------------------------------------------------
10:27:35 SQL> --			       APPLY/score THE MODEL
10:27:35 SQL> -----------------------------------------------------------------------
10:27:35 SQL> 
10:27:35 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:35 SQL> -----------------------
10:27:35 SQL> -- PREPARE SCORING DATA
10:27:35 SQL> --
10:27:35 SQL> -- If the data for model creation has been prepared, then the data
10:27:35 SQL> -- to be scored using the model must be prepared in the same manner
10:27:35 SQL> -- in order to obtain meaningful results.
10:27:35 SQL> --
10:27:35 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:35 SQL> -- 2. Normalization
10:27:35 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:35 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:35 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:35 SQL> --
10:27:35 SQL> BEGIN
10:27:35   2  	-- Xform Test data to replace missing values
10:27:35   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:35   4  	  miss_table_name => 'svmc_miss_num',
10:27:35   5  	  data_table_name => '&scoretable',
10:27:35   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:35   7  
10:27:35   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:35   9  	  miss_table_name => 'svmc_miss_cat',
10:27:35  10  	  data_table_name => '&scoretable',
10:27:35  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:35  12  
10:27:35  13  	-- Normalize the data to be scored
10:27:35  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:35  15  	  norm_table_name => 'svmc_norm',
10:27:35  16  	  data_table_name => '&scoretable',
10:27:35  17  	  xform_view_name => 'svmc_apply_prep');
10:27:35  18  END;
10:27:35  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:36 SQL> 
10:27:36 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:36 SQL> -- DELETE it if I did:
10:27:36 SQL> DELETE ystkscores
10:27:36   2  WHERE score > 0
10:27:36   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:36   4  -- I need to supply the target attribute name:
10:27:36   5  AND targ = '&1'
10:27:36   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:36 SQL> 
10:27:36 SQL> -- We do a drumroll here:
10:27:36 SQL> 
10:27:36 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:36   2  SELECT
10:27:36   3  tkrdate
10:27:36   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:36   5  ,sysdate
10:27:36   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:36   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:36   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:36   9  ,SUBSTR(tkrdate,-10)ydate
10:27:36  10  ,'&1'
10:27:36  11  FROM svmc_apply_prep
10:27:36  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:27:36 SQL> @score1_5min.sql	      2010-08-31 TLT
10:27:36 SQL> --
10:27:36 SQL> -- score1_5min.sql
10:27:36 SQL> --
10:27:36 SQL> 
10:27:36 SQL> -- Demo:
10:27:36 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:36 SQL> 
10:27:36 SQL> CREATE OR REPLACE VIEW sme AS
10:27:36   2  SELECT
10:27:36   3  tkrdate
10:27:36   4  ,NULL gatt
10:27:36   5  ,g00
10:27:36   6  ,g01
10:27:36   7  ,g02
10:27:36   8  ,g03
10:27:36   9  ,g04
10:27:36  10  ,g05
10:27:36  11  ,g06
10:27:36  12  ,g07
10:27:36  13  ,g08
10:27:36  14  ,g09
10:27:36  15  ,g10
10:27:36  16  ,g11
10:27:36  17  ,g12
10:27:36  18  ,g13
10:27:36  19  ,g14
10:27:36  20  ,g15
10:27:36  21  ,g16
10:27:36  22  ,g17
10:27:36  23  ,g18
10:27:36  24  ,g19
10:27:36  25  ,g20
10:27:36  26  ,g21
10:27:36  27  ,g22
10:27:36  28  ,g23
10:27:36  29  ,g24
10:27:36  30  ,g25
10:27:36  31  ,g26
10:27:36  32  ,g27
10:27:36  33  ,g28
10:27:36  34  ,g29
10:27:36  35  FROM stk_ms
10:27:36  36  WHERE ydate = '&1'
10:27:36  37  AND tkr = '&2'
10:27:36  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-31'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:36 SQL> 
10:27:36 SQL> -- rpt
10:27:36 SQL> -- We should see just 1 row:
10:27:36 SQL> 
10:27:36 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:36   2  
10:27:36 SQL> -- Build the model:
10:27:36 SQL> CREATE OR REPLACE VIEW bme AS
10:27:36   2  SELECT
10:27:36   3  tkrdate
10:27:36   4  ,gatt
10:27:36   5  ,g00
10:27:36   6  ,g01
10:27:36   7  ,g02
10:27:36   8  ,g03
10:27:36   9  ,g04
10:27:36  10  ,g05
10:27:36  11  ,g06
10:27:36  12  ,g07
10:27:36  13  ,g08
10:27:36  14  ,g09
10:27:36  15  ,g10
10:27:36  16  ,g11
10:27:36  17  ,g12
10:27:36  18  ,g13
10:27:36  19  ,g14
10:27:36  20  ,g15
10:27:36  21  ,g16
10:27:36  22  ,g17
10:27:36  23  ,g18
10:27:36  24  ,g19
10:27:36  25  ,g20
10:27:36  26  ,g21
10:27:36  27  ,g22
10:27:36  28  ,g23
10:27:36  29  ,g24
10:27:36  30  ,g25
10:27:36  31  ,g26
10:27:36  32  ,g27
10:27:36  33  ,g28
10:27:36  34  ,g29
10:27:36  35  FROM stk_ms
10:27:36  36  WHERE gatt IN('nup','up')
10:27:36  37  -- Use only rows which are older than 1 day:
10:27:36  38  AND 1+ydate < '&1'
10:27:36  39  AND tkr = '&2'
10:27:36  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-31'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:36 SQL> 
10:27:36 SQL> -- rpt
10:27:36 SQL> 
10:27:36 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:36   2  
10:27:36 SQL> SELECT MAX(tkrdate) FROM bme
10:27:36   2  
10:27:36 SQL> -- Now build model from bme and score sme
10:27:36 SQL> @score1.sql gatt
10:27:36 SQL> -- score1.sql
10:27:36 SQL> 
10:27:36 SQL> -- I use this script to send 5 params to score.sql
10:27:36 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:36 SQL> -- Then at the very end of this script I use the model
10:27:36 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:36 SQL> 
10:27:36 SQL> -- I call this script from 2 other scripts:
10:27:36 SQL> -- score1_5min.sql
10:27:36 SQL> -- score1_5min_gattn.sql
10:27:36 SQL> 
10:27:36 SQL> -- The 1st param is the name of the target attribute.
10:27:36 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:36 SQL> 
10:27:36 SQL> -- Demo:
10:27:36 SQL> -- @score1.sql 'gatt'
10:27:36 SQL> -- @score1.sql 'gattn'
10:27:36 SQL> 
10:27:36 SQL> -- Now, I fill up svmc_apply_prep.
10:27:36 SQL> -- I use same model_name used in score.sql
10:27:36 SQL> DEFINE model_name = 'svmspy101'
10:27:36 SQL> DEFINE bldtable	= 'bme'
10:27:36 SQL> DEFINE scoretable = 'sme'
10:27:36 SQL> DEFINE case_id	= 'tkrdate'
10:27:36 SQL> -- Demo:
10:27:36 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:36 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:36 SQL> --
10:27:36 SQL> -- score.sql
10:27:36 SQL> --
10:27:36 SQL> 
10:27:36 SQL> -- usage: score.sql
10:27:36 SQL> 
10:27:36 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:36 SQL> 
10:27:36 SQL> -- DEFINE target	   = 'gatt'
10:27:36 SQL> -- DEFINE model_name = 'svmspy100'
10:27:36 SQL> -- DEFINE bldtable   = 'bme'
10:27:36 SQL> -- DEFINE scoretable = 'sme'
10:27:36 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:36 SQL> 
10:27:36 SQL> DEFINE target	= '&1'
10:27:36 SQL> DEFINE model_name = '&2'
10:27:36 SQL> DEFINE bldtable	= '&3'
10:27:36 SQL> DEFINE scoretable = '&4'
10:27:36 SQL> DEFINE case_id	= '&5'
10:27:36 SQL> 
10:27:36 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:36 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:36 SQL> 
10:27:36 SQL> -- Builds an SVM model using pl/sql.
10:27:36 SQL> 
10:27:36 SQL> -----------------------------------------------------------------------
10:27:36 SQL> --			    BUILD THE MODEL
10:27:36 SQL> -----------------------------------------------------------------------
10:27:36 SQL> 
10:27:36 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:36 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:36 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:36 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:36 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:36 SQL> 
10:27:36 SQL> 
10:27:36 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:36 SQL> --
10:27:36 SQL> -- DROP	TABLE svmc_settings ;
10:27:36 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:36 SQL> -- DELETE svmc_settings;
10:27:36 SQL> 
10:27:36 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:36 SQL> -- this choice to SVM using a settings table.
10:27:36 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:36 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:36 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:36 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:36 SQL> -- models.
10:27:36 SQL> --
10:27:36 SQL> 
10:27:36 SQL> -- Do this once and then comment it out.
10:27:36 SQL> -- That makes script go faster.
10:27:36 SQL> -- BEGIN
10:27:36 SQL> -- -- Populate settings table
10:27:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:36 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:36 SQL> --
10:27:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:36 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:36 SQL> --
10:27:36 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:36 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:36 SQL> --   COMMIT;
10:27:36 SQL> -- END;
10:27:36 SQL> -- /
10:27:36 SQL> 
10:27:36 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:36 SQL> 
10:27:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:27:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:36 SQL> 
10:27:36 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:36   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:36   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:36 SQL> 
10:27:36 SQL> --------------------------------
10:27:36 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:36 SQL> --
10:27:36 SQL> 
10:27:36 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:36 SQL> -- 2. Outlier Treatment and
10:27:36 SQL> -- 3. Normalization are performed below.
10:27:36 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:36 SQL> --    normalized here.
10:27:36 SQL> 
10:27:36 SQL> BEGIN
10:27:36   2  	-- Perform missing value treatment for all predictors
10:27:36   3  	-- create miss tables
10:27:36   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:36   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:36   6  
10:27:36   7  	-- populate miss tables
10:27:36   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:36   9  	  miss_table_name => 'svmc_miss_num',
10:27:36  10  	  data_table_name => '&bldtable',
10:27:36  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:36  12  
10:27:36  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:36  14  	  miss_table_name => 'svmc_miss_cat',
10:27:36  15  	  data_table_name => '&bldtable',
10:27:36  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:36  17  
10:27:36  18  	-- xform input data to replace missing values
10:27:36  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:36  20  	  miss_table_name => 'svmc_miss_num',
10:27:36  21  	  data_table_name => '&bldtable',
10:27:36  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:36  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:36  24  	  miss_table_name => 'svmc_miss_cat',
10:27:36  25  	  data_table_name => '&bldtable',
10:27:36  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:36  27  
10:27:36  28  	-- Perform outlier treatment.
10:27:36  29  	-- create clip table
10:27:36  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:36  31  
10:27:36  32  	-- populate clip table
10:27:36  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:36  34  	  clip_table_name => 'svmc_clip',
10:27:36  35  	  data_table_name => '&bldtable',
10:27:36  36  	  tail_frac	  => 0.025,
10:27:36  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:36  38  
10:27:36  39  	-- xform input data to winsorized data
10:27:36  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:36  41  	  clip_table_name => 'svmc_clip',
10:27:36  42  	  data_table_name => '&bldtable',
10:27:36  43  	  xform_view_name => 'svmc_winsor');
10:27:36  44  
10:27:36  45  	-- create normalization table
10:27:36  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:36  47  
10:27:36  48  	-- populate normalization table based on winsorized data
10:27:36  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:36  50  	  norm_table_name => 'svmc_norm',
10:27:36  51  	  data_table_name => 'svmc_winsor',
10:27:36  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:36  53  
10:27:36  54  	-- normalize the original data
10:27:36  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:36  56  	  norm_table_name => 'svmc_norm',
10:27:36  57  	  data_table_name => '&bldtable',
10:27:36  58  	  xform_view_name => 'svmc_build_prep');
10:27:36  59  END;
10:27:36  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:27:37 SQL> 
10:27:37 SQL> ---------------------
10:27:37 SQL> -- CREATE A NEW MODEL
10:27:37 SQL> --
10:27:37 SQL> -- Cleanup old model with the same name for repeat runs
10:27:37 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:37   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.06
10:27:38 SQL> 
10:27:38 SQL> -- Build a new SVM Model
10:27:38 SQL> BEGIN
10:27:38   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:38   3  	  model_name	      => '&model_name',
10:27:38   4  	  mining_function     => dbms_data_mining.classification,
10:27:38   5  	  data_table_name     => 'svmc_build_prep',
10:27:38   6  	  case_id_column_name => '&case_id',
10:27:38   7  	  target_column_name  => '&target',
10:27:38   8  	  settings_table_name => 'svmc_settings');
10:27:38   9  END;
10:27:38  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.90
10:27:39 SQL> 
10:27:39 SQL> -----------------------------------------------------------------------
10:27:39 SQL> --			       APPLY/score THE MODEL
10:27:39 SQL> -----------------------------------------------------------------------
10:27:39 SQL> 
10:27:39 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:40 SQL> -----------------------
10:27:40 SQL> -- PREPARE SCORING DATA
10:27:40 SQL> --
10:27:40 SQL> -- If the data for model creation has been prepared, then the data
10:27:40 SQL> -- to be scored using the model must be prepared in the same manner
10:27:40 SQL> -- in order to obtain meaningful results.
10:27:40 SQL> --
10:27:40 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:40 SQL> -- 2. Normalization
10:27:40 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:40 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:40 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:40 SQL> --
10:27:40 SQL> BEGIN
10:27:40   2  	-- Xform Test data to replace missing values
10:27:40   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:40   4  	  miss_table_name => 'svmc_miss_num',
10:27:40   5  	  data_table_name => '&scoretable',
10:27:40   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:40   7  
10:27:40   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:40   9  	  miss_table_name => 'svmc_miss_cat',
10:27:40  10  	  data_table_name => '&scoretable',
10:27:40  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:40  12  
10:27:40  13  	-- Normalize the data to be scored
10:27:40  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:40  15  	  norm_table_name => 'svmc_norm',
10:27:40  16  	  data_table_name => '&scoretable',
10:27:40  17  	  xform_view_name => 'svmc_apply_prep');
10:27:40  18  END;
10:27:40  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:40 SQL> 
10:27:40 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:40 SQL> -- DELETE it if I did:
10:27:40 SQL> DELETE ystkscores
10:27:40   2  WHERE score > 0
10:27:40   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:40   4  -- I need to supply the target attribute name:
10:27:40   5  AND targ = '&1'
10:27:40   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:27:40 SQL> 
10:27:40 SQL> -- We do a drumroll here:
10:27:40 SQL> 
10:27:40 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:40   2  SELECT
10:27:40   3  tkrdate
10:27:40   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:40   5  ,sysdate
10:27:40   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:40   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:40   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:40   9  ,SUBSTR(tkrdate,-10)ydate
10:27:40  10  ,'&1'
10:27:40  11  FROM svmc_apply_prep
10:27:40  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:27:40 SQL> @score1_5min.sql	      2010-11-15 TLT
10:27:40 SQL> --
10:27:40 SQL> -- score1_5min.sql
10:27:40 SQL> --
10:27:40 SQL> 
10:27:40 SQL> -- Demo:
10:27:40 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:40 SQL> 
10:27:40 SQL> CREATE OR REPLACE VIEW sme AS
10:27:40   2  SELECT
10:27:40   3  tkrdate
10:27:40   4  ,NULL gatt
10:27:40   5  ,g00
10:27:40   6  ,g01
10:27:40   7  ,g02
10:27:40   8  ,g03
10:27:40   9  ,g04
10:27:40  10  ,g05
10:27:40  11  ,g06
10:27:40  12  ,g07
10:27:40  13  ,g08
10:27:40  14  ,g09
10:27:40  15  ,g10
10:27:40  16  ,g11
10:27:40  17  ,g12
10:27:40  18  ,g13
10:27:40  19  ,g14
10:27:40  20  ,g15
10:27:40  21  ,g16
10:27:40  22  ,g17
10:27:40  23  ,g18
10:27:40  24  ,g19
10:27:40  25  ,g20
10:27:40  26  ,g21
10:27:40  27  ,g22
10:27:40  28  ,g23
10:27:40  29  ,g24
10:27:40  30  ,g25
10:27:40  31  ,g26
10:27:40  32  ,g27
10:27:40  33  ,g28
10:27:40  34  ,g29
10:27:40  35  FROM stk_ms
10:27:40  36  WHERE ydate = '&1'
10:27:40  37  AND tkr = '&2'
10:27:40  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-15'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:40 SQL> 
10:27:40 SQL> -- rpt
10:27:40 SQL> -- We should see just 1 row:
10:27:40 SQL> 
10:27:40 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:40   2  
10:27:40 SQL> -- Build the model:
10:27:40 SQL> CREATE OR REPLACE VIEW bme AS
10:27:40   2  SELECT
10:27:40   3  tkrdate
10:27:40   4  ,gatt
10:27:40   5  ,g00
10:27:40   6  ,g01
10:27:40   7  ,g02
10:27:40   8  ,g03
10:27:40   9  ,g04
10:27:40  10  ,g05
10:27:40  11  ,g06
10:27:40  12  ,g07
10:27:40  13  ,g08
10:27:40  14  ,g09
10:27:40  15  ,g10
10:27:40  16  ,g11
10:27:40  17  ,g12
10:27:40  18  ,g13
10:27:40  19  ,g14
10:27:40  20  ,g15
10:27:40  21  ,g16
10:27:40  22  ,g17
10:27:40  23  ,g18
10:27:40  24  ,g19
10:27:40  25  ,g20
10:27:40  26  ,g21
10:27:40  27  ,g22
10:27:40  28  ,g23
10:27:40  29  ,g24
10:27:40  30  ,g25
10:27:40  31  ,g26
10:27:40  32  ,g27
10:27:40  33  ,g28
10:27:40  34  ,g29
10:27:40  35  FROM stk_ms
10:27:40  36  WHERE gatt IN('nup','up')
10:27:40  37  -- Use only rows which are older than 1 day:
10:27:40  38  AND 1+ydate < '&1'
10:27:40  39  AND tkr = '&2'
10:27:40  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-15'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:40 SQL> 
10:27:40 SQL> -- rpt
10:27:40 SQL> 
10:27:40 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:40   2  
10:27:40 SQL> SELECT MAX(tkrdate) FROM bme
10:27:40   2  
10:27:40 SQL> -- Now build model from bme and score sme
10:27:40 SQL> @score1.sql gatt
10:27:40 SQL> -- score1.sql
10:27:40 SQL> 
10:27:40 SQL> -- I use this script to send 5 params to score.sql
10:27:40 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:40 SQL> -- Then at the very end of this script I use the model
10:27:40 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:40 SQL> 
10:27:40 SQL> -- I call this script from 2 other scripts:
10:27:40 SQL> -- score1_5min.sql
10:27:40 SQL> -- score1_5min_gattn.sql
10:27:40 SQL> 
10:27:40 SQL> -- The 1st param is the name of the target attribute.
10:27:40 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:40 SQL> 
10:27:40 SQL> -- Demo:
10:27:40 SQL> -- @score1.sql 'gatt'
10:27:40 SQL> -- @score1.sql 'gattn'
10:27:40 SQL> 
10:27:40 SQL> -- Now, I fill up svmc_apply_prep.
10:27:40 SQL> -- I use same model_name used in score.sql
10:27:40 SQL> DEFINE model_name = 'svmspy101'
10:27:40 SQL> DEFINE bldtable	= 'bme'
10:27:40 SQL> DEFINE scoretable = 'sme'
10:27:40 SQL> DEFINE case_id	= 'tkrdate'
10:27:40 SQL> -- Demo:
10:27:40 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:40 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:40 SQL> --
10:27:40 SQL> -- score.sql
10:27:40 SQL> --
10:27:40 SQL> 
10:27:40 SQL> -- usage: score.sql
10:27:40 SQL> 
10:27:40 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:40 SQL> 
10:27:40 SQL> -- DEFINE target	   = 'gatt'
10:27:40 SQL> -- DEFINE model_name = 'svmspy100'
10:27:40 SQL> -- DEFINE bldtable   = 'bme'
10:27:40 SQL> -- DEFINE scoretable = 'sme'
10:27:40 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:40 SQL> 
10:27:40 SQL> DEFINE target	= '&1'
10:27:40 SQL> DEFINE model_name = '&2'
10:27:40 SQL> DEFINE bldtable	= '&3'
10:27:40 SQL> DEFINE scoretable = '&4'
10:27:40 SQL> DEFINE case_id	= '&5'
10:27:40 SQL> 
10:27:40 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:40 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:40 SQL> 
10:27:40 SQL> -- Builds an SVM model using pl/sql.
10:27:40 SQL> 
10:27:40 SQL> -----------------------------------------------------------------------
10:27:40 SQL> --			    BUILD THE MODEL
10:27:40 SQL> -----------------------------------------------------------------------
10:27:40 SQL> 
10:27:40 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:40 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:40 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:40 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:40 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:40 SQL> 
10:27:40 SQL> 
10:27:40 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:40 SQL> --
10:27:40 SQL> -- DROP	TABLE svmc_settings ;
10:27:40 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:40 SQL> -- DELETE svmc_settings;
10:27:40 SQL> 
10:27:40 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:40 SQL> -- this choice to SVM using a settings table.
10:27:40 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:40 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:40 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:40 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:40 SQL> -- models.
10:27:40 SQL> --
10:27:40 SQL> 
10:27:40 SQL> -- Do this once and then comment it out.
10:27:40 SQL> -- That makes script go faster.
10:27:40 SQL> -- BEGIN
10:27:40 SQL> -- -- Populate settings table
10:27:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:40 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:40 SQL> --
10:27:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:40 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:40 SQL> --
10:27:40 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:40 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:40 SQL> --   COMMIT;
10:27:40 SQL> -- END;
10:27:40 SQL> -- /
10:27:40 SQL> 
10:27:40 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:40 SQL> 
10:27:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:40 SQL> 
10:27:40 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:40   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:40 SQL> 
10:27:40 SQL> --------------------------------
10:27:40 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:40 SQL> --
10:27:40 SQL> 
10:27:40 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:40 SQL> -- 2. Outlier Treatment and
10:27:40 SQL> -- 3. Normalization are performed below.
10:27:40 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:40 SQL> --    normalized here.
10:27:40 SQL> 
10:27:40 SQL> BEGIN
10:27:40   2  	-- Perform missing value treatment for all predictors
10:27:40   3  	-- create miss tables
10:27:40   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:40   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:40   6  
10:27:40   7  	-- populate miss tables
10:27:40   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:40   9  	  miss_table_name => 'svmc_miss_num',
10:27:40  10  	  data_table_name => '&bldtable',
10:27:40  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:40  12  
10:27:40  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:40  14  	  miss_table_name => 'svmc_miss_cat',
10:27:40  15  	  data_table_name => '&bldtable',
10:27:40  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:40  17  
10:27:40  18  	-- xform input data to replace missing values
10:27:40  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:40  20  	  miss_table_name => 'svmc_miss_num',
10:27:40  21  	  data_table_name => '&bldtable',
10:27:40  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:40  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:40  24  	  miss_table_name => 'svmc_miss_cat',
10:27:40  25  	  data_table_name => '&bldtable',
10:27:40  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:40  27  
10:27:40  28  	-- Perform outlier treatment.
10:27:40  29  	-- create clip table
10:27:40  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:40  31  
10:27:40  32  	-- populate clip table
10:27:40  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:40  34  	  clip_table_name => 'svmc_clip',
10:27:40  35  	  data_table_name => '&bldtable',
10:27:40  36  	  tail_frac	  => 0.025,
10:27:40  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:40  38  
10:27:40  39  	-- xform input data to winsorized data
10:27:40  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:40  41  	  clip_table_name => 'svmc_clip',
10:27:40  42  	  data_table_name => '&bldtable',
10:27:40  43  	  xform_view_name => 'svmc_winsor');
10:27:40  44  
10:27:40  45  	-- create normalization table
10:27:40  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:40  47  
10:27:40  48  	-- populate normalization table based on winsorized data
10:27:40  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:40  50  	  norm_table_name => 'svmc_norm',
10:27:40  51  	  data_table_name => 'svmc_winsor',
10:27:40  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:40  53  
10:27:40  54  	-- normalize the original data
10:27:40  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:40  56  	  norm_table_name => 'svmc_norm',
10:27:40  57  	  data_table_name => '&bldtable',
10:27:40  58  	  xform_view_name => 'svmc_build_prep');
10:27:40  59  END;
10:27:40  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:27:41 SQL> 
10:27:41 SQL> ---------------------
10:27:41 SQL> -- CREATE A NEW MODEL
10:27:41 SQL> --
10:27:41 SQL> -- Cleanup old model with the same name for repeat runs
10:27:41 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:41   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:41   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.34
10:27:42 SQL> 
10:27:42 SQL> -- Build a new SVM Model
10:27:42 SQL> BEGIN
10:27:42   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:42   3  	  model_name	      => '&model_name',
10:27:42   4  	  mining_function     => dbms_data_mining.classification,
10:27:42   5  	  data_table_name     => 'svmc_build_prep',
10:27:42   6  	  case_id_column_name => '&case_id',
10:27:42   7  	  target_column_name  => '&target',
10:27:42   8  	  settings_table_name => 'svmc_settings');
10:27:42   9  END;
10:27:42  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.20
10:27:44 SQL> 
10:27:44 SQL> -----------------------------------------------------------------------
10:27:44 SQL> --			       APPLY/score THE MODEL
10:27:44 SQL> -----------------------------------------------------------------------
10:27:44 SQL> 
10:27:44 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:44 SQL> -----------------------
10:27:44 SQL> -- PREPARE SCORING DATA
10:27:44 SQL> --
10:27:44 SQL> -- If the data for model creation has been prepared, then the data
10:27:44 SQL> -- to be scored using the model must be prepared in the same manner
10:27:44 SQL> -- in order to obtain meaningful results.
10:27:44 SQL> --
10:27:44 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:44 SQL> -- 2. Normalization
10:27:44 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:44 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:44 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:44 SQL> --
10:27:44 SQL> BEGIN
10:27:44   2  	-- Xform Test data to replace missing values
10:27:44   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:44   4  	  miss_table_name => 'svmc_miss_num',
10:27:44   5  	  data_table_name => '&scoretable',
10:27:44   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:44   7  
10:27:44   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:44   9  	  miss_table_name => 'svmc_miss_cat',
10:27:44  10  	  data_table_name => '&scoretable',
10:27:44  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:44  12  
10:27:44  13  	-- Normalize the data to be scored
10:27:44  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:44  15  	  norm_table_name => 'svmc_norm',
10:27:44  16  	  data_table_name => '&scoretable',
10:27:44  17  	  xform_view_name => 'svmc_apply_prep');
10:27:44  18  END;
10:27:44  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:45 SQL> 
10:27:45 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:45 SQL> -- DELETE it if I did:
10:27:45 SQL> DELETE ystkscores
10:27:45   2  WHERE score > 0
10:27:45   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:45   4  -- I need to supply the target attribute name:
10:27:45   5  AND targ = '&1'
10:27:45   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:45 SQL> 
10:27:45 SQL> -- We do a drumroll here:
10:27:45 SQL> 
10:27:45 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:45   2  SELECT
10:27:45   3  tkrdate
10:27:45   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:45   5  ,sysdate
10:27:45   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:45   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:45   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:45   9  ,SUBSTR(tkrdate,-10)ydate
10:27:45  10  ,'&1'
10:27:45  11  FROM svmc_apply_prep
10:27:45  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:27:45 SQL> @score1_5min.sql	      2010-02-19 TLT
10:27:45 SQL> --
10:27:45 SQL> -- score1_5min.sql
10:27:45 SQL> --
10:27:45 SQL> 
10:27:45 SQL> -- Demo:
10:27:45 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:45 SQL> 
10:27:45 SQL> CREATE OR REPLACE VIEW sme AS
10:27:45   2  SELECT
10:27:45   3  tkrdate
10:27:45   4  ,NULL gatt
10:27:45   5  ,g00
10:27:45   6  ,g01
10:27:45   7  ,g02
10:27:45   8  ,g03
10:27:45   9  ,g04
10:27:45  10  ,g05
10:27:45  11  ,g06
10:27:45  12  ,g07
10:27:45  13  ,g08
10:27:45  14  ,g09
10:27:45  15  ,g10
10:27:45  16  ,g11
10:27:45  17  ,g12
10:27:45  18  ,g13
10:27:45  19  ,g14
10:27:45  20  ,g15
10:27:45  21  ,g16
10:27:45  22  ,g17
10:27:45  23  ,g18
10:27:45  24  ,g19
10:27:45  25  ,g20
10:27:45  26  ,g21
10:27:45  27  ,g22
10:27:45  28  ,g23
10:27:45  29  ,g24
10:27:45  30  ,g25
10:27:45  31  ,g26
10:27:45  32  ,g27
10:27:45  33  ,g28
10:27:45  34  ,g29
10:27:45  35  FROM stk_ms
10:27:45  36  WHERE ydate = '&1'
10:27:45  37  AND tkr = '&2'
10:27:45  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-19'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.12
10:27:45 SQL> 
10:27:45 SQL> -- rpt
10:27:45 SQL> -- We should see just 1 row:
10:27:45 SQL> 
10:27:45 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:45   2  
10:27:45 SQL> -- Build the model:
10:27:45 SQL> CREATE OR REPLACE VIEW bme AS
10:27:45   2  SELECT
10:27:45   3  tkrdate
10:27:45   4  ,gatt
10:27:45   5  ,g00
10:27:45   6  ,g01
10:27:45   7  ,g02
10:27:45   8  ,g03
10:27:45   9  ,g04
10:27:45  10  ,g05
10:27:45  11  ,g06
10:27:45  12  ,g07
10:27:45  13  ,g08
10:27:45  14  ,g09
10:27:45  15  ,g10
10:27:45  16  ,g11
10:27:45  17  ,g12
10:27:45  18  ,g13
10:27:45  19  ,g14
10:27:45  20  ,g15
10:27:45  21  ,g16
10:27:45  22  ,g17
10:27:45  23  ,g18
10:27:45  24  ,g19
10:27:45  25  ,g20
10:27:45  26  ,g21
10:27:45  27  ,g22
10:27:45  28  ,g23
10:27:45  29  ,g24
10:27:45  30  ,g25
10:27:45  31  ,g26
10:27:45  32  ,g27
10:27:45  33  ,g28
10:27:45  34  ,g29
10:27:45  35  FROM stk_ms
10:27:45  36  WHERE gatt IN('nup','up')
10:27:45  37  -- Use only rows which are older than 1 day:
10:27:45  38  AND 1+ydate < '&1'
10:27:45  39  AND tkr = '&2'
10:27:45  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-19'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.14
10:27:45 SQL> 
10:27:45 SQL> -- rpt
10:27:45 SQL> 
10:27:45 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:45   2  
10:27:45 SQL> SELECT MAX(tkrdate) FROM bme
10:27:45   2  
10:27:45 SQL> -- Now build model from bme and score sme
10:27:45 SQL> @score1.sql gatt
10:27:45 SQL> -- score1.sql
10:27:45 SQL> 
10:27:45 SQL> -- I use this script to send 5 params to score.sql
10:27:45 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:45 SQL> -- Then at the very end of this script I use the model
10:27:45 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:45 SQL> 
10:27:45 SQL> -- I call this script from 2 other scripts:
10:27:45 SQL> -- score1_5min.sql
10:27:45 SQL> -- score1_5min_gattn.sql
10:27:45 SQL> 
10:27:45 SQL> -- The 1st param is the name of the target attribute.
10:27:45 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:45 SQL> 
10:27:45 SQL> -- Demo:
10:27:45 SQL> -- @score1.sql 'gatt'
10:27:45 SQL> -- @score1.sql 'gattn'
10:27:45 SQL> 
10:27:45 SQL> -- Now, I fill up svmc_apply_prep.
10:27:45 SQL> -- I use same model_name used in score.sql
10:27:45 SQL> DEFINE model_name = 'svmspy101'
10:27:45 SQL> DEFINE bldtable	= 'bme'
10:27:45 SQL> DEFINE scoretable = 'sme'
10:27:45 SQL> DEFINE case_id	= 'tkrdate'
10:27:45 SQL> -- Demo:
10:27:45 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:45 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:45 SQL> --
10:27:45 SQL> -- score.sql
10:27:45 SQL> --
10:27:45 SQL> 
10:27:45 SQL> -- usage: score.sql
10:27:45 SQL> 
10:27:45 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:45 SQL> 
10:27:45 SQL> -- DEFINE target	   = 'gatt'
10:27:45 SQL> -- DEFINE model_name = 'svmspy100'
10:27:45 SQL> -- DEFINE bldtable   = 'bme'
10:27:45 SQL> -- DEFINE scoretable = 'sme'
10:27:45 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:45 SQL> 
10:27:45 SQL> DEFINE target	= '&1'
10:27:45 SQL> DEFINE model_name = '&2'
10:27:45 SQL> DEFINE bldtable	= '&3'
10:27:45 SQL> DEFINE scoretable = '&4'
10:27:45 SQL> DEFINE case_id	= '&5'
10:27:45 SQL> 
10:27:45 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:45 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:45 SQL> 
10:27:45 SQL> -- Builds an SVM model using pl/sql.
10:27:45 SQL> 
10:27:45 SQL> -----------------------------------------------------------------------
10:27:45 SQL> --			    BUILD THE MODEL
10:27:45 SQL> -----------------------------------------------------------------------
10:27:45 SQL> 
10:27:45 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:45 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:45 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:27:45 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:45 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:45 SQL> 
10:27:45 SQL> 
10:27:45 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:45 SQL> --
10:27:45 SQL> -- DROP	TABLE svmc_settings ;
10:27:45 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:45 SQL> -- DELETE svmc_settings;
10:27:45 SQL> 
10:27:45 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:45 SQL> -- this choice to SVM using a settings table.
10:27:45 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:45 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:45 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:45 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:45 SQL> -- models.
10:27:45 SQL> --
10:27:45 SQL> 
10:27:45 SQL> -- Do this once and then comment it out.
10:27:45 SQL> -- That makes script go faster.
10:27:45 SQL> -- BEGIN
10:27:45 SQL> -- -- Populate settings table
10:27:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:45 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:45 SQL> --
10:27:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:45 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:45 SQL> --
10:27:45 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:45 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:45 SQL> --   COMMIT;
10:27:45 SQL> -- END;
10:27:45 SQL> -- /
10:27:45 SQL> 
10:27:45 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:27:45 SQL> 
10:27:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:45 SQL> 
10:27:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:45 SQL> 
10:27:45 SQL> --------------------------------
10:27:45 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:45 SQL> --
10:27:45 SQL> 
10:27:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:45 SQL> -- 2. Outlier Treatment and
10:27:45 SQL> -- 3. Normalization are performed below.
10:27:45 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:45 SQL> --    normalized here.
10:27:45 SQL> 
10:27:45 SQL> BEGIN
10:27:45   2  	-- Perform missing value treatment for all predictors
10:27:45   3  	-- create miss tables
10:27:45   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:45   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:45   6  
10:27:45   7  	-- populate miss tables
10:27:45   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:45   9  	  miss_table_name => 'svmc_miss_num',
10:27:45  10  	  data_table_name => '&bldtable',
10:27:45  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:45  12  
10:27:45  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:45  14  	  miss_table_name => 'svmc_miss_cat',
10:27:45  15  	  data_table_name => '&bldtable',
10:27:45  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:45  17  
10:27:45  18  	-- xform input data to replace missing values
10:27:45  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:45  20  	  miss_table_name => 'svmc_miss_num',
10:27:45  21  	  data_table_name => '&bldtable',
10:27:45  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:45  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:45  24  	  miss_table_name => 'svmc_miss_cat',
10:27:45  25  	  data_table_name => '&bldtable',
10:27:45  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:45  27  
10:27:45  28  	-- Perform outlier treatment.
10:27:45  29  	-- create clip table
10:27:45  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:45  31  
10:27:45  32  	-- populate clip table
10:27:45  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:45  34  	  clip_table_name => 'svmc_clip',
10:27:45  35  	  data_table_name => '&bldtable',
10:27:45  36  	  tail_frac	  => 0.025,
10:27:45  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:45  38  
10:27:45  39  	-- xform input data to winsorized data
10:27:45  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:45  41  	  clip_table_name => 'svmc_clip',
10:27:45  42  	  data_table_name => '&bldtable',
10:27:45  43  	  xform_view_name => 'svmc_winsor');
10:27:45  44  
10:27:45  45  	-- create normalization table
10:27:45  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:45  47  
10:27:45  48  	-- populate normalization table based on winsorized data
10:27:45  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:45  50  	  norm_table_name => 'svmc_norm',
10:27:45  51  	  data_table_name => 'svmc_winsor',
10:27:45  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:45  53  
10:27:45  54  	-- normalize the original data
10:27:45  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:45  56  	  norm_table_name => 'svmc_norm',
10:27:45  57  	  data_table_name => '&bldtable',
10:27:45  58  	  xform_view_name => 'svmc_build_prep');
10:27:45  59  END;
10:27:45  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:27:46 SQL> 
10:27:46 SQL> ---------------------
10:27:46 SQL> -- CREATE A NEW MODEL
10:27:46 SQL> --
10:27:46 SQL> -- Cleanup old model with the same name for repeat runs
10:27:46 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:46   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.93
10:27:46 SQL> 
10:27:46 SQL> -- Build a new SVM Model
10:27:46 SQL> BEGIN
10:27:46   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:46   3  	  model_name	      => '&model_name',
10:27:46   4  	  mining_function     => dbms_data_mining.classification,
10:27:46   5  	  data_table_name     => 'svmc_build_prep',
10:27:46   6  	  case_id_column_name => '&case_id',
10:27:46   7  	  target_column_name  => '&target',
10:27:46   8  	  settings_table_name => 'svmc_settings');
10:27:46   9  END;
10:27:46  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.52
10:27:49 SQL> 
10:27:49 SQL> -----------------------------------------------------------------------
10:27:49 SQL> --			       APPLY/score THE MODEL
10:27:49 SQL> -----------------------------------------------------------------------
10:27:49 SQL> 
10:27:49 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:49 SQL> -----------------------
10:27:49 SQL> -- PREPARE SCORING DATA
10:27:49 SQL> --
10:27:49 SQL> -- If the data for model creation has been prepared, then the data
10:27:49 SQL> -- to be scored using the model must be prepared in the same manner
10:27:49 SQL> -- in order to obtain meaningful results.
10:27:49 SQL> --
10:27:49 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:49 SQL> -- 2. Normalization
10:27:49 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:49 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:49 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:49 SQL> --
10:27:49 SQL> BEGIN
10:27:49   2  	-- Xform Test data to replace missing values
10:27:49   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:49   4  	  miss_table_name => 'svmc_miss_num',
10:27:49   5  	  data_table_name => '&scoretable',
10:27:49   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:49   7  
10:27:49   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:49   9  	  miss_table_name => 'svmc_miss_cat',
10:27:49  10  	  data_table_name => '&scoretable',
10:27:49  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:49  12  
10:27:49  13  	-- Normalize the data to be scored
10:27:49  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:49  15  	  norm_table_name => 'svmc_norm',
10:27:49  16  	  data_table_name => '&scoretable',
10:27:49  17  	  xform_view_name => 'svmc_apply_prep');
10:27:49  18  END;
10:27:49  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:49 SQL> 
10:27:49 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:49 SQL> -- DELETE it if I did:
10:27:49 SQL> DELETE ystkscores
10:27:49   2  WHERE score > 0
10:27:49   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:49   4  -- I need to supply the target attribute name:
10:27:49   5  AND targ = '&1'
10:27:49   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:49 SQL> 
10:27:49 SQL> -- We do a drumroll here:
10:27:49 SQL> 
10:27:49 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:49   2  SELECT
10:27:49   3  tkrdate
10:27:49   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:49   5  ,sysdate
10:27:49   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:49   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:49   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:49   9  ,SUBSTR(tkrdate,-10)ydate
10:27:49  10  ,'&1'
10:27:49  11  FROM svmc_apply_prep
10:27:49  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:27:49 SQL> @score1_5min.sql	      2010-11-05 TLT
10:27:49 SQL> --
10:27:49 SQL> -- score1_5min.sql
10:27:49 SQL> --
10:27:49 SQL> 
10:27:49 SQL> -- Demo:
10:27:49 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:49 SQL> 
10:27:49 SQL> CREATE OR REPLACE VIEW sme AS
10:27:49   2  SELECT
10:27:49   3  tkrdate
10:27:49   4  ,NULL gatt
10:27:49   5  ,g00
10:27:49   6  ,g01
10:27:49   7  ,g02
10:27:49   8  ,g03
10:27:49   9  ,g04
10:27:49  10  ,g05
10:27:49  11  ,g06
10:27:49  12  ,g07
10:27:49  13  ,g08
10:27:49  14  ,g09
10:27:49  15  ,g10
10:27:49  16  ,g11
10:27:49  17  ,g12
10:27:49  18  ,g13
10:27:49  19  ,g14
10:27:49  20  ,g15
10:27:49  21  ,g16
10:27:49  22  ,g17
10:27:49  23  ,g18
10:27:49  24  ,g19
10:27:49  25  ,g20
10:27:49  26  ,g21
10:27:49  27  ,g22
10:27:49  28  ,g23
10:27:49  29  ,g24
10:27:49  30  ,g25
10:27:49  31  ,g26
10:27:49  32  ,g27
10:27:49  33  ,g28
10:27:49  34  ,g29
10:27:49  35  FROM stk_ms
10:27:49  36  WHERE ydate = '&1'
10:27:49  37  AND tkr = '&2'
10:27:49  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-05'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:49 SQL> 
10:27:49 SQL> -- rpt
10:27:49 SQL> -- We should see just 1 row:
10:27:49 SQL> 
10:27:49 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:49   2  
10:27:49 SQL> -- Build the model:
10:27:49 SQL> CREATE OR REPLACE VIEW bme AS
10:27:49   2  SELECT
10:27:49   3  tkrdate
10:27:49   4  ,gatt
10:27:49   5  ,g00
10:27:49   6  ,g01
10:27:49   7  ,g02
10:27:49   8  ,g03
10:27:49   9  ,g04
10:27:49  10  ,g05
10:27:49  11  ,g06
10:27:49  12  ,g07
10:27:49  13  ,g08
10:27:49  14  ,g09
10:27:49  15  ,g10
10:27:49  16  ,g11
10:27:49  17  ,g12
10:27:49  18  ,g13
10:27:49  19  ,g14
10:27:49  20  ,g15
10:27:49  21  ,g16
10:27:49  22  ,g17
10:27:49  23  ,g18
10:27:49  24  ,g19
10:27:49  25  ,g20
10:27:49  26  ,g21
10:27:49  27  ,g22
10:27:49  28  ,g23
10:27:49  29  ,g24
10:27:49  30  ,g25
10:27:49  31  ,g26
10:27:49  32  ,g27
10:27:49  33  ,g28
10:27:49  34  ,g29
10:27:49  35  FROM stk_ms
10:27:49  36  WHERE gatt IN('nup','up')
10:27:49  37  -- Use only rows which are older than 1 day:
10:27:49  38  AND 1+ydate < '&1'
10:27:49  39  AND tkr = '&2'
10:27:49  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-05'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.06
10:27:49 SQL> 
10:27:49 SQL> -- rpt
10:27:49 SQL> 
10:27:49 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:49   2  
10:27:49 SQL> SELECT MAX(tkrdate) FROM bme
10:27:49   2  
10:27:49 SQL> -- Now build model from bme and score sme
10:27:49 SQL> @score1.sql gatt
10:27:49 SQL> -- score1.sql
10:27:49 SQL> 
10:27:49 SQL> -- I use this script to send 5 params to score.sql
10:27:49 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:49 SQL> -- Then at the very end of this script I use the model
10:27:49 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:49 SQL> 
10:27:49 SQL> -- I call this script from 2 other scripts:
10:27:49 SQL> -- score1_5min.sql
10:27:49 SQL> -- score1_5min_gattn.sql
10:27:49 SQL> 
10:27:49 SQL> -- The 1st param is the name of the target attribute.
10:27:49 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:49 SQL> 
10:27:49 SQL> -- Demo:
10:27:49 SQL> -- @score1.sql 'gatt'
10:27:49 SQL> -- @score1.sql 'gattn'
10:27:49 SQL> 
10:27:49 SQL> -- Now, I fill up svmc_apply_prep.
10:27:49 SQL> -- I use same model_name used in score.sql
10:27:49 SQL> DEFINE model_name = 'svmspy101'
10:27:49 SQL> DEFINE bldtable	= 'bme'
10:27:49 SQL> DEFINE scoretable = 'sme'
10:27:49 SQL> DEFINE case_id	= 'tkrdate'
10:27:49 SQL> -- Demo:
10:27:49 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:49 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:49 SQL> --
10:27:49 SQL> -- score.sql
10:27:49 SQL> --
10:27:49 SQL> 
10:27:49 SQL> -- usage: score.sql
10:27:49 SQL> 
10:27:49 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:49 SQL> 
10:27:49 SQL> -- DEFINE target	   = 'gatt'
10:27:49 SQL> -- DEFINE model_name = 'svmspy100'
10:27:49 SQL> -- DEFINE bldtable   = 'bme'
10:27:49 SQL> -- DEFINE scoretable = 'sme'
10:27:49 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:49 SQL> 
10:27:49 SQL> DEFINE target	= '&1'
10:27:49 SQL> DEFINE model_name = '&2'
10:27:49 SQL> DEFINE bldtable	= '&3'
10:27:49 SQL> DEFINE scoretable = '&4'
10:27:49 SQL> DEFINE case_id	= '&5'
10:27:49 SQL> 
10:27:49 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:49 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:49 SQL> 
10:27:49 SQL> -- Builds an SVM model using pl/sql.
10:27:49 SQL> 
10:27:49 SQL> -----------------------------------------------------------------------
10:27:49 SQL> --			    BUILD THE MODEL
10:27:49 SQL> -----------------------------------------------------------------------
10:27:49 SQL> 
10:27:49 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:49 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:49 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:27:49 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:49 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:49 SQL> 
10:27:49 SQL> 
10:27:49 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:49 SQL> --
10:27:49 SQL> -- DROP	TABLE svmc_settings ;
10:27:49 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:49 SQL> -- DELETE svmc_settings;
10:27:49 SQL> 
10:27:49 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:49 SQL> -- this choice to SVM using a settings table.
10:27:49 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:49 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:49 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:49 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:49 SQL> -- models.
10:27:49 SQL> --
10:27:49 SQL> 
10:27:49 SQL> -- Do this once and then comment it out.
10:27:49 SQL> -- That makes script go faster.
10:27:49 SQL> -- BEGIN
10:27:49 SQL> -- -- Populate settings table
10:27:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:49 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:49 SQL> --
10:27:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:49 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:49 SQL> --
10:27:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:49 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:49 SQL> --   COMMIT;
10:27:49 SQL> -- END;
10:27:49 SQL> -- /
10:27:49 SQL> 
10:27:49 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:49 SQL> 
10:27:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:50 SQL> 
10:27:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:50 SQL> 
10:27:50 SQL> --------------------------------
10:27:50 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:50 SQL> --
10:27:50 SQL> 
10:27:50 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:50 SQL> -- 2. Outlier Treatment and
10:27:50 SQL> -- 3. Normalization are performed below.
10:27:50 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:50 SQL> --    normalized here.
10:27:50 SQL> 
10:27:50 SQL> BEGIN
10:27:50   2  	-- Perform missing value treatment for all predictors
10:27:50   3  	-- create miss tables
10:27:50   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:50   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:50   6  
10:27:50   7  	-- populate miss tables
10:27:50   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:50   9  	  miss_table_name => 'svmc_miss_num',
10:27:50  10  	  data_table_name => '&bldtable',
10:27:50  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:50  12  
10:27:50  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:50  14  	  miss_table_name => 'svmc_miss_cat',
10:27:50  15  	  data_table_name => '&bldtable',
10:27:50  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:50  17  
10:27:50  18  	-- xform input data to replace missing values
10:27:50  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:50  20  	  miss_table_name => 'svmc_miss_num',
10:27:50  21  	  data_table_name => '&bldtable',
10:27:50  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:50  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:50  24  	  miss_table_name => 'svmc_miss_cat',
10:27:50  25  	  data_table_name => '&bldtable',
10:27:50  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:50  27  
10:27:50  28  	-- Perform outlier treatment.
10:27:50  29  	-- create clip table
10:27:50  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:50  31  
10:27:50  32  	-- populate clip table
10:27:50  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:50  34  	  clip_table_name => 'svmc_clip',
10:27:50  35  	  data_table_name => '&bldtable',
10:27:50  36  	  tail_frac	  => 0.025,
10:27:50  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:50  38  
10:27:50  39  	-- xform input data to winsorized data
10:27:50  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:50  41  	  clip_table_name => 'svmc_clip',
10:27:50  42  	  data_table_name => '&bldtable',
10:27:50  43  	  xform_view_name => 'svmc_winsor');
10:27:50  44  
10:27:50  45  	-- create normalization table
10:27:50  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:50  47  
10:27:50  48  	-- populate normalization table based on winsorized data
10:27:50  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:50  50  	  norm_table_name => 'svmc_norm',
10:27:50  51  	  data_table_name => 'svmc_winsor',
10:27:50  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:50  53  
10:27:50  54  	-- normalize the original data
10:27:50  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:50  56  	  norm_table_name => 'svmc_norm',
10:27:50  57  	  data_table_name => '&bldtable',
10:27:50  58  	  xform_view_name => 'svmc_build_prep');
10:27:50  59  END;
10:27:50  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:27:50 SQL> 
10:27:50 SQL> ---------------------
10:27:50 SQL> -- CREATE A NEW MODEL
10:27:50 SQL> --
10:27:50 SQL> -- Cleanup old model with the same name for repeat runs
10:27:50 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:50   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.97
10:27:51 SQL> 
10:27:51 SQL> -- Build a new SVM Model
10:27:51 SQL> BEGIN
10:27:51   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:51   3  	  model_name	      => '&model_name',
10:27:51   4  	  mining_function     => dbms_data_mining.classification,
10:27:51   5  	  data_table_name     => 'svmc_build_prep',
10:27:51   6  	  case_id_column_name => '&case_id',
10:27:51   7  	  target_column_name  => '&target',
10:27:51   8  	  settings_table_name => 'svmc_settings');
10:27:51   9  END;
10:27:51  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.79
10:27:54 SQL> 
10:27:54 SQL> -----------------------------------------------------------------------
10:27:54 SQL> --			       APPLY/score THE MODEL
10:27:54 SQL> -----------------------------------------------------------------------
10:27:54 SQL> 
10:27:54 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:54 SQL> -----------------------
10:27:54 SQL> -- PREPARE SCORING DATA
10:27:54 SQL> --
10:27:54 SQL> -- If the data for model creation has been prepared, then the data
10:27:54 SQL> -- to be scored using the model must be prepared in the same manner
10:27:54 SQL> -- in order to obtain meaningful results.
10:27:54 SQL> --
10:27:54 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:54 SQL> -- 2. Normalization
10:27:54 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:54 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:54 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:54 SQL> --
10:27:54 SQL> BEGIN
10:27:54   2  	-- Xform Test data to replace missing values
10:27:54   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:54   4  	  miss_table_name => 'svmc_miss_num',
10:27:54   5  	  data_table_name => '&scoretable',
10:27:54   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:54   7  
10:27:54   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:54   9  	  miss_table_name => 'svmc_miss_cat',
10:27:54  10  	  data_table_name => '&scoretable',
10:27:54  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:54  12  
10:27:54  13  	-- Normalize the data to be scored
10:27:54  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:54  15  	  norm_table_name => 'svmc_norm',
10:27:54  16  	  data_table_name => '&scoretable',
10:27:54  17  	  xform_view_name => 'svmc_apply_prep');
10:27:54  18  END;
10:27:54  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:54 SQL> 
10:27:54 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:54 SQL> -- DELETE it if I did:
10:27:54 SQL> DELETE ystkscores
10:27:54   2  WHERE score > 0
10:27:54   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:54   4  -- I need to supply the target attribute name:
10:27:54   5  AND targ = '&1'
10:27:54   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:27:54 SQL> 
10:27:54 SQL> -- We do a drumroll here:
10:27:54 SQL> 
10:27:54 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:54   2  SELECT
10:27:54   3  tkrdate
10:27:54   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:54   5  ,sysdate
10:27:54   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:54   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:54   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:54   9  ,SUBSTR(tkrdate,-10)ydate
10:27:54  10  ,'&1'
10:27:54  11  FROM svmc_apply_prep
10:27:54  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:27:54 SQL> @score1_5min.sql	      2010-02-11 TLT
10:27:54 SQL> --
10:27:54 SQL> -- score1_5min.sql
10:27:54 SQL> --
10:27:54 SQL> 
10:27:54 SQL> -- Demo:
10:27:54 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:27:54 SQL> 
10:27:54 SQL> CREATE OR REPLACE VIEW sme AS
10:27:54   2  SELECT
10:27:54   3  tkrdate
10:27:54   4  ,NULL gatt
10:27:54   5  ,g00
10:27:54   6  ,g01
10:27:54   7  ,g02
10:27:54   8  ,g03
10:27:54   9  ,g04
10:27:54  10  ,g05
10:27:54  11  ,g06
10:27:54  12  ,g07
10:27:54  13  ,g08
10:27:54  14  ,g09
10:27:54  15  ,g10
10:27:54  16  ,g11
10:27:54  17  ,g12
10:27:54  18  ,g13
10:27:54  19  ,g14
10:27:54  20  ,g15
10:27:54  21  ,g16
10:27:54  22  ,g17
10:27:54  23  ,g18
10:27:54  24  ,g19
10:27:54  25  ,g20
10:27:54  26  ,g21
10:27:54  27  ,g22
10:27:54  28  ,g23
10:27:54  29  ,g24
10:27:54  30  ,g25
10:27:54  31  ,g26
10:27:54  32  ,g27
10:27:54  33  ,g28
10:27:54  34  ,g29
10:27:54  35  FROM stk_ms
10:27:54  36  WHERE ydate = '&1'
10:27:54  37  AND tkr = '&2'
10:27:54  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-02-11'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:54 SQL> 
10:27:54 SQL> -- rpt
10:27:54 SQL> -- We should see just 1 row:
10:27:54 SQL> 
10:27:54 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:54   2  
10:27:54 SQL> -- Build the model:
10:27:54 SQL> CREATE OR REPLACE VIEW bme AS
10:27:54   2  SELECT
10:27:54   3  tkrdate
10:27:54   4  ,gatt
10:27:54   5  ,g00
10:27:54   6  ,g01
10:27:54   7  ,g02
10:27:54   8  ,g03
10:27:54   9  ,g04
10:27:54  10  ,g05
10:27:54  11  ,g06
10:27:54  12  ,g07
10:27:54  13  ,g08
10:27:54  14  ,g09
10:27:54  15  ,g10
10:27:54  16  ,g11
10:27:54  17  ,g12
10:27:54  18  ,g13
10:27:54  19  ,g14
10:27:54  20  ,g15
10:27:54  21  ,g16
10:27:54  22  ,g17
10:27:54  23  ,g18
10:27:54  24  ,g19
10:27:54  25  ,g20
10:27:54  26  ,g21
10:27:54  27  ,g22
10:27:54  28  ,g23
10:27:54  29  ,g24
10:27:54  30  ,g25
10:27:54  31  ,g26
10:27:54  32  ,g27
10:27:54  33  ,g28
10:27:54  34  ,g29
10:27:54  35  FROM stk_ms
10:27:54  36  WHERE gatt IN('nup','up')
10:27:54  37  -- Use only rows which are older than 1 day:
10:27:54  38  AND 1+ydate < '&1'
10:27:54  39  AND tkr = '&2'
10:27:54  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-02-11'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:54 SQL> 
10:27:54 SQL> -- rpt
10:27:54 SQL> 
10:27:54 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:27:54   2  
10:27:54 SQL> SELECT MAX(tkrdate) FROM bme
10:27:54   2  
10:27:54 SQL> -- Now build model from bme and score sme
10:27:54 SQL> @score1.sql gatt
10:27:54 SQL> -- score1.sql
10:27:54 SQL> 
10:27:54 SQL> -- I use this script to send 5 params to score.sql
10:27:54 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:54 SQL> -- Then at the very end of this script I use the model
10:27:54 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:54 SQL> 
10:27:54 SQL> -- I call this script from 2 other scripts:
10:27:54 SQL> -- score1_5min.sql
10:27:54 SQL> -- score1_5min_gattn.sql
10:27:54 SQL> 
10:27:54 SQL> -- The 1st param is the name of the target attribute.
10:27:54 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:54 SQL> 
10:27:54 SQL> -- Demo:
10:27:54 SQL> -- @score1.sql 'gatt'
10:27:54 SQL> -- @score1.sql 'gattn'
10:27:54 SQL> 
10:27:54 SQL> -- Now, I fill up svmc_apply_prep.
10:27:54 SQL> -- I use same model_name used in score.sql
10:27:54 SQL> DEFINE model_name = 'svmspy101'
10:27:54 SQL> DEFINE bldtable	= 'bme'
10:27:54 SQL> DEFINE scoretable = 'sme'
10:27:54 SQL> DEFINE case_id	= 'tkrdate'
10:27:54 SQL> -- Demo:
10:27:54 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:54 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:54 SQL> --
10:27:54 SQL> -- score.sql
10:27:54 SQL> --
10:27:54 SQL> 
10:27:54 SQL> -- usage: score.sql
10:27:54 SQL> 
10:27:54 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:54 SQL> 
10:27:54 SQL> -- DEFINE target	   = 'gatt'
10:27:54 SQL> -- DEFINE model_name = 'svmspy100'
10:27:54 SQL> -- DEFINE bldtable   = 'bme'
10:27:54 SQL> -- DEFINE scoretable = 'sme'
10:27:54 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:54 SQL> 
10:27:54 SQL> DEFINE target	= '&1'
10:27:54 SQL> DEFINE model_name = '&2'
10:27:54 SQL> DEFINE bldtable	= '&3'
10:27:54 SQL> DEFINE scoretable = '&4'
10:27:54 SQL> DEFINE case_id	= '&5'
10:27:54 SQL> 
10:27:54 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:54 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:54 SQL> 
10:27:54 SQL> -- Builds an SVM model using pl/sql.
10:27:54 SQL> 
10:27:54 SQL> -----------------------------------------------------------------------
10:27:54 SQL> --			    BUILD THE MODEL
10:27:54 SQL> -----------------------------------------------------------------------
10:27:54 SQL> 
10:27:54 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:54 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:54 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:54 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:54 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:27:54 SQL> 
10:27:54 SQL> 
10:27:54 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:54 SQL> --
10:27:54 SQL> -- DROP	TABLE svmc_settings ;
10:27:54 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:54 SQL> -- DELETE svmc_settings;
10:27:54 SQL> 
10:27:54 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:54 SQL> -- this choice to SVM using a settings table.
10:27:54 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:54 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:54 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:54 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:54 SQL> -- models.
10:27:54 SQL> --
10:27:54 SQL> 
10:27:54 SQL> -- Do this once and then comment it out.
10:27:54 SQL> -- That makes script go faster.
10:27:54 SQL> -- BEGIN
10:27:54 SQL> -- -- Populate settings table
10:27:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:54 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:54 SQL> --
10:27:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:54 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:54 SQL> --
10:27:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:54 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:54 SQL> --   COMMIT;
10:27:54 SQL> -- END;
10:27:54 SQL> -- /
10:27:54 SQL> 
10:27:54 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:54 SQL> 
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:27:54 SQL> 
10:27:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:55 SQL> 
10:27:55 SQL> --------------------------------
10:27:55 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:55 SQL> --
10:27:55 SQL> 
10:27:55 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:55 SQL> -- 2. Outlier Treatment and
10:27:55 SQL> -- 3. Normalization are performed below.
10:27:55 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:55 SQL> --    normalized here.
10:27:55 SQL> 
10:27:55 SQL> BEGIN
10:27:55   2  	-- Perform missing value treatment for all predictors
10:27:55   3  	-- create miss tables
10:27:55   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:55   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:55   6  
10:27:55   7  	-- populate miss tables
10:27:55   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:55   9  	  miss_table_name => 'svmc_miss_num',
10:27:55  10  	  data_table_name => '&bldtable',
10:27:55  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:55  12  
10:27:55  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:55  14  	  miss_table_name => 'svmc_miss_cat',
10:27:55  15  	  data_table_name => '&bldtable',
10:27:55  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:55  17  
10:27:55  18  	-- xform input data to replace missing values
10:27:55  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:55  20  	  miss_table_name => 'svmc_miss_num',
10:27:55  21  	  data_table_name => '&bldtable',
10:27:55  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:55  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:55  24  	  miss_table_name => 'svmc_miss_cat',
10:27:55  25  	  data_table_name => '&bldtable',
10:27:55  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:55  27  
10:27:55  28  	-- Perform outlier treatment.
10:27:55  29  	-- create clip table
10:27:55  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:55  31  
10:27:55  32  	-- populate clip table
10:27:55  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:55  34  	  clip_table_name => 'svmc_clip',
10:27:55  35  	  data_table_name => '&bldtable',
10:27:55  36  	  tail_frac	  => 0.025,
10:27:55  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:55  38  
10:27:55  39  	-- xform input data to winsorized data
10:27:55  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:55  41  	  clip_table_name => 'svmc_clip',
10:27:55  42  	  data_table_name => '&bldtable',
10:27:55  43  	  xform_view_name => 'svmc_winsor');
10:27:55  44  
10:27:55  45  	-- create normalization table
10:27:55  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:55  47  
10:27:55  48  	-- populate normalization table based on winsorized data
10:27:55  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:55  50  	  norm_table_name => 'svmc_norm',
10:27:55  51  	  data_table_name => 'svmc_winsor',
10:27:55  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:55  53  
10:27:55  54  	-- normalize the original data
10:27:55  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:55  56  	  norm_table_name => 'svmc_norm',
10:27:55  57  	  data_table_name => '&bldtable',
10:27:55  58  	  xform_view_name => 'svmc_build_prep');
10:27:55  59  END;
10:27:55  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:27:55 SQL> 
10:27:55 SQL> ---------------------
10:27:55 SQL> -- CREATE A NEW MODEL
10:27:55 SQL> --
10:27:55 SQL> -- Cleanup old model with the same name for repeat runs
10:27:55 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:55   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.96
10:27:56 SQL> 
10:27:56 SQL> -- Build a new SVM Model
10:27:56 SQL> BEGIN
10:27:56   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:27:56   3  	  model_name	      => '&model_name',
10:27:56   4  	  mining_function     => dbms_data_mining.classification,
10:27:56   5  	  data_table_name     => 'svmc_build_prep',
10:27:56   6  	  case_id_column_name => '&case_id',
10:27:56   7  	  target_column_name  => '&target',
10:27:56   8  	  settings_table_name => 'svmc_settings');
10:27:56   9  END;
10:27:56  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.15
10:27:58 SQL> 
10:27:58 SQL> -----------------------------------------------------------------------
10:27:58 SQL> --			       APPLY/score THE MODEL
10:27:58 SQL> -----------------------------------------------------------------------
10:27:58 SQL> 
10:27:58 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:27:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:27:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:27:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:58 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:27:58   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:58   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:58 SQL> -----------------------
10:27:58 SQL> -- PREPARE SCORING DATA
10:27:58 SQL> --
10:27:58 SQL> -- If the data for model creation has been prepared, then the data
10:27:58 SQL> -- to be scored using the model must be prepared in the same manner
10:27:58 SQL> -- in order to obtain meaningful results.
10:27:58 SQL> --
10:27:58 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:58 SQL> -- 2. Normalization
10:27:58 SQL> -- No outlier treatment will be performed during test and apply. The
10:27:58 SQL> -- normalization step is sufficient, since the normalization parameters
10:27:58 SQL> -- already capture the effects of outlier treatment done with build data.
10:27:58 SQL> --
10:27:58 SQL> BEGIN
10:27:58   2  	-- Xform Test data to replace missing values
10:27:58   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:58   4  	  miss_table_name => 'svmc_miss_num',
10:27:58   5  	  data_table_name => '&scoretable',
10:27:58   6  	  xform_view_name => 'xformed_apply_miss_num');
10:27:58   7  
10:27:58   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:58   9  	  miss_table_name => 'svmc_miss_cat',
10:27:58  10  	  data_table_name => '&scoretable',
10:27:58  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:27:58  12  
10:27:58  13  	-- Normalize the data to be scored
10:27:58  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:58  15  	  norm_table_name => 'svmc_norm',
10:27:58  16  	  data_table_name => '&scoretable',
10:27:58  17  	  xform_view_name => 'svmc_apply_prep');
10:27:58  18  END;
10:27:58  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:27:59 SQL> 
10:27:59 SQL> -- Maybe I already collected a score for this tkrdate.
10:27:59 SQL> -- DELETE it if I did:
10:27:59 SQL> DELETE ystkscores
10:27:59   2  WHERE score > 0
10:27:59   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:27:59   4  -- I need to supply the target attribute name:
10:27:59   5  AND targ = '&1'
10:27:59   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:27:59 SQL> 
10:27:59 SQL> -- We do a drumroll here:
10:27:59 SQL> 
10:27:59 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:27:59   2  SELECT
10:27:59   3  tkrdate
10:27:59   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:27:59   5  ,sysdate
10:27:59   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:27:59   7  -- rluck/oracle_sql_demos/substr.sql :
10:27:59   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:27:59   9  ,SUBSTR(tkrdate,-10)ydate
10:27:59  10  ,'&1'
10:27:59  11  FROM svmc_apply_prep
10:27:59  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:27:59 SQL> @score1_5min_gattn.sql	2010-04-20 TLT
10:27:59 SQL> --
10:27:59 SQL> -- score1_5min_gattn.sql
10:27:59 SQL> --
10:27:59 SQL> 
10:27:59 SQL> -- Demo:
10:27:59 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:27:59 SQL> 
10:27:59 SQL> CREATE OR REPLACE VIEW sme AS
10:27:59   2  SELECT
10:27:59   3  tkrdate
10:27:59   4  ,NULL gattn
10:27:59   5  ,g00
10:27:59   6  ,g01
10:27:59   7  ,g02
10:27:59   8  ,g03
10:27:59   9  ,g04
10:27:59  10  ,g05
10:27:59  11  ,g06
10:27:59  12  ,g07
10:27:59  13  ,g08
10:27:59  14  ,g09
10:27:59  15  ,g10
10:27:59  16  ,g11
10:27:59  17  ,g12
10:27:59  18  ,g13
10:27:59  19  ,g14
10:27:59  20  ,g15
10:27:59  21  ,g16
10:27:59  22  ,g17
10:27:59  23  ,g18
10:27:59  24  ,g19
10:27:59  25  ,g20
10:27:59  26  ,g21
10:27:59  27  ,g22
10:27:59  28  ,g23
10:27:59  29  ,g24
10:27:59  30  ,g25
10:27:59  31  ,g26
10:27:59  32  ,g27
10:27:59  33  ,g28
10:27:59  34  ,g29
10:27:59  35  FROM stk_ms
10:27:59  36  WHERE ydate = '&1'
10:27:59  37  AND tkr = '&2'
10:27:59  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-20'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:27:59 SQL> 
10:27:59 SQL> -- rpt
10:27:59 SQL> -- We should see just 1 row:
10:27:59 SQL> 
10:27:59 SQL> SELECT COUNT(tkrdate) FROM sme
10:27:59   2  
10:27:59 SQL> -- Build the model:
10:27:59 SQL> CREATE OR REPLACE VIEW bme AS
10:27:59   2  SELECT
10:27:59   3  tkrdate
10:27:59   4  ,gattn
10:27:59   5  ,g00
10:27:59   6  ,g01
10:27:59   7  ,g02
10:27:59   8  ,g03
10:27:59   9  ,g04
10:27:59  10  ,g05
10:27:59  11  ,g06
10:27:59  12  ,g07
10:27:59  13  ,g08
10:27:59  14  ,g09
10:27:59  15  ,g10
10:27:59  16  ,g11
10:27:59  17  ,g12
10:27:59  18  ,g13
10:27:59  19  ,g14
10:27:59  20  ,g15
10:27:59  21  ,g16
10:27:59  22  ,g17
10:27:59  23  ,g18
10:27:59  24  ,g19
10:27:59  25  ,g20
10:27:59  26  ,g21
10:27:59  27  ,g22
10:27:59  28  ,g23
10:27:59  29  ,g24
10:27:59  30  ,g25
10:27:59  31  ,g26
10:27:59  32  ,g27
10:27:59  33  ,g28
10:27:59  34  ,g29
10:27:59  35  FROM stk_ms
10:27:59  36  WHERE gattn IN('nup','up')
10:27:59  37  -- Use only rows which are older than 1 day:
10:27:59  38  AND 1+ydate < '&1'
10:27:59  39  AND tkr = '&2'
10:27:59  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-20'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:27:59 SQL> 
10:27:59 SQL> -- rpt
10:27:59 SQL> 
10:27:59 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:27:59   2  
10:27:59 SQL> SELECT MAX(tkrdate) FROM bme
10:27:59   2  
10:27:59 SQL> -- Now build model from bme and score sme
10:27:59 SQL> @score1.sql gattn
10:27:59 SQL> -- score1.sql
10:27:59 SQL> 
10:27:59 SQL> -- I use this script to send 5 params to score.sql
10:27:59 SQL> -- which does the heavy lifting of creating an SVM model.
10:27:59 SQL> -- Then at the very end of this script I use the model
10:27:59 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:27:59 SQL> 
10:27:59 SQL> -- I call this script from 2 other scripts:
10:27:59 SQL> -- score1_5min.sql
10:27:59 SQL> -- score1_5min_gattn.sql
10:27:59 SQL> 
10:27:59 SQL> -- The 1st param is the name of the target attribute.
10:27:59 SQL> -- I like to call my target attributes either gatt or gattn.
10:27:59 SQL> 
10:27:59 SQL> -- Demo:
10:27:59 SQL> -- @score1.sql 'gatt'
10:27:59 SQL> -- @score1.sql 'gattn'
10:27:59 SQL> 
10:27:59 SQL> -- Now, I fill up svmc_apply_prep.
10:27:59 SQL> -- I use same model_name used in score.sql
10:27:59 SQL> DEFINE model_name = 'svmspy101'
10:27:59 SQL> DEFINE bldtable	= 'bme'
10:27:59 SQL> DEFINE scoretable = 'sme'
10:27:59 SQL> DEFINE case_id	= 'tkrdate'
10:27:59 SQL> -- Demo:
10:27:59 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:27:59 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:27:59 SQL> --
10:27:59 SQL> -- score.sql
10:27:59 SQL> --
10:27:59 SQL> 
10:27:59 SQL> -- usage: score.sql
10:27:59 SQL> 
10:27:59 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:27:59 SQL> 
10:27:59 SQL> -- DEFINE target	   = 'gatt'
10:27:59 SQL> -- DEFINE model_name = 'svmspy100'
10:27:59 SQL> -- DEFINE bldtable   = 'bme'
10:27:59 SQL> -- DEFINE scoretable = 'sme'
10:27:59 SQL> -- DEFINE case_id    = 'tkrdate'
10:27:59 SQL> 
10:27:59 SQL> DEFINE target	= '&1'
10:27:59 SQL> DEFINE model_name = '&2'
10:27:59 SQL> DEFINE bldtable	= '&3'
10:27:59 SQL> DEFINE scoretable = '&4'
10:27:59 SQL> DEFINE case_id	= '&5'
10:27:59 SQL> 
10:27:59 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:27:59 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:27:59 SQL> 
10:27:59 SQL> -- Builds an SVM model using pl/sql.
10:27:59 SQL> 
10:27:59 SQL> -----------------------------------------------------------------------
10:27:59 SQL> --			    BUILD THE MODEL
10:27:59 SQL> -----------------------------------------------------------------------
10:27:59 SQL> 
10:27:59 SQL> -- Cleanup old build data preparation objects for repeat runs
10:27:59 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:27:59 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:27:59 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:59 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:27:59 SQL> 
10:27:59 SQL> 
10:27:59 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:27:59 SQL> --
10:27:59 SQL> -- DROP	TABLE svmc_settings ;
10:27:59 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:27:59 SQL> -- DELETE svmc_settings;
10:27:59 SQL> 
10:27:59 SQL> -- The default classification algorithm is Naive Bayes. So override
10:27:59 SQL> -- this choice to SVM using a settings table.
10:27:59 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:27:59 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:27:59 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:27:59 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:27:59 SQL> -- models.
10:27:59 SQL> --
10:27:59 SQL> 
10:27:59 SQL> -- Do this once and then comment it out.
10:27:59 SQL> -- That makes script go faster.
10:27:59 SQL> -- BEGIN
10:27:59 SQL> -- -- Populate settings table
10:27:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:59 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:27:59 SQL> --
10:27:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:59 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:27:59 SQL> --
10:27:59 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:27:59 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:27:59 SQL> --   COMMIT;
10:27:59 SQL> -- END;
10:27:59 SQL> -- /
10:27:59 SQL> 
10:27:59 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:27:59 SQL> 
10:27:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:27:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:27:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:27:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:27:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:27:59 SQL> 
10:27:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:27:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:27:59 SQL> 
10:27:59 SQL> --------------------------------
10:27:59 SQL> -- PREPARE BUILD (TRAINING) DATA
10:27:59 SQL> --
10:27:59 SQL> 
10:27:59 SQL> -- 1. Missing Value treatment for all Predictors and
10:27:59 SQL> -- 2. Outlier Treatment and
10:27:59 SQL> -- 3. Normalization are performed below.
10:27:59 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:27:59 SQL> --    normalized here.
10:27:59 SQL> 
10:27:59 SQL> BEGIN
10:27:59   2  	-- Perform missing value treatment for all predictors
10:27:59   3  	-- create miss tables
10:27:59   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:27:59   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:27:59   6  
10:27:59   7  	-- populate miss tables
10:27:59   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:27:59   9  	  miss_table_name => 'svmc_miss_num',
10:27:59  10  	  data_table_name => '&bldtable',
10:27:59  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:59  12  
10:27:59  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:27:59  14  	  miss_table_name => 'svmc_miss_cat',
10:27:59  15  	  data_table_name => '&bldtable',
10:27:59  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:59  17  
10:27:59  18  	-- xform input data to replace missing values
10:27:59  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:27:59  20  	  miss_table_name => 'svmc_miss_num',
10:27:59  21  	  data_table_name => '&bldtable',
10:27:59  22  	  xform_view_name => 'xformed_build_miss_num');
10:27:59  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:27:59  24  	  miss_table_name => 'svmc_miss_cat',
10:27:59  25  	  data_table_name => '&bldtable',
10:27:59  26  	  xform_view_name => 'xformed_build_miss_cat');
10:27:59  27  
10:27:59  28  	-- Perform outlier treatment.
10:27:59  29  	-- create clip table
10:27:59  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:27:59  31  
10:27:59  32  	-- populate clip table
10:27:59  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:27:59  34  	  clip_table_name => 'svmc_clip',
10:27:59  35  	  data_table_name => '&bldtable',
10:27:59  36  	  tail_frac	  => 0.025,
10:27:59  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:59  38  
10:27:59  39  	-- xform input data to winsorized data
10:27:59  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:27:59  41  	  clip_table_name => 'svmc_clip',
10:27:59  42  	  data_table_name => '&bldtable',
10:27:59  43  	  xform_view_name => 'svmc_winsor');
10:27:59  44  
10:27:59  45  	-- create normalization table
10:27:59  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:27:59  47  
10:27:59  48  	-- populate normalization table based on winsorized data
10:27:59  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:27:59  50  	  norm_table_name => 'svmc_norm',
10:27:59  51  	  data_table_name => 'svmc_winsor',
10:27:59  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:27:59  53  
10:27:59  54  	-- normalize the original data
10:27:59  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:27:59  56  	  norm_table_name => 'svmc_norm',
10:27:59  57  	  data_table_name => '&bldtable',
10:27:59  58  	  xform_view_name => 'svmc_build_prep');
10:27:59  59  END;
10:27:59  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:27:59 SQL> 
10:27:59 SQL> ---------------------
10:27:59 SQL> -- CREATE A NEW MODEL
10:27:59 SQL> --
10:27:59 SQL> -- Cleanup old model with the same name for repeat runs
10:27:59 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:27:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:27:59   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.44
10:28:01 SQL> 
10:28:01 SQL> -- Build a new SVM Model
10:28:01 SQL> BEGIN
10:28:01   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:01   3  	  model_name	      => '&model_name',
10:28:01   4  	  mining_function     => dbms_data_mining.classification,
10:28:01   5  	  data_table_name     => 'svmc_build_prep',
10:28:01   6  	  case_id_column_name => '&case_id',
10:28:01   7  	  target_column_name  => '&target',
10:28:01   8  	  settings_table_name => 'svmc_settings');
10:28:01   9  END;
10:28:01  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.97
10:28:03 SQL> 
10:28:03 SQL> -----------------------------------------------------------------------
10:28:03 SQL> --			       APPLY/score THE MODEL
10:28:03 SQL> -----------------------------------------------------------------------
10:28:03 SQL> 
10:28:03 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:03 SQL> -----------------------
10:28:03 SQL> -- PREPARE SCORING DATA
10:28:03 SQL> --
10:28:03 SQL> -- If the data for model creation has been prepared, then the data
10:28:03 SQL> -- to be scored using the model must be prepared in the same manner
10:28:03 SQL> -- in order to obtain meaningful results.
10:28:03 SQL> --
10:28:03 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:03 SQL> -- 2. Normalization
10:28:03 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:03 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:03 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:03 SQL> --
10:28:03 SQL> BEGIN
10:28:03   2  	-- Xform Test data to replace missing values
10:28:03   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:03   4  	  miss_table_name => 'svmc_miss_num',
10:28:03   5  	  data_table_name => '&scoretable',
10:28:03   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:03   7  
10:28:03   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:03   9  	  miss_table_name => 'svmc_miss_cat',
10:28:03  10  	  data_table_name => '&scoretable',
10:28:03  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:03  12  
10:28:03  13  	-- Normalize the data to be scored
10:28:03  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:03  15  	  norm_table_name => 'svmc_norm',
10:28:03  16  	  data_table_name => '&scoretable',
10:28:03  17  	  xform_view_name => 'svmc_apply_prep');
10:28:03  18  END;
10:28:03  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.29
10:28:03 SQL> 
10:28:03 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:03 SQL> -- DELETE it if I did:
10:28:03 SQL> DELETE ystkscores
10:28:03   2  WHERE score > 0
10:28:03   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:03   4  -- I need to supply the target attribute name:
10:28:03   5  AND targ = '&1'
10:28:03   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:03 SQL> 
10:28:03 SQL> -- We do a drumroll here:
10:28:03 SQL> 
10:28:03 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:03   2  SELECT
10:28:03   3  tkrdate
10:28:03   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:03   5  ,sysdate
10:28:03   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:03   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:03   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:03   9  ,SUBSTR(tkrdate,-10)ydate
10:28:03  10  ,'&1'
10:28:03  11  FROM svmc_apply_prep
10:28:03  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:28:03 SQL> @score1_5min_gattn.sql	2010-04-05 TLT
10:28:03 SQL> --
10:28:03 SQL> -- score1_5min_gattn.sql
10:28:03 SQL> --
10:28:03 SQL> 
10:28:03 SQL> -- Demo:
10:28:03 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:03 SQL> 
10:28:03 SQL> CREATE OR REPLACE VIEW sme AS
10:28:03   2  SELECT
10:28:03   3  tkrdate
10:28:03   4  ,NULL gattn
10:28:03   5  ,g00
10:28:03   6  ,g01
10:28:03   7  ,g02
10:28:03   8  ,g03
10:28:03   9  ,g04
10:28:03  10  ,g05
10:28:03  11  ,g06
10:28:03  12  ,g07
10:28:03  13  ,g08
10:28:03  14  ,g09
10:28:03  15  ,g10
10:28:03  16  ,g11
10:28:03  17  ,g12
10:28:03  18  ,g13
10:28:03  19  ,g14
10:28:03  20  ,g15
10:28:03  21  ,g16
10:28:03  22  ,g17
10:28:03  23  ,g18
10:28:03  24  ,g19
10:28:03  25  ,g20
10:28:03  26  ,g21
10:28:03  27  ,g22
10:28:03  28  ,g23
10:28:03  29  ,g24
10:28:03  30  ,g25
10:28:03  31  ,g26
10:28:03  32  ,g27
10:28:03  33  ,g28
10:28:03  34  ,g29
10:28:03  35  FROM stk_ms
10:28:03  36  WHERE ydate = '&1'
10:28:03  37  AND tkr = '&2'
10:28:03  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-05'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:03 SQL> 
10:28:03 SQL> -- rpt
10:28:03 SQL> -- We should see just 1 row:
10:28:03 SQL> 
10:28:03 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:03   2  
10:28:03 SQL> -- Build the model:
10:28:03 SQL> CREATE OR REPLACE VIEW bme AS
10:28:03   2  SELECT
10:28:03   3  tkrdate
10:28:03   4  ,gattn
10:28:03   5  ,g00
10:28:03   6  ,g01
10:28:03   7  ,g02
10:28:03   8  ,g03
10:28:03   9  ,g04
10:28:03  10  ,g05
10:28:03  11  ,g06
10:28:03  12  ,g07
10:28:03  13  ,g08
10:28:03  14  ,g09
10:28:03  15  ,g10
10:28:03  16  ,g11
10:28:03  17  ,g12
10:28:03  18  ,g13
10:28:03  19  ,g14
10:28:03  20  ,g15
10:28:03  21  ,g16
10:28:03  22  ,g17
10:28:03  23  ,g18
10:28:03  24  ,g19
10:28:03  25  ,g20
10:28:03  26  ,g21
10:28:03  27  ,g22
10:28:03  28  ,g23
10:28:03  29  ,g24
10:28:03  30  ,g25
10:28:03  31  ,g26
10:28:03  32  ,g27
10:28:03  33  ,g28
10:28:03  34  ,g29
10:28:03  35  FROM stk_ms
10:28:03  36  WHERE gattn IN('nup','up')
10:28:03  37  -- Use only rows which are older than 1 day:
10:28:03  38  AND 1+ydate < '&1'
10:28:03  39  AND tkr = '&2'
10:28:03  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-05'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.06
10:28:03 SQL> 
10:28:03 SQL> -- rpt
10:28:03 SQL> 
10:28:03 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:03   2  
10:28:03 SQL> SELECT MAX(tkrdate) FROM bme
10:28:03   2  
10:28:03 SQL> -- Now build model from bme and score sme
10:28:03 SQL> @score1.sql gattn
10:28:03 SQL> -- score1.sql
10:28:03 SQL> 
10:28:03 SQL> -- I use this script to send 5 params to score.sql
10:28:03 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:03 SQL> -- Then at the very end of this script I use the model
10:28:03 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:03 SQL> 
10:28:03 SQL> -- I call this script from 2 other scripts:
10:28:03 SQL> -- score1_5min.sql
10:28:03 SQL> -- score1_5min_gattn.sql
10:28:03 SQL> 
10:28:03 SQL> -- The 1st param is the name of the target attribute.
10:28:03 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:03 SQL> 
10:28:03 SQL> -- Demo:
10:28:03 SQL> -- @score1.sql 'gatt'
10:28:03 SQL> -- @score1.sql 'gattn'
10:28:03 SQL> 
10:28:03 SQL> -- Now, I fill up svmc_apply_prep.
10:28:03 SQL> -- I use same model_name used in score.sql
10:28:03 SQL> DEFINE model_name = 'svmspy101'
10:28:03 SQL> DEFINE bldtable	= 'bme'
10:28:03 SQL> DEFINE scoretable = 'sme'
10:28:03 SQL> DEFINE case_id	= 'tkrdate'
10:28:03 SQL> -- Demo:
10:28:03 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:03 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:03 SQL> --
10:28:03 SQL> -- score.sql
10:28:03 SQL> --
10:28:03 SQL> 
10:28:03 SQL> -- usage: score.sql
10:28:03 SQL> 
10:28:03 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:03 SQL> 
10:28:03 SQL> -- DEFINE target	   = 'gatt'
10:28:03 SQL> -- DEFINE model_name = 'svmspy100'
10:28:03 SQL> -- DEFINE bldtable   = 'bme'
10:28:03 SQL> -- DEFINE scoretable = 'sme'
10:28:03 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:03 SQL> 
10:28:03 SQL> DEFINE target	= '&1'
10:28:03 SQL> DEFINE model_name = '&2'
10:28:03 SQL> DEFINE bldtable	= '&3'
10:28:03 SQL> DEFINE scoretable = '&4'
10:28:03 SQL> DEFINE case_id	= '&5'
10:28:03 SQL> 
10:28:03 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:03 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:03 SQL> 
10:28:03 SQL> -- Builds an SVM model using pl/sql.
10:28:03 SQL> 
10:28:03 SQL> -----------------------------------------------------------------------
10:28:03 SQL> --			    BUILD THE MODEL
10:28:03 SQL> -----------------------------------------------------------------------
10:28:03 SQL> 
10:28:03 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:03 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:03 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:03 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:03 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:03 SQL> 
10:28:03 SQL> 
10:28:03 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:03 SQL> --
10:28:03 SQL> -- DROP	TABLE svmc_settings ;
10:28:03 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:03 SQL> -- DELETE svmc_settings;
10:28:03 SQL> 
10:28:03 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:03 SQL> -- this choice to SVM using a settings table.
10:28:03 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:03 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:03 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:03 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:03 SQL> -- models.
10:28:03 SQL> --
10:28:03 SQL> 
10:28:03 SQL> -- Do this once and then comment it out.
10:28:03 SQL> -- That makes script go faster.
10:28:03 SQL> -- BEGIN
10:28:03 SQL> -- -- Populate settings table
10:28:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:03 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:03 SQL> --
10:28:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:03 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:03 SQL> --
10:28:03 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:03 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:03 SQL> --   COMMIT;
10:28:03 SQL> -- END;
10:28:03 SQL> -- /
10:28:03 SQL> 
10:28:03 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:03 SQL> 
10:28:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:03 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:03   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:03   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:04 SQL> 
10:28:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
10:28:04 SQL> 
10:28:04 SQL> --------------------------------
10:28:04 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:04 SQL> --
10:28:04 SQL> 
10:28:04 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:04 SQL> -- 2. Outlier Treatment and
10:28:04 SQL> -- 3. Normalization are performed below.
10:28:04 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:04 SQL> --    normalized here.
10:28:04 SQL> 
10:28:04 SQL> BEGIN
10:28:04   2  	-- Perform missing value treatment for all predictors
10:28:04   3  	-- create miss tables
10:28:04   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:04   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:04   6  
10:28:04   7  	-- populate miss tables
10:28:04   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:04   9  	  miss_table_name => 'svmc_miss_num',
10:28:04  10  	  data_table_name => '&bldtable',
10:28:04  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:04  12  
10:28:04  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:04  14  	  miss_table_name => 'svmc_miss_cat',
10:28:04  15  	  data_table_name => '&bldtable',
10:28:04  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:04  17  
10:28:04  18  	-- xform input data to replace missing values
10:28:04  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:04  20  	  miss_table_name => 'svmc_miss_num',
10:28:04  21  	  data_table_name => '&bldtable',
10:28:04  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:04  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:04  24  	  miss_table_name => 'svmc_miss_cat',
10:28:04  25  	  data_table_name => '&bldtable',
10:28:04  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:04  27  
10:28:04  28  	-- Perform outlier treatment.
10:28:04  29  	-- create clip table
10:28:04  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:04  31  
10:28:04  32  	-- populate clip table
10:28:04  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:04  34  	  clip_table_name => 'svmc_clip',
10:28:04  35  	  data_table_name => '&bldtable',
10:28:04  36  	  tail_frac	  => 0.025,
10:28:04  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:04  38  
10:28:04  39  	-- xform input data to winsorized data
10:28:04  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:04  41  	  clip_table_name => 'svmc_clip',
10:28:04  42  	  data_table_name => '&bldtable',
10:28:04  43  	  xform_view_name => 'svmc_winsor');
10:28:04  44  
10:28:04  45  	-- create normalization table
10:28:04  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:04  47  
10:28:04  48  	-- populate normalization table based on winsorized data
10:28:04  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:04  50  	  norm_table_name => 'svmc_norm',
10:28:04  51  	  data_table_name => 'svmc_winsor',
10:28:04  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:04  53  
10:28:04  54  	-- normalize the original data
10:28:04  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:04  56  	  norm_table_name => 'svmc_norm',
10:28:04  57  	  data_table_name => '&bldtable',
10:28:04  58  	  xform_view_name => 'svmc_build_prep');
10:28:04  59  END;
10:28:04  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:28:04 SQL> 
10:28:04 SQL> ---------------------
10:28:04 SQL> -- CREATE A NEW MODEL
10:28:04 SQL> --
10:28:04 SQL> -- Cleanup old model with the same name for repeat runs
10:28:04 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:04   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.98
10:28:05 SQL> 
10:28:05 SQL> -- Build a new SVM Model
10:28:05 SQL> BEGIN
10:28:05   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:05   3  	  model_name	      => '&model_name',
10:28:05   4  	  mining_function     => dbms_data_mining.classification,
10:28:05   5  	  data_table_name     => 'svmc_build_prep',
10:28:05   6  	  case_id_column_name => '&case_id',
10:28:05   7  	  target_column_name  => '&target',
10:28:05   8  	  settings_table_name => 'svmc_settings');
10:28:05   9  END;
10:28:05  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.71
10:28:07 SQL> 
10:28:07 SQL> -----------------------------------------------------------------------
10:28:07 SQL> --			       APPLY/score THE MODEL
10:28:07 SQL> -----------------------------------------------------------------------
10:28:07 SQL> 
10:28:07 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:07 SQL> -----------------------
10:28:07 SQL> -- PREPARE SCORING DATA
10:28:07 SQL> --
10:28:07 SQL> -- If the data for model creation has been prepared, then the data
10:28:07 SQL> -- to be scored using the model must be prepared in the same manner
10:28:07 SQL> -- in order to obtain meaningful results.
10:28:07 SQL> --
10:28:07 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:07 SQL> -- 2. Normalization
10:28:07 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:07 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:07 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:07 SQL> --
10:28:07 SQL> BEGIN
10:28:07   2  	-- Xform Test data to replace missing values
10:28:07   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:07   4  	  miss_table_name => 'svmc_miss_num',
10:28:07   5  	  data_table_name => '&scoretable',
10:28:07   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:07   7  
10:28:07   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:07   9  	  miss_table_name => 'svmc_miss_cat',
10:28:07  10  	  data_table_name => '&scoretable',
10:28:07  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:07  12  
10:28:07  13  	-- Normalize the data to be scored
10:28:07  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:07  15  	  norm_table_name => 'svmc_norm',
10:28:07  16  	  data_table_name => '&scoretable',
10:28:07  17  	  xform_view_name => 'svmc_apply_prep');
10:28:07  18  END;
10:28:07  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:28:07 SQL> 
10:28:07 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:07 SQL> -- DELETE it if I did:
10:28:07 SQL> DELETE ystkscores
10:28:07   2  WHERE score > 0
10:28:07   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:07   4  -- I need to supply the target attribute name:
10:28:07   5  AND targ = '&1'
10:28:07   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:07 SQL> 
10:28:07 SQL> -- We do a drumroll here:
10:28:07 SQL> 
10:28:07 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:07   2  SELECT
10:28:07   3  tkrdate
10:28:07   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:07   5  ,sysdate
10:28:07   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:07   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:07   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:07   9  ,SUBSTR(tkrdate,-10)ydate
10:28:07  10  ,'&1'
10:28:07  11  FROM svmc_apply_prep
10:28:07  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:28:07 SQL> @score1_5min.sql	      2010-11-23 TLT
10:28:07 SQL> --
10:28:07 SQL> -- score1_5min.sql
10:28:07 SQL> --
10:28:07 SQL> 
10:28:07 SQL> -- Demo:
10:28:07 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:28:07 SQL> 
10:28:07 SQL> CREATE OR REPLACE VIEW sme AS
10:28:07   2  SELECT
10:28:07   3  tkrdate
10:28:07   4  ,NULL gatt
10:28:07   5  ,g00
10:28:07   6  ,g01
10:28:07   7  ,g02
10:28:07   8  ,g03
10:28:07   9  ,g04
10:28:07  10  ,g05
10:28:07  11  ,g06
10:28:07  12  ,g07
10:28:07  13  ,g08
10:28:07  14  ,g09
10:28:07  15  ,g10
10:28:07  16  ,g11
10:28:07  17  ,g12
10:28:07  18  ,g13
10:28:07  19  ,g14
10:28:07  20  ,g15
10:28:07  21  ,g16
10:28:07  22  ,g17
10:28:07  23  ,g18
10:28:07  24  ,g19
10:28:07  25  ,g20
10:28:07  26  ,g21
10:28:07  27  ,g22
10:28:07  28  ,g23
10:28:07  29  ,g24
10:28:07  30  ,g25
10:28:07  31  ,g26
10:28:07  32  ,g27
10:28:07  33  ,g28
10:28:07  34  ,g29
10:28:07  35  FROM stk_ms
10:28:07  36  WHERE ydate = '&1'
10:28:07  37  AND tkr = '&2'
10:28:07  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-23'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:28:07 SQL> 
10:28:07 SQL> -- rpt
10:28:07 SQL> -- We should see just 1 row:
10:28:07 SQL> 
10:28:07 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:07   2  
10:28:07 SQL> -- Build the model:
10:28:07 SQL> CREATE OR REPLACE VIEW bme AS
10:28:07   2  SELECT
10:28:07   3  tkrdate
10:28:07   4  ,gatt
10:28:07   5  ,g00
10:28:07   6  ,g01
10:28:07   7  ,g02
10:28:07   8  ,g03
10:28:07   9  ,g04
10:28:07  10  ,g05
10:28:07  11  ,g06
10:28:07  12  ,g07
10:28:07  13  ,g08
10:28:07  14  ,g09
10:28:07  15  ,g10
10:28:07  16  ,g11
10:28:07  17  ,g12
10:28:07  18  ,g13
10:28:07  19  ,g14
10:28:07  20  ,g15
10:28:07  21  ,g16
10:28:07  22  ,g17
10:28:07  23  ,g18
10:28:07  24  ,g19
10:28:07  25  ,g20
10:28:07  26  ,g21
10:28:07  27  ,g22
10:28:07  28  ,g23
10:28:07  29  ,g24
10:28:07  30  ,g25
10:28:07  31  ,g26
10:28:07  32  ,g27
10:28:07  33  ,g28
10:28:07  34  ,g29
10:28:07  35  FROM stk_ms
10:28:07  36  WHERE gatt IN('nup','up')
10:28:07  37  -- Use only rows which are older than 1 day:
10:28:07  38  AND 1+ydate < '&1'
10:28:07  39  AND tkr = '&2'
10:28:07  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-23'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:07 SQL> 
10:28:07 SQL> -- rpt
10:28:07 SQL> 
10:28:07 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:28:07   2  
10:28:07 SQL> SELECT MAX(tkrdate) FROM bme
10:28:07   2  
10:28:07 SQL> -- Now build model from bme and score sme
10:28:07 SQL> @score1.sql gatt
10:28:07 SQL> -- score1.sql
10:28:07 SQL> 
10:28:07 SQL> -- I use this script to send 5 params to score.sql
10:28:07 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:07 SQL> -- Then at the very end of this script I use the model
10:28:07 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:07 SQL> 
10:28:07 SQL> -- I call this script from 2 other scripts:
10:28:07 SQL> -- score1_5min.sql
10:28:07 SQL> -- score1_5min_gattn.sql
10:28:07 SQL> 
10:28:07 SQL> -- The 1st param is the name of the target attribute.
10:28:07 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:07 SQL> 
10:28:07 SQL> -- Demo:
10:28:07 SQL> -- @score1.sql 'gatt'
10:28:07 SQL> -- @score1.sql 'gattn'
10:28:07 SQL> 
10:28:07 SQL> -- Now, I fill up svmc_apply_prep.
10:28:07 SQL> -- I use same model_name used in score.sql
10:28:07 SQL> DEFINE model_name = 'svmspy101'
10:28:07 SQL> DEFINE bldtable	= 'bme'
10:28:07 SQL> DEFINE scoretable = 'sme'
10:28:07 SQL> DEFINE case_id	= 'tkrdate'
10:28:07 SQL> -- Demo:
10:28:07 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:07 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:07 SQL> --
10:28:07 SQL> -- score.sql
10:28:07 SQL> --
10:28:07 SQL> 
10:28:07 SQL> -- usage: score.sql
10:28:07 SQL> 
10:28:07 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:07 SQL> 
10:28:07 SQL> -- DEFINE target	   = 'gatt'
10:28:07 SQL> -- DEFINE model_name = 'svmspy100'
10:28:07 SQL> -- DEFINE bldtable   = 'bme'
10:28:07 SQL> -- DEFINE scoretable = 'sme'
10:28:07 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:07 SQL> 
10:28:07 SQL> DEFINE target	= '&1'
10:28:07 SQL> DEFINE model_name = '&2'
10:28:07 SQL> DEFINE bldtable	= '&3'
10:28:07 SQL> DEFINE scoretable = '&4'
10:28:07 SQL> DEFINE case_id	= '&5'
10:28:07 SQL> 
10:28:07 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:07 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:07 SQL> 
10:28:07 SQL> -- Builds an SVM model using pl/sql.
10:28:07 SQL> 
10:28:07 SQL> -----------------------------------------------------------------------
10:28:07 SQL> --			    BUILD THE MODEL
10:28:07 SQL> -----------------------------------------------------------------------
10:28:07 SQL> 
10:28:07 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:07 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:07 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:28:07 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:07 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:07 SQL> 
10:28:07 SQL> 
10:28:07 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:07 SQL> --
10:28:07 SQL> -- DROP	TABLE svmc_settings ;
10:28:07 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:07 SQL> -- DELETE svmc_settings;
10:28:07 SQL> 
10:28:07 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:07 SQL> -- this choice to SVM using a settings table.
10:28:07 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:07 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:07 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:07 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:07 SQL> -- models.
10:28:07 SQL> --
10:28:07 SQL> 
10:28:07 SQL> -- Do this once and then comment it out.
10:28:07 SQL> -- That makes script go faster.
10:28:07 SQL> -- BEGIN
10:28:07 SQL> -- -- Populate settings table
10:28:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:07 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:07 SQL> --
10:28:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:07 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:07 SQL> --
10:28:07 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:07 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:07 SQL> --   COMMIT;
10:28:07 SQL> -- END;
10:28:07 SQL> -- /
10:28:07 SQL> 
10:28:07 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:28:07 SQL> 
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:07 SQL> 
10:28:07 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:07   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:07   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:07 SQL> 
10:28:07 SQL> --------------------------------
10:28:07 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:07 SQL> --
10:28:07 SQL> 
10:28:07 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:07 SQL> -- 2. Outlier Treatment and
10:28:07 SQL> -- 3. Normalization are performed below.
10:28:07 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:07 SQL> --    normalized here.
10:28:07 SQL> 
10:28:07 SQL> BEGIN
10:28:07   2  	-- Perform missing value treatment for all predictors
10:28:07   3  	-- create miss tables
10:28:07   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:07   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:07   6  
10:28:07   7  	-- populate miss tables
10:28:07   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:07   9  	  miss_table_name => 'svmc_miss_num',
10:28:07  10  	  data_table_name => '&bldtable',
10:28:07  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:07  12  
10:28:07  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:07  14  	  miss_table_name => 'svmc_miss_cat',
10:28:07  15  	  data_table_name => '&bldtable',
10:28:07  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:07  17  
10:28:07  18  	-- xform input data to replace missing values
10:28:07  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:07  20  	  miss_table_name => 'svmc_miss_num',
10:28:07  21  	  data_table_name => '&bldtable',
10:28:07  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:07  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:07  24  	  miss_table_name => 'svmc_miss_cat',
10:28:07  25  	  data_table_name => '&bldtable',
10:28:07  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:07  27  
10:28:07  28  	-- Perform outlier treatment.
10:28:07  29  	-- create clip table
10:28:07  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:07  31  
10:28:07  32  	-- populate clip table
10:28:07  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:07  34  	  clip_table_name => 'svmc_clip',
10:28:07  35  	  data_table_name => '&bldtable',
10:28:07  36  	  tail_frac	  => 0.025,
10:28:07  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:07  38  
10:28:07  39  	-- xform input data to winsorized data
10:28:07  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:07  41  	  clip_table_name => 'svmc_clip',
10:28:07  42  	  data_table_name => '&bldtable',
10:28:07  43  	  xform_view_name => 'svmc_winsor');
10:28:07  44  
10:28:07  45  	-- create normalization table
10:28:07  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:07  47  
10:28:07  48  	-- populate normalization table based on winsorized data
10:28:07  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:07  50  	  norm_table_name => 'svmc_norm',
10:28:07  51  	  data_table_name => 'svmc_winsor',
10:28:07  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:07  53  
10:28:07  54  	-- normalize the original data
10:28:07  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:07  56  	  norm_table_name => 'svmc_norm',
10:28:07  57  	  data_table_name => '&bldtable',
10:28:07  58  	  xform_view_name => 'svmc_build_prep');
10:28:07  59  END;
10:28:07  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:28:08 SQL> 
10:28:08 SQL> ---------------------
10:28:08 SQL> -- CREATE A NEW MODEL
10:28:08 SQL> --
10:28:08 SQL> -- Cleanup old model with the same name for repeat runs
10:28:08 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:08   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:08   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.72
10:28:10 SQL> 
10:28:10 SQL> -- Build a new SVM Model
10:28:10 SQL> BEGIN
10:28:10   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:10   3  	  model_name	      => '&model_name',
10:28:10   4  	  mining_function     => dbms_data_mining.classification,
10:28:10   5  	  data_table_name     => 'svmc_build_prep',
10:28:10   6  	  case_id_column_name => '&case_id',
10:28:10   7  	  target_column_name  => '&target',
10:28:10   8  	  settings_table_name => 'svmc_settings');
10:28:10   9  END;
10:28:10  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.01
10:28:12 SQL> 
10:28:12 SQL> -----------------------------------------------------------------------
10:28:12 SQL> --			       APPLY/score THE MODEL
10:28:12 SQL> -----------------------------------------------------------------------
10:28:12 SQL> 
10:28:12 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.40
10:28:12 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:12   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:12   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
10:28:12 SQL> -----------------------
10:28:12 SQL> -- PREPARE SCORING DATA
10:28:12 SQL> --
10:28:12 SQL> -- If the data for model creation has been prepared, then the data
10:28:12 SQL> -- to be scored using the model must be prepared in the same manner
10:28:12 SQL> -- in order to obtain meaningful results.
10:28:12 SQL> --
10:28:12 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:12 SQL> -- 2. Normalization
10:28:12 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:12 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:12 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:12 SQL> --
10:28:12 SQL> BEGIN
10:28:12   2  	-- Xform Test data to replace missing values
10:28:12   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:12   4  	  miss_table_name => 'svmc_miss_num',
10:28:12   5  	  data_table_name => '&scoretable',
10:28:12   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:12   7  
10:28:12   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:12   9  	  miss_table_name => 'svmc_miss_cat',
10:28:12  10  	  data_table_name => '&scoretable',
10:28:12  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:12  12  
10:28:12  13  	-- Normalize the data to be scored
10:28:12  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:12  15  	  norm_table_name => 'svmc_norm',
10:28:12  16  	  data_table_name => '&scoretable',
10:28:12  17  	  xform_view_name => 'svmc_apply_prep');
10:28:12  18  END;
10:28:12  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:28:12 SQL> 
10:28:12 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:12 SQL> -- DELETE it if I did:
10:28:12 SQL> DELETE ystkscores
10:28:12   2  WHERE score > 0
10:28:12   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:12   4  -- I need to supply the target attribute name:
10:28:12   5  AND targ = '&1'
10:28:12   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:13 SQL> 
10:28:13 SQL> -- We do a drumroll here:
10:28:13 SQL> 
10:28:13 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:13   2  SELECT
10:28:13   3  tkrdate
10:28:13   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:13   5  ,sysdate
10:28:13   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:13   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:13   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:13   9  ,SUBSTR(tkrdate,-10)ydate
10:28:13  10  ,'&1'
10:28:13  11  FROM svmc_apply_prep
10:28:13  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:28:13 SQL> @score1_5min.sql	      2010-07-19 TLT
10:28:13 SQL> --
10:28:13 SQL> -- score1_5min.sql
10:28:13 SQL> --
10:28:13 SQL> 
10:28:13 SQL> -- Demo:
10:28:13 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:28:13 SQL> 
10:28:13 SQL> CREATE OR REPLACE VIEW sme AS
10:28:13   2  SELECT
10:28:13   3  tkrdate
10:28:13   4  ,NULL gatt
10:28:13   5  ,g00
10:28:13   6  ,g01
10:28:13   7  ,g02
10:28:13   8  ,g03
10:28:13   9  ,g04
10:28:13  10  ,g05
10:28:13  11  ,g06
10:28:13  12  ,g07
10:28:13  13  ,g08
10:28:13  14  ,g09
10:28:13  15  ,g10
10:28:13  16  ,g11
10:28:13  17  ,g12
10:28:13  18  ,g13
10:28:13  19  ,g14
10:28:13  20  ,g15
10:28:13  21  ,g16
10:28:13  22  ,g17
10:28:13  23  ,g18
10:28:13  24  ,g19
10:28:13  25  ,g20
10:28:13  26  ,g21
10:28:13  27  ,g22
10:28:13  28  ,g23
10:28:13  29  ,g24
10:28:13  30  ,g25
10:28:13  31  ,g26
10:28:13  32  ,g27
10:28:13  33  ,g28
10:28:13  34  ,g29
10:28:13  35  FROM stk_ms
10:28:13  36  WHERE ydate = '&1'
10:28:13  37  AND tkr = '&2'
10:28:13  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-07-19'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:28:13 SQL> 
10:28:13 SQL> -- rpt
10:28:13 SQL> -- We should see just 1 row:
10:28:13 SQL> 
10:28:13 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:13   2  
10:28:13 SQL> -- Build the model:
10:28:13 SQL> CREATE OR REPLACE VIEW bme AS
10:28:13   2  SELECT
10:28:13   3  tkrdate
10:28:13   4  ,gatt
10:28:13   5  ,g00
10:28:13   6  ,g01
10:28:13   7  ,g02
10:28:13   8  ,g03
10:28:13   9  ,g04
10:28:13  10  ,g05
10:28:13  11  ,g06
10:28:13  12  ,g07
10:28:13  13  ,g08
10:28:13  14  ,g09
10:28:13  15  ,g10
10:28:13  16  ,g11
10:28:13  17  ,g12
10:28:13  18  ,g13
10:28:13  19  ,g14
10:28:13  20  ,g15
10:28:13  21  ,g16
10:28:13  22  ,g17
10:28:13  23  ,g18
10:28:13  24  ,g19
10:28:13  25  ,g20
10:28:13  26  ,g21
10:28:13  27  ,g22
10:28:13  28  ,g23
10:28:13  29  ,g24
10:28:13  30  ,g25
10:28:13  31  ,g26
10:28:13  32  ,g27
10:28:13  33  ,g28
10:28:13  34  ,g29
10:28:13  35  FROM stk_ms
10:28:13  36  WHERE gatt IN('nup','up')
10:28:13  37  -- Use only rows which are older than 1 day:
10:28:13  38  AND 1+ydate < '&1'
10:28:13  39  AND tkr = '&2'
10:28:13  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-07-19'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:28:13 SQL> 
10:28:13 SQL> -- rpt
10:28:13 SQL> 
10:28:13 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:28:13   2  
10:28:13 SQL> SELECT MAX(tkrdate) FROM bme
10:28:13   2  
10:28:13 SQL> -- Now build model from bme and score sme
10:28:13 SQL> @score1.sql gatt
10:28:13 SQL> -- score1.sql
10:28:13 SQL> 
10:28:13 SQL> -- I use this script to send 5 params to score.sql
10:28:13 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:13 SQL> -- Then at the very end of this script I use the model
10:28:13 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:13 SQL> 
10:28:13 SQL> -- I call this script from 2 other scripts:
10:28:13 SQL> -- score1_5min.sql
10:28:13 SQL> -- score1_5min_gattn.sql
10:28:13 SQL> 
10:28:13 SQL> -- The 1st param is the name of the target attribute.
10:28:13 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:13 SQL> 
10:28:13 SQL> -- Demo:
10:28:13 SQL> -- @score1.sql 'gatt'
10:28:13 SQL> -- @score1.sql 'gattn'
10:28:13 SQL> 
10:28:13 SQL> -- Now, I fill up svmc_apply_prep.
10:28:13 SQL> -- I use same model_name used in score.sql
10:28:13 SQL> DEFINE model_name = 'svmspy101'
10:28:13 SQL> DEFINE bldtable	= 'bme'
10:28:13 SQL> DEFINE scoretable = 'sme'
10:28:13 SQL> DEFINE case_id	= 'tkrdate'
10:28:13 SQL> -- Demo:
10:28:13 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:13 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:13 SQL> --
10:28:13 SQL> -- score.sql
10:28:13 SQL> --
10:28:13 SQL> 
10:28:13 SQL> -- usage: score.sql
10:28:13 SQL> 
10:28:13 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:13 SQL> 
10:28:13 SQL> -- DEFINE target	   = 'gatt'
10:28:13 SQL> -- DEFINE model_name = 'svmspy100'
10:28:13 SQL> -- DEFINE bldtable   = 'bme'
10:28:13 SQL> -- DEFINE scoretable = 'sme'
10:28:13 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:13 SQL> 
10:28:13 SQL> DEFINE target	= '&1'
10:28:13 SQL> DEFINE model_name = '&2'
10:28:13 SQL> DEFINE bldtable	= '&3'
10:28:13 SQL> DEFINE scoretable = '&4'
10:28:13 SQL> DEFINE case_id	= '&5'
10:28:13 SQL> 
10:28:13 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:13 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:13 SQL> 
10:28:13 SQL> -- Builds an SVM model using pl/sql.
10:28:13 SQL> 
10:28:13 SQL> -----------------------------------------------------------------------
10:28:13 SQL> --			    BUILD THE MODEL
10:28:13 SQL> -----------------------------------------------------------------------
10:28:13 SQL> 
10:28:13 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:13 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:13 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:13 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:13 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:13 SQL> 
10:28:13 SQL> 
10:28:13 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:13 SQL> --
10:28:13 SQL> -- DROP	TABLE svmc_settings ;
10:28:13 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:13 SQL> -- DELETE svmc_settings;
10:28:13 SQL> 
10:28:13 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:13 SQL> -- this choice to SVM using a settings table.
10:28:13 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:13 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:13 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:13 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:13 SQL> -- models.
10:28:13 SQL> --
10:28:13 SQL> 
10:28:13 SQL> -- Do this once and then comment it out.
10:28:13 SQL> -- That makes script go faster.
10:28:13 SQL> -- BEGIN
10:28:13 SQL> -- -- Populate settings table
10:28:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:13 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:13 SQL> --
10:28:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:13 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:13 SQL> --
10:28:13 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:13 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:13 SQL> --   COMMIT;
10:28:13 SQL> -- END;
10:28:13 SQL> -- /
10:28:13 SQL> 
10:28:13 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:13 SQL> 
10:28:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:28:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:13 SQL> 
10:28:13 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:13   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:13 SQL> 
10:28:13 SQL> --------------------------------
10:28:13 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:13 SQL> --
10:28:13 SQL> 
10:28:13 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:13 SQL> -- 2. Outlier Treatment and
10:28:13 SQL> -- 3. Normalization are performed below.
10:28:13 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:13 SQL> --    normalized here.
10:28:13 SQL> 
10:28:13 SQL> BEGIN
10:28:13   2  	-- Perform missing value treatment for all predictors
10:28:13   3  	-- create miss tables
10:28:13   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:13   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:13   6  
10:28:13   7  	-- populate miss tables
10:28:13   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:13   9  	  miss_table_name => 'svmc_miss_num',
10:28:13  10  	  data_table_name => '&bldtable',
10:28:13  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:13  12  
10:28:13  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:13  14  	  miss_table_name => 'svmc_miss_cat',
10:28:13  15  	  data_table_name => '&bldtable',
10:28:13  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:13  17  
10:28:13  18  	-- xform input data to replace missing values
10:28:13  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:13  20  	  miss_table_name => 'svmc_miss_num',
10:28:13  21  	  data_table_name => '&bldtable',
10:28:13  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:13  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:13  24  	  miss_table_name => 'svmc_miss_cat',
10:28:13  25  	  data_table_name => '&bldtable',
10:28:13  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:13  27  
10:28:13  28  	-- Perform outlier treatment.
10:28:13  29  	-- create clip table
10:28:13  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:13  31  
10:28:13  32  	-- populate clip table
10:28:13  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:13  34  	  clip_table_name => 'svmc_clip',
10:28:13  35  	  data_table_name => '&bldtable',
10:28:13  36  	  tail_frac	  => 0.025,
10:28:13  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:13  38  
10:28:13  39  	-- xform input data to winsorized data
10:28:13  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:13  41  	  clip_table_name => 'svmc_clip',
10:28:13  42  	  data_table_name => '&bldtable',
10:28:13  43  	  xform_view_name => 'svmc_winsor');
10:28:13  44  
10:28:13  45  	-- create normalization table
10:28:13  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:13  47  
10:28:13  48  	-- populate normalization table based on winsorized data
10:28:13  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:13  50  	  norm_table_name => 'svmc_norm',
10:28:13  51  	  data_table_name => 'svmc_winsor',
10:28:13  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:13  53  
10:28:13  54  	-- normalize the original data
10:28:13  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:13  56  	  norm_table_name => 'svmc_norm',
10:28:13  57  	  data_table_name => '&bldtable',
10:28:13  58  	  xform_view_name => 'svmc_build_prep');
10:28:13  59  END;
10:28:13  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:28:13 SQL> 
10:28:13 SQL> ---------------------
10:28:13 SQL> -- CREATE A NEW MODEL
10:28:13 SQL> --
10:28:13 SQL> -- Cleanup old model with the same name for repeat runs
10:28:13 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:13   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:13   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.11
10:28:14 SQL> 
10:28:14 SQL> -- Build a new SVM Model
10:28:14 SQL> BEGIN
10:28:14   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:14   3  	  model_name	      => '&model_name',
10:28:14   4  	  mining_function     => dbms_data_mining.classification,
10:28:14   5  	  data_table_name     => 'svmc_build_prep',
10:28:14   6  	  case_id_column_name => '&case_id',
10:28:14   7  	  target_column_name  => '&target',
10:28:14   8  	  settings_table_name => 'svmc_settings');
10:28:14   9  END;
10:28:14  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.72
10:28:17 SQL> 
10:28:17 SQL> -----------------------------------------------------------------------
10:28:17 SQL> --			       APPLY/score THE MODEL
10:28:17 SQL> -----------------------------------------------------------------------
10:28:17 SQL> 
10:28:17 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
10:28:17 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:17   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:17   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:17 SQL> -----------------------
10:28:17 SQL> -- PREPARE SCORING DATA
10:28:17 SQL> --
10:28:17 SQL> -- If the data for model creation has been prepared, then the data
10:28:17 SQL> -- to be scored using the model must be prepared in the same manner
10:28:17 SQL> -- in order to obtain meaningful results.
10:28:17 SQL> --
10:28:17 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:17 SQL> -- 2. Normalization
10:28:17 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:17 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:17 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:17 SQL> --
10:28:17 SQL> BEGIN
10:28:17   2  	-- Xform Test data to replace missing values
10:28:17   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:17   4  	  miss_table_name => 'svmc_miss_num',
10:28:17   5  	  data_table_name => '&scoretable',
10:28:17   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:17   7  
10:28:17   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:17   9  	  miss_table_name => 'svmc_miss_cat',
10:28:17  10  	  data_table_name => '&scoretable',
10:28:17  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:17  12  
10:28:17  13  	-- Normalize the data to be scored
10:28:17  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:17  15  	  norm_table_name => 'svmc_norm',
10:28:17  16  	  data_table_name => '&scoretable',
10:28:17  17  	  xform_view_name => 'svmc_apply_prep');
10:28:17  18  END;
10:28:17  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:28:18 SQL> 
10:28:18 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:18 SQL> -- DELETE it if I did:
10:28:18 SQL> DELETE ystkscores
10:28:18   2  WHERE score > 0
10:28:18   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:18   4  -- I need to supply the target attribute name:
10:28:18   5  AND targ = '&1'
10:28:18   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:28:18 SQL> 
10:28:18 SQL> -- We do a drumroll here:
10:28:18 SQL> 
10:28:18 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:18   2  SELECT
10:28:18   3  tkrdate
10:28:18   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:18   5  ,sysdate
10:28:18   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:18   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:18   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:18   9  ,SUBSTR(tkrdate,-10)ydate
10:28:18  10  ,'&1'
10:28:18  11  FROM svmc_apply_prep
10:28:18  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:28:18 SQL> @score1_5min.sql	      2010-06-23 TLT
10:28:18 SQL> --
10:28:18 SQL> -- score1_5min.sql
10:28:18 SQL> --
10:28:18 SQL> 
10:28:18 SQL> -- Demo:
10:28:18 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:28:18 SQL> 
10:28:18 SQL> CREATE OR REPLACE VIEW sme AS
10:28:18   2  SELECT
10:28:18   3  tkrdate
10:28:18   4  ,NULL gatt
10:28:18   5  ,g00
10:28:18   6  ,g01
10:28:18   7  ,g02
10:28:18   8  ,g03
10:28:18   9  ,g04
10:28:18  10  ,g05
10:28:18  11  ,g06
10:28:18  12  ,g07
10:28:18  13  ,g08
10:28:18  14  ,g09
10:28:18  15  ,g10
10:28:18  16  ,g11
10:28:18  17  ,g12
10:28:18  18  ,g13
10:28:18  19  ,g14
10:28:18  20  ,g15
10:28:18  21  ,g16
10:28:18  22  ,g17
10:28:18  23  ,g18
10:28:18  24  ,g19
10:28:18  25  ,g20
10:28:18  26  ,g21
10:28:18  27  ,g22
10:28:18  28  ,g23
10:28:18  29  ,g24
10:28:18  30  ,g25
10:28:18  31  ,g26
10:28:18  32  ,g27
10:28:18  33  ,g28
10:28:18  34  ,g29
10:28:18  35  FROM stk_ms
10:28:18  36  WHERE ydate = '&1'
10:28:18  37  AND tkr = '&2'
10:28:18  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-23'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:18 SQL> 
10:28:18 SQL> -- rpt
10:28:18 SQL> -- We should see just 1 row:
10:28:18 SQL> 
10:28:18 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:18   2  
10:28:18 SQL> -- Build the model:
10:28:18 SQL> CREATE OR REPLACE VIEW bme AS
10:28:18   2  SELECT
10:28:18   3  tkrdate
10:28:18   4  ,gatt
10:28:18   5  ,g00
10:28:18   6  ,g01
10:28:18   7  ,g02
10:28:18   8  ,g03
10:28:18   9  ,g04
10:28:18  10  ,g05
10:28:18  11  ,g06
10:28:18  12  ,g07
10:28:18  13  ,g08
10:28:18  14  ,g09
10:28:18  15  ,g10
10:28:18  16  ,g11
10:28:18  17  ,g12
10:28:18  18  ,g13
10:28:18  19  ,g14
10:28:18  20  ,g15
10:28:18  21  ,g16
10:28:18  22  ,g17
10:28:18  23  ,g18
10:28:18  24  ,g19
10:28:18  25  ,g20
10:28:18  26  ,g21
10:28:18  27  ,g22
10:28:18  28  ,g23
10:28:18  29  ,g24
10:28:18  30  ,g25
10:28:18  31  ,g26
10:28:18  32  ,g27
10:28:18  33  ,g28
10:28:18  34  ,g29
10:28:18  35  FROM stk_ms
10:28:18  36  WHERE gatt IN('nup','up')
10:28:18  37  -- Use only rows which are older than 1 day:
10:28:18  38  AND 1+ydate < '&1'
10:28:18  39  AND tkr = '&2'
10:28:18  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-23'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:18 SQL> 
10:28:18 SQL> -- rpt
10:28:18 SQL> 
10:28:18 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:28:18   2  
10:28:18 SQL> SELECT MAX(tkrdate) FROM bme
10:28:18   2  
10:28:18 SQL> -- Now build model from bme and score sme
10:28:18 SQL> @score1.sql gatt
10:28:18 SQL> -- score1.sql
10:28:18 SQL> 
10:28:18 SQL> -- I use this script to send 5 params to score.sql
10:28:18 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:18 SQL> -- Then at the very end of this script I use the model
10:28:18 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:18 SQL> 
10:28:18 SQL> -- I call this script from 2 other scripts:
10:28:18 SQL> -- score1_5min.sql
10:28:18 SQL> -- score1_5min_gattn.sql
10:28:18 SQL> 
10:28:18 SQL> -- The 1st param is the name of the target attribute.
10:28:18 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:18 SQL> 
10:28:18 SQL> -- Demo:
10:28:18 SQL> -- @score1.sql 'gatt'
10:28:18 SQL> -- @score1.sql 'gattn'
10:28:18 SQL> 
10:28:18 SQL> -- Now, I fill up svmc_apply_prep.
10:28:18 SQL> -- I use same model_name used in score.sql
10:28:18 SQL> DEFINE model_name = 'svmspy101'
10:28:18 SQL> DEFINE bldtable	= 'bme'
10:28:18 SQL> DEFINE scoretable = 'sme'
10:28:18 SQL> DEFINE case_id	= 'tkrdate'
10:28:18 SQL> -- Demo:
10:28:18 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:18 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:18 SQL> --
10:28:18 SQL> -- score.sql
10:28:18 SQL> --
10:28:18 SQL> 
10:28:18 SQL> -- usage: score.sql
10:28:18 SQL> 
10:28:18 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:18 SQL> 
10:28:18 SQL> -- DEFINE target	   = 'gatt'
10:28:18 SQL> -- DEFINE model_name = 'svmspy100'
10:28:18 SQL> -- DEFINE bldtable   = 'bme'
10:28:18 SQL> -- DEFINE scoretable = 'sme'
10:28:18 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:18 SQL> 
10:28:18 SQL> DEFINE target	= '&1'
10:28:18 SQL> DEFINE model_name = '&2'
10:28:18 SQL> DEFINE bldtable	= '&3'
10:28:18 SQL> DEFINE scoretable = '&4'
10:28:18 SQL> DEFINE case_id	= '&5'
10:28:18 SQL> 
10:28:18 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:18 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:18 SQL> 
10:28:18 SQL> -- Builds an SVM model using pl/sql.
10:28:18 SQL> 
10:28:18 SQL> -----------------------------------------------------------------------
10:28:18 SQL> --			    BUILD THE MODEL
10:28:18 SQL> -----------------------------------------------------------------------
10:28:18 SQL> 
10:28:18 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:18 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:18 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:28:18 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:18 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:18 SQL> 
10:28:18 SQL> 
10:28:18 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:18 SQL> --
10:28:18 SQL> -- DROP	TABLE svmc_settings ;
10:28:18 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:18 SQL> -- DELETE svmc_settings;
10:28:18 SQL> 
10:28:18 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:18 SQL> -- this choice to SVM using a settings table.
10:28:18 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:18 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:18 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:18 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:18 SQL> -- models.
10:28:18 SQL> --
10:28:18 SQL> 
10:28:18 SQL> -- Do this once and then comment it out.
10:28:18 SQL> -- That makes script go faster.
10:28:18 SQL> -- BEGIN
10:28:18 SQL> -- -- Populate settings table
10:28:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:18 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:18 SQL> --
10:28:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:18 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:18 SQL> --
10:28:18 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:18 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:18 SQL> --   COMMIT;
10:28:18 SQL> -- END;
10:28:18 SQL> -- /
10:28:18 SQL> 
10:28:18 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:18 SQL> 
10:28:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:18 SQL> 
10:28:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:18 SQL> 
10:28:18 SQL> --------------------------------
10:28:18 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:18 SQL> --
10:28:18 SQL> 
10:28:18 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:18 SQL> -- 2. Outlier Treatment and
10:28:18 SQL> -- 3. Normalization are performed below.
10:28:18 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:18 SQL> --    normalized here.
10:28:18 SQL> 
10:28:18 SQL> BEGIN
10:28:18   2  	-- Perform missing value treatment for all predictors
10:28:18   3  	-- create miss tables
10:28:18   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:18   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:18   6  
10:28:18   7  	-- populate miss tables
10:28:18   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:18   9  	  miss_table_name => 'svmc_miss_num',
10:28:18  10  	  data_table_name => '&bldtable',
10:28:18  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:18  12  
10:28:18  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:18  14  	  miss_table_name => 'svmc_miss_cat',
10:28:18  15  	  data_table_name => '&bldtable',
10:28:18  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:18  17  
10:28:18  18  	-- xform input data to replace missing values
10:28:18  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:18  20  	  miss_table_name => 'svmc_miss_num',
10:28:18  21  	  data_table_name => '&bldtable',
10:28:18  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:18  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:18  24  	  miss_table_name => 'svmc_miss_cat',
10:28:18  25  	  data_table_name => '&bldtable',
10:28:18  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:18  27  
10:28:18  28  	-- Perform outlier treatment.
10:28:18  29  	-- create clip table
10:28:18  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:18  31  
10:28:18  32  	-- populate clip table
10:28:18  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:18  34  	  clip_table_name => 'svmc_clip',
10:28:18  35  	  data_table_name => '&bldtable',
10:28:18  36  	  tail_frac	  => 0.025,
10:28:18  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:18  38  
10:28:18  39  	-- xform input data to winsorized data
10:28:18  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:18  41  	  clip_table_name => 'svmc_clip',
10:28:18  42  	  data_table_name => '&bldtable',
10:28:18  43  	  xform_view_name => 'svmc_winsor');
10:28:18  44  
10:28:18  45  	-- create normalization table
10:28:18  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:18  47  
10:28:18  48  	-- populate normalization table based on winsorized data
10:28:18  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:18  50  	  norm_table_name => 'svmc_norm',
10:28:18  51  	  data_table_name => 'svmc_winsor',
10:28:18  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:18  53  
10:28:18  54  	-- normalize the original data
10:28:18  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:18  56  	  norm_table_name => 'svmc_norm',
10:28:18  57  	  data_table_name => '&bldtable',
10:28:18  58  	  xform_view_name => 'svmc_build_prep');
10:28:18  59  END;
10:28:18  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:28:18 SQL> 
10:28:18 SQL> ---------------------
10:28:18 SQL> -- CREATE A NEW MODEL
10:28:18 SQL> --
10:28:18 SQL> -- Cleanup old model with the same name for repeat runs
10:28:18 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:18   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.06
10:28:20 SQL> 
10:28:20 SQL> -- Build a new SVM Model
10:28:20 SQL> BEGIN
10:28:20   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:20   3  	  model_name	      => '&model_name',
10:28:20   4  	  mining_function     => dbms_data_mining.classification,
10:28:20   5  	  data_table_name     => 'svmc_build_prep',
10:28:20   6  	  case_id_column_name => '&case_id',
10:28:20   7  	  target_column_name  => '&target',
10:28:20   8  	  settings_table_name => 'svmc_settings');
10:28:20   9  END;
10:28:20  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.20
10:28:22 SQL> 
10:28:22 SQL> -----------------------------------------------------------------------
10:28:22 SQL> --			       APPLY/score THE MODEL
10:28:22 SQL> -----------------------------------------------------------------------
10:28:22 SQL> 
10:28:22 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:22 SQL> -----------------------
10:28:22 SQL> -- PREPARE SCORING DATA
10:28:22 SQL> --
10:28:22 SQL> -- If the data for model creation has been prepared, then the data
10:28:22 SQL> -- to be scored using the model must be prepared in the same manner
10:28:22 SQL> -- in order to obtain meaningful results.
10:28:22 SQL> --
10:28:22 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:22 SQL> -- 2. Normalization
10:28:22 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:22 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:22 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:22 SQL> --
10:28:22 SQL> BEGIN
10:28:22   2  	-- Xform Test data to replace missing values
10:28:22   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:22   4  	  miss_table_name => 'svmc_miss_num',
10:28:22   5  	  data_table_name => '&scoretable',
10:28:22   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:22   7  
10:28:22   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:22   9  	  miss_table_name => 'svmc_miss_cat',
10:28:22  10  	  data_table_name => '&scoretable',
10:28:22  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:22  12  
10:28:22  13  	-- Normalize the data to be scored
10:28:22  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:22  15  	  norm_table_name => 'svmc_norm',
10:28:22  16  	  data_table_name => '&scoretable',
10:28:22  17  	  xform_view_name => 'svmc_apply_prep');
10:28:22  18  END;
10:28:22  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.27
10:28:22 SQL> 
10:28:22 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:22 SQL> -- DELETE it if I did:
10:28:22 SQL> DELETE ystkscores
10:28:22   2  WHERE score > 0
10:28:22   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:22   4  -- I need to supply the target attribute name:
10:28:22   5  AND targ = '&1'
10:28:22   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:22 SQL> 
10:28:22 SQL> -- We do a drumroll here:
10:28:22 SQL> 
10:28:22 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:22   2  SELECT
10:28:22   3  tkrdate
10:28:22   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:22   5  ,sysdate
10:28:22   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:22   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:22   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:22   9  ,SUBSTR(tkrdate,-10)ydate
10:28:22  10  ,'&1'
10:28:22  11  FROM svmc_apply_prep
10:28:22  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:28:22 SQL> @score1_5min_gattn.sql	2010-05-04 TLT
10:28:22 SQL> --
10:28:22 SQL> -- score1_5min_gattn.sql
10:28:22 SQL> --
10:28:22 SQL> 
10:28:22 SQL> -- Demo:
10:28:22 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:22 SQL> 
10:28:22 SQL> CREATE OR REPLACE VIEW sme AS
10:28:22   2  SELECT
10:28:22   3  tkrdate
10:28:22   4  ,NULL gattn
10:28:22   5  ,g00
10:28:22   6  ,g01
10:28:22   7  ,g02
10:28:22   8  ,g03
10:28:22   9  ,g04
10:28:22  10  ,g05
10:28:22  11  ,g06
10:28:22  12  ,g07
10:28:22  13  ,g08
10:28:22  14  ,g09
10:28:22  15  ,g10
10:28:22  16  ,g11
10:28:22  17  ,g12
10:28:22  18  ,g13
10:28:22  19  ,g14
10:28:22  20  ,g15
10:28:22  21  ,g16
10:28:22  22  ,g17
10:28:22  23  ,g18
10:28:22  24  ,g19
10:28:22  25  ,g20
10:28:22  26  ,g21
10:28:22  27  ,g22
10:28:22  28  ,g23
10:28:22  29  ,g24
10:28:22  30  ,g25
10:28:22  31  ,g26
10:28:22  32  ,g27
10:28:22  33  ,g28
10:28:22  34  ,g29
10:28:22  35  FROM stk_ms
10:28:22  36  WHERE ydate = '&1'
10:28:22  37  AND tkr = '&2'
10:28:22  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-05-04'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:22 SQL> 
10:28:22 SQL> -- rpt
10:28:22 SQL> -- We should see just 1 row:
10:28:22 SQL> 
10:28:22 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:22   2  
10:28:22 SQL> -- Build the model:
10:28:22 SQL> CREATE OR REPLACE VIEW bme AS
10:28:22   2  SELECT
10:28:22   3  tkrdate
10:28:22   4  ,gattn
10:28:22   5  ,g00
10:28:22   6  ,g01
10:28:22   7  ,g02
10:28:22   8  ,g03
10:28:22   9  ,g04
10:28:22  10  ,g05
10:28:22  11  ,g06
10:28:22  12  ,g07
10:28:22  13  ,g08
10:28:22  14  ,g09
10:28:22  15  ,g10
10:28:22  16  ,g11
10:28:22  17  ,g12
10:28:22  18  ,g13
10:28:22  19  ,g14
10:28:22  20  ,g15
10:28:22  21  ,g16
10:28:22  22  ,g17
10:28:22  23  ,g18
10:28:22  24  ,g19
10:28:22  25  ,g20
10:28:22  26  ,g21
10:28:22  27  ,g22
10:28:22  28  ,g23
10:28:22  29  ,g24
10:28:22  30  ,g25
10:28:22  31  ,g26
10:28:22  32  ,g27
10:28:22  33  ,g28
10:28:22  34  ,g29
10:28:22  35  FROM stk_ms
10:28:22  36  WHERE gattn IN('nup','up')
10:28:22  37  -- Use only rows which are older than 1 day:
10:28:22  38  AND 1+ydate < '&1'
10:28:22  39  AND tkr = '&2'
10:28:22  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-05-04'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:28:22 SQL> 
10:28:22 SQL> -- rpt
10:28:22 SQL> 
10:28:22 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:22   2  
10:28:22 SQL> SELECT MAX(tkrdate) FROM bme
10:28:22   2  
10:28:22 SQL> -- Now build model from bme and score sme
10:28:22 SQL> @score1.sql gattn
10:28:22 SQL> -- score1.sql
10:28:22 SQL> 
10:28:22 SQL> -- I use this script to send 5 params to score.sql
10:28:22 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:22 SQL> -- Then at the very end of this script I use the model
10:28:22 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:22 SQL> 
10:28:22 SQL> -- I call this script from 2 other scripts:
10:28:22 SQL> -- score1_5min.sql
10:28:22 SQL> -- score1_5min_gattn.sql
10:28:22 SQL> 
10:28:22 SQL> -- The 1st param is the name of the target attribute.
10:28:22 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:22 SQL> 
10:28:22 SQL> -- Demo:
10:28:22 SQL> -- @score1.sql 'gatt'
10:28:22 SQL> -- @score1.sql 'gattn'
10:28:22 SQL> 
10:28:22 SQL> -- Now, I fill up svmc_apply_prep.
10:28:22 SQL> -- I use same model_name used in score.sql
10:28:22 SQL> DEFINE model_name = 'svmspy101'
10:28:22 SQL> DEFINE bldtable	= 'bme'
10:28:22 SQL> DEFINE scoretable = 'sme'
10:28:22 SQL> DEFINE case_id	= 'tkrdate'
10:28:22 SQL> -- Demo:
10:28:22 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:22 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:22 SQL> --
10:28:22 SQL> -- score.sql
10:28:22 SQL> --
10:28:22 SQL> 
10:28:22 SQL> -- usage: score.sql
10:28:22 SQL> 
10:28:22 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:22 SQL> 
10:28:22 SQL> -- DEFINE target	   = 'gatt'
10:28:22 SQL> -- DEFINE model_name = 'svmspy100'
10:28:22 SQL> -- DEFINE bldtable   = 'bme'
10:28:22 SQL> -- DEFINE scoretable = 'sme'
10:28:22 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:22 SQL> 
10:28:22 SQL> DEFINE target	= '&1'
10:28:22 SQL> DEFINE model_name = '&2'
10:28:22 SQL> DEFINE bldtable	= '&3'
10:28:22 SQL> DEFINE scoretable = '&4'
10:28:22 SQL> DEFINE case_id	= '&5'
10:28:22 SQL> 
10:28:22 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:22 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:22 SQL> 
10:28:22 SQL> -- Builds an SVM model using pl/sql.
10:28:22 SQL> 
10:28:22 SQL> -----------------------------------------------------------------------
10:28:22 SQL> --			    BUILD THE MODEL
10:28:22 SQL> -----------------------------------------------------------------------
10:28:22 SQL> 
10:28:22 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:22 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:22 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:22 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:22 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:22 SQL> 
10:28:22 SQL> 
10:28:22 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:22 SQL> --
10:28:22 SQL> -- DROP	TABLE svmc_settings ;
10:28:22 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:22 SQL> -- DELETE svmc_settings;
10:28:22 SQL> 
10:28:22 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:22 SQL> -- this choice to SVM using a settings table.
10:28:22 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:22 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:22 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:22 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:22 SQL> -- models.
10:28:22 SQL> --
10:28:22 SQL> 
10:28:22 SQL> -- Do this once and then comment it out.
10:28:22 SQL> -- That makes script go faster.
10:28:22 SQL> -- BEGIN
10:28:22 SQL> -- -- Populate settings table
10:28:22 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:22 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:22 SQL> --
10:28:22 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:22 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:22 SQL> --
10:28:22 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:22 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:22 SQL> --   COMMIT;
10:28:22 SQL> -- END;
10:28:22 SQL> -- /
10:28:22 SQL> 
10:28:22 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:28:22 SQL> 
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:22 SQL> 
10:28:22 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:22   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:22   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:22 SQL> 
10:28:22 SQL> --------------------------------
10:28:22 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:22 SQL> --
10:28:22 SQL> 
10:28:22 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:22 SQL> -- 2. Outlier Treatment and
10:28:22 SQL> -- 3. Normalization are performed below.
10:28:22 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:22 SQL> --    normalized here.
10:28:22 SQL> 
10:28:22 SQL> BEGIN
10:28:22   2  	-- Perform missing value treatment for all predictors
10:28:22   3  	-- create miss tables
10:28:22   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:22   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:22   6  
10:28:22   7  	-- populate miss tables
10:28:22   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:22   9  	  miss_table_name => 'svmc_miss_num',
10:28:22  10  	  data_table_name => '&bldtable',
10:28:22  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:22  12  
10:28:22  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:22  14  	  miss_table_name => 'svmc_miss_cat',
10:28:22  15  	  data_table_name => '&bldtable',
10:28:22  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:22  17  
10:28:22  18  	-- xform input data to replace missing values
10:28:22  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:22  20  	  miss_table_name => 'svmc_miss_num',
10:28:22  21  	  data_table_name => '&bldtable',
10:28:22  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:22  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:22  24  	  miss_table_name => 'svmc_miss_cat',
10:28:22  25  	  data_table_name => '&bldtable',
10:28:22  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:22  27  
10:28:22  28  	-- Perform outlier treatment.
10:28:22  29  	-- create clip table
10:28:22  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:22  31  
10:28:22  32  	-- populate clip table
10:28:22  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:22  34  	  clip_table_name => 'svmc_clip',
10:28:22  35  	  data_table_name => '&bldtable',
10:28:22  36  	  tail_frac	  => 0.025,
10:28:22  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:22  38  
10:28:22  39  	-- xform input data to winsorized data
10:28:22  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:22  41  	  clip_table_name => 'svmc_clip',
10:28:22  42  	  data_table_name => '&bldtable',
10:28:22  43  	  xform_view_name => 'svmc_winsor');
10:28:22  44  
10:28:22  45  	-- create normalization table
10:28:22  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:22  47  
10:28:22  48  	-- populate normalization table based on winsorized data
10:28:22  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:22  50  	  norm_table_name => 'svmc_norm',
10:28:22  51  	  data_table_name => 'svmc_winsor',
10:28:22  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:22  53  
10:28:22  54  	-- normalize the original data
10:28:22  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:22  56  	  norm_table_name => 'svmc_norm',
10:28:22  57  	  data_table_name => '&bldtable',
10:28:22  58  	  xform_view_name => 'svmc_build_prep');
10:28:22  59  END;
10:28:22  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.63
10:28:23 SQL> 
10:28:23 SQL> ---------------------
10:28:23 SQL> -- CREATE A NEW MODEL
10:28:23 SQL> --
10:28:23 SQL> -- Cleanup old model with the same name for repeat runs
10:28:23 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:23   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.50
10:28:25 SQL> 
10:28:25 SQL> -- Build a new SVM Model
10:28:25 SQL> BEGIN
10:28:25   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:25   3  	  model_name	      => '&model_name',
10:28:25   4  	  mining_function     => dbms_data_mining.classification,
10:28:25   5  	  data_table_name     => 'svmc_build_prep',
10:28:25   6  	  case_id_column_name => '&case_id',
10:28:25   7  	  target_column_name  => '&target',
10:28:25   8  	  settings_table_name => 'svmc_settings');
10:28:25   9  END;
10:28:25  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.03
10:28:27 SQL> 
10:28:27 SQL> -----------------------------------------------------------------------
10:28:27 SQL> --			       APPLY/score THE MODEL
10:28:27 SQL> -----------------------------------------------------------------------
10:28:27 SQL> 
10:28:27 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:27 SQL> -----------------------
10:28:27 SQL> -- PREPARE SCORING DATA
10:28:27 SQL> --
10:28:27 SQL> -- If the data for model creation has been prepared, then the data
10:28:27 SQL> -- to be scored using the model must be prepared in the same manner
10:28:27 SQL> -- in order to obtain meaningful results.
10:28:27 SQL> --
10:28:27 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:27 SQL> -- 2. Normalization
10:28:27 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:27 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:27 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:27 SQL> --
10:28:27 SQL> BEGIN
10:28:27   2  	-- Xform Test data to replace missing values
10:28:27   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:27   4  	  miss_table_name => 'svmc_miss_num',
10:28:27   5  	  data_table_name => '&scoretable',
10:28:27   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:27   7  
10:28:27   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:27   9  	  miss_table_name => 'svmc_miss_cat',
10:28:27  10  	  data_table_name => '&scoretable',
10:28:27  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:27  12  
10:28:27  13  	-- Normalize the data to be scored
10:28:27  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:27  15  	  norm_table_name => 'svmc_norm',
10:28:27  16  	  data_table_name => '&scoretable',
10:28:27  17  	  xform_view_name => 'svmc_apply_prep');
10:28:27  18  END;
10:28:27  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:28:27 SQL> 
10:28:27 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:27 SQL> -- DELETE it if I did:
10:28:27 SQL> DELETE ystkscores
10:28:27   2  WHERE score > 0
10:28:27   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:27   4  -- I need to supply the target attribute name:
10:28:27   5  AND targ = '&1'
10:28:27   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:27 SQL> 
10:28:27 SQL> -- We do a drumroll here:
10:28:27 SQL> 
10:28:27 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:27   2  SELECT
10:28:27   3  tkrdate
10:28:27   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:27   5  ,sysdate
10:28:27   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:27   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:27   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:27   9  ,SUBSTR(tkrdate,-10)ydate
10:28:27  10  ,'&1'
10:28:27  11  FROM svmc_apply_prep
10:28:27  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:28:27 SQL> @score1_5min_gattn.sql	2010-06-29 TLT
10:28:27 SQL> --
10:28:27 SQL> -- score1_5min_gattn.sql
10:28:27 SQL> --
10:28:27 SQL> 
10:28:27 SQL> -- Demo:
10:28:27 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:27 SQL> 
10:28:27 SQL> CREATE OR REPLACE VIEW sme AS
10:28:27   2  SELECT
10:28:27   3  tkrdate
10:28:27   4  ,NULL gattn
10:28:27   5  ,g00
10:28:27   6  ,g01
10:28:27   7  ,g02
10:28:27   8  ,g03
10:28:27   9  ,g04
10:28:27  10  ,g05
10:28:27  11  ,g06
10:28:27  12  ,g07
10:28:27  13  ,g08
10:28:27  14  ,g09
10:28:27  15  ,g10
10:28:27  16  ,g11
10:28:27  17  ,g12
10:28:27  18  ,g13
10:28:27  19  ,g14
10:28:27  20  ,g15
10:28:27  21  ,g16
10:28:27  22  ,g17
10:28:27  23  ,g18
10:28:27  24  ,g19
10:28:27  25  ,g20
10:28:27  26  ,g21
10:28:27  27  ,g22
10:28:27  28  ,g23
10:28:27  29  ,g24
10:28:27  30  ,g25
10:28:27  31  ,g26
10:28:27  32  ,g27
10:28:27  33  ,g28
10:28:27  34  ,g29
10:28:27  35  FROM stk_ms
10:28:27  36  WHERE ydate = '&1'
10:28:27  37  AND tkr = '&2'
10:28:27  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-29'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:28:27 SQL> 
10:28:27 SQL> -- rpt
10:28:27 SQL> -- We should see just 1 row:
10:28:27 SQL> 
10:28:27 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:27   2  
10:28:27 SQL> -- Build the model:
10:28:27 SQL> CREATE OR REPLACE VIEW bme AS
10:28:27   2  SELECT
10:28:27   3  tkrdate
10:28:27   4  ,gattn
10:28:27   5  ,g00
10:28:27   6  ,g01
10:28:27   7  ,g02
10:28:27   8  ,g03
10:28:27   9  ,g04
10:28:27  10  ,g05
10:28:27  11  ,g06
10:28:27  12  ,g07
10:28:27  13  ,g08
10:28:27  14  ,g09
10:28:27  15  ,g10
10:28:27  16  ,g11
10:28:27  17  ,g12
10:28:27  18  ,g13
10:28:27  19  ,g14
10:28:27  20  ,g15
10:28:27  21  ,g16
10:28:27  22  ,g17
10:28:27  23  ,g18
10:28:27  24  ,g19
10:28:27  25  ,g20
10:28:27  26  ,g21
10:28:27  27  ,g22
10:28:27  28  ,g23
10:28:27  29  ,g24
10:28:27  30  ,g25
10:28:27  31  ,g26
10:28:27  32  ,g27
10:28:27  33  ,g28
10:28:27  34  ,g29
10:28:27  35  FROM stk_ms
10:28:27  36  WHERE gattn IN('nup','up')
10:28:27  37  -- Use only rows which are older than 1 day:
10:28:27  38  AND 1+ydate < '&1'
10:28:27  39  AND tkr = '&2'
10:28:27  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-29'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:28:27 SQL> 
10:28:27 SQL> -- rpt
10:28:27 SQL> 
10:28:27 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:27   2  
10:28:27 SQL> SELECT MAX(tkrdate) FROM bme
10:28:27   2  
10:28:27 SQL> -- Now build model from bme and score sme
10:28:27 SQL> @score1.sql gattn
10:28:27 SQL> -- score1.sql
10:28:27 SQL> 
10:28:27 SQL> -- I use this script to send 5 params to score.sql
10:28:27 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:27 SQL> -- Then at the very end of this script I use the model
10:28:27 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:27 SQL> 
10:28:27 SQL> -- I call this script from 2 other scripts:
10:28:27 SQL> -- score1_5min.sql
10:28:27 SQL> -- score1_5min_gattn.sql
10:28:27 SQL> 
10:28:27 SQL> -- The 1st param is the name of the target attribute.
10:28:27 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:27 SQL> 
10:28:27 SQL> -- Demo:
10:28:27 SQL> -- @score1.sql 'gatt'
10:28:27 SQL> -- @score1.sql 'gattn'
10:28:27 SQL> 
10:28:27 SQL> -- Now, I fill up svmc_apply_prep.
10:28:27 SQL> -- I use same model_name used in score.sql
10:28:27 SQL> DEFINE model_name = 'svmspy101'
10:28:27 SQL> DEFINE bldtable	= 'bme'
10:28:27 SQL> DEFINE scoretable = 'sme'
10:28:27 SQL> DEFINE case_id	= 'tkrdate'
10:28:27 SQL> -- Demo:
10:28:27 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:27 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:27 SQL> --
10:28:27 SQL> -- score.sql
10:28:27 SQL> --
10:28:27 SQL> 
10:28:27 SQL> -- usage: score.sql
10:28:27 SQL> 
10:28:27 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:27 SQL> 
10:28:27 SQL> -- DEFINE target	   = 'gatt'
10:28:27 SQL> -- DEFINE model_name = 'svmspy100'
10:28:27 SQL> -- DEFINE bldtable   = 'bme'
10:28:27 SQL> -- DEFINE scoretable = 'sme'
10:28:27 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:27 SQL> 
10:28:27 SQL> DEFINE target	= '&1'
10:28:27 SQL> DEFINE model_name = '&2'
10:28:27 SQL> DEFINE bldtable	= '&3'
10:28:27 SQL> DEFINE scoretable = '&4'
10:28:27 SQL> DEFINE case_id	= '&5'
10:28:27 SQL> 
10:28:27 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:27 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:27 SQL> 
10:28:27 SQL> -- Builds an SVM model using pl/sql.
10:28:27 SQL> 
10:28:27 SQL> -----------------------------------------------------------------------
10:28:27 SQL> --			    BUILD THE MODEL
10:28:27 SQL> -----------------------------------------------------------------------
10:28:27 SQL> 
10:28:27 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:27 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:27 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:27 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:27 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:27 SQL> 
10:28:27 SQL> 
10:28:27 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:27 SQL> --
10:28:27 SQL> -- DROP	TABLE svmc_settings ;
10:28:27 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:27 SQL> -- DELETE svmc_settings;
10:28:27 SQL> 
10:28:27 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:27 SQL> -- this choice to SVM using a settings table.
10:28:27 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:27 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:27 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:27 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:27 SQL> -- models.
10:28:27 SQL> --
10:28:27 SQL> 
10:28:27 SQL> -- Do this once and then comment it out.
10:28:27 SQL> -- That makes script go faster.
10:28:27 SQL> -- BEGIN
10:28:27 SQL> -- -- Populate settings table
10:28:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:27 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:27 SQL> --
10:28:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:27 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:27 SQL> --
10:28:27 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:27 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:27 SQL> --   COMMIT;
10:28:27 SQL> -- END;
10:28:27 SQL> -- /
10:28:27 SQL> 
10:28:27 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:27 SQL> 
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:27 SQL> 
10:28:27 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:27   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:27   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:27 SQL> 
10:28:27 SQL> --------------------------------
10:28:27 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:27 SQL> --
10:28:27 SQL> 
10:28:27 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:27 SQL> -- 2. Outlier Treatment and
10:28:27 SQL> -- 3. Normalization are performed below.
10:28:27 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:27 SQL> --    normalized here.
10:28:27 SQL> 
10:28:27 SQL> BEGIN
10:28:27   2  	-- Perform missing value treatment for all predictors
10:28:27   3  	-- create miss tables
10:28:27   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:27   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:27   6  
10:28:27   7  	-- populate miss tables
10:28:27   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:27   9  	  miss_table_name => 'svmc_miss_num',
10:28:27  10  	  data_table_name => '&bldtable',
10:28:27  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:27  12  
10:28:27  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:27  14  	  miss_table_name => 'svmc_miss_cat',
10:28:27  15  	  data_table_name => '&bldtable',
10:28:27  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:27  17  
10:28:27  18  	-- xform input data to replace missing values
10:28:27  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:27  20  	  miss_table_name => 'svmc_miss_num',
10:28:27  21  	  data_table_name => '&bldtable',
10:28:27  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:27  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:27  24  	  miss_table_name => 'svmc_miss_cat',
10:28:27  25  	  data_table_name => '&bldtable',
10:28:27  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:27  27  
10:28:27  28  	-- Perform outlier treatment.
10:28:27  29  	-- create clip table
10:28:27  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:27  31  
10:28:27  32  	-- populate clip table
10:28:27  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:27  34  	  clip_table_name => 'svmc_clip',
10:28:27  35  	  data_table_name => '&bldtable',
10:28:27  36  	  tail_frac	  => 0.025,
10:28:27  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:27  38  
10:28:27  39  	-- xform input data to winsorized data
10:28:27  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:27  41  	  clip_table_name => 'svmc_clip',
10:28:27  42  	  data_table_name => '&bldtable',
10:28:27  43  	  xform_view_name => 'svmc_winsor');
10:28:27  44  
10:28:27  45  	-- create normalization table
10:28:27  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:27  47  
10:28:27  48  	-- populate normalization table based on winsorized data
10:28:27  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:27  50  	  norm_table_name => 'svmc_norm',
10:28:27  51  	  data_table_name => 'svmc_winsor',
10:28:27  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:27  53  
10:28:27  54  	-- normalize the original data
10:28:27  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:27  56  	  norm_table_name => 'svmc_norm',
10:28:27  57  	  data_table_name => '&bldtable',
10:28:27  58  	  xform_view_name => 'svmc_build_prep');
10:28:27  59  END;
10:28:27  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:28:28 SQL> 
10:28:28 SQL> ---------------------
10:28:28 SQL> -- CREATE A NEW MODEL
10:28:28 SQL> --
10:28:28 SQL> -- Cleanup old model with the same name for repeat runs
10:28:28 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:28   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.77
10:28:30 SQL> 
10:28:30 SQL> -- Build a new SVM Model
10:28:30 SQL> BEGIN
10:28:30   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:30   3  	  model_name	      => '&model_name',
10:28:30   4  	  mining_function     => dbms_data_mining.classification,
10:28:30   5  	  data_table_name     => 'svmc_build_prep',
10:28:30   6  	  case_id_column_name => '&case_id',
10:28:30   7  	  target_column_name  => '&target',
10:28:30   8  	  settings_table_name => 'svmc_settings');
10:28:30   9  END;
10:28:30  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.47
10:28:32 SQL> 
10:28:32 SQL> -----------------------------------------------------------------------
10:28:32 SQL> --			       APPLY/score THE MODEL
10:28:32 SQL> -----------------------------------------------------------------------
10:28:32 SQL> 
10:28:32 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.12
10:28:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:28:32 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:32   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:32   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:28:33 SQL> -----------------------
10:28:33 SQL> -- PREPARE SCORING DATA
10:28:33 SQL> --
10:28:33 SQL> -- If the data for model creation has been prepared, then the data
10:28:33 SQL> -- to be scored using the model must be prepared in the same manner
10:28:33 SQL> -- in order to obtain meaningful results.
10:28:33 SQL> --
10:28:33 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:33 SQL> -- 2. Normalization
10:28:33 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:33 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:33 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:33 SQL> --
10:28:33 SQL> BEGIN
10:28:33   2  	-- Xform Test data to replace missing values
10:28:33   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:33   4  	  miss_table_name => 'svmc_miss_num',
10:28:33   5  	  data_table_name => '&scoretable',
10:28:33   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:33   7  
10:28:33   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:33   9  	  miss_table_name => 'svmc_miss_cat',
10:28:33  10  	  data_table_name => '&scoretable',
10:28:33  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:33  12  
10:28:33  13  	-- Normalize the data to be scored
10:28:33  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:33  15  	  norm_table_name => 'svmc_norm',
10:28:33  16  	  data_table_name => '&scoretable',
10:28:33  17  	  xform_view_name => 'svmc_apply_prep');
10:28:33  18  END;
10:28:33  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:28:33 SQL> 
10:28:33 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:33 SQL> -- DELETE it if I did:
10:28:33 SQL> DELETE ystkscores
10:28:33   2  WHERE score > 0
10:28:33   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:33   4  -- I need to supply the target attribute name:
10:28:33   5  AND targ = '&1'
10:28:33   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:33 SQL> 
10:28:33 SQL> -- We do a drumroll here:
10:28:33 SQL> 
10:28:33 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:33   2  SELECT
10:28:33   3  tkrdate
10:28:33   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:33   5  ,sysdate
10:28:33   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:33   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:33   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:33   9  ,SUBSTR(tkrdate,-10)ydate
10:28:33  10  ,'&1'
10:28:33  11  FROM svmc_apply_prep
10:28:33  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:28:33 SQL> @score1_5min_gattn.sql	2010-11-18 TLT
10:28:33 SQL> --
10:28:33 SQL> -- score1_5min_gattn.sql
10:28:33 SQL> --
10:28:33 SQL> 
10:28:33 SQL> -- Demo:
10:28:33 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:33 SQL> 
10:28:33 SQL> CREATE OR REPLACE VIEW sme AS
10:28:33   2  SELECT
10:28:33   3  tkrdate
10:28:33   4  ,NULL gattn
10:28:33   5  ,g00
10:28:33   6  ,g01
10:28:33   7  ,g02
10:28:33   8  ,g03
10:28:33   9  ,g04
10:28:33  10  ,g05
10:28:33  11  ,g06
10:28:33  12  ,g07
10:28:33  13  ,g08
10:28:33  14  ,g09
10:28:33  15  ,g10
10:28:33  16  ,g11
10:28:33  17  ,g12
10:28:33  18  ,g13
10:28:33  19  ,g14
10:28:33  20  ,g15
10:28:33  21  ,g16
10:28:33  22  ,g17
10:28:33  23  ,g18
10:28:33  24  ,g19
10:28:33  25  ,g20
10:28:33  26  ,g21
10:28:33  27  ,g22
10:28:33  28  ,g23
10:28:33  29  ,g24
10:28:33  30  ,g25
10:28:33  31  ,g26
10:28:33  32  ,g27
10:28:33  33  ,g28
10:28:33  34  ,g29
10:28:33  35  FROM stk_ms
10:28:33  36  WHERE ydate = '&1'
10:28:33  37  AND tkr = '&2'
10:28:33  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-18'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:33 SQL> 
10:28:33 SQL> -- rpt
10:28:33 SQL> -- We should see just 1 row:
10:28:33 SQL> 
10:28:33 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:33   2  
10:28:33 SQL> -- Build the model:
10:28:33 SQL> CREATE OR REPLACE VIEW bme AS
10:28:33   2  SELECT
10:28:33   3  tkrdate
10:28:33   4  ,gattn
10:28:33   5  ,g00
10:28:33   6  ,g01
10:28:33   7  ,g02
10:28:33   8  ,g03
10:28:33   9  ,g04
10:28:33  10  ,g05
10:28:33  11  ,g06
10:28:33  12  ,g07
10:28:33  13  ,g08
10:28:33  14  ,g09
10:28:33  15  ,g10
10:28:33  16  ,g11
10:28:33  17  ,g12
10:28:33  18  ,g13
10:28:33  19  ,g14
10:28:33  20  ,g15
10:28:33  21  ,g16
10:28:33  22  ,g17
10:28:33  23  ,g18
10:28:33  24  ,g19
10:28:33  25  ,g20
10:28:33  26  ,g21
10:28:33  27  ,g22
10:28:33  28  ,g23
10:28:33  29  ,g24
10:28:33  30  ,g25
10:28:33  31  ,g26
10:28:33  32  ,g27
10:28:33  33  ,g28
10:28:33  34  ,g29
10:28:33  35  FROM stk_ms
10:28:33  36  WHERE gattn IN('nup','up')
10:28:33  37  -- Use only rows which are older than 1 day:
10:28:33  38  AND 1+ydate < '&1'
10:28:33  39  AND tkr = '&2'
10:28:33  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-18'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:28:33 SQL> 
10:28:33 SQL> -- rpt
10:28:33 SQL> 
10:28:33 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:33   2  
10:28:33 SQL> SELECT MAX(tkrdate) FROM bme
10:28:33   2  
10:28:33 SQL> -- Now build model from bme and score sme
10:28:33 SQL> @score1.sql gattn
10:28:33 SQL> -- score1.sql
10:28:33 SQL> 
10:28:33 SQL> -- I use this script to send 5 params to score.sql
10:28:33 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:33 SQL> -- Then at the very end of this script I use the model
10:28:33 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:33 SQL> 
10:28:33 SQL> -- I call this script from 2 other scripts:
10:28:33 SQL> -- score1_5min.sql
10:28:33 SQL> -- score1_5min_gattn.sql
10:28:33 SQL> 
10:28:33 SQL> -- The 1st param is the name of the target attribute.
10:28:33 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:33 SQL> 
10:28:33 SQL> -- Demo:
10:28:33 SQL> -- @score1.sql 'gatt'
10:28:33 SQL> -- @score1.sql 'gattn'
10:28:33 SQL> 
10:28:33 SQL> -- Now, I fill up svmc_apply_prep.
10:28:33 SQL> -- I use same model_name used in score.sql
10:28:33 SQL> DEFINE model_name = 'svmspy101'
10:28:33 SQL> DEFINE bldtable	= 'bme'
10:28:33 SQL> DEFINE scoretable = 'sme'
10:28:33 SQL> DEFINE case_id	= 'tkrdate'
10:28:33 SQL> -- Demo:
10:28:33 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:33 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:33 SQL> --
10:28:33 SQL> -- score.sql
10:28:33 SQL> --
10:28:33 SQL> 
10:28:33 SQL> -- usage: score.sql
10:28:33 SQL> 
10:28:33 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:33 SQL> 
10:28:33 SQL> -- DEFINE target	   = 'gatt'
10:28:33 SQL> -- DEFINE model_name = 'svmspy100'
10:28:33 SQL> -- DEFINE bldtable   = 'bme'
10:28:33 SQL> -- DEFINE scoretable = 'sme'
10:28:33 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:33 SQL> 
10:28:33 SQL> DEFINE target	= '&1'
10:28:33 SQL> DEFINE model_name = '&2'
10:28:33 SQL> DEFINE bldtable	= '&3'
10:28:33 SQL> DEFINE scoretable = '&4'
10:28:33 SQL> DEFINE case_id	= '&5'
10:28:33 SQL> 
10:28:33 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:33 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:33 SQL> 
10:28:33 SQL> -- Builds an SVM model using pl/sql.
10:28:33 SQL> 
10:28:33 SQL> -----------------------------------------------------------------------
10:28:33 SQL> --			    BUILD THE MODEL
10:28:33 SQL> -----------------------------------------------------------------------
10:28:33 SQL> 
10:28:33 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:33 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:33 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:33 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:33 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:33 SQL> 
10:28:33 SQL> 
10:28:33 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:33 SQL> --
10:28:33 SQL> -- DROP	TABLE svmc_settings ;
10:28:33 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:33 SQL> -- DELETE svmc_settings;
10:28:33 SQL> 
10:28:33 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:33 SQL> -- this choice to SVM using a settings table.
10:28:33 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:33 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:33 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:33 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:33 SQL> -- models.
10:28:33 SQL> --
10:28:33 SQL> 
10:28:33 SQL> -- Do this once and then comment it out.
10:28:33 SQL> -- That makes script go faster.
10:28:33 SQL> -- BEGIN
10:28:33 SQL> -- -- Populate settings table
10:28:33 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:33 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:33 SQL> --
10:28:33 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:33 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:33 SQL> --
10:28:33 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:33 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:33 SQL> --   COMMIT;
10:28:33 SQL> -- END;
10:28:33 SQL> -- /
10:28:33 SQL> 
10:28:33 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:33 SQL> 
10:28:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:28:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:33 SQL> 
10:28:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:33 SQL> 
10:28:33 SQL> --------------------------------
10:28:33 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:33 SQL> --
10:28:33 SQL> 
10:28:33 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:33 SQL> -- 2. Outlier Treatment and
10:28:33 SQL> -- 3. Normalization are performed below.
10:28:33 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:33 SQL> --    normalized here.
10:28:33 SQL> 
10:28:33 SQL> BEGIN
10:28:33   2  	-- Perform missing value treatment for all predictors
10:28:33   3  	-- create miss tables
10:28:33   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:33   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:33   6  
10:28:33   7  	-- populate miss tables
10:28:33   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:33   9  	  miss_table_name => 'svmc_miss_num',
10:28:33  10  	  data_table_name => '&bldtable',
10:28:33  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:33  12  
10:28:33  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:33  14  	  miss_table_name => 'svmc_miss_cat',
10:28:33  15  	  data_table_name => '&bldtable',
10:28:33  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:33  17  
10:28:33  18  	-- xform input data to replace missing values
10:28:33  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:33  20  	  miss_table_name => 'svmc_miss_num',
10:28:33  21  	  data_table_name => '&bldtable',
10:28:33  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:33  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:33  24  	  miss_table_name => 'svmc_miss_cat',
10:28:33  25  	  data_table_name => '&bldtable',
10:28:33  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:33  27  
10:28:33  28  	-- Perform outlier treatment.
10:28:33  29  	-- create clip table
10:28:33  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:33  31  
10:28:33  32  	-- populate clip table
10:28:33  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:33  34  	  clip_table_name => 'svmc_clip',
10:28:33  35  	  data_table_name => '&bldtable',
10:28:33  36  	  tail_frac	  => 0.025,
10:28:33  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:33  38  
10:28:33  39  	-- xform input data to winsorized data
10:28:33  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:33  41  	  clip_table_name => 'svmc_clip',
10:28:33  42  	  data_table_name => '&bldtable',
10:28:33  43  	  xform_view_name => 'svmc_winsor');
10:28:33  44  
10:28:33  45  	-- create normalization table
10:28:33  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:33  47  
10:28:33  48  	-- populate normalization table based on winsorized data
10:28:33  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:33  50  	  norm_table_name => 'svmc_norm',
10:28:33  51  	  data_table_name => 'svmc_winsor',
10:28:33  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:33  53  
10:28:33  54  	-- normalize the original data
10:28:33  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:33  56  	  norm_table_name => 'svmc_norm',
10:28:33  57  	  data_table_name => '&bldtable',
10:28:33  58  	  xform_view_name => 'svmc_build_prep');
10:28:33  59  END;
10:28:33  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:28:34 SQL> 
10:28:34 SQL> ---------------------
10:28:34 SQL> -- CREATE A NEW MODEL
10:28:34 SQL> --
10:28:34 SQL> -- Cleanup old model with the same name for repeat runs
10:28:34 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:34   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.08
10:28:35 SQL> 
10:28:35 SQL> -- Build a new SVM Model
10:28:35 SQL> BEGIN
10:28:35   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:35   3  	  model_name	      => '&model_name',
10:28:35   4  	  mining_function     => dbms_data_mining.classification,
10:28:35   5  	  data_table_name     => 'svmc_build_prep',
10:28:35   6  	  case_id_column_name => '&case_id',
10:28:35   7  	  target_column_name  => '&target',
10:28:35   8  	  settings_table_name => 'svmc_settings');
10:28:35   9  END;
10:28:35  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.62
10:28:37 SQL> 
10:28:37 SQL> -----------------------------------------------------------------------
10:28:37 SQL> --			       APPLY/score THE MODEL
10:28:37 SQL> -----------------------------------------------------------------------
10:28:37 SQL> 
10:28:37 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:28:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:37 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:37   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:37   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:37 SQL> -----------------------
10:28:37 SQL> -- PREPARE SCORING DATA
10:28:37 SQL> --
10:28:37 SQL> -- If the data for model creation has been prepared, then the data
10:28:37 SQL> -- to be scored using the model must be prepared in the same manner
10:28:37 SQL> -- in order to obtain meaningful results.
10:28:37 SQL> --
10:28:37 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:37 SQL> -- 2. Normalization
10:28:37 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:37 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:37 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:37 SQL> --
10:28:37 SQL> BEGIN
10:28:37   2  	-- Xform Test data to replace missing values
10:28:37   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:37   4  	  miss_table_name => 'svmc_miss_num',
10:28:37   5  	  data_table_name => '&scoretable',
10:28:37   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:37   7  
10:28:37   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:37   9  	  miss_table_name => 'svmc_miss_cat',
10:28:37  10  	  data_table_name => '&scoretable',
10:28:37  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:37  12  
10:28:37  13  	-- Normalize the data to be scored
10:28:37  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:37  15  	  norm_table_name => 'svmc_norm',
10:28:37  16  	  data_table_name => '&scoretable',
10:28:37  17  	  xform_view_name => 'svmc_apply_prep');
10:28:37  18  END;
10:28:37  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:28:38 SQL> 
10:28:38 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:38 SQL> -- DELETE it if I did:
10:28:38 SQL> DELETE ystkscores
10:28:38   2  WHERE score > 0
10:28:38   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:38   4  -- I need to supply the target attribute name:
10:28:38   5  AND targ = '&1'
10:28:38   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:28:38 SQL> 
10:28:38 SQL> -- We do a drumroll here:
10:28:38 SQL> 
10:28:38 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:38   2  SELECT
10:28:38   3  tkrdate
10:28:38   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:38   5  ,sysdate
10:28:38   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:38   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:38   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:38   9  ,SUBSTR(tkrdate,-10)ydate
10:28:38  10  ,'&1'
10:28:38  11  FROM svmc_apply_prep
10:28:38  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:28:38 SQL> @score1_5min_gattn.sql	2010-01-04 TLT
10:28:38 SQL> --
10:28:38 SQL> -- score1_5min_gattn.sql
10:28:38 SQL> --
10:28:38 SQL> 
10:28:38 SQL> -- Demo:
10:28:38 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:38 SQL> 
10:28:38 SQL> CREATE OR REPLACE VIEW sme AS
10:28:38   2  SELECT
10:28:38   3  tkrdate
10:28:38   4  ,NULL gattn
10:28:38   5  ,g00
10:28:38   6  ,g01
10:28:38   7  ,g02
10:28:38   8  ,g03
10:28:38   9  ,g04
10:28:38  10  ,g05
10:28:38  11  ,g06
10:28:38  12  ,g07
10:28:38  13  ,g08
10:28:38  14  ,g09
10:28:38  15  ,g10
10:28:38  16  ,g11
10:28:38  17  ,g12
10:28:38  18  ,g13
10:28:38  19  ,g14
10:28:38  20  ,g15
10:28:38  21  ,g16
10:28:38  22  ,g17
10:28:38  23  ,g18
10:28:38  24  ,g19
10:28:38  25  ,g20
10:28:38  26  ,g21
10:28:38  27  ,g22
10:28:38  28  ,g23
10:28:38  29  ,g24
10:28:38  30  ,g25
10:28:38  31  ,g26
10:28:38  32  ,g27
10:28:38  33  ,g28
10:28:38  34  ,g29
10:28:38  35  FROM stk_ms
10:28:38  36  WHERE ydate = '&1'
10:28:38  37  AND tkr = '&2'
10:28:38  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-01-04'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:38 SQL> 
10:28:38 SQL> -- rpt
10:28:38 SQL> -- We should see just 1 row:
10:28:38 SQL> 
10:28:38 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:38   2  
10:28:38 SQL> -- Build the model:
10:28:38 SQL> CREATE OR REPLACE VIEW bme AS
10:28:38   2  SELECT
10:28:38   3  tkrdate
10:28:38   4  ,gattn
10:28:38   5  ,g00
10:28:38   6  ,g01
10:28:38   7  ,g02
10:28:38   8  ,g03
10:28:38   9  ,g04
10:28:38  10  ,g05
10:28:38  11  ,g06
10:28:38  12  ,g07
10:28:38  13  ,g08
10:28:38  14  ,g09
10:28:38  15  ,g10
10:28:38  16  ,g11
10:28:38  17  ,g12
10:28:38  18  ,g13
10:28:38  19  ,g14
10:28:38  20  ,g15
10:28:38  21  ,g16
10:28:38  22  ,g17
10:28:38  23  ,g18
10:28:38  24  ,g19
10:28:38  25  ,g20
10:28:38  26  ,g21
10:28:38  27  ,g22
10:28:38  28  ,g23
10:28:38  29  ,g24
10:28:38  30  ,g25
10:28:38  31  ,g26
10:28:38  32  ,g27
10:28:38  33  ,g28
10:28:38  34  ,g29
10:28:38  35  FROM stk_ms
10:28:38  36  WHERE gattn IN('nup','up')
10:28:38  37  -- Use only rows which are older than 1 day:
10:28:38  38  AND 1+ydate < '&1'
10:28:38  39  AND tkr = '&2'
10:28:38  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-01-04'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:38 SQL> 
10:28:38 SQL> -- rpt
10:28:38 SQL> 
10:28:38 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:38   2  
10:28:38 SQL> SELECT MAX(tkrdate) FROM bme
10:28:38   2  
10:28:38 SQL> -- Now build model from bme and score sme
10:28:38 SQL> @score1.sql gattn
10:28:38 SQL> -- score1.sql
10:28:38 SQL> 
10:28:38 SQL> -- I use this script to send 5 params to score.sql
10:28:38 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:38 SQL> -- Then at the very end of this script I use the model
10:28:38 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:38 SQL> 
10:28:38 SQL> -- I call this script from 2 other scripts:
10:28:38 SQL> -- score1_5min.sql
10:28:38 SQL> -- score1_5min_gattn.sql
10:28:38 SQL> 
10:28:38 SQL> -- The 1st param is the name of the target attribute.
10:28:38 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:38 SQL> 
10:28:38 SQL> -- Demo:
10:28:38 SQL> -- @score1.sql 'gatt'
10:28:38 SQL> -- @score1.sql 'gattn'
10:28:38 SQL> 
10:28:38 SQL> -- Now, I fill up svmc_apply_prep.
10:28:38 SQL> -- I use same model_name used in score.sql
10:28:38 SQL> DEFINE model_name = 'svmspy101'
10:28:38 SQL> DEFINE bldtable	= 'bme'
10:28:38 SQL> DEFINE scoretable = 'sme'
10:28:38 SQL> DEFINE case_id	= 'tkrdate'
10:28:38 SQL> -- Demo:
10:28:38 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:38 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:38 SQL> --
10:28:38 SQL> -- score.sql
10:28:38 SQL> --
10:28:38 SQL> 
10:28:38 SQL> -- usage: score.sql
10:28:38 SQL> 
10:28:38 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:38 SQL> 
10:28:38 SQL> -- DEFINE target	   = 'gatt'
10:28:38 SQL> -- DEFINE model_name = 'svmspy100'
10:28:38 SQL> -- DEFINE bldtable   = 'bme'
10:28:38 SQL> -- DEFINE scoretable = 'sme'
10:28:38 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:38 SQL> 
10:28:38 SQL> DEFINE target	= '&1'
10:28:38 SQL> DEFINE model_name = '&2'
10:28:38 SQL> DEFINE bldtable	= '&3'
10:28:38 SQL> DEFINE scoretable = '&4'
10:28:38 SQL> DEFINE case_id	= '&5'
10:28:38 SQL> 
10:28:38 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:38 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:38 SQL> 
10:28:38 SQL> -- Builds an SVM model using pl/sql.
10:28:38 SQL> 
10:28:38 SQL> -----------------------------------------------------------------------
10:28:38 SQL> --			    BUILD THE MODEL
10:28:38 SQL> -----------------------------------------------------------------------
10:28:38 SQL> 
10:28:38 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:38 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:38 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:38 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:38 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:38 SQL> 
10:28:38 SQL> 
10:28:38 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:38 SQL> --
10:28:38 SQL> -- DROP	TABLE svmc_settings ;
10:28:38 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:38 SQL> -- DELETE svmc_settings;
10:28:38 SQL> 
10:28:38 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:38 SQL> -- this choice to SVM using a settings table.
10:28:38 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:38 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:38 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:38 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:38 SQL> -- models.
10:28:38 SQL> --
10:28:38 SQL> 
10:28:38 SQL> -- Do this once and then comment it out.
10:28:38 SQL> -- That makes script go faster.
10:28:38 SQL> -- BEGIN
10:28:38 SQL> -- -- Populate settings table
10:28:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:38 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:38 SQL> --
10:28:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:38 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:38 SQL> --
10:28:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:38 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:38 SQL> --   COMMIT;
10:28:38 SQL> -- END;
10:28:38 SQL> -- /
10:28:38 SQL> 
10:28:38 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:38 SQL> 
10:28:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
10:28:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:38 SQL> 
10:28:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:38 SQL> 
10:28:38 SQL> --------------------------------
10:28:38 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:38 SQL> --
10:28:38 SQL> 
10:28:38 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:38 SQL> -- 2. Outlier Treatment and
10:28:38 SQL> -- 3. Normalization are performed below.
10:28:38 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:38 SQL> --    normalized here.
10:28:38 SQL> 
10:28:38 SQL> BEGIN
10:28:38   2  	-- Perform missing value treatment for all predictors
10:28:38   3  	-- create miss tables
10:28:38   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:38   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:38   6  
10:28:38   7  	-- populate miss tables
10:28:38   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:38   9  	  miss_table_name => 'svmc_miss_num',
10:28:38  10  	  data_table_name => '&bldtable',
10:28:38  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:38  12  
10:28:38  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:38  14  	  miss_table_name => 'svmc_miss_cat',
10:28:38  15  	  data_table_name => '&bldtable',
10:28:38  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:38  17  
10:28:38  18  	-- xform input data to replace missing values
10:28:38  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:38  20  	  miss_table_name => 'svmc_miss_num',
10:28:38  21  	  data_table_name => '&bldtable',
10:28:38  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:38  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:38  24  	  miss_table_name => 'svmc_miss_cat',
10:28:38  25  	  data_table_name => '&bldtable',
10:28:38  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:38  27  
10:28:38  28  	-- Perform outlier treatment.
10:28:38  29  	-- create clip table
10:28:38  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:38  31  
10:28:38  32  	-- populate clip table
10:28:38  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:38  34  	  clip_table_name => 'svmc_clip',
10:28:38  35  	  data_table_name => '&bldtable',
10:28:38  36  	  tail_frac	  => 0.025,
10:28:38  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:38  38  
10:28:38  39  	-- xform input data to winsorized data
10:28:38  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:38  41  	  clip_table_name => 'svmc_clip',
10:28:38  42  	  data_table_name => '&bldtable',
10:28:38  43  	  xform_view_name => 'svmc_winsor');
10:28:38  44  
10:28:38  45  	-- create normalization table
10:28:38  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:38  47  
10:28:38  48  	-- populate normalization table based on winsorized data
10:28:38  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:38  50  	  norm_table_name => 'svmc_norm',
10:28:38  51  	  data_table_name => 'svmc_winsor',
10:28:38  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:38  53  
10:28:38  54  	-- normalize the original data
10:28:38  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:38  56  	  norm_table_name => 'svmc_norm',
10:28:38  57  	  data_table_name => '&bldtable',
10:28:38  58  	  xform_view_name => 'svmc_build_prep');
10:28:38  59  END;
10:28:38  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:28:39 SQL> 
10:28:39 SQL> ---------------------
10:28:39 SQL> -- CREATE A NEW MODEL
10:28:39 SQL> --
10:28:39 SQL> -- Cleanup old model with the same name for repeat runs
10:28:39 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:39   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.05
10:28:40 SQL> 
10:28:40 SQL> -- Build a new SVM Model
10:28:40 SQL> BEGIN
10:28:40   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:40   3  	  model_name	      => '&model_name',
10:28:40   4  	  mining_function     => dbms_data_mining.classification,
10:28:40   5  	  data_table_name     => 'svmc_build_prep',
10:28:40   6  	  case_id_column_name => '&case_id',
10:28:40   7  	  target_column_name  => '&target',
10:28:40   8  	  settings_table_name => 'svmc_settings');
10:28:40   9  END;
10:28:40  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.12
10:28:42 SQL> 
10:28:42 SQL> -----------------------------------------------------------------------
10:28:42 SQL> --			       APPLY/score THE MODEL
10:28:42 SQL> -----------------------------------------------------------------------
10:28:42 SQL> 
10:28:42 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:42 SQL> -----------------------
10:28:42 SQL> -- PREPARE SCORING DATA
10:28:42 SQL> --
10:28:42 SQL> -- If the data for model creation has been prepared, then the data
10:28:42 SQL> -- to be scored using the model must be prepared in the same manner
10:28:42 SQL> -- in order to obtain meaningful results.
10:28:42 SQL> --
10:28:42 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:42 SQL> -- 2. Normalization
10:28:42 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:42 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:42 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:42 SQL> --
10:28:42 SQL> BEGIN
10:28:42   2  	-- Xform Test data to replace missing values
10:28:42   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:42   4  	  miss_table_name => 'svmc_miss_num',
10:28:42   5  	  data_table_name => '&scoretable',
10:28:42   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:42   7  
10:28:42   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:42   9  	  miss_table_name => 'svmc_miss_cat',
10:28:42  10  	  data_table_name => '&scoretable',
10:28:42  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:42  12  
10:28:42  13  	-- Normalize the data to be scored
10:28:42  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:42  15  	  norm_table_name => 'svmc_norm',
10:28:42  16  	  data_table_name => '&scoretable',
10:28:42  17  	  xform_view_name => 'svmc_apply_prep');
10:28:42  18  END;
10:28:42  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:28:42 SQL> 
10:28:42 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:42 SQL> -- DELETE it if I did:
10:28:42 SQL> DELETE ystkscores
10:28:42   2  WHERE score > 0
10:28:42   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:42   4  -- I need to supply the target attribute name:
10:28:42   5  AND targ = '&1'
10:28:42   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:28:42 SQL> 
10:28:42 SQL> -- We do a drumroll here:
10:28:42 SQL> 
10:28:42 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:42   2  SELECT
10:28:42   3  tkrdate
10:28:42   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:42   5  ,sysdate
10:28:42   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:42   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:42   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:42   9  ,SUBSTR(tkrdate,-10)ydate
10:28:42  10  ,'&1'
10:28:42  11  FROM svmc_apply_prep
10:28:42  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:28:42 SQL> @score1_5min_gattn.sql	2010-04-15 TLT
10:28:42 SQL> --
10:28:42 SQL> -- score1_5min_gattn.sql
10:28:42 SQL> --
10:28:42 SQL> 
10:28:42 SQL> -- Demo:
10:28:42 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:42 SQL> 
10:28:42 SQL> CREATE OR REPLACE VIEW sme AS
10:28:42   2  SELECT
10:28:42   3  tkrdate
10:28:42   4  ,NULL gattn
10:28:42   5  ,g00
10:28:42   6  ,g01
10:28:42   7  ,g02
10:28:42   8  ,g03
10:28:42   9  ,g04
10:28:42  10  ,g05
10:28:42  11  ,g06
10:28:42  12  ,g07
10:28:42  13  ,g08
10:28:42  14  ,g09
10:28:42  15  ,g10
10:28:42  16  ,g11
10:28:42  17  ,g12
10:28:42  18  ,g13
10:28:42  19  ,g14
10:28:42  20  ,g15
10:28:42  21  ,g16
10:28:42  22  ,g17
10:28:42  23  ,g18
10:28:42  24  ,g19
10:28:42  25  ,g20
10:28:42  26  ,g21
10:28:42  27  ,g22
10:28:42  28  ,g23
10:28:42  29  ,g24
10:28:42  30  ,g25
10:28:42  31  ,g26
10:28:42  32  ,g27
10:28:42  33  ,g28
10:28:42  34  ,g29
10:28:42  35  FROM stk_ms
10:28:42  36  WHERE ydate = '&1'
10:28:42  37  AND tkr = '&2'
10:28:42  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-15'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:42 SQL> 
10:28:42 SQL> -- rpt
10:28:42 SQL> -- We should see just 1 row:
10:28:42 SQL> 
10:28:42 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:42   2  
10:28:42 SQL> -- Build the model:
10:28:42 SQL> CREATE OR REPLACE VIEW bme AS
10:28:42   2  SELECT
10:28:42   3  tkrdate
10:28:42   4  ,gattn
10:28:42   5  ,g00
10:28:42   6  ,g01
10:28:42   7  ,g02
10:28:42   8  ,g03
10:28:42   9  ,g04
10:28:42  10  ,g05
10:28:42  11  ,g06
10:28:42  12  ,g07
10:28:42  13  ,g08
10:28:42  14  ,g09
10:28:42  15  ,g10
10:28:42  16  ,g11
10:28:42  17  ,g12
10:28:42  18  ,g13
10:28:42  19  ,g14
10:28:42  20  ,g15
10:28:42  21  ,g16
10:28:42  22  ,g17
10:28:42  23  ,g18
10:28:42  24  ,g19
10:28:42  25  ,g20
10:28:42  26  ,g21
10:28:42  27  ,g22
10:28:42  28  ,g23
10:28:42  29  ,g24
10:28:42  30  ,g25
10:28:42  31  ,g26
10:28:42  32  ,g27
10:28:42  33  ,g28
10:28:42  34  ,g29
10:28:42  35  FROM stk_ms
10:28:42  36  WHERE gattn IN('nup','up')
10:28:42  37  -- Use only rows which are older than 1 day:
10:28:42  38  AND 1+ydate < '&1'
10:28:42  39  AND tkr = '&2'
10:28:42  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-15'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:28:42 SQL> 
10:28:42 SQL> -- rpt
10:28:42 SQL> 
10:28:42 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:42   2  
10:28:42 SQL> SELECT MAX(tkrdate) FROM bme
10:28:42   2  
10:28:42 SQL> -- Now build model from bme and score sme
10:28:42 SQL> @score1.sql gattn
10:28:42 SQL> -- score1.sql
10:28:42 SQL> 
10:28:42 SQL> -- I use this script to send 5 params to score.sql
10:28:42 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:42 SQL> -- Then at the very end of this script I use the model
10:28:42 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:42 SQL> 
10:28:42 SQL> -- I call this script from 2 other scripts:
10:28:42 SQL> -- score1_5min.sql
10:28:42 SQL> -- score1_5min_gattn.sql
10:28:42 SQL> 
10:28:42 SQL> -- The 1st param is the name of the target attribute.
10:28:42 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:42 SQL> 
10:28:42 SQL> -- Demo:
10:28:42 SQL> -- @score1.sql 'gatt'
10:28:42 SQL> -- @score1.sql 'gattn'
10:28:42 SQL> 
10:28:42 SQL> -- Now, I fill up svmc_apply_prep.
10:28:42 SQL> -- I use same model_name used in score.sql
10:28:42 SQL> DEFINE model_name = 'svmspy101'
10:28:42 SQL> DEFINE bldtable	= 'bme'
10:28:42 SQL> DEFINE scoretable = 'sme'
10:28:42 SQL> DEFINE case_id	= 'tkrdate'
10:28:42 SQL> -- Demo:
10:28:42 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:42 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:42 SQL> --
10:28:42 SQL> -- score.sql
10:28:42 SQL> --
10:28:42 SQL> 
10:28:42 SQL> -- usage: score.sql
10:28:42 SQL> 
10:28:42 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:42 SQL> 
10:28:42 SQL> -- DEFINE target	   = 'gatt'
10:28:42 SQL> -- DEFINE model_name = 'svmspy100'
10:28:42 SQL> -- DEFINE bldtable   = 'bme'
10:28:42 SQL> -- DEFINE scoretable = 'sme'
10:28:42 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:42 SQL> 
10:28:42 SQL> DEFINE target	= '&1'
10:28:42 SQL> DEFINE model_name = '&2'
10:28:42 SQL> DEFINE bldtable	= '&3'
10:28:42 SQL> DEFINE scoretable = '&4'
10:28:42 SQL> DEFINE case_id	= '&5'
10:28:42 SQL> 
10:28:42 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:42 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:42 SQL> 
10:28:42 SQL> -- Builds an SVM model using pl/sql.
10:28:42 SQL> 
10:28:42 SQL> -----------------------------------------------------------------------
10:28:42 SQL> --			    BUILD THE MODEL
10:28:42 SQL> -----------------------------------------------------------------------
10:28:42 SQL> 
10:28:42 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:42 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:42 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:42 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:42 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:42 SQL> 
10:28:42 SQL> 
10:28:42 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:42 SQL> --
10:28:42 SQL> -- DROP	TABLE svmc_settings ;
10:28:42 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:42 SQL> -- DELETE svmc_settings;
10:28:42 SQL> 
10:28:42 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:42 SQL> -- this choice to SVM using a settings table.
10:28:42 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:42 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:42 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:42 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:42 SQL> -- models.
10:28:42 SQL> --
10:28:42 SQL> 
10:28:42 SQL> -- Do this once and then comment it out.
10:28:42 SQL> -- That makes script go faster.
10:28:42 SQL> -- BEGIN
10:28:42 SQL> -- -- Populate settings table
10:28:42 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:42 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:42 SQL> --
10:28:42 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:42 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:42 SQL> --
10:28:42 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:42 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:42 SQL> --   COMMIT;
10:28:42 SQL> -- END;
10:28:42 SQL> -- /
10:28:42 SQL> 
10:28:42 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:42 SQL> 
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:42 SQL> 
10:28:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:42 SQL> 
10:28:42 SQL> --------------------------------
10:28:42 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:42 SQL> --
10:28:42 SQL> 
10:28:42 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:42 SQL> -- 2. Outlier Treatment and
10:28:42 SQL> -- 3. Normalization are performed below.
10:28:42 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:42 SQL> --    normalized here.
10:28:42 SQL> 
10:28:42 SQL> BEGIN
10:28:42   2  	-- Perform missing value treatment for all predictors
10:28:42   3  	-- create miss tables
10:28:42   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:42   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:42   6  
10:28:42   7  	-- populate miss tables
10:28:42   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:42   9  	  miss_table_name => 'svmc_miss_num',
10:28:42  10  	  data_table_name => '&bldtable',
10:28:42  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:42  12  
10:28:42  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:42  14  	  miss_table_name => 'svmc_miss_cat',
10:28:42  15  	  data_table_name => '&bldtable',
10:28:42  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:42  17  
10:28:42  18  	-- xform input data to replace missing values
10:28:42  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:42  20  	  miss_table_name => 'svmc_miss_num',
10:28:42  21  	  data_table_name => '&bldtable',
10:28:42  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:42  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:42  24  	  miss_table_name => 'svmc_miss_cat',
10:28:42  25  	  data_table_name => '&bldtable',
10:28:42  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:42  27  
10:28:42  28  	-- Perform outlier treatment.
10:28:42  29  	-- create clip table
10:28:42  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:42  31  
10:28:42  32  	-- populate clip table
10:28:42  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:42  34  	  clip_table_name => 'svmc_clip',
10:28:42  35  	  data_table_name => '&bldtable',
10:28:42  36  	  tail_frac	  => 0.025,
10:28:42  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:42  38  
10:28:42  39  	-- xform input data to winsorized data
10:28:42  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:42  41  	  clip_table_name => 'svmc_clip',
10:28:42  42  	  data_table_name => '&bldtable',
10:28:42  43  	  xform_view_name => 'svmc_winsor');
10:28:42  44  
10:28:42  45  	-- create normalization table
10:28:42  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:42  47  
10:28:42  48  	-- populate normalization table based on winsorized data
10:28:42  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:42  50  	  norm_table_name => 'svmc_norm',
10:28:42  51  	  data_table_name => 'svmc_winsor',
10:28:42  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:42  53  
10:28:42  54  	-- normalize the original data
10:28:42  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:42  56  	  norm_table_name => 'svmc_norm',
10:28:42  57  	  data_table_name => '&bldtable',
10:28:42  58  	  xform_view_name => 'svmc_build_prep');
10:28:42  59  END;
10:28:42  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:28:43 SQL> 
10:28:43 SQL> ---------------------
10:28:43 SQL> -- CREATE A NEW MODEL
10:28:43 SQL> --
10:28:43 SQL> -- Cleanup old model with the same name for repeat runs
10:28:43 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:43   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:43   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.67
10:28:45 SQL> 
10:28:45 SQL> -- Build a new SVM Model
10:28:45 SQL> BEGIN
10:28:45   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:45   3  	  model_name	      => '&model_name',
10:28:45   4  	  mining_function     => dbms_data_mining.classification,
10:28:45   5  	  data_table_name     => 'svmc_build_prep',
10:28:45   6  	  case_id_column_name => '&case_id',
10:28:45   7  	  target_column_name  => '&target',
10:28:45   8  	  settings_table_name => 'svmc_settings');
10:28:45   9  END;
10:28:45  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.96
10:28:46 SQL> 
10:28:46 SQL> -----------------------------------------------------------------------
10:28:46 SQL> --			       APPLY/score THE MODEL
10:28:46 SQL> -----------------------------------------------------------------------
10:28:46 SQL> 
10:28:46 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:46 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:46   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:46   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
10:28:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:47 SQL> -----------------------
10:28:47 SQL> -- PREPARE SCORING DATA
10:28:47 SQL> --
10:28:47 SQL> -- If the data for model creation has been prepared, then the data
10:28:47 SQL> -- to be scored using the model must be prepared in the same manner
10:28:47 SQL> -- in order to obtain meaningful results.
10:28:47 SQL> --
10:28:47 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:47 SQL> -- 2. Normalization
10:28:47 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:47 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:47 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:47 SQL> --
10:28:47 SQL> BEGIN
10:28:47   2  	-- Xform Test data to replace missing values
10:28:47   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:47   4  	  miss_table_name => 'svmc_miss_num',
10:28:47   5  	  data_table_name => '&scoretable',
10:28:47   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:47   7  
10:28:47   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:47   9  	  miss_table_name => 'svmc_miss_cat',
10:28:47  10  	  data_table_name => '&scoretable',
10:28:47  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:47  12  
10:28:47  13  	-- Normalize the data to be scored
10:28:47  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:47  15  	  norm_table_name => 'svmc_norm',
10:28:47  16  	  data_table_name => '&scoretable',
10:28:47  17  	  xform_view_name => 'svmc_apply_prep');
10:28:47  18  END;
10:28:47  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:28:47 SQL> 
10:28:47 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:47 SQL> -- DELETE it if I did:
10:28:47 SQL> DELETE ystkscores
10:28:47   2  WHERE score > 0
10:28:47   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:47   4  -- I need to supply the target attribute name:
10:28:47   5  AND targ = '&1'
10:28:47   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:47 SQL> 
10:28:47 SQL> -- We do a drumroll here:
10:28:47 SQL> 
10:28:47 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:47   2  SELECT
10:28:47   3  tkrdate
10:28:47   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:47   5  ,sysdate
10:28:47   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:47   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:47   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:47   9  ,SUBSTR(tkrdate,-10)ydate
10:28:47  10  ,'&1'
10:28:47  11  FROM svmc_apply_prep
10:28:47  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:28:47 SQL> @score1_5min_gattn.sql	2010-08-23 TLT
10:28:47 SQL> --
10:28:47 SQL> -- score1_5min_gattn.sql
10:28:47 SQL> --
10:28:47 SQL> 
10:28:47 SQL> -- Demo:
10:28:47 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:47 SQL> 
10:28:47 SQL> CREATE OR REPLACE VIEW sme AS
10:28:47   2  SELECT
10:28:47   3  tkrdate
10:28:47   4  ,NULL gattn
10:28:47   5  ,g00
10:28:47   6  ,g01
10:28:47   7  ,g02
10:28:47   8  ,g03
10:28:47   9  ,g04
10:28:47  10  ,g05
10:28:47  11  ,g06
10:28:47  12  ,g07
10:28:47  13  ,g08
10:28:47  14  ,g09
10:28:47  15  ,g10
10:28:47  16  ,g11
10:28:47  17  ,g12
10:28:47  18  ,g13
10:28:47  19  ,g14
10:28:47  20  ,g15
10:28:47  21  ,g16
10:28:47  22  ,g17
10:28:47  23  ,g18
10:28:47  24  ,g19
10:28:47  25  ,g20
10:28:47  26  ,g21
10:28:47  27  ,g22
10:28:47  28  ,g23
10:28:47  29  ,g24
10:28:47  30  ,g25
10:28:47  31  ,g26
10:28:47  32  ,g27
10:28:47  33  ,g28
10:28:47  34  ,g29
10:28:47  35  FROM stk_ms
10:28:47  36  WHERE ydate = '&1'
10:28:47  37  AND tkr = '&2'
10:28:47  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-23'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:28:47 SQL> 
10:28:47 SQL> -- rpt
10:28:47 SQL> -- We should see just 1 row:
10:28:47 SQL> 
10:28:47 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:47   2  
10:28:47 SQL> -- Build the model:
10:28:47 SQL> CREATE OR REPLACE VIEW bme AS
10:28:47   2  SELECT
10:28:47   3  tkrdate
10:28:47   4  ,gattn
10:28:47   5  ,g00
10:28:47   6  ,g01
10:28:47   7  ,g02
10:28:47   8  ,g03
10:28:47   9  ,g04
10:28:47  10  ,g05
10:28:47  11  ,g06
10:28:47  12  ,g07
10:28:47  13  ,g08
10:28:47  14  ,g09
10:28:47  15  ,g10
10:28:47  16  ,g11
10:28:47  17  ,g12
10:28:47  18  ,g13
10:28:47  19  ,g14
10:28:47  20  ,g15
10:28:47  21  ,g16
10:28:47  22  ,g17
10:28:47  23  ,g18
10:28:47  24  ,g19
10:28:47  25  ,g20
10:28:47  26  ,g21
10:28:47  27  ,g22
10:28:47  28  ,g23
10:28:47  29  ,g24
10:28:47  30  ,g25
10:28:47  31  ,g26
10:28:47  32  ,g27
10:28:47  33  ,g28
10:28:47  34  ,g29
10:28:47  35  FROM stk_ms
10:28:47  36  WHERE gattn IN('nup','up')
10:28:47  37  -- Use only rows which are older than 1 day:
10:28:47  38  AND 1+ydate < '&1'
10:28:47  39  AND tkr = '&2'
10:28:47  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-23'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:28:47 SQL> 
10:28:47 SQL> -- rpt
10:28:47 SQL> 
10:28:47 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:47   2  
10:28:47 SQL> SELECT MAX(tkrdate) FROM bme
10:28:47   2  
10:28:47 SQL> -- Now build model from bme and score sme
10:28:47 SQL> @score1.sql gattn
10:28:47 SQL> -- score1.sql
10:28:47 SQL> 
10:28:47 SQL> -- I use this script to send 5 params to score.sql
10:28:47 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:47 SQL> -- Then at the very end of this script I use the model
10:28:47 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:47 SQL> 
10:28:47 SQL> -- I call this script from 2 other scripts:
10:28:47 SQL> -- score1_5min.sql
10:28:47 SQL> -- score1_5min_gattn.sql
10:28:47 SQL> 
10:28:47 SQL> -- The 1st param is the name of the target attribute.
10:28:47 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:47 SQL> 
10:28:47 SQL> -- Demo:
10:28:47 SQL> -- @score1.sql 'gatt'
10:28:47 SQL> -- @score1.sql 'gattn'
10:28:47 SQL> 
10:28:47 SQL> -- Now, I fill up svmc_apply_prep.
10:28:47 SQL> -- I use same model_name used in score.sql
10:28:47 SQL> DEFINE model_name = 'svmspy101'
10:28:47 SQL> DEFINE bldtable	= 'bme'
10:28:47 SQL> DEFINE scoretable = 'sme'
10:28:47 SQL> DEFINE case_id	= 'tkrdate'
10:28:47 SQL> -- Demo:
10:28:47 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:47 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:47 SQL> --
10:28:47 SQL> -- score.sql
10:28:47 SQL> --
10:28:47 SQL> 
10:28:47 SQL> -- usage: score.sql
10:28:47 SQL> 
10:28:47 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:47 SQL> 
10:28:47 SQL> -- DEFINE target	   = 'gatt'
10:28:47 SQL> -- DEFINE model_name = 'svmspy100'
10:28:47 SQL> -- DEFINE bldtable   = 'bme'
10:28:47 SQL> -- DEFINE scoretable = 'sme'
10:28:47 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:47 SQL> 
10:28:47 SQL> DEFINE target	= '&1'
10:28:47 SQL> DEFINE model_name = '&2'
10:28:47 SQL> DEFINE bldtable	= '&3'
10:28:47 SQL> DEFINE scoretable = '&4'
10:28:47 SQL> DEFINE case_id	= '&5'
10:28:47 SQL> 
10:28:47 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:47 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:47 SQL> 
10:28:47 SQL> -- Builds an SVM model using pl/sql.
10:28:47 SQL> 
10:28:47 SQL> -----------------------------------------------------------------------
10:28:47 SQL> --			    BUILD THE MODEL
10:28:47 SQL> -----------------------------------------------------------------------
10:28:47 SQL> 
10:28:47 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:47 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:47 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:47 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:47 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:47 SQL> 
10:28:47 SQL> 
10:28:47 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:47 SQL> --
10:28:47 SQL> -- DROP	TABLE svmc_settings ;
10:28:47 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:47 SQL> -- DELETE svmc_settings;
10:28:47 SQL> 
10:28:47 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:47 SQL> -- this choice to SVM using a settings table.
10:28:47 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:47 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:47 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:47 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:47 SQL> -- models.
10:28:47 SQL> --
10:28:47 SQL> 
10:28:47 SQL> -- Do this once and then comment it out.
10:28:47 SQL> -- That makes script go faster.
10:28:47 SQL> -- BEGIN
10:28:47 SQL> -- -- Populate settings table
10:28:47 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:47 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:47 SQL> --
10:28:47 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:47 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:47 SQL> --
10:28:47 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:47 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:47 SQL> --   COMMIT;
10:28:47 SQL> -- END;
10:28:47 SQL> -- /
10:28:47 SQL> 
10:28:47 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:47 SQL> 
10:28:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:47 SQL> 
10:28:47 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:47   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:47   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:47 SQL> 
10:28:47 SQL> --------------------------------
10:28:47 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:47 SQL> --
10:28:47 SQL> 
10:28:47 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:47 SQL> -- 2. Outlier Treatment and
10:28:47 SQL> -- 3. Normalization are performed below.
10:28:47 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:47 SQL> --    normalized here.
10:28:47 SQL> 
10:28:47 SQL> BEGIN
10:28:47   2  	-- Perform missing value treatment for all predictors
10:28:47   3  	-- create miss tables
10:28:47   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:47   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:47   6  
10:28:47   7  	-- populate miss tables
10:28:47   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:47   9  	  miss_table_name => 'svmc_miss_num',
10:28:47  10  	  data_table_name => '&bldtable',
10:28:47  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:47  12  
10:28:47  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:47  14  	  miss_table_name => 'svmc_miss_cat',
10:28:47  15  	  data_table_name => '&bldtable',
10:28:47  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:47  17  
10:28:47  18  	-- xform input data to replace missing values
10:28:47  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:47  20  	  miss_table_name => 'svmc_miss_num',
10:28:47  21  	  data_table_name => '&bldtable',
10:28:47  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:47  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:47  24  	  miss_table_name => 'svmc_miss_cat',
10:28:47  25  	  data_table_name => '&bldtable',
10:28:47  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:47  27  
10:28:47  28  	-- Perform outlier treatment.
10:28:47  29  	-- create clip table
10:28:47  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:47  31  
10:28:47  32  	-- populate clip table
10:28:47  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:47  34  	  clip_table_name => 'svmc_clip',
10:28:47  35  	  data_table_name => '&bldtable',
10:28:47  36  	  tail_frac	  => 0.025,
10:28:47  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:47  38  
10:28:47  39  	-- xform input data to winsorized data
10:28:47  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:47  41  	  clip_table_name => 'svmc_clip',
10:28:47  42  	  data_table_name => '&bldtable',
10:28:47  43  	  xform_view_name => 'svmc_winsor');
10:28:47  44  
10:28:47  45  	-- create normalization table
10:28:47  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:47  47  
10:28:47  48  	-- populate normalization table based on winsorized data
10:28:47  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:47  50  	  norm_table_name => 'svmc_norm',
10:28:47  51  	  data_table_name => 'svmc_winsor',
10:28:47  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:47  53  
10:28:47  54  	-- normalize the original data
10:28:47  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:47  56  	  norm_table_name => 'svmc_norm',
10:28:47  57  	  data_table_name => '&bldtable',
10:28:47  58  	  xform_view_name => 'svmc_build_prep');
10:28:47  59  END;
10:28:47  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:28:48 SQL> 
10:28:48 SQL> ---------------------
10:28:48 SQL> -- CREATE A NEW MODEL
10:28:48 SQL> --
10:28:48 SQL> -- Cleanup old model with the same name for repeat runs
10:28:48 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:48   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.98
10:28:49 SQL> 
10:28:49 SQL> -- Build a new SVM Model
10:28:49 SQL> BEGIN
10:28:49   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:49   3  	  model_name	      => '&model_name',
10:28:49   4  	  mining_function     => dbms_data_mining.classification,
10:28:49   5  	  data_table_name     => 'svmc_build_prep',
10:28:49   6  	  case_id_column_name => '&case_id',
10:28:49   7  	  target_column_name  => '&target',
10:28:49   8  	  settings_table_name => 'svmc_settings');
10:28:49   9  END;
10:28:49  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.22
10:28:51 SQL> 
10:28:51 SQL> -----------------------------------------------------------------------
10:28:51 SQL> --			       APPLY/score THE MODEL
10:28:51 SQL> -----------------------------------------------------------------------
10:28:51 SQL> 
10:28:51 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:51 SQL> -----------------------
10:28:51 SQL> -- PREPARE SCORING DATA
10:28:51 SQL> --
10:28:51 SQL> -- If the data for model creation has been prepared, then the data
10:28:51 SQL> -- to be scored using the model must be prepared in the same manner
10:28:51 SQL> -- in order to obtain meaningful results.
10:28:51 SQL> --
10:28:51 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:51 SQL> -- 2. Normalization
10:28:51 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:51 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:51 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:51 SQL> --
10:28:51 SQL> BEGIN
10:28:51   2  	-- Xform Test data to replace missing values
10:28:51   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:51   4  	  miss_table_name => 'svmc_miss_num',
10:28:51   5  	  data_table_name => '&scoretable',
10:28:51   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:51   7  
10:28:51   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:51   9  	  miss_table_name => 'svmc_miss_cat',
10:28:51  10  	  data_table_name => '&scoretable',
10:28:51  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:51  12  
10:28:51  13  	-- Normalize the data to be scored
10:28:51  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:51  15  	  norm_table_name => 'svmc_norm',
10:28:51  16  	  data_table_name => '&scoretable',
10:28:51  17  	  xform_view_name => 'svmc_apply_prep');
10:28:51  18  END;
10:28:51  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:28:51 SQL> 
10:28:51 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:51 SQL> -- DELETE it if I did:
10:28:51 SQL> DELETE ystkscores
10:28:51   2  WHERE score > 0
10:28:51   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:51   4  -- I need to supply the target attribute name:
10:28:51   5  AND targ = '&1'
10:28:51   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:28:51 SQL> 
10:28:51 SQL> -- We do a drumroll here:
10:28:51 SQL> 
10:28:51 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:51   2  SELECT
10:28:51   3  tkrdate
10:28:51   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:51   5  ,sysdate
10:28:51   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:51   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:51   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:51   9  ,SUBSTR(tkrdate,-10)ydate
10:28:51  10  ,'&1'
10:28:51  11  FROM svmc_apply_prep
10:28:51  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:28:51 SQL> @score1_5min.sql	      2010-10-13 TLT
10:28:51 SQL> --
10:28:51 SQL> -- score1_5min.sql
10:28:51 SQL> --
10:28:51 SQL> 
10:28:51 SQL> -- Demo:
10:28:51 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:28:51 SQL> 
10:28:51 SQL> CREATE OR REPLACE VIEW sme AS
10:28:51   2  SELECT
10:28:51   3  tkrdate
10:28:51   4  ,NULL gatt
10:28:51   5  ,g00
10:28:51   6  ,g01
10:28:51   7  ,g02
10:28:51   8  ,g03
10:28:51   9  ,g04
10:28:51  10  ,g05
10:28:51  11  ,g06
10:28:51  12  ,g07
10:28:51  13  ,g08
10:28:51  14  ,g09
10:28:51  15  ,g10
10:28:51  16  ,g11
10:28:51  17  ,g12
10:28:51  18  ,g13
10:28:51  19  ,g14
10:28:51  20  ,g15
10:28:51  21  ,g16
10:28:51  22  ,g17
10:28:51  23  ,g18
10:28:51  24  ,g19
10:28:51  25  ,g20
10:28:51  26  ,g21
10:28:51  27  ,g22
10:28:51  28  ,g23
10:28:51  29  ,g24
10:28:51  30  ,g25
10:28:51  31  ,g26
10:28:51  32  ,g27
10:28:51  33  ,g28
10:28:51  34  ,g29
10:28:51  35  FROM stk_ms
10:28:51  36  WHERE ydate = '&1'
10:28:51  37  AND tkr = '&2'
10:28:51  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-10-13'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:51 SQL> 
10:28:51 SQL> -- rpt
10:28:51 SQL> -- We should see just 1 row:
10:28:51 SQL> 
10:28:51 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:51   2  
10:28:51 SQL> -- Build the model:
10:28:51 SQL> CREATE OR REPLACE VIEW bme AS
10:28:51   2  SELECT
10:28:51   3  tkrdate
10:28:51   4  ,gatt
10:28:51   5  ,g00
10:28:51   6  ,g01
10:28:51   7  ,g02
10:28:51   8  ,g03
10:28:51   9  ,g04
10:28:51  10  ,g05
10:28:51  11  ,g06
10:28:51  12  ,g07
10:28:51  13  ,g08
10:28:51  14  ,g09
10:28:51  15  ,g10
10:28:51  16  ,g11
10:28:51  17  ,g12
10:28:51  18  ,g13
10:28:51  19  ,g14
10:28:51  20  ,g15
10:28:51  21  ,g16
10:28:51  22  ,g17
10:28:51  23  ,g18
10:28:51  24  ,g19
10:28:51  25  ,g20
10:28:51  26  ,g21
10:28:51  27  ,g22
10:28:51  28  ,g23
10:28:51  29  ,g24
10:28:51  30  ,g25
10:28:51  31  ,g26
10:28:51  32  ,g27
10:28:51  33  ,g28
10:28:51  34  ,g29
10:28:51  35  FROM stk_ms
10:28:51  36  WHERE gatt IN('nup','up')
10:28:51  37  -- Use only rows which are older than 1 day:
10:28:51  38  AND 1+ydate < '&1'
10:28:51  39  AND tkr = '&2'
10:28:51  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-10-13'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:28:51 SQL> 
10:28:51 SQL> -- rpt
10:28:51 SQL> 
10:28:51 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:28:51   2  
10:28:51 SQL> SELECT MAX(tkrdate) FROM bme
10:28:51   2  
10:28:51 SQL> -- Now build model from bme and score sme
10:28:51 SQL> @score1.sql gatt
10:28:51 SQL> -- score1.sql
10:28:51 SQL> 
10:28:51 SQL> -- I use this script to send 5 params to score.sql
10:28:51 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:51 SQL> -- Then at the very end of this script I use the model
10:28:51 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:51 SQL> 
10:28:51 SQL> -- I call this script from 2 other scripts:
10:28:51 SQL> -- score1_5min.sql
10:28:51 SQL> -- score1_5min_gattn.sql
10:28:51 SQL> 
10:28:51 SQL> -- The 1st param is the name of the target attribute.
10:28:51 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:51 SQL> 
10:28:51 SQL> -- Demo:
10:28:51 SQL> -- @score1.sql 'gatt'
10:28:51 SQL> -- @score1.sql 'gattn'
10:28:51 SQL> 
10:28:51 SQL> -- Now, I fill up svmc_apply_prep.
10:28:51 SQL> -- I use same model_name used in score.sql
10:28:51 SQL> DEFINE model_name = 'svmspy101'
10:28:51 SQL> DEFINE bldtable	= 'bme'
10:28:51 SQL> DEFINE scoretable = 'sme'
10:28:51 SQL> DEFINE case_id	= 'tkrdate'
10:28:51 SQL> -- Demo:
10:28:51 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:51 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:51 SQL> --
10:28:51 SQL> -- score.sql
10:28:51 SQL> --
10:28:51 SQL> 
10:28:51 SQL> -- usage: score.sql
10:28:51 SQL> 
10:28:51 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:51 SQL> 
10:28:51 SQL> -- DEFINE target	   = 'gatt'
10:28:51 SQL> -- DEFINE model_name = 'svmspy100'
10:28:51 SQL> -- DEFINE bldtable   = 'bme'
10:28:51 SQL> -- DEFINE scoretable = 'sme'
10:28:51 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:51 SQL> 
10:28:51 SQL> DEFINE target	= '&1'
10:28:51 SQL> DEFINE model_name = '&2'
10:28:51 SQL> DEFINE bldtable	= '&3'
10:28:51 SQL> DEFINE scoretable = '&4'
10:28:51 SQL> DEFINE case_id	= '&5'
10:28:51 SQL> 
10:28:51 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:51 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:51 SQL> 
10:28:51 SQL> -- Builds an SVM model using pl/sql.
10:28:51 SQL> 
10:28:51 SQL> -----------------------------------------------------------------------
10:28:51 SQL> --			    BUILD THE MODEL
10:28:51 SQL> -----------------------------------------------------------------------
10:28:51 SQL> 
10:28:51 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:51 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:51 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:51 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:51 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:51 SQL> 
10:28:51 SQL> 
10:28:51 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:51 SQL> --
10:28:51 SQL> -- DROP	TABLE svmc_settings ;
10:28:51 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:51 SQL> -- DELETE svmc_settings;
10:28:51 SQL> 
10:28:51 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:51 SQL> -- this choice to SVM using a settings table.
10:28:51 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:51 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:51 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:51 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:51 SQL> -- models.
10:28:51 SQL> --
10:28:51 SQL> 
10:28:51 SQL> -- Do this once and then comment it out.
10:28:51 SQL> -- That makes script go faster.
10:28:51 SQL> -- BEGIN
10:28:51 SQL> -- -- Populate settings table
10:28:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:51 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:51 SQL> --
10:28:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:51 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:51 SQL> --
10:28:51 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:51 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:51 SQL> --   COMMIT;
10:28:51 SQL> -- END;
10:28:51 SQL> -- /
10:28:51 SQL> 
10:28:51 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:51 SQL> 
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:51 SQL> 
10:28:51 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:51   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:51   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:51 SQL> 
10:28:51 SQL> --------------------------------
10:28:51 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:51 SQL> --
10:28:51 SQL> 
10:28:51 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:51 SQL> -- 2. Outlier Treatment and
10:28:51 SQL> -- 3. Normalization are performed below.
10:28:51 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:51 SQL> --    normalized here.
10:28:51 SQL> 
10:28:51 SQL> BEGIN
10:28:51   2  	-- Perform missing value treatment for all predictors
10:28:51   3  	-- create miss tables
10:28:51   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:51   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:51   6  
10:28:51   7  	-- populate miss tables
10:28:51   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:51   9  	  miss_table_name => 'svmc_miss_num',
10:28:51  10  	  data_table_name => '&bldtable',
10:28:51  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:51  12  
10:28:51  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:51  14  	  miss_table_name => 'svmc_miss_cat',
10:28:51  15  	  data_table_name => '&bldtable',
10:28:51  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:51  17  
10:28:51  18  	-- xform input data to replace missing values
10:28:51  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:51  20  	  miss_table_name => 'svmc_miss_num',
10:28:51  21  	  data_table_name => '&bldtable',
10:28:51  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:51  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:51  24  	  miss_table_name => 'svmc_miss_cat',
10:28:51  25  	  data_table_name => '&bldtable',
10:28:51  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:51  27  
10:28:51  28  	-- Perform outlier treatment.
10:28:51  29  	-- create clip table
10:28:51  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:51  31  
10:28:51  32  	-- populate clip table
10:28:51  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:51  34  	  clip_table_name => 'svmc_clip',
10:28:51  35  	  data_table_name => '&bldtable',
10:28:51  36  	  tail_frac	  => 0.025,
10:28:51  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:51  38  
10:28:51  39  	-- xform input data to winsorized data
10:28:51  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:51  41  	  clip_table_name => 'svmc_clip',
10:28:51  42  	  data_table_name => '&bldtable',
10:28:51  43  	  xform_view_name => 'svmc_winsor');
10:28:51  44  
10:28:51  45  	-- create normalization table
10:28:51  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:51  47  
10:28:51  48  	-- populate normalization table based on winsorized data
10:28:51  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:51  50  	  norm_table_name => 'svmc_norm',
10:28:51  51  	  data_table_name => 'svmc_winsor',
10:28:51  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:51  53  
10:28:51  54  	-- normalize the original data
10:28:51  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:51  56  	  norm_table_name => 'svmc_norm',
10:28:51  57  	  data_table_name => '&bldtable',
10:28:51  58  	  xform_view_name => 'svmc_build_prep');
10:28:51  59  END;
10:28:51  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:28:52 SQL> 
10:28:52 SQL> ---------------------
10:28:52 SQL> -- CREATE A NEW MODEL
10:28:52 SQL> --
10:28:52 SQL> -- Cleanup old model with the same name for repeat runs
10:28:52 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:52   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:52   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.99
10:28:53 SQL> 
10:28:53 SQL> -- Build a new SVM Model
10:28:53 SQL> BEGIN
10:28:53   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:53   3  	  model_name	      => '&model_name',
10:28:53   4  	  mining_function     => dbms_data_mining.classification,
10:28:53   5  	  data_table_name     => 'svmc_build_prep',
10:28:53   6  	  case_id_column_name => '&case_id',
10:28:53   7  	  target_column_name  => '&target',
10:28:53   8  	  settings_table_name => 'svmc_settings');
10:28:53   9  END;
10:28:53  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.37
10:28:55 SQL> 
10:28:55 SQL> -----------------------------------------------------------------------
10:28:55 SQL> --			       APPLY/score THE MODEL
10:28:55 SQL> -----------------------------------------------------------------------
10:28:55 SQL> 
10:28:55 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:28:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:28:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:28:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:28:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:28:55 SQL> -----------------------
10:28:55 SQL> -- PREPARE SCORING DATA
10:28:55 SQL> --
10:28:55 SQL> -- If the data for model creation has been prepared, then the data
10:28:55 SQL> -- to be scored using the model must be prepared in the same manner
10:28:55 SQL> -- in order to obtain meaningful results.
10:28:55 SQL> --
10:28:55 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:55 SQL> -- 2. Normalization
10:28:55 SQL> -- No outlier treatment will be performed during test and apply. The
10:28:55 SQL> -- normalization step is sufficient, since the normalization parameters
10:28:55 SQL> -- already capture the effects of outlier treatment done with build data.
10:28:55 SQL> --
10:28:55 SQL> BEGIN
10:28:55   2  	-- Xform Test data to replace missing values
10:28:55   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:55   4  	  miss_table_name => 'svmc_miss_num',
10:28:55   5  	  data_table_name => '&scoretable',
10:28:55   6  	  xform_view_name => 'xformed_apply_miss_num');
10:28:55   7  
10:28:55   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:55   9  	  miss_table_name => 'svmc_miss_cat',
10:28:55  10  	  data_table_name => '&scoretable',
10:28:55  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:28:55  12  
10:28:55  13  	-- Normalize the data to be scored
10:28:55  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:55  15  	  norm_table_name => 'svmc_norm',
10:28:55  16  	  data_table_name => '&scoretable',
10:28:55  17  	  xform_view_name => 'svmc_apply_prep');
10:28:55  18  END;
10:28:55  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:28:56 SQL> 
10:28:56 SQL> -- Maybe I already collected a score for this tkrdate.
10:28:56 SQL> -- DELETE it if I did:
10:28:56 SQL> DELETE ystkscores
10:28:56   2  WHERE score > 0
10:28:56   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:28:56   4  -- I need to supply the target attribute name:
10:28:56   5  AND targ = '&1'
10:28:56   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:28:56 SQL> 
10:28:56 SQL> -- We do a drumroll here:
10:28:56 SQL> 
10:28:56 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:28:56   2  SELECT
10:28:56   3  tkrdate
10:28:56   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:28:56   5  ,sysdate
10:28:56   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:28:56   7  -- rluck/oracle_sql_demos/substr.sql :
10:28:56   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:28:56   9  ,SUBSTR(tkrdate,-10)ydate
10:28:56  10  ,'&1'
10:28:56  11  FROM svmc_apply_prep
10:28:56  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.05
10:28:56 SQL> @score1_5min_gattn.sql	2010-03-22 TLT
10:28:56 SQL> --
10:28:56 SQL> -- score1_5min_gattn.sql
10:28:56 SQL> --
10:28:56 SQL> 
10:28:56 SQL> -- Demo:
10:28:56 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:28:56 SQL> 
10:28:56 SQL> CREATE OR REPLACE VIEW sme AS
10:28:56   2  SELECT
10:28:56   3  tkrdate
10:28:56   4  ,NULL gattn
10:28:56   5  ,g00
10:28:56   6  ,g01
10:28:56   7  ,g02
10:28:56   8  ,g03
10:28:56   9  ,g04
10:28:56  10  ,g05
10:28:56  11  ,g06
10:28:56  12  ,g07
10:28:56  13  ,g08
10:28:56  14  ,g09
10:28:56  15  ,g10
10:28:56  16  ,g11
10:28:56  17  ,g12
10:28:56  18  ,g13
10:28:56  19  ,g14
10:28:56  20  ,g15
10:28:56  21  ,g16
10:28:56  22  ,g17
10:28:56  23  ,g18
10:28:56  24  ,g19
10:28:56  25  ,g20
10:28:56  26  ,g21
10:28:56  27  ,g22
10:28:56  28  ,g23
10:28:56  29  ,g24
10:28:56  30  ,g25
10:28:56  31  ,g26
10:28:56  32  ,g27
10:28:56  33  ,g28
10:28:56  34  ,g29
10:28:56  35  FROM stk_ms
10:28:56  36  WHERE ydate = '&1'
10:28:56  37  AND tkr = '&2'
10:28:56  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-22'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:28:56 SQL> 
10:28:56 SQL> -- rpt
10:28:56 SQL> -- We should see just 1 row:
10:28:56 SQL> 
10:28:56 SQL> SELECT COUNT(tkrdate) FROM sme
10:28:56   2  
10:28:56 SQL> -- Build the model:
10:28:56 SQL> CREATE OR REPLACE VIEW bme AS
10:28:56   2  SELECT
10:28:56   3  tkrdate
10:28:56   4  ,gattn
10:28:56   5  ,g00
10:28:56   6  ,g01
10:28:56   7  ,g02
10:28:56   8  ,g03
10:28:56   9  ,g04
10:28:56  10  ,g05
10:28:56  11  ,g06
10:28:56  12  ,g07
10:28:56  13  ,g08
10:28:56  14  ,g09
10:28:56  15  ,g10
10:28:56  16  ,g11
10:28:56  17  ,g12
10:28:56  18  ,g13
10:28:56  19  ,g14
10:28:56  20  ,g15
10:28:56  21  ,g16
10:28:56  22  ,g17
10:28:56  23  ,g18
10:28:56  24  ,g19
10:28:56  25  ,g20
10:28:56  26  ,g21
10:28:56  27  ,g22
10:28:56  28  ,g23
10:28:56  29  ,g24
10:28:56  30  ,g25
10:28:56  31  ,g26
10:28:56  32  ,g27
10:28:56  33  ,g28
10:28:56  34  ,g29
10:28:56  35  FROM stk_ms
10:28:56  36  WHERE gattn IN('nup','up')
10:28:56  37  -- Use only rows which are older than 1 day:
10:28:56  38  AND 1+ydate < '&1'
10:28:56  39  AND tkr = '&2'
10:28:56  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-22'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:28:56 SQL> 
10:28:56 SQL> -- rpt
10:28:56 SQL> 
10:28:56 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:28:56   2  
10:28:56 SQL> SELECT MAX(tkrdate) FROM bme
10:28:56   2  
10:28:56 SQL> -- Now build model from bme and score sme
10:28:56 SQL> @score1.sql gattn
10:28:56 SQL> -- score1.sql
10:28:56 SQL> 
10:28:56 SQL> -- I use this script to send 5 params to score.sql
10:28:56 SQL> -- which does the heavy lifting of creating an SVM model.
10:28:56 SQL> -- Then at the very end of this script I use the model
10:28:56 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:28:56 SQL> 
10:28:56 SQL> -- I call this script from 2 other scripts:
10:28:56 SQL> -- score1_5min.sql
10:28:56 SQL> -- score1_5min_gattn.sql
10:28:56 SQL> 
10:28:56 SQL> -- The 1st param is the name of the target attribute.
10:28:56 SQL> -- I like to call my target attributes either gatt or gattn.
10:28:56 SQL> 
10:28:56 SQL> -- Demo:
10:28:56 SQL> -- @score1.sql 'gatt'
10:28:56 SQL> -- @score1.sql 'gattn'
10:28:56 SQL> 
10:28:56 SQL> -- Now, I fill up svmc_apply_prep.
10:28:56 SQL> -- I use same model_name used in score.sql
10:28:56 SQL> DEFINE model_name = 'svmspy101'
10:28:56 SQL> DEFINE bldtable	= 'bme'
10:28:56 SQL> DEFINE scoretable = 'sme'
10:28:56 SQL> DEFINE case_id	= 'tkrdate'
10:28:56 SQL> -- Demo:
10:28:56 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:28:56 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:28:56 SQL> --
10:28:56 SQL> -- score.sql
10:28:56 SQL> --
10:28:56 SQL> 
10:28:56 SQL> -- usage: score.sql
10:28:56 SQL> 
10:28:56 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:28:56 SQL> 
10:28:56 SQL> -- DEFINE target	   = 'gatt'
10:28:56 SQL> -- DEFINE model_name = 'svmspy100'
10:28:56 SQL> -- DEFINE bldtable   = 'bme'
10:28:56 SQL> -- DEFINE scoretable = 'sme'
10:28:56 SQL> -- DEFINE case_id    = 'tkrdate'
10:28:56 SQL> 
10:28:56 SQL> DEFINE target	= '&1'
10:28:56 SQL> DEFINE model_name = '&2'
10:28:56 SQL> DEFINE bldtable	= '&3'
10:28:56 SQL> DEFINE scoretable = '&4'
10:28:56 SQL> DEFINE case_id	= '&5'
10:28:56 SQL> 
10:28:56 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:28:56 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:28:56 SQL> 
10:28:56 SQL> -- Builds an SVM model using pl/sql.
10:28:56 SQL> 
10:28:56 SQL> -----------------------------------------------------------------------
10:28:56 SQL> --			    BUILD THE MODEL
10:28:56 SQL> -----------------------------------------------------------------------
10:28:56 SQL> 
10:28:56 SQL> -- Cleanup old build data preparation objects for repeat runs
10:28:56 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:56 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:28:56 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:28:56 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:28:56 SQL> 
10:28:56 SQL> 
10:28:56 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:28:56 SQL> --
10:28:56 SQL> -- DROP	TABLE svmc_settings ;
10:28:56 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:28:56 SQL> -- DELETE svmc_settings;
10:28:56 SQL> 
10:28:56 SQL> -- The default classification algorithm is Naive Bayes. So override
10:28:56 SQL> -- this choice to SVM using a settings table.
10:28:56 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:28:56 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:28:56 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:28:56 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:28:56 SQL> -- models.
10:28:56 SQL> --
10:28:56 SQL> 
10:28:56 SQL> -- Do this once and then comment it out.
10:28:56 SQL> -- That makes script go faster.
10:28:56 SQL> -- BEGIN
10:28:56 SQL> -- -- Populate settings table
10:28:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:56 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:28:56 SQL> --
10:28:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:56 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:28:56 SQL> --
10:28:56 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:28:56 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:28:56 SQL> --   COMMIT;
10:28:56 SQL> -- END;
10:28:56 SQL> -- /
10:28:56 SQL> 
10:28:56 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:28:56 SQL> 
10:28:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:28:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:28:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:28:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:28:56 SQL> 
10:28:56 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:28:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:56   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:28:56 SQL> 
10:28:56 SQL> --------------------------------
10:28:56 SQL> -- PREPARE BUILD (TRAINING) DATA
10:28:56 SQL> --
10:28:56 SQL> 
10:28:56 SQL> -- 1. Missing Value treatment for all Predictors and
10:28:56 SQL> -- 2. Outlier Treatment and
10:28:56 SQL> -- 3. Normalization are performed below.
10:28:56 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:28:56 SQL> --    normalized here.
10:28:56 SQL> 
10:28:56 SQL> BEGIN
10:28:56   2  	-- Perform missing value treatment for all predictors
10:28:56   3  	-- create miss tables
10:28:56   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:28:56   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:28:56   6  
10:28:56   7  	-- populate miss tables
10:28:56   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:28:56   9  	  miss_table_name => 'svmc_miss_num',
10:28:56  10  	  data_table_name => '&bldtable',
10:28:56  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:56  12  
10:28:56  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:28:56  14  	  miss_table_name => 'svmc_miss_cat',
10:28:56  15  	  data_table_name => '&bldtable',
10:28:56  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:56  17  
10:28:56  18  	-- xform input data to replace missing values
10:28:56  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:28:56  20  	  miss_table_name => 'svmc_miss_num',
10:28:56  21  	  data_table_name => '&bldtable',
10:28:56  22  	  xform_view_name => 'xformed_build_miss_num');
10:28:56  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:28:56  24  	  miss_table_name => 'svmc_miss_cat',
10:28:56  25  	  data_table_name => '&bldtable',
10:28:56  26  	  xform_view_name => 'xformed_build_miss_cat');
10:28:56  27  
10:28:56  28  	-- Perform outlier treatment.
10:28:56  29  	-- create clip table
10:28:56  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:28:56  31  
10:28:56  32  	-- populate clip table
10:28:56  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:28:56  34  	  clip_table_name => 'svmc_clip',
10:28:56  35  	  data_table_name => '&bldtable',
10:28:56  36  	  tail_frac	  => 0.025,
10:28:56  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:56  38  
10:28:56  39  	-- xform input data to winsorized data
10:28:56  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:28:56  41  	  clip_table_name => 'svmc_clip',
10:28:56  42  	  data_table_name => '&bldtable',
10:28:56  43  	  xform_view_name => 'svmc_winsor');
10:28:56  44  
10:28:56  45  	-- create normalization table
10:28:56  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:28:56  47  
10:28:56  48  	-- populate normalization table based on winsorized data
10:28:56  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:28:56  50  	  norm_table_name => 'svmc_norm',
10:28:56  51  	  data_table_name => 'svmc_winsor',
10:28:56  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:28:56  53  
10:28:56  54  	-- normalize the original data
10:28:56  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:28:56  56  	  norm_table_name => 'svmc_norm',
10:28:56  57  	  data_table_name => '&bldtable',
10:28:56  58  	  xform_view_name => 'svmc_build_prep');
10:28:56  59  END;
10:28:56  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:28:57 SQL> 
10:28:57 SQL> ---------------------
10:28:57 SQL> -- CREATE A NEW MODEL
10:28:57 SQL> --
10:28:57 SQL> -- Cleanup old model with the same name for repeat runs
10:28:57 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:28:57   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:28:57   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.11
10:28:58 SQL> 
10:28:58 SQL> -- Build a new SVM Model
10:28:58 SQL> BEGIN
10:28:58   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:28:58   3  	  model_name	      => '&model_name',
10:28:58   4  	  mining_function     => dbms_data_mining.classification,
10:28:58   5  	  data_table_name     => 'svmc_build_prep',
10:28:58   6  	  case_id_column_name => '&case_id',
10:28:58   7  	  target_column_name  => '&target',
10:28:58   8  	  settings_table_name => 'svmc_settings');
10:28:58   9  END;
10:28:58  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.92
10:29:00 SQL> 
10:29:00 SQL> -----------------------------------------------------------------------
10:29:00 SQL> --			       APPLY/score THE MODEL
10:29:00 SQL> -----------------------------------------------------------------------
10:29:00 SQL> 
10:29:00 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:00 SQL> -----------------------
10:29:00 SQL> -- PREPARE SCORING DATA
10:29:00 SQL> --
10:29:00 SQL> -- If the data for model creation has been prepared, then the data
10:29:00 SQL> -- to be scored using the model must be prepared in the same manner
10:29:00 SQL> -- in order to obtain meaningful results.
10:29:00 SQL> --
10:29:00 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:00 SQL> -- 2. Normalization
10:29:00 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:00 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:00 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:00 SQL> --
10:29:00 SQL> BEGIN
10:29:00   2  	-- Xform Test data to replace missing values
10:29:00   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:00   4  	  miss_table_name => 'svmc_miss_num',
10:29:00   5  	  data_table_name => '&scoretable',
10:29:00   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:00   7  
10:29:00   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:00   9  	  miss_table_name => 'svmc_miss_cat',
10:29:00  10  	  data_table_name => '&scoretable',
10:29:00  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:00  12  
10:29:00  13  	-- Normalize the data to be scored
10:29:00  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:00  15  	  norm_table_name => 'svmc_norm',
10:29:00  16  	  data_table_name => '&scoretable',
10:29:00  17  	  xform_view_name => 'svmc_apply_prep');
10:29:00  18  END;
10:29:00  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:29:00 SQL> 
10:29:00 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:00 SQL> -- DELETE it if I did:
10:29:00 SQL> DELETE ystkscores
10:29:00   2  WHERE score > 0
10:29:00   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:00   4  -- I need to supply the target attribute name:
10:29:00   5  AND targ = '&1'
10:29:00   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:29:00 SQL> 
10:29:00 SQL> -- We do a drumroll here:
10:29:00 SQL> 
10:29:00 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:00   2  SELECT
10:29:00   3  tkrdate
10:29:00   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:00   5  ,sysdate
10:29:00   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:00   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:00   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:00   9  ,SUBSTR(tkrdate,-10)ydate
10:29:00  10  ,'&1'
10:29:00  11  FROM svmc_apply_prep
10:29:00  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:29:00 SQL> @score1_5min.sql	      2009-12-07 TLT
10:29:00 SQL> --
10:29:00 SQL> -- score1_5min.sql
10:29:00 SQL> --
10:29:00 SQL> 
10:29:00 SQL> -- Demo:
10:29:00 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:00 SQL> 
10:29:00 SQL> CREATE OR REPLACE VIEW sme AS
10:29:00   2  SELECT
10:29:00   3  tkrdate
10:29:00   4  ,NULL gatt
10:29:00   5  ,g00
10:29:00   6  ,g01
10:29:00   7  ,g02
10:29:00   8  ,g03
10:29:00   9  ,g04
10:29:00  10  ,g05
10:29:00  11  ,g06
10:29:00  12  ,g07
10:29:00  13  ,g08
10:29:00  14  ,g09
10:29:00  15  ,g10
10:29:00  16  ,g11
10:29:00  17  ,g12
10:29:00  18  ,g13
10:29:00  19  ,g14
10:29:00  20  ,g15
10:29:00  21  ,g16
10:29:00  22  ,g17
10:29:00  23  ,g18
10:29:00  24  ,g19
10:29:00  25  ,g20
10:29:00  26  ,g21
10:29:00  27  ,g22
10:29:00  28  ,g23
10:29:00  29  ,g24
10:29:00  30  ,g25
10:29:00  31  ,g26
10:29:00  32  ,g27
10:29:00  33  ,g28
10:29:00  34  ,g29
10:29:00  35  FROM stk_ms
10:29:00  36  WHERE ydate = '&1'
10:29:00  37  AND tkr = '&2'
10:29:00  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-07'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:00 SQL> 
10:29:00 SQL> -- rpt
10:29:00 SQL> -- We should see just 1 row:
10:29:00 SQL> 
10:29:00 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:00   2  
10:29:00 SQL> -- Build the model:
10:29:00 SQL> CREATE OR REPLACE VIEW bme AS
10:29:00   2  SELECT
10:29:00   3  tkrdate
10:29:00   4  ,gatt
10:29:00   5  ,g00
10:29:00   6  ,g01
10:29:00   7  ,g02
10:29:00   8  ,g03
10:29:00   9  ,g04
10:29:00  10  ,g05
10:29:00  11  ,g06
10:29:00  12  ,g07
10:29:00  13  ,g08
10:29:00  14  ,g09
10:29:00  15  ,g10
10:29:00  16  ,g11
10:29:00  17  ,g12
10:29:00  18  ,g13
10:29:00  19  ,g14
10:29:00  20  ,g15
10:29:00  21  ,g16
10:29:00  22  ,g17
10:29:00  23  ,g18
10:29:00  24  ,g19
10:29:00  25  ,g20
10:29:00  26  ,g21
10:29:00  27  ,g22
10:29:00  28  ,g23
10:29:00  29  ,g24
10:29:00  30  ,g25
10:29:00  31  ,g26
10:29:00  32  ,g27
10:29:00  33  ,g28
10:29:00  34  ,g29
10:29:00  35  FROM stk_ms
10:29:00  36  WHERE gatt IN('nup','up')
10:29:00  37  -- Use only rows which are older than 1 day:
10:29:00  38  AND 1+ydate < '&1'
10:29:00  39  AND tkr = '&2'
10:29:00  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-07'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:00 SQL> 
10:29:00 SQL> -- rpt
10:29:00 SQL> 
10:29:00 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:00   2  
10:29:00 SQL> SELECT MAX(tkrdate) FROM bme
10:29:00   2  
10:29:00 SQL> -- Now build model from bme and score sme
10:29:00 SQL> @score1.sql gatt
10:29:00 SQL> -- score1.sql
10:29:00 SQL> 
10:29:00 SQL> -- I use this script to send 5 params to score.sql
10:29:00 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:00 SQL> -- Then at the very end of this script I use the model
10:29:00 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:00 SQL> 
10:29:00 SQL> -- I call this script from 2 other scripts:
10:29:00 SQL> -- score1_5min.sql
10:29:00 SQL> -- score1_5min_gattn.sql
10:29:00 SQL> 
10:29:00 SQL> -- The 1st param is the name of the target attribute.
10:29:00 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:00 SQL> 
10:29:00 SQL> -- Demo:
10:29:00 SQL> -- @score1.sql 'gatt'
10:29:00 SQL> -- @score1.sql 'gattn'
10:29:00 SQL> 
10:29:00 SQL> -- Now, I fill up svmc_apply_prep.
10:29:00 SQL> -- I use same model_name used in score.sql
10:29:00 SQL> DEFINE model_name = 'svmspy101'
10:29:00 SQL> DEFINE bldtable	= 'bme'
10:29:00 SQL> DEFINE scoretable = 'sme'
10:29:00 SQL> DEFINE case_id	= 'tkrdate'
10:29:00 SQL> -- Demo:
10:29:00 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:00 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:00 SQL> --
10:29:00 SQL> -- score.sql
10:29:00 SQL> --
10:29:00 SQL> 
10:29:00 SQL> -- usage: score.sql
10:29:00 SQL> 
10:29:00 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:00 SQL> 
10:29:00 SQL> -- DEFINE target	   = 'gatt'
10:29:00 SQL> -- DEFINE model_name = 'svmspy100'
10:29:00 SQL> -- DEFINE bldtable   = 'bme'
10:29:00 SQL> -- DEFINE scoretable = 'sme'
10:29:00 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:00 SQL> 
10:29:00 SQL> DEFINE target	= '&1'
10:29:00 SQL> DEFINE model_name = '&2'
10:29:00 SQL> DEFINE bldtable	= '&3'
10:29:00 SQL> DEFINE scoretable = '&4'
10:29:00 SQL> DEFINE case_id	= '&5'
10:29:00 SQL> 
10:29:00 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:00 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:00 SQL> 
10:29:00 SQL> -- Builds an SVM model using pl/sql.
10:29:00 SQL> 
10:29:00 SQL> -----------------------------------------------------------------------
10:29:00 SQL> --			    BUILD THE MODEL
10:29:00 SQL> -----------------------------------------------------------------------
10:29:00 SQL> 
10:29:00 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:00 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:00 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:00 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:00 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:00 SQL> 
10:29:00 SQL> 
10:29:00 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:00 SQL> --
10:29:00 SQL> -- DROP	TABLE svmc_settings ;
10:29:00 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:00 SQL> -- DELETE svmc_settings;
10:29:00 SQL> 
10:29:00 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:00 SQL> -- this choice to SVM using a settings table.
10:29:00 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:00 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:00 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:00 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:00 SQL> -- models.
10:29:00 SQL> --
10:29:00 SQL> 
10:29:00 SQL> -- Do this once and then comment it out.
10:29:00 SQL> -- That makes script go faster.
10:29:00 SQL> -- BEGIN
10:29:00 SQL> -- -- Populate settings table
10:29:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:00 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:00 SQL> --
10:29:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:00 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:00 SQL> --
10:29:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:00 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:00 SQL> --   COMMIT;
10:29:00 SQL> -- END;
10:29:00 SQL> -- /
10:29:00 SQL> 
10:29:00 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:00 SQL> 
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:00 SQL> 
10:29:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:00 SQL> 
10:29:00 SQL> --------------------------------
10:29:00 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:00 SQL> --
10:29:00 SQL> 
10:29:00 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:00 SQL> -- 2. Outlier Treatment and
10:29:00 SQL> -- 3. Normalization are performed below.
10:29:00 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:00 SQL> --    normalized here.
10:29:00 SQL> 
10:29:00 SQL> BEGIN
10:29:00   2  	-- Perform missing value treatment for all predictors
10:29:00   3  	-- create miss tables
10:29:00   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:00   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:00   6  
10:29:00   7  	-- populate miss tables
10:29:00   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:00   9  	  miss_table_name => 'svmc_miss_num',
10:29:00  10  	  data_table_name => '&bldtable',
10:29:00  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:00  12  
10:29:00  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:00  14  	  miss_table_name => 'svmc_miss_cat',
10:29:00  15  	  data_table_name => '&bldtable',
10:29:00  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:00  17  
10:29:00  18  	-- xform input data to replace missing values
10:29:00  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:00  20  	  miss_table_name => 'svmc_miss_num',
10:29:00  21  	  data_table_name => '&bldtable',
10:29:00  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:00  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:00  24  	  miss_table_name => 'svmc_miss_cat',
10:29:00  25  	  data_table_name => '&bldtable',
10:29:00  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:00  27  
10:29:00  28  	-- Perform outlier treatment.
10:29:00  29  	-- create clip table
10:29:00  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:00  31  
10:29:00  32  	-- populate clip table
10:29:00  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:00  34  	  clip_table_name => 'svmc_clip',
10:29:00  35  	  data_table_name => '&bldtable',
10:29:00  36  	  tail_frac	  => 0.025,
10:29:00  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:00  38  
10:29:00  39  	-- xform input data to winsorized data
10:29:00  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:00  41  	  clip_table_name => 'svmc_clip',
10:29:00  42  	  data_table_name => '&bldtable',
10:29:00  43  	  xform_view_name => 'svmc_winsor');
10:29:00  44  
10:29:00  45  	-- create normalization table
10:29:00  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:00  47  
10:29:00  48  	-- populate normalization table based on winsorized data
10:29:00  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:00  50  	  norm_table_name => 'svmc_norm',
10:29:00  51  	  data_table_name => 'svmc_winsor',
10:29:00  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:00  53  
10:29:00  54  	-- normalize the original data
10:29:00  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:00  56  	  norm_table_name => 'svmc_norm',
10:29:00  57  	  data_table_name => '&bldtable',
10:29:00  58  	  xform_view_name => 'svmc_build_prep');
10:29:00  59  END;
10:29:00  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:29:01 SQL> 
10:29:01 SQL> ---------------------
10:29:01 SQL> -- CREATE A NEW MODEL
10:29:01 SQL> --
10:29:01 SQL> -- Cleanup old model with the same name for repeat runs
10:29:01 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:01   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:01   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.99
10:29:02 SQL> 
10:29:02 SQL> -- Build a new SVM Model
10:29:02 SQL> BEGIN
10:29:02   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:02   3  	  model_name	      => '&model_name',
10:29:02   4  	  mining_function     => dbms_data_mining.classification,
10:29:02   5  	  data_table_name     => 'svmc_build_prep',
10:29:02   6  	  case_id_column_name => '&case_id',
10:29:02   7  	  target_column_name  => '&target',
10:29:02   8  	  settings_table_name => 'svmc_settings');
10:29:02   9  END;
10:29:02  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.40
10:29:04 SQL> 
10:29:04 SQL> -----------------------------------------------------------------------
10:29:04 SQL> --			       APPLY/score THE MODEL
10:29:04 SQL> -----------------------------------------------------------------------
10:29:04 SQL> 
10:29:04 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:04 SQL> -----------------------
10:29:04 SQL> -- PREPARE SCORING DATA
10:29:04 SQL> --
10:29:04 SQL> -- If the data for model creation has been prepared, then the data
10:29:04 SQL> -- to be scored using the model must be prepared in the same manner
10:29:04 SQL> -- in order to obtain meaningful results.
10:29:04 SQL> --
10:29:04 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:04 SQL> -- 2. Normalization
10:29:04 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:04 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:04 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:04 SQL> --
10:29:04 SQL> BEGIN
10:29:04   2  	-- Xform Test data to replace missing values
10:29:04   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:04   4  	  miss_table_name => 'svmc_miss_num',
10:29:04   5  	  data_table_name => '&scoretable',
10:29:04   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:04   7  
10:29:04   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:04   9  	  miss_table_name => 'svmc_miss_cat',
10:29:04  10  	  data_table_name => '&scoretable',
10:29:04  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:04  12  
10:29:04  13  	-- Normalize the data to be scored
10:29:04  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:04  15  	  norm_table_name => 'svmc_norm',
10:29:04  16  	  data_table_name => '&scoretable',
10:29:04  17  	  xform_view_name => 'svmc_apply_prep');
10:29:04  18  END;
10:29:04  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.23
10:29:04 SQL> 
10:29:04 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:04 SQL> -- DELETE it if I did:
10:29:04 SQL> DELETE ystkscores
10:29:04   2  WHERE score > 0
10:29:04   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:04   4  -- I need to supply the target attribute name:
10:29:04   5  AND targ = '&1'
10:29:04   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:29:05 SQL> 
10:29:05 SQL> -- We do a drumroll here:
10:29:05 SQL> 
10:29:05 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:05   2  SELECT
10:29:05   3  tkrdate
10:29:05   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:05   5  ,sysdate
10:29:05   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:05   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:05   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:05   9  ,SUBSTR(tkrdate,-10)ydate
10:29:05  10  ,'&1'
10:29:05  11  FROM svmc_apply_prep
10:29:05  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:05 SQL> @score1_5min.sql	      2010-11-19 TLT
10:29:05 SQL> --
10:29:05 SQL> -- score1_5min.sql
10:29:05 SQL> --
10:29:05 SQL> 
10:29:05 SQL> -- Demo:
10:29:05 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:05 SQL> 
10:29:05 SQL> CREATE OR REPLACE VIEW sme AS
10:29:05   2  SELECT
10:29:05   3  tkrdate
10:29:05   4  ,NULL gatt
10:29:05   5  ,g00
10:29:05   6  ,g01
10:29:05   7  ,g02
10:29:05   8  ,g03
10:29:05   9  ,g04
10:29:05  10  ,g05
10:29:05  11  ,g06
10:29:05  12  ,g07
10:29:05  13  ,g08
10:29:05  14  ,g09
10:29:05  15  ,g10
10:29:05  16  ,g11
10:29:05  17  ,g12
10:29:05  18  ,g13
10:29:05  19  ,g14
10:29:05  20  ,g15
10:29:05  21  ,g16
10:29:05  22  ,g17
10:29:05  23  ,g18
10:29:05  24  ,g19
10:29:05  25  ,g20
10:29:05  26  ,g21
10:29:05  27  ,g22
10:29:05  28  ,g23
10:29:05  29  ,g24
10:29:05  30  ,g25
10:29:05  31  ,g26
10:29:05  32  ,g27
10:29:05  33  ,g28
10:29:05  34  ,g29
10:29:05  35  FROM stk_ms
10:29:05  36  WHERE ydate = '&1'
10:29:05  37  AND tkr = '&2'
10:29:05  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-19'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:29:05 SQL> 
10:29:05 SQL> -- rpt
10:29:05 SQL> -- We should see just 1 row:
10:29:05 SQL> 
10:29:05 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:05   2  
10:29:05 SQL> -- Build the model:
10:29:05 SQL> CREATE OR REPLACE VIEW bme AS
10:29:05   2  SELECT
10:29:05   3  tkrdate
10:29:05   4  ,gatt
10:29:05   5  ,g00
10:29:05   6  ,g01
10:29:05   7  ,g02
10:29:05   8  ,g03
10:29:05   9  ,g04
10:29:05  10  ,g05
10:29:05  11  ,g06
10:29:05  12  ,g07
10:29:05  13  ,g08
10:29:05  14  ,g09
10:29:05  15  ,g10
10:29:05  16  ,g11
10:29:05  17  ,g12
10:29:05  18  ,g13
10:29:05  19  ,g14
10:29:05  20  ,g15
10:29:05  21  ,g16
10:29:05  22  ,g17
10:29:05  23  ,g18
10:29:05  24  ,g19
10:29:05  25  ,g20
10:29:05  26  ,g21
10:29:05  27  ,g22
10:29:05  28  ,g23
10:29:05  29  ,g24
10:29:05  30  ,g25
10:29:05  31  ,g26
10:29:05  32  ,g27
10:29:05  33  ,g28
10:29:05  34  ,g29
10:29:05  35  FROM stk_ms
10:29:05  36  WHERE gatt IN('nup','up')
10:29:05  37  -- Use only rows which are older than 1 day:
10:29:05  38  AND 1+ydate < '&1'
10:29:05  39  AND tkr = '&2'
10:29:05  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-19'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:05 SQL> 
10:29:05 SQL> -- rpt
10:29:05 SQL> 
10:29:05 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:05   2  
10:29:05 SQL> SELECT MAX(tkrdate) FROM bme
10:29:05   2  
10:29:05 SQL> -- Now build model from bme and score sme
10:29:05 SQL> @score1.sql gatt
10:29:05 SQL> -- score1.sql
10:29:05 SQL> 
10:29:05 SQL> -- I use this script to send 5 params to score.sql
10:29:05 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:05 SQL> -- Then at the very end of this script I use the model
10:29:05 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:05 SQL> 
10:29:05 SQL> -- I call this script from 2 other scripts:
10:29:05 SQL> -- score1_5min.sql
10:29:05 SQL> -- score1_5min_gattn.sql
10:29:05 SQL> 
10:29:05 SQL> -- The 1st param is the name of the target attribute.
10:29:05 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:05 SQL> 
10:29:05 SQL> -- Demo:
10:29:05 SQL> -- @score1.sql 'gatt'
10:29:05 SQL> -- @score1.sql 'gattn'
10:29:05 SQL> 
10:29:05 SQL> -- Now, I fill up svmc_apply_prep.
10:29:05 SQL> -- I use same model_name used in score.sql
10:29:05 SQL> DEFINE model_name = 'svmspy101'
10:29:05 SQL> DEFINE bldtable	= 'bme'
10:29:05 SQL> DEFINE scoretable = 'sme'
10:29:05 SQL> DEFINE case_id	= 'tkrdate'
10:29:05 SQL> -- Demo:
10:29:05 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:05 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:05 SQL> --
10:29:05 SQL> -- score.sql
10:29:05 SQL> --
10:29:05 SQL> 
10:29:05 SQL> -- usage: score.sql
10:29:05 SQL> 
10:29:05 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:05 SQL> 
10:29:05 SQL> -- DEFINE target	   = 'gatt'
10:29:05 SQL> -- DEFINE model_name = 'svmspy100'
10:29:05 SQL> -- DEFINE bldtable   = 'bme'
10:29:05 SQL> -- DEFINE scoretable = 'sme'
10:29:05 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:05 SQL> 
10:29:05 SQL> DEFINE target	= '&1'
10:29:05 SQL> DEFINE model_name = '&2'
10:29:05 SQL> DEFINE bldtable	= '&3'
10:29:05 SQL> DEFINE scoretable = '&4'
10:29:05 SQL> DEFINE case_id	= '&5'
10:29:05 SQL> 
10:29:05 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:05 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:05 SQL> 
10:29:05 SQL> -- Builds an SVM model using pl/sql.
10:29:05 SQL> 
10:29:05 SQL> -----------------------------------------------------------------------
10:29:05 SQL> --			    BUILD THE MODEL
10:29:05 SQL> -----------------------------------------------------------------------
10:29:05 SQL> 
10:29:05 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:05 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:05 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:05 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:05 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:05 SQL> 
10:29:05 SQL> 
10:29:05 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:05 SQL> --
10:29:05 SQL> -- DROP	TABLE svmc_settings ;
10:29:05 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:05 SQL> -- DELETE svmc_settings;
10:29:05 SQL> 
10:29:05 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:05 SQL> -- this choice to SVM using a settings table.
10:29:05 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:05 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:05 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:05 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:05 SQL> -- models.
10:29:05 SQL> --
10:29:05 SQL> 
10:29:05 SQL> -- Do this once and then comment it out.
10:29:05 SQL> -- That makes script go faster.
10:29:05 SQL> -- BEGIN
10:29:05 SQL> -- -- Populate settings table
10:29:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:05 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:05 SQL> --
10:29:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:05 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:05 SQL> --
10:29:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:05 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:05 SQL> --   COMMIT;
10:29:05 SQL> -- END;
10:29:05 SQL> -- /
10:29:05 SQL> 
10:29:05 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:05 SQL> 
10:29:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:05 SQL> 
10:29:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:05 SQL> 
10:29:05 SQL> --------------------------------
10:29:05 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:05 SQL> --
10:29:05 SQL> 
10:29:05 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:05 SQL> -- 2. Outlier Treatment and
10:29:05 SQL> -- 3. Normalization are performed below.
10:29:05 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:05 SQL> --    normalized here.
10:29:05 SQL> 
10:29:05 SQL> BEGIN
10:29:05   2  	-- Perform missing value treatment for all predictors
10:29:05   3  	-- create miss tables
10:29:05   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:05   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:05   6  
10:29:05   7  	-- populate miss tables
10:29:05   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:05   9  	  miss_table_name => 'svmc_miss_num',
10:29:05  10  	  data_table_name => '&bldtable',
10:29:05  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:05  12  
10:29:05  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:05  14  	  miss_table_name => 'svmc_miss_cat',
10:29:05  15  	  data_table_name => '&bldtable',
10:29:05  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:05  17  
10:29:05  18  	-- xform input data to replace missing values
10:29:05  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:05  20  	  miss_table_name => 'svmc_miss_num',
10:29:05  21  	  data_table_name => '&bldtable',
10:29:05  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:05  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:05  24  	  miss_table_name => 'svmc_miss_cat',
10:29:05  25  	  data_table_name => '&bldtable',
10:29:05  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:05  27  
10:29:05  28  	-- Perform outlier treatment.
10:29:05  29  	-- create clip table
10:29:05  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:05  31  
10:29:05  32  	-- populate clip table
10:29:05  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:05  34  	  clip_table_name => 'svmc_clip',
10:29:05  35  	  data_table_name => '&bldtable',
10:29:05  36  	  tail_frac	  => 0.025,
10:29:05  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:05  38  
10:29:05  39  	-- xform input data to winsorized data
10:29:05  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:05  41  	  clip_table_name => 'svmc_clip',
10:29:05  42  	  data_table_name => '&bldtable',
10:29:05  43  	  xform_view_name => 'svmc_winsor');
10:29:05  44  
10:29:05  45  	-- create normalization table
10:29:05  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:05  47  
10:29:05  48  	-- populate normalization table based on winsorized data
10:29:05  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:05  50  	  norm_table_name => 'svmc_norm',
10:29:05  51  	  data_table_name => 'svmc_winsor',
10:29:05  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:05  53  
10:29:05  54  	-- normalize the original data
10:29:05  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:05  56  	  norm_table_name => 'svmc_norm',
10:29:05  57  	  data_table_name => '&bldtable',
10:29:05  58  	  xform_view_name => 'svmc_build_prep');
10:29:05  59  END;
10:29:05  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:29:05 SQL> 
10:29:05 SQL> ---------------------
10:29:05 SQL> -- CREATE A NEW MODEL
10:29:05 SQL> --
10:29:05 SQL> -- Cleanup old model with the same name for repeat runs
10:29:05 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:05   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.97
10:29:06 SQL> 
10:29:06 SQL> -- Build a new SVM Model
10:29:06 SQL> BEGIN
10:29:06   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:06   3  	  model_name	      => '&model_name',
10:29:06   4  	  mining_function     => dbms_data_mining.classification,
10:29:06   5  	  data_table_name     => 'svmc_build_prep',
10:29:06   6  	  case_id_column_name => '&case_id',
10:29:06   7  	  target_column_name  => '&target',
10:29:06   8  	  settings_table_name => 'svmc_settings');
10:29:06   9  END;
10:29:06  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.47
10:29:09 SQL> 
10:29:09 SQL> -----------------------------------------------------------------------
10:29:09 SQL> --			       APPLY/score THE MODEL
10:29:09 SQL> -----------------------------------------------------------------------
10:29:09 SQL> 
10:29:09 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.13
10:29:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:09 SQL> -----------------------
10:29:09 SQL> -- PREPARE SCORING DATA
10:29:09 SQL> --
10:29:09 SQL> -- If the data for model creation has been prepared, then the data
10:29:09 SQL> -- to be scored using the model must be prepared in the same manner
10:29:09 SQL> -- in order to obtain meaningful results.
10:29:09 SQL> --
10:29:09 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:09 SQL> -- 2. Normalization
10:29:09 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:09 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:09 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:09 SQL> --
10:29:09 SQL> BEGIN
10:29:09   2  	-- Xform Test data to replace missing values
10:29:09   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:09   4  	  miss_table_name => 'svmc_miss_num',
10:29:09   5  	  data_table_name => '&scoretable',
10:29:09   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:09   7  
10:29:09   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:09   9  	  miss_table_name => 'svmc_miss_cat',
10:29:09  10  	  data_table_name => '&scoretable',
10:29:09  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:09  12  
10:29:09  13  	-- Normalize the data to be scored
10:29:09  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:09  15  	  norm_table_name => 'svmc_norm',
10:29:09  16  	  data_table_name => '&scoretable',
10:29:09  17  	  xform_view_name => 'svmc_apply_prep');
10:29:09  18  END;
10:29:09  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.52
10:29:10 SQL> 
10:29:10 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:10 SQL> -- DELETE it if I did:
10:29:10 SQL> DELETE ystkscores
10:29:10   2  WHERE score > 0
10:29:10   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:10   4  -- I need to supply the target attribute name:
10:29:10   5  AND targ = '&1'
10:29:10   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:29:10 SQL> 
10:29:10 SQL> -- We do a drumroll here:
10:29:10 SQL> 
10:29:10 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:10   2  SELECT
10:29:10   3  tkrdate
10:29:10   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:10   5  ,sysdate
10:29:10   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:10   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:10   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:10   9  ,SUBSTR(tkrdate,-10)ydate
10:29:10  10  ,'&1'
10:29:10  11  FROM svmc_apply_prep
10:29:10  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:10 SQL> @score1_5min.sql	      2010-05-11 TLT
10:29:10 SQL> --
10:29:10 SQL> -- score1_5min.sql
10:29:10 SQL> --
10:29:10 SQL> 
10:29:10 SQL> -- Demo:
10:29:10 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:10 SQL> 
10:29:10 SQL> CREATE OR REPLACE VIEW sme AS
10:29:10   2  SELECT
10:29:10   3  tkrdate
10:29:10   4  ,NULL gatt
10:29:10   5  ,g00
10:29:10   6  ,g01
10:29:10   7  ,g02
10:29:10   8  ,g03
10:29:10   9  ,g04
10:29:10  10  ,g05
10:29:10  11  ,g06
10:29:10  12  ,g07
10:29:10  13  ,g08
10:29:10  14  ,g09
10:29:10  15  ,g10
10:29:10  16  ,g11
10:29:10  17  ,g12
10:29:10  18  ,g13
10:29:10  19  ,g14
10:29:10  20  ,g15
10:29:10  21  ,g16
10:29:10  22  ,g17
10:29:10  23  ,g18
10:29:10  24  ,g19
10:29:10  25  ,g20
10:29:10  26  ,g21
10:29:10  27  ,g22
10:29:10  28  ,g23
10:29:10  29  ,g24
10:29:10  30  ,g25
10:29:10  31  ,g26
10:29:10  32  ,g27
10:29:10  33  ,g28
10:29:10  34  ,g29
10:29:10  35  FROM stk_ms
10:29:10  36  WHERE ydate = '&1'
10:29:10  37  AND tkr = '&2'
10:29:10  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-05-11'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:29:10 SQL> 
10:29:10 SQL> -- rpt
10:29:10 SQL> -- We should see just 1 row:
10:29:10 SQL> 
10:29:10 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:10   2  
10:29:10 SQL> -- Build the model:
10:29:10 SQL> CREATE OR REPLACE VIEW bme AS
10:29:10   2  SELECT
10:29:10   3  tkrdate
10:29:10   4  ,gatt
10:29:10   5  ,g00
10:29:10   6  ,g01
10:29:10   7  ,g02
10:29:10   8  ,g03
10:29:10   9  ,g04
10:29:10  10  ,g05
10:29:10  11  ,g06
10:29:10  12  ,g07
10:29:10  13  ,g08
10:29:10  14  ,g09
10:29:10  15  ,g10
10:29:10  16  ,g11
10:29:10  17  ,g12
10:29:10  18  ,g13
10:29:10  19  ,g14
10:29:10  20  ,g15
10:29:10  21  ,g16
10:29:10  22  ,g17
10:29:10  23  ,g18
10:29:10  24  ,g19
10:29:10  25  ,g20
10:29:10  26  ,g21
10:29:10  27  ,g22
10:29:10  28  ,g23
10:29:10  29  ,g24
10:29:10  30  ,g25
10:29:10  31  ,g26
10:29:10  32  ,g27
10:29:10  33  ,g28
10:29:10  34  ,g29
10:29:10  35  FROM stk_ms
10:29:10  36  WHERE gatt IN('nup','up')
10:29:10  37  -- Use only rows which are older than 1 day:
10:29:10  38  AND 1+ydate < '&1'
10:29:10  39  AND tkr = '&2'
10:29:10  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-05-11'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:10 SQL> 
10:29:10 SQL> -- rpt
10:29:10 SQL> 
10:29:10 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:10   2  
10:29:10 SQL> SELECT MAX(tkrdate) FROM bme
10:29:10   2  
10:29:10 SQL> -- Now build model from bme and score sme
10:29:10 SQL> @score1.sql gatt
10:29:10 SQL> -- score1.sql
10:29:10 SQL> 
10:29:10 SQL> -- I use this script to send 5 params to score.sql
10:29:10 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:10 SQL> -- Then at the very end of this script I use the model
10:29:10 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:10 SQL> 
10:29:10 SQL> -- I call this script from 2 other scripts:
10:29:10 SQL> -- score1_5min.sql
10:29:10 SQL> -- score1_5min_gattn.sql
10:29:10 SQL> 
10:29:10 SQL> -- The 1st param is the name of the target attribute.
10:29:10 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:10 SQL> 
10:29:10 SQL> -- Demo:
10:29:10 SQL> -- @score1.sql 'gatt'
10:29:10 SQL> -- @score1.sql 'gattn'
10:29:10 SQL> 
10:29:10 SQL> -- Now, I fill up svmc_apply_prep.
10:29:10 SQL> -- I use same model_name used in score.sql
10:29:10 SQL> DEFINE model_name = 'svmspy101'
10:29:10 SQL> DEFINE bldtable	= 'bme'
10:29:10 SQL> DEFINE scoretable = 'sme'
10:29:10 SQL> DEFINE case_id	= 'tkrdate'
10:29:10 SQL> -- Demo:
10:29:10 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:10 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:10 SQL> --
10:29:10 SQL> -- score.sql
10:29:10 SQL> --
10:29:10 SQL> 
10:29:10 SQL> -- usage: score.sql
10:29:10 SQL> 
10:29:10 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:10 SQL> 
10:29:10 SQL> -- DEFINE target	   = 'gatt'
10:29:10 SQL> -- DEFINE model_name = 'svmspy100'
10:29:10 SQL> -- DEFINE bldtable   = 'bme'
10:29:10 SQL> -- DEFINE scoretable = 'sme'
10:29:10 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:10 SQL> 
10:29:10 SQL> DEFINE target	= '&1'
10:29:10 SQL> DEFINE model_name = '&2'
10:29:10 SQL> DEFINE bldtable	= '&3'
10:29:10 SQL> DEFINE scoretable = '&4'
10:29:10 SQL> DEFINE case_id	= '&5'
10:29:10 SQL> 
10:29:10 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:10 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:10 SQL> 
10:29:10 SQL> -- Builds an SVM model using pl/sql.
10:29:10 SQL> 
10:29:10 SQL> -----------------------------------------------------------------------
10:29:10 SQL> --			    BUILD THE MODEL
10:29:10 SQL> -----------------------------------------------------------------------
10:29:10 SQL> 
10:29:10 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:10 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:10 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:10 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:10 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:10 SQL> 
10:29:10 SQL> 
10:29:10 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:10 SQL> --
10:29:10 SQL> -- DROP	TABLE svmc_settings ;
10:29:10 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:10 SQL> -- DELETE svmc_settings;
10:29:10 SQL> 
10:29:10 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:10 SQL> -- this choice to SVM using a settings table.
10:29:10 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:10 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:10 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:10 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:10 SQL> -- models.
10:29:10 SQL> --
10:29:10 SQL> 
10:29:10 SQL> -- Do this once and then comment it out.
10:29:10 SQL> -- That makes script go faster.
10:29:10 SQL> -- BEGIN
10:29:10 SQL> -- -- Populate settings table
10:29:10 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:10 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:10 SQL> --
10:29:10 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:10 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:10 SQL> --
10:29:10 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:10 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:10 SQL> --   COMMIT;
10:29:10 SQL> -- END;
10:29:10 SQL> -- /
10:29:10 SQL> 
10:29:10 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:10 SQL> 
10:29:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:10 SQL> 
10:29:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:10 SQL> 
10:29:10 SQL> --------------------------------
10:29:10 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:10 SQL> --
10:29:10 SQL> 
10:29:10 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:10 SQL> -- 2. Outlier Treatment and
10:29:10 SQL> -- 3. Normalization are performed below.
10:29:10 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:10 SQL> --    normalized here.
10:29:10 SQL> 
10:29:10 SQL> BEGIN
10:29:10   2  	-- Perform missing value treatment for all predictors
10:29:10   3  	-- create miss tables
10:29:10   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:10   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:10   6  
10:29:10   7  	-- populate miss tables
10:29:10   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:10   9  	  miss_table_name => 'svmc_miss_num',
10:29:10  10  	  data_table_name => '&bldtable',
10:29:10  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:10  12  
10:29:10  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:10  14  	  miss_table_name => 'svmc_miss_cat',
10:29:10  15  	  data_table_name => '&bldtable',
10:29:10  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:10  17  
10:29:10  18  	-- xform input data to replace missing values
10:29:10  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:10  20  	  miss_table_name => 'svmc_miss_num',
10:29:10  21  	  data_table_name => '&bldtable',
10:29:10  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:10  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:10  24  	  miss_table_name => 'svmc_miss_cat',
10:29:10  25  	  data_table_name => '&bldtable',
10:29:10  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:10  27  
10:29:10  28  	-- Perform outlier treatment.
10:29:10  29  	-- create clip table
10:29:10  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:10  31  
10:29:10  32  	-- populate clip table
10:29:10  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:10  34  	  clip_table_name => 'svmc_clip',
10:29:10  35  	  data_table_name => '&bldtable',
10:29:10  36  	  tail_frac	  => 0.025,
10:29:10  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:10  38  
10:29:10  39  	-- xform input data to winsorized data
10:29:10  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:10  41  	  clip_table_name => 'svmc_clip',
10:29:10  42  	  data_table_name => '&bldtable',
10:29:10  43  	  xform_view_name => 'svmc_winsor');
10:29:10  44  
10:29:10  45  	-- create normalization table
10:29:10  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:10  47  
10:29:10  48  	-- populate normalization table based on winsorized data
10:29:10  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:10  50  	  norm_table_name => 'svmc_norm',
10:29:10  51  	  data_table_name => 'svmc_winsor',
10:29:10  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:10  53  
10:29:10  54  	-- normalize the original data
10:29:10  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:10  56  	  norm_table_name => 'svmc_norm',
10:29:10  57  	  data_table_name => '&bldtable',
10:29:10  58  	  xform_view_name => 'svmc_build_prep');
10:29:10  59  END;
10:29:10  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.63
10:29:10 SQL> 
10:29:10 SQL> ---------------------
10:29:10 SQL> -- CREATE A NEW MODEL
10:29:10 SQL> --
10:29:10 SQL> -- Cleanup old model with the same name for repeat runs
10:29:10 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:10   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.58
10:29:12 SQL> 
10:29:12 SQL> -- Build a new SVM Model
10:29:12 SQL> BEGIN
10:29:12   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:12   3  	  model_name	      => '&model_name',
10:29:12   4  	  mining_function     => dbms_data_mining.classification,
10:29:12   5  	  data_table_name     => 'svmc_build_prep',
10:29:12   6  	  case_id_column_name => '&case_id',
10:29:12   7  	  target_column_name  => '&target',
10:29:12   8  	  settings_table_name => 'svmc_settings');
10:29:12   9  END;
10:29:12  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.19
10:29:14 SQL> 
10:29:14 SQL> -----------------------------------------------------------------------
10:29:14 SQL> --			       APPLY/score THE MODEL
10:29:14 SQL> -----------------------------------------------------------------------
10:29:14 SQL> 
10:29:14 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:14 SQL> -----------------------
10:29:14 SQL> -- PREPARE SCORING DATA
10:29:14 SQL> --
10:29:14 SQL> -- If the data for model creation has been prepared, then the data
10:29:14 SQL> -- to be scored using the model must be prepared in the same manner
10:29:14 SQL> -- in order to obtain meaningful results.
10:29:14 SQL> --
10:29:14 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:14 SQL> -- 2. Normalization
10:29:14 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:14 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:14 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:14 SQL> --
10:29:14 SQL> BEGIN
10:29:14   2  	-- Xform Test data to replace missing values
10:29:14   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:14   4  	  miss_table_name => 'svmc_miss_num',
10:29:14   5  	  data_table_name => '&scoretable',
10:29:14   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:14   7  
10:29:14   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:14   9  	  miss_table_name => 'svmc_miss_cat',
10:29:14  10  	  data_table_name => '&scoretable',
10:29:14  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:14  12  
10:29:14  13  	-- Normalize the data to be scored
10:29:14  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:14  15  	  norm_table_name => 'svmc_norm',
10:29:14  16  	  data_table_name => '&scoretable',
10:29:14  17  	  xform_view_name => 'svmc_apply_prep');
10:29:14  18  END;
10:29:14  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
10:29:15 SQL> 
10:29:15 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:15 SQL> -- DELETE it if I did:
10:29:15 SQL> DELETE ystkscores
10:29:15   2  WHERE score > 0
10:29:15   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:15   4  -- I need to supply the target attribute name:
10:29:15   5  AND targ = '&1'
10:29:15   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:15 SQL> 
10:29:15 SQL> -- We do a drumroll here:
10:29:15 SQL> 
10:29:15 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:15   2  SELECT
10:29:15   3  tkrdate
10:29:15   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:15   5  ,sysdate
10:29:15   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:15   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:15   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:15   9  ,SUBSTR(tkrdate,-10)ydate
10:29:15  10  ,'&1'
10:29:15  11  FROM svmc_apply_prep
10:29:15  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:15 SQL> @score1_5min_gattn.sql	2010-10-04 TLT
10:29:15 SQL> --
10:29:15 SQL> -- score1_5min_gattn.sql
10:29:15 SQL> --
10:29:15 SQL> 
10:29:15 SQL> -- Demo:
10:29:15 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:29:15 SQL> 
10:29:15 SQL> CREATE OR REPLACE VIEW sme AS
10:29:15   2  SELECT
10:29:15   3  tkrdate
10:29:15   4  ,NULL gattn
10:29:15   5  ,g00
10:29:15   6  ,g01
10:29:15   7  ,g02
10:29:15   8  ,g03
10:29:15   9  ,g04
10:29:15  10  ,g05
10:29:15  11  ,g06
10:29:15  12  ,g07
10:29:15  13  ,g08
10:29:15  14  ,g09
10:29:15  15  ,g10
10:29:15  16  ,g11
10:29:15  17  ,g12
10:29:15  18  ,g13
10:29:15  19  ,g14
10:29:15  20  ,g15
10:29:15  21  ,g16
10:29:15  22  ,g17
10:29:15  23  ,g18
10:29:15  24  ,g19
10:29:15  25  ,g20
10:29:15  26  ,g21
10:29:15  27  ,g22
10:29:15  28  ,g23
10:29:15  29  ,g24
10:29:15  30  ,g25
10:29:15  31  ,g26
10:29:15  32  ,g27
10:29:15  33  ,g28
10:29:15  34  ,g29
10:29:15  35  FROM stk_ms
10:29:15  36  WHERE ydate = '&1'
10:29:15  37  AND tkr = '&2'
10:29:15  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-10-04'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:15 SQL> 
10:29:15 SQL> -- rpt
10:29:15 SQL> -- We should see just 1 row:
10:29:15 SQL> 
10:29:15 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:15   2  
10:29:15 SQL> -- Build the model:
10:29:15 SQL> CREATE OR REPLACE VIEW bme AS
10:29:15   2  SELECT
10:29:15   3  tkrdate
10:29:15   4  ,gattn
10:29:15   5  ,g00
10:29:15   6  ,g01
10:29:15   7  ,g02
10:29:15   8  ,g03
10:29:15   9  ,g04
10:29:15  10  ,g05
10:29:15  11  ,g06
10:29:15  12  ,g07
10:29:15  13  ,g08
10:29:15  14  ,g09
10:29:15  15  ,g10
10:29:15  16  ,g11
10:29:15  17  ,g12
10:29:15  18  ,g13
10:29:15  19  ,g14
10:29:15  20  ,g15
10:29:15  21  ,g16
10:29:15  22  ,g17
10:29:15  23  ,g18
10:29:15  24  ,g19
10:29:15  25  ,g20
10:29:15  26  ,g21
10:29:15  27  ,g22
10:29:15  28  ,g23
10:29:15  29  ,g24
10:29:15  30  ,g25
10:29:15  31  ,g26
10:29:15  32  ,g27
10:29:15  33  ,g28
10:29:15  34  ,g29
10:29:15  35  FROM stk_ms
10:29:15  36  WHERE gattn IN('nup','up')
10:29:15  37  -- Use only rows which are older than 1 day:
10:29:15  38  AND 1+ydate < '&1'
10:29:15  39  AND tkr = '&2'
10:29:15  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-10-04'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:15 SQL> 
10:29:15 SQL> -- rpt
10:29:15 SQL> 
10:29:15 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:29:15   2  
10:29:15 SQL> SELECT MAX(tkrdate) FROM bme
10:29:15   2  
10:29:15 SQL> -- Now build model from bme and score sme
10:29:15 SQL> @score1.sql gattn
10:29:15 SQL> -- score1.sql
10:29:15 SQL> 
10:29:15 SQL> -- I use this script to send 5 params to score.sql
10:29:15 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:15 SQL> -- Then at the very end of this script I use the model
10:29:15 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:15 SQL> 
10:29:15 SQL> -- I call this script from 2 other scripts:
10:29:15 SQL> -- score1_5min.sql
10:29:15 SQL> -- score1_5min_gattn.sql
10:29:15 SQL> 
10:29:15 SQL> -- The 1st param is the name of the target attribute.
10:29:15 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:15 SQL> 
10:29:15 SQL> -- Demo:
10:29:15 SQL> -- @score1.sql 'gatt'
10:29:15 SQL> -- @score1.sql 'gattn'
10:29:15 SQL> 
10:29:15 SQL> -- Now, I fill up svmc_apply_prep.
10:29:15 SQL> -- I use same model_name used in score.sql
10:29:15 SQL> DEFINE model_name = 'svmspy101'
10:29:15 SQL> DEFINE bldtable	= 'bme'
10:29:15 SQL> DEFINE scoretable = 'sme'
10:29:15 SQL> DEFINE case_id	= 'tkrdate'
10:29:15 SQL> -- Demo:
10:29:15 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:15 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:15 SQL> --
10:29:15 SQL> -- score.sql
10:29:15 SQL> --
10:29:15 SQL> 
10:29:15 SQL> -- usage: score.sql
10:29:15 SQL> 
10:29:15 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:15 SQL> 
10:29:15 SQL> -- DEFINE target	   = 'gatt'
10:29:15 SQL> -- DEFINE model_name = 'svmspy100'
10:29:15 SQL> -- DEFINE bldtable   = 'bme'
10:29:15 SQL> -- DEFINE scoretable = 'sme'
10:29:15 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:15 SQL> 
10:29:15 SQL> DEFINE target	= '&1'
10:29:15 SQL> DEFINE model_name = '&2'
10:29:15 SQL> DEFINE bldtable	= '&3'
10:29:15 SQL> DEFINE scoretable = '&4'
10:29:15 SQL> DEFINE case_id	= '&5'
10:29:15 SQL> 
10:29:15 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:15 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:15 SQL> 
10:29:15 SQL> -- Builds an SVM model using pl/sql.
10:29:15 SQL> 
10:29:15 SQL> -----------------------------------------------------------------------
10:29:15 SQL> --			    BUILD THE MODEL
10:29:15 SQL> -----------------------------------------------------------------------
10:29:15 SQL> 
10:29:15 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:15 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:15 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:15 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:15 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:15 SQL> 
10:29:15 SQL> 
10:29:15 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:15 SQL> --
10:29:15 SQL> -- DROP	TABLE svmc_settings ;
10:29:15 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:15 SQL> -- DELETE svmc_settings;
10:29:15 SQL> 
10:29:15 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:15 SQL> -- this choice to SVM using a settings table.
10:29:15 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:15 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:15 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:15 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:15 SQL> -- models.
10:29:15 SQL> --
10:29:15 SQL> 
10:29:15 SQL> -- Do this once and then comment it out.
10:29:15 SQL> -- That makes script go faster.
10:29:15 SQL> -- BEGIN
10:29:15 SQL> -- -- Populate settings table
10:29:15 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:15 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:15 SQL> --
10:29:15 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:15 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:15 SQL> --
10:29:15 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:15 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:15 SQL> --   COMMIT;
10:29:15 SQL> -- END;
10:29:15 SQL> -- /
10:29:15 SQL> 
10:29:15 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:15 SQL> 
10:29:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:15 SQL> 
10:29:15 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:15   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:15 SQL> 
10:29:15 SQL> --------------------------------
10:29:15 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:15 SQL> --
10:29:15 SQL> 
10:29:15 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:15 SQL> -- 2. Outlier Treatment and
10:29:15 SQL> -- 3. Normalization are performed below.
10:29:15 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:15 SQL> --    normalized here.
10:29:15 SQL> 
10:29:15 SQL> BEGIN
10:29:15   2  	-- Perform missing value treatment for all predictors
10:29:15   3  	-- create miss tables
10:29:15   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:15   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:15   6  
10:29:15   7  	-- populate miss tables
10:29:15   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:15   9  	  miss_table_name => 'svmc_miss_num',
10:29:15  10  	  data_table_name => '&bldtable',
10:29:15  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:15  12  
10:29:15  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:15  14  	  miss_table_name => 'svmc_miss_cat',
10:29:15  15  	  data_table_name => '&bldtable',
10:29:15  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:15  17  
10:29:15  18  	-- xform input data to replace missing values
10:29:15  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:15  20  	  miss_table_name => 'svmc_miss_num',
10:29:15  21  	  data_table_name => '&bldtable',
10:29:15  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:15  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:15  24  	  miss_table_name => 'svmc_miss_cat',
10:29:15  25  	  data_table_name => '&bldtable',
10:29:15  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:15  27  
10:29:15  28  	-- Perform outlier treatment.
10:29:15  29  	-- create clip table
10:29:15  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:15  31  
10:29:15  32  	-- populate clip table
10:29:15  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:15  34  	  clip_table_name => 'svmc_clip',
10:29:15  35  	  data_table_name => '&bldtable',
10:29:15  36  	  tail_frac	  => 0.025,
10:29:15  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:15  38  
10:29:15  39  	-- xform input data to winsorized data
10:29:15  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:15  41  	  clip_table_name => 'svmc_clip',
10:29:15  42  	  data_table_name => '&bldtable',
10:29:15  43  	  xform_view_name => 'svmc_winsor');
10:29:15  44  
10:29:15  45  	-- create normalization table
10:29:15  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:15  47  
10:29:15  48  	-- populate normalization table based on winsorized data
10:29:15  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:15  50  	  norm_table_name => 'svmc_norm',
10:29:15  51  	  data_table_name => 'svmc_winsor',
10:29:15  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:15  53  
10:29:15  54  	-- normalize the original data
10:29:15  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:15  56  	  norm_table_name => 'svmc_norm',
10:29:15  57  	  data_table_name => '&bldtable',
10:29:15  58  	  xform_view_name => 'svmc_build_prep');
10:29:15  59  END;
10:29:15  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:29:15 SQL> 
10:29:15 SQL> ---------------------
10:29:15 SQL> -- CREATE A NEW MODEL
10:29:15 SQL> --
10:29:15 SQL> -- Cleanup old model with the same name for repeat runs
10:29:15 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:15   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.76
10:29:17 SQL> 
10:29:17 SQL> -- Build a new SVM Model
10:29:17 SQL> BEGIN
10:29:17   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:17   3  	  model_name	      => '&model_name',
10:29:17   4  	  mining_function     => dbms_data_mining.classification,
10:29:17   5  	  data_table_name     => 'svmc_build_prep',
10:29:17   6  	  case_id_column_name => '&case_id',
10:29:17   7  	  target_column_name  => '&target',
10:29:17   8  	  settings_table_name => 'svmc_settings');
10:29:17   9  END;
10:29:17  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.94
10:29:19 SQL> 
10:29:19 SQL> -----------------------------------------------------------------------
10:29:19 SQL> --			       APPLY/score THE MODEL
10:29:19 SQL> -----------------------------------------------------------------------
10:29:19 SQL> 
10:29:19 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:19 SQL> -----------------------
10:29:19 SQL> -- PREPARE SCORING DATA
10:29:19 SQL> --
10:29:19 SQL> -- If the data for model creation has been prepared, then the data
10:29:19 SQL> -- to be scored using the model must be prepared in the same manner
10:29:19 SQL> -- in order to obtain meaningful results.
10:29:19 SQL> --
10:29:19 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:19 SQL> -- 2. Normalization
10:29:19 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:19 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:19 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:19 SQL> --
10:29:19 SQL> BEGIN
10:29:19   2  	-- Xform Test data to replace missing values
10:29:19   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:19   4  	  miss_table_name => 'svmc_miss_num',
10:29:19   5  	  data_table_name => '&scoretable',
10:29:19   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:19   7  
10:29:19   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:19   9  	  miss_table_name => 'svmc_miss_cat',
10:29:19  10  	  data_table_name => '&scoretable',
10:29:19  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:19  12  
10:29:19  13  	-- Normalize the data to be scored
10:29:19  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:19  15  	  norm_table_name => 'svmc_norm',
10:29:19  16  	  data_table_name => '&scoretable',
10:29:19  17  	  xform_view_name => 'svmc_apply_prep');
10:29:19  18  END;
10:29:19  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:29:19 SQL> 
10:29:19 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:19 SQL> -- DELETE it if I did:
10:29:19 SQL> DELETE ystkscores
10:29:19   2  WHERE score > 0
10:29:19   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:19   4  -- I need to supply the target attribute name:
10:29:19   5  AND targ = '&1'
10:29:19   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:19 SQL> 
10:29:19 SQL> -- We do a drumroll here:
10:29:19 SQL> 
10:29:19 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:19   2  SELECT
10:29:19   3  tkrdate
10:29:19   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:19   5  ,sysdate
10:29:19   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:19   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:19   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:19   9  ,SUBSTR(tkrdate,-10)ydate
10:29:19  10  ,'&1'
10:29:19  11  FROM svmc_apply_prep
10:29:19  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:29:19 SQL> @score1_5min.sql	      2011-01-06 TLT
10:29:19 SQL> --
10:29:19 SQL> -- score1_5min.sql
10:29:19 SQL> --
10:29:19 SQL> 
10:29:19 SQL> -- Demo:
10:29:19 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:19 SQL> 
10:29:19 SQL> CREATE OR REPLACE VIEW sme AS
10:29:19   2  SELECT
10:29:19   3  tkrdate
10:29:19   4  ,NULL gatt
10:29:19   5  ,g00
10:29:19   6  ,g01
10:29:19   7  ,g02
10:29:19   8  ,g03
10:29:19   9  ,g04
10:29:19  10  ,g05
10:29:19  11  ,g06
10:29:19  12  ,g07
10:29:19  13  ,g08
10:29:19  14  ,g09
10:29:19  15  ,g10
10:29:19  16  ,g11
10:29:19  17  ,g12
10:29:19  18  ,g13
10:29:19  19  ,g14
10:29:19  20  ,g15
10:29:19  21  ,g16
10:29:19  22  ,g17
10:29:19  23  ,g18
10:29:19  24  ,g19
10:29:19  25  ,g20
10:29:19  26  ,g21
10:29:19  27  ,g22
10:29:19  28  ,g23
10:29:19  29  ,g24
10:29:19  30  ,g25
10:29:19  31  ,g26
10:29:19  32  ,g27
10:29:19  33  ,g28
10:29:19  34  ,g29
10:29:19  35  FROM stk_ms
10:29:19  36  WHERE ydate = '&1'
10:29:19  37  AND tkr = '&2'
10:29:19  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2011-01-06'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:19 SQL> 
10:29:19 SQL> -- rpt
10:29:19 SQL> -- We should see just 1 row:
10:29:19 SQL> 
10:29:19 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:19   2  
10:29:19 SQL> -- Build the model:
10:29:19 SQL> CREATE OR REPLACE VIEW bme AS
10:29:19   2  SELECT
10:29:19   3  tkrdate
10:29:19   4  ,gatt
10:29:19   5  ,g00
10:29:19   6  ,g01
10:29:19   7  ,g02
10:29:19   8  ,g03
10:29:19   9  ,g04
10:29:19  10  ,g05
10:29:19  11  ,g06
10:29:19  12  ,g07
10:29:19  13  ,g08
10:29:19  14  ,g09
10:29:19  15  ,g10
10:29:19  16  ,g11
10:29:19  17  ,g12
10:29:19  18  ,g13
10:29:19  19  ,g14
10:29:19  20  ,g15
10:29:19  21  ,g16
10:29:19  22  ,g17
10:29:19  23  ,g18
10:29:19  24  ,g19
10:29:19  25  ,g20
10:29:19  26  ,g21
10:29:19  27  ,g22
10:29:19  28  ,g23
10:29:19  29  ,g24
10:29:19  30  ,g25
10:29:19  31  ,g26
10:29:19  32  ,g27
10:29:19  33  ,g28
10:29:19  34  ,g29
10:29:19  35  FROM stk_ms
10:29:19  36  WHERE gatt IN('nup','up')
10:29:19  37  -- Use only rows which are older than 1 day:
10:29:19  38  AND 1+ydate < '&1'
10:29:19  39  AND tkr = '&2'
10:29:19  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2011-01-06'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.08
10:29:20 SQL> 
10:29:20 SQL> -- rpt
10:29:20 SQL> 
10:29:20 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:20   2  
10:29:20 SQL> SELECT MAX(tkrdate) FROM bme
10:29:20   2  
10:29:20 SQL> -- Now build model from bme and score sme
10:29:20 SQL> @score1.sql gatt
10:29:20 SQL> -- score1.sql
10:29:20 SQL> 
10:29:20 SQL> -- I use this script to send 5 params to score.sql
10:29:20 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:20 SQL> -- Then at the very end of this script I use the model
10:29:20 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:20 SQL> 
10:29:20 SQL> -- I call this script from 2 other scripts:
10:29:20 SQL> -- score1_5min.sql
10:29:20 SQL> -- score1_5min_gattn.sql
10:29:20 SQL> 
10:29:20 SQL> -- The 1st param is the name of the target attribute.
10:29:20 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:20 SQL> 
10:29:20 SQL> -- Demo:
10:29:20 SQL> -- @score1.sql 'gatt'
10:29:20 SQL> -- @score1.sql 'gattn'
10:29:20 SQL> 
10:29:20 SQL> -- Now, I fill up svmc_apply_prep.
10:29:20 SQL> -- I use same model_name used in score.sql
10:29:20 SQL> DEFINE model_name = 'svmspy101'
10:29:20 SQL> DEFINE bldtable	= 'bme'
10:29:20 SQL> DEFINE scoretable = 'sme'
10:29:20 SQL> DEFINE case_id	= 'tkrdate'
10:29:20 SQL> -- Demo:
10:29:20 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:20 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:20 SQL> --
10:29:20 SQL> -- score.sql
10:29:20 SQL> --
10:29:20 SQL> 
10:29:20 SQL> -- usage: score.sql
10:29:20 SQL> 
10:29:20 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:20 SQL> 
10:29:20 SQL> -- DEFINE target	   = 'gatt'
10:29:20 SQL> -- DEFINE model_name = 'svmspy100'
10:29:20 SQL> -- DEFINE bldtable   = 'bme'
10:29:20 SQL> -- DEFINE scoretable = 'sme'
10:29:20 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:20 SQL> 
10:29:20 SQL> DEFINE target	= '&1'
10:29:20 SQL> DEFINE model_name = '&2'
10:29:20 SQL> DEFINE bldtable	= '&3'
10:29:20 SQL> DEFINE scoretable = '&4'
10:29:20 SQL> DEFINE case_id	= '&5'
10:29:20 SQL> 
10:29:20 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:20 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:20 SQL> 
10:29:20 SQL> -- Builds an SVM model using pl/sql.
10:29:20 SQL> 
10:29:20 SQL> -----------------------------------------------------------------------
10:29:20 SQL> --			    BUILD THE MODEL
10:29:20 SQL> -----------------------------------------------------------------------
10:29:20 SQL> 
10:29:20 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:20 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:20 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:20 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:20 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:20 SQL> 
10:29:20 SQL> 
10:29:20 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:20 SQL> --
10:29:20 SQL> -- DROP	TABLE svmc_settings ;
10:29:20 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:20 SQL> -- DELETE svmc_settings;
10:29:20 SQL> 
10:29:20 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:20 SQL> -- this choice to SVM using a settings table.
10:29:20 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:20 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:20 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:20 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:20 SQL> -- models.
10:29:20 SQL> --
10:29:20 SQL> 
10:29:20 SQL> -- Do this once and then comment it out.
10:29:20 SQL> -- That makes script go faster.
10:29:20 SQL> -- BEGIN
10:29:20 SQL> -- -- Populate settings table
10:29:20 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:20 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:20 SQL> --
10:29:20 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:20 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:20 SQL> --
10:29:20 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:20 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:20 SQL> --   COMMIT;
10:29:20 SQL> -- END;
10:29:20 SQL> -- /
10:29:20 SQL> 
10:29:20 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:29:20 SQL> 
10:29:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:20 SQL> 
10:29:20 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:20   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:20 SQL> 
10:29:20 SQL> --------------------------------
10:29:20 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:20 SQL> --
10:29:20 SQL> 
10:29:20 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:20 SQL> -- 2. Outlier Treatment and
10:29:20 SQL> -- 3. Normalization are performed below.
10:29:20 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:20 SQL> --    normalized here.
10:29:20 SQL> 
10:29:20 SQL> BEGIN
10:29:20   2  	-- Perform missing value treatment for all predictors
10:29:20   3  	-- create miss tables
10:29:20   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:20   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:20   6  
10:29:20   7  	-- populate miss tables
10:29:20   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:20   9  	  miss_table_name => 'svmc_miss_num',
10:29:20  10  	  data_table_name => '&bldtable',
10:29:20  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:20  12  
10:29:20  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:20  14  	  miss_table_name => 'svmc_miss_cat',
10:29:20  15  	  data_table_name => '&bldtable',
10:29:20  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:20  17  
10:29:20  18  	-- xform input data to replace missing values
10:29:20  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:20  20  	  miss_table_name => 'svmc_miss_num',
10:29:20  21  	  data_table_name => '&bldtable',
10:29:20  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:20  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:20  24  	  miss_table_name => 'svmc_miss_cat',
10:29:20  25  	  data_table_name => '&bldtable',
10:29:20  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:20  27  
10:29:20  28  	-- Perform outlier treatment.
10:29:20  29  	-- create clip table
10:29:20  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:20  31  
10:29:20  32  	-- populate clip table
10:29:20  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:20  34  	  clip_table_name => 'svmc_clip',
10:29:20  35  	  data_table_name => '&bldtable',
10:29:20  36  	  tail_frac	  => 0.025,
10:29:20  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:20  38  
10:29:20  39  	-- xform input data to winsorized data
10:29:20  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:20  41  	  clip_table_name => 'svmc_clip',
10:29:20  42  	  data_table_name => '&bldtable',
10:29:20  43  	  xform_view_name => 'svmc_winsor');
10:29:20  44  
10:29:20  45  	-- create normalization table
10:29:20  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:20  47  
10:29:20  48  	-- populate normalization table based on winsorized data
10:29:20  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:20  50  	  norm_table_name => 'svmc_norm',
10:29:20  51  	  data_table_name => 'svmc_winsor',
10:29:20  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:20  53  
10:29:20  54  	-- normalize the original data
10:29:20  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:20  56  	  norm_table_name => 'svmc_norm',
10:29:20  57  	  data_table_name => '&bldtable',
10:29:20  58  	  xform_view_name => 'svmc_build_prep');
10:29:20  59  END;
10:29:20  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.62
10:29:20 SQL> 
10:29:20 SQL> ---------------------
10:29:20 SQL> -- CREATE A NEW MODEL
10:29:20 SQL> --
10:29:20 SQL> -- Cleanup old model with the same name for repeat runs
10:29:20 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:20   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:20   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.95
10:29:21 SQL> 
10:29:21 SQL> -- Build a new SVM Model
10:29:21 SQL> BEGIN
10:29:21   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:21   3  	  model_name	      => '&model_name',
10:29:21   4  	  mining_function     => dbms_data_mining.classification,
10:29:21   5  	  data_table_name     => 'svmc_build_prep',
10:29:21   6  	  case_id_column_name => '&case_id',
10:29:21   7  	  target_column_name  => '&target',
10:29:21   8  	  settings_table_name => 'svmc_settings');
10:29:21   9  END;
10:29:21  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
10:29:24 SQL> 
10:29:24 SQL> -----------------------------------------------------------------------
10:29:24 SQL> --			       APPLY/score THE MODEL
10:29:24 SQL> -----------------------------------------------------------------------
10:29:24 SQL> 
10:29:24 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:24 SQL> -----------------------
10:29:24 SQL> -- PREPARE SCORING DATA
10:29:24 SQL> --
10:29:24 SQL> -- If the data for model creation has been prepared, then the data
10:29:24 SQL> -- to be scored using the model must be prepared in the same manner
10:29:24 SQL> -- in order to obtain meaningful results.
10:29:24 SQL> --
10:29:24 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:24 SQL> -- 2. Normalization
10:29:24 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:24 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:24 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:24 SQL> --
10:29:24 SQL> BEGIN
10:29:24   2  	-- Xform Test data to replace missing values
10:29:24   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:24   4  	  miss_table_name => 'svmc_miss_num',
10:29:24   5  	  data_table_name => '&scoretable',
10:29:24   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:24   7  
10:29:24   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:24   9  	  miss_table_name => 'svmc_miss_cat',
10:29:24  10  	  data_table_name => '&scoretable',
10:29:24  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:24  12  
10:29:24  13  	-- Normalize the data to be scored
10:29:24  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:24  15  	  norm_table_name => 'svmc_norm',
10:29:24  16  	  data_table_name => '&scoretable',
10:29:24  17  	  xform_view_name => 'svmc_apply_prep');
10:29:24  18  END;
10:29:24  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:29:24 SQL> 
10:29:24 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:24 SQL> -- DELETE it if I did:
10:29:24 SQL> DELETE ystkscores
10:29:24   2  WHERE score > 0
10:29:24   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:24   4  -- I need to supply the target attribute name:
10:29:24   5  AND targ = '&1'
10:29:24   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:24 SQL> 
10:29:24 SQL> -- We do a drumroll here:
10:29:24 SQL> 
10:29:24 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:24   2  SELECT
10:29:24   3  tkrdate
10:29:24   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:24   5  ,sysdate
10:29:24   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:24   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:24   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:24   9  ,SUBSTR(tkrdate,-10)ydate
10:29:24  10  ,'&1'
10:29:24  11  FROM svmc_apply_prep
10:29:24  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:29:24 SQL> @score1_5min.sql	      2010-08-16 TLT
10:29:24 SQL> --
10:29:24 SQL> -- score1_5min.sql
10:29:24 SQL> --
10:29:24 SQL> 
10:29:24 SQL> -- Demo:
10:29:24 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:24 SQL> 
10:29:24 SQL> CREATE OR REPLACE VIEW sme AS
10:29:24   2  SELECT
10:29:24   3  tkrdate
10:29:24   4  ,NULL gatt
10:29:24   5  ,g00
10:29:24   6  ,g01
10:29:24   7  ,g02
10:29:24   8  ,g03
10:29:24   9  ,g04
10:29:24  10  ,g05
10:29:24  11  ,g06
10:29:24  12  ,g07
10:29:24  13  ,g08
10:29:24  14  ,g09
10:29:24  15  ,g10
10:29:24  16  ,g11
10:29:24  17  ,g12
10:29:24  18  ,g13
10:29:24  19  ,g14
10:29:24  20  ,g15
10:29:24  21  ,g16
10:29:24  22  ,g17
10:29:24  23  ,g18
10:29:24  24  ,g19
10:29:24  25  ,g20
10:29:24  26  ,g21
10:29:24  27  ,g22
10:29:24  28  ,g23
10:29:24  29  ,g24
10:29:24  30  ,g25
10:29:24  31  ,g26
10:29:24  32  ,g27
10:29:24  33  ,g28
10:29:24  34  ,g29
10:29:24  35  FROM stk_ms
10:29:24  36  WHERE ydate = '&1'
10:29:24  37  AND tkr = '&2'
10:29:24  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-16'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:29:24 SQL> 
10:29:24 SQL> -- rpt
10:29:24 SQL> -- We should see just 1 row:
10:29:24 SQL> 
10:29:24 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:24   2  
10:29:24 SQL> -- Build the model:
10:29:24 SQL> CREATE OR REPLACE VIEW bme AS
10:29:24   2  SELECT
10:29:24   3  tkrdate
10:29:24   4  ,gatt
10:29:24   5  ,g00
10:29:24   6  ,g01
10:29:24   7  ,g02
10:29:24   8  ,g03
10:29:24   9  ,g04
10:29:24  10  ,g05
10:29:24  11  ,g06
10:29:24  12  ,g07
10:29:24  13  ,g08
10:29:24  14  ,g09
10:29:24  15  ,g10
10:29:24  16  ,g11
10:29:24  17  ,g12
10:29:24  18  ,g13
10:29:24  19  ,g14
10:29:24  20  ,g15
10:29:24  21  ,g16
10:29:24  22  ,g17
10:29:24  23  ,g18
10:29:24  24  ,g19
10:29:24  25  ,g20
10:29:24  26  ,g21
10:29:24  27  ,g22
10:29:24  28  ,g23
10:29:24  29  ,g24
10:29:24  30  ,g25
10:29:24  31  ,g26
10:29:24  32  ,g27
10:29:24  33  ,g28
10:29:24  34  ,g29
10:29:24  35  FROM stk_ms
10:29:24  36  WHERE gatt IN('nup','up')
10:29:24  37  -- Use only rows which are older than 1 day:
10:29:24  38  AND 1+ydate < '&1'
10:29:24  39  AND tkr = '&2'
10:29:24  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-16'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:24 SQL> 
10:29:24 SQL> -- rpt
10:29:24 SQL> 
10:29:24 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:24   2  
10:29:24 SQL> SELECT MAX(tkrdate) FROM bme
10:29:24   2  
10:29:24 SQL> -- Now build model from bme and score sme
10:29:24 SQL> @score1.sql gatt
10:29:24 SQL> -- score1.sql
10:29:24 SQL> 
10:29:24 SQL> -- I use this script to send 5 params to score.sql
10:29:24 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:24 SQL> -- Then at the very end of this script I use the model
10:29:24 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:24 SQL> 
10:29:24 SQL> -- I call this script from 2 other scripts:
10:29:24 SQL> -- score1_5min.sql
10:29:24 SQL> -- score1_5min_gattn.sql
10:29:24 SQL> 
10:29:24 SQL> -- The 1st param is the name of the target attribute.
10:29:24 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:24 SQL> 
10:29:24 SQL> -- Demo:
10:29:24 SQL> -- @score1.sql 'gatt'
10:29:24 SQL> -- @score1.sql 'gattn'
10:29:24 SQL> 
10:29:24 SQL> -- Now, I fill up svmc_apply_prep.
10:29:24 SQL> -- I use same model_name used in score.sql
10:29:24 SQL> DEFINE model_name = 'svmspy101'
10:29:24 SQL> DEFINE bldtable	= 'bme'
10:29:24 SQL> DEFINE scoretable = 'sme'
10:29:24 SQL> DEFINE case_id	= 'tkrdate'
10:29:24 SQL> -- Demo:
10:29:24 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:24 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:24 SQL> --
10:29:24 SQL> -- score.sql
10:29:24 SQL> --
10:29:24 SQL> 
10:29:24 SQL> -- usage: score.sql
10:29:24 SQL> 
10:29:24 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:24 SQL> 
10:29:24 SQL> -- DEFINE target	   = 'gatt'
10:29:24 SQL> -- DEFINE model_name = 'svmspy100'
10:29:24 SQL> -- DEFINE bldtable   = 'bme'
10:29:24 SQL> -- DEFINE scoretable = 'sme'
10:29:24 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:24 SQL> 
10:29:24 SQL> DEFINE target	= '&1'
10:29:24 SQL> DEFINE model_name = '&2'
10:29:24 SQL> DEFINE bldtable	= '&3'
10:29:24 SQL> DEFINE scoretable = '&4'
10:29:24 SQL> DEFINE case_id	= '&5'
10:29:24 SQL> 
10:29:24 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:24 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:24 SQL> 
10:29:24 SQL> -- Builds an SVM model using pl/sql.
10:29:24 SQL> 
10:29:24 SQL> -----------------------------------------------------------------------
10:29:24 SQL> --			    BUILD THE MODEL
10:29:24 SQL> -----------------------------------------------------------------------
10:29:24 SQL> 
10:29:24 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:24 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:24 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:24 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:24 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:24 SQL> 
10:29:24 SQL> 
10:29:24 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:24 SQL> --
10:29:24 SQL> -- DROP	TABLE svmc_settings ;
10:29:24 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:24 SQL> -- DELETE svmc_settings;
10:29:24 SQL> 
10:29:24 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:24 SQL> -- this choice to SVM using a settings table.
10:29:24 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:24 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:24 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:24 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:24 SQL> -- models.
10:29:24 SQL> --
10:29:24 SQL> 
10:29:24 SQL> -- Do this once and then comment it out.
10:29:24 SQL> -- That makes script go faster.
10:29:24 SQL> -- BEGIN
10:29:24 SQL> -- -- Populate settings table
10:29:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:24 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:24 SQL> --
10:29:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:24 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:24 SQL> --
10:29:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:24 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:24 SQL> --   COMMIT;
10:29:24 SQL> -- END;
10:29:24 SQL> -- /
10:29:24 SQL> 
10:29:24 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:24 SQL> 
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:24 SQL> 
10:29:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:24 SQL> 
10:29:24 SQL> --------------------------------
10:29:24 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:24 SQL> --
10:29:24 SQL> 
10:29:24 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:24 SQL> -- 2. Outlier Treatment and
10:29:24 SQL> -- 3. Normalization are performed below.
10:29:24 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:24 SQL> --    normalized here.
10:29:24 SQL> 
10:29:24 SQL> BEGIN
10:29:24   2  	-- Perform missing value treatment for all predictors
10:29:24   3  	-- create miss tables
10:29:24   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:24   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:24   6  
10:29:24   7  	-- populate miss tables
10:29:24   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:24   9  	  miss_table_name => 'svmc_miss_num',
10:29:24  10  	  data_table_name => '&bldtable',
10:29:24  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:24  12  
10:29:24  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:24  14  	  miss_table_name => 'svmc_miss_cat',
10:29:24  15  	  data_table_name => '&bldtable',
10:29:24  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:24  17  
10:29:24  18  	-- xform input data to replace missing values
10:29:24  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:24  20  	  miss_table_name => 'svmc_miss_num',
10:29:24  21  	  data_table_name => '&bldtable',
10:29:24  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:24  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:24  24  	  miss_table_name => 'svmc_miss_cat',
10:29:24  25  	  data_table_name => '&bldtable',
10:29:24  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:24  27  
10:29:24  28  	-- Perform outlier treatment.
10:29:24  29  	-- create clip table
10:29:24  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:24  31  
10:29:24  32  	-- populate clip table
10:29:24  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:24  34  	  clip_table_name => 'svmc_clip',
10:29:24  35  	  data_table_name => '&bldtable',
10:29:24  36  	  tail_frac	  => 0.025,
10:29:24  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:24  38  
10:29:24  39  	-- xform input data to winsorized data
10:29:24  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:24  41  	  clip_table_name => 'svmc_clip',
10:29:24  42  	  data_table_name => '&bldtable',
10:29:24  43  	  xform_view_name => 'svmc_winsor');
10:29:24  44  
10:29:24  45  	-- create normalization table
10:29:24  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:24  47  
10:29:24  48  	-- populate normalization table based on winsorized data
10:29:24  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:24  50  	  norm_table_name => 'svmc_norm',
10:29:24  51  	  data_table_name => 'svmc_winsor',
10:29:24  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:24  53  
10:29:24  54  	-- normalize the original data
10:29:24  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:24  56  	  norm_table_name => 'svmc_norm',
10:29:24  57  	  data_table_name => '&bldtable',
10:29:24  58  	  xform_view_name => 'svmc_build_prep');
10:29:24  59  END;
10:29:24  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:29:25 SQL> 
10:29:25 SQL> ---------------------
10:29:25 SQL> -- CREATE A NEW MODEL
10:29:25 SQL> --
10:29:25 SQL> -- Cleanup old model with the same name for repeat runs
10:29:25 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:25   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.89
10:29:27 SQL> 
10:29:27 SQL> -- Build a new SVM Model
10:29:27 SQL> BEGIN
10:29:27   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:27   3  	  model_name	      => '&model_name',
10:29:27   4  	  mining_function     => dbms_data_mining.classification,
10:29:27   5  	  data_table_name     => 'svmc_build_prep',
10:29:27   6  	  case_id_column_name => '&case_id',
10:29:27   7  	  target_column_name  => '&target',
10:29:27   8  	  settings_table_name => 'svmc_settings');
10:29:27   9  END;
10:29:27  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.95
10:29:29 SQL> 
10:29:29 SQL> -----------------------------------------------------------------------
10:29:29 SQL> --			       APPLY/score THE MODEL
10:29:29 SQL> -----------------------------------------------------------------------
10:29:29 SQL> 
10:29:29 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:29 SQL> -----------------------
10:29:29 SQL> -- PREPARE SCORING DATA
10:29:29 SQL> --
10:29:29 SQL> -- If the data for model creation has been prepared, then the data
10:29:29 SQL> -- to be scored using the model must be prepared in the same manner
10:29:29 SQL> -- in order to obtain meaningful results.
10:29:29 SQL> --
10:29:29 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:29 SQL> -- 2. Normalization
10:29:29 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:29 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:29 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:29 SQL> --
10:29:29 SQL> BEGIN
10:29:29   2  	-- Xform Test data to replace missing values
10:29:29   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:29   4  	  miss_table_name => 'svmc_miss_num',
10:29:29   5  	  data_table_name => '&scoretable',
10:29:29   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:29   7  
10:29:29   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:29   9  	  miss_table_name => 'svmc_miss_cat',
10:29:29  10  	  data_table_name => '&scoretable',
10:29:29  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:29  12  
10:29:29  13  	-- Normalize the data to be scored
10:29:29  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:29  15  	  norm_table_name => 'svmc_norm',
10:29:29  16  	  data_table_name => '&scoretable',
10:29:29  17  	  xform_view_name => 'svmc_apply_prep');
10:29:29  18  END;
10:29:29  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:29:29 SQL> 
10:29:29 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:29 SQL> -- DELETE it if I did:
10:29:29 SQL> DELETE ystkscores
10:29:29   2  WHERE score > 0
10:29:29   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:29   4  -- I need to supply the target attribute name:
10:29:29   5  AND targ = '&1'
10:29:29   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:29 SQL> 
10:29:29 SQL> -- We do a drumroll here:
10:29:29 SQL> 
10:29:29 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:29   2  SELECT
10:29:29   3  tkrdate
10:29:29   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:29   5  ,sysdate
10:29:29   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:29   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:29   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:29   9  ,SUBSTR(tkrdate,-10)ydate
10:29:29  10  ,'&1'
10:29:29  11  FROM svmc_apply_prep
10:29:29  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:29 SQL> @score1_5min_gattn.sql	2010-04-29 TLT
10:29:29 SQL> --
10:29:29 SQL> -- score1_5min_gattn.sql
10:29:29 SQL> --
10:29:29 SQL> 
10:29:29 SQL> -- Demo:
10:29:29 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:29:29 SQL> 
10:29:29 SQL> CREATE OR REPLACE VIEW sme AS
10:29:29   2  SELECT
10:29:29   3  tkrdate
10:29:29   4  ,NULL gattn
10:29:29   5  ,g00
10:29:29   6  ,g01
10:29:29   7  ,g02
10:29:29   8  ,g03
10:29:29   9  ,g04
10:29:29  10  ,g05
10:29:29  11  ,g06
10:29:29  12  ,g07
10:29:29  13  ,g08
10:29:29  14  ,g09
10:29:29  15  ,g10
10:29:29  16  ,g11
10:29:29  17  ,g12
10:29:29  18  ,g13
10:29:29  19  ,g14
10:29:29  20  ,g15
10:29:29  21  ,g16
10:29:29  22  ,g17
10:29:29  23  ,g18
10:29:29  24  ,g19
10:29:29  25  ,g20
10:29:29  26  ,g21
10:29:29  27  ,g22
10:29:29  28  ,g23
10:29:29  29  ,g24
10:29:29  30  ,g25
10:29:29  31  ,g26
10:29:29  32  ,g27
10:29:29  33  ,g28
10:29:29  34  ,g29
10:29:29  35  FROM stk_ms
10:29:29  36  WHERE ydate = '&1'
10:29:29  37  AND tkr = '&2'
10:29:29  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-04-29'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:29:29 SQL> 
10:29:29 SQL> -- rpt
10:29:29 SQL> -- We should see just 1 row:
10:29:29 SQL> 
10:29:29 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:29   2  
10:29:29 SQL> -- Build the model:
10:29:29 SQL> CREATE OR REPLACE VIEW bme AS
10:29:29   2  SELECT
10:29:29   3  tkrdate
10:29:29   4  ,gattn
10:29:29   5  ,g00
10:29:29   6  ,g01
10:29:29   7  ,g02
10:29:29   8  ,g03
10:29:29   9  ,g04
10:29:29  10  ,g05
10:29:29  11  ,g06
10:29:29  12  ,g07
10:29:29  13  ,g08
10:29:29  14  ,g09
10:29:29  15  ,g10
10:29:29  16  ,g11
10:29:29  17  ,g12
10:29:29  18  ,g13
10:29:29  19  ,g14
10:29:29  20  ,g15
10:29:29  21  ,g16
10:29:29  22  ,g17
10:29:29  23  ,g18
10:29:29  24  ,g19
10:29:29  25  ,g20
10:29:29  26  ,g21
10:29:29  27  ,g22
10:29:29  28  ,g23
10:29:29  29  ,g24
10:29:29  30  ,g25
10:29:29  31  ,g26
10:29:29  32  ,g27
10:29:29  33  ,g28
10:29:29  34  ,g29
10:29:29  35  FROM stk_ms
10:29:29  36  WHERE gattn IN('nup','up')
10:29:29  37  -- Use only rows which are older than 1 day:
10:29:29  38  AND 1+ydate < '&1'
10:29:29  39  AND tkr = '&2'
10:29:29  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-04-29'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:29 SQL> 
10:29:29 SQL> -- rpt
10:29:29 SQL> 
10:29:29 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:29:29   2  
10:29:29 SQL> SELECT MAX(tkrdate) FROM bme
10:29:29   2  
10:29:29 SQL> -- Now build model from bme and score sme
10:29:29 SQL> @score1.sql gattn
10:29:29 SQL> -- score1.sql
10:29:29 SQL> 
10:29:29 SQL> -- I use this script to send 5 params to score.sql
10:29:29 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:29 SQL> -- Then at the very end of this script I use the model
10:29:29 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:29 SQL> 
10:29:29 SQL> -- I call this script from 2 other scripts:
10:29:29 SQL> -- score1_5min.sql
10:29:29 SQL> -- score1_5min_gattn.sql
10:29:29 SQL> 
10:29:29 SQL> -- The 1st param is the name of the target attribute.
10:29:29 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:29 SQL> 
10:29:29 SQL> -- Demo:
10:29:29 SQL> -- @score1.sql 'gatt'
10:29:29 SQL> -- @score1.sql 'gattn'
10:29:29 SQL> 
10:29:29 SQL> -- Now, I fill up svmc_apply_prep.
10:29:29 SQL> -- I use same model_name used in score.sql
10:29:29 SQL> DEFINE model_name = 'svmspy101'
10:29:29 SQL> DEFINE bldtable	= 'bme'
10:29:29 SQL> DEFINE scoretable = 'sme'
10:29:29 SQL> DEFINE case_id	= 'tkrdate'
10:29:29 SQL> -- Demo:
10:29:29 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:29 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:29 SQL> --
10:29:29 SQL> -- score.sql
10:29:29 SQL> --
10:29:29 SQL> 
10:29:29 SQL> -- usage: score.sql
10:29:29 SQL> 
10:29:29 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:29 SQL> 
10:29:29 SQL> -- DEFINE target	   = 'gatt'
10:29:29 SQL> -- DEFINE model_name = 'svmspy100'
10:29:29 SQL> -- DEFINE bldtable   = 'bme'
10:29:29 SQL> -- DEFINE scoretable = 'sme'
10:29:29 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:29 SQL> 
10:29:29 SQL> DEFINE target	= '&1'
10:29:29 SQL> DEFINE model_name = '&2'
10:29:29 SQL> DEFINE bldtable	= '&3'
10:29:29 SQL> DEFINE scoretable = '&4'
10:29:29 SQL> DEFINE case_id	= '&5'
10:29:29 SQL> 
10:29:29 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:29 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:29 SQL> 
10:29:29 SQL> -- Builds an SVM model using pl/sql.
10:29:29 SQL> 
10:29:29 SQL> -----------------------------------------------------------------------
10:29:29 SQL> --			    BUILD THE MODEL
10:29:29 SQL> -----------------------------------------------------------------------
10:29:29 SQL> 
10:29:29 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:29 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:29 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:29 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:29 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:29 SQL> 
10:29:29 SQL> 
10:29:29 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:29 SQL> --
10:29:29 SQL> -- DROP	TABLE svmc_settings ;
10:29:29 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:29 SQL> -- DELETE svmc_settings;
10:29:29 SQL> 
10:29:29 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:29 SQL> -- this choice to SVM using a settings table.
10:29:29 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:29 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:29 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:29 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:29 SQL> -- models.
10:29:29 SQL> --
10:29:29 SQL> 
10:29:29 SQL> -- Do this once and then comment it out.
10:29:29 SQL> -- That makes script go faster.
10:29:29 SQL> -- BEGIN
10:29:29 SQL> -- -- Populate settings table
10:29:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:29 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:29 SQL> --
10:29:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:29 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:29 SQL> --
10:29:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:29 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:29 SQL> --   COMMIT;
10:29:29 SQL> -- END;
10:29:29 SQL> -- /
10:29:29 SQL> 
10:29:29 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:29 SQL> 
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:29 SQL> 
10:29:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:29 SQL> 
10:29:29 SQL> --------------------------------
10:29:29 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:29 SQL> --
10:29:29 SQL> 
10:29:29 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:29 SQL> -- 2. Outlier Treatment and
10:29:29 SQL> -- 3. Normalization are performed below.
10:29:29 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:29 SQL> --    normalized here.
10:29:29 SQL> 
10:29:29 SQL> BEGIN
10:29:29   2  	-- Perform missing value treatment for all predictors
10:29:29   3  	-- create miss tables
10:29:29   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:29   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:29   6  
10:29:29   7  	-- populate miss tables
10:29:29   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:29   9  	  miss_table_name => 'svmc_miss_num',
10:29:29  10  	  data_table_name => '&bldtable',
10:29:29  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:29  12  
10:29:29  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:29  14  	  miss_table_name => 'svmc_miss_cat',
10:29:29  15  	  data_table_name => '&bldtable',
10:29:29  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:29  17  
10:29:29  18  	-- xform input data to replace missing values
10:29:29  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:29  20  	  miss_table_name => 'svmc_miss_num',
10:29:29  21  	  data_table_name => '&bldtable',
10:29:29  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:29  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:29  24  	  miss_table_name => 'svmc_miss_cat',
10:29:29  25  	  data_table_name => '&bldtable',
10:29:29  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:29  27  
10:29:29  28  	-- Perform outlier treatment.
10:29:29  29  	-- create clip table
10:29:29  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:29  31  
10:29:29  32  	-- populate clip table
10:29:29  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:29  34  	  clip_table_name => 'svmc_clip',
10:29:29  35  	  data_table_name => '&bldtable',
10:29:29  36  	  tail_frac	  => 0.025,
10:29:29  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:29  38  
10:29:29  39  	-- xform input data to winsorized data
10:29:29  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:29  41  	  clip_table_name => 'svmc_clip',
10:29:29  42  	  data_table_name => '&bldtable',
10:29:29  43  	  xform_view_name => 'svmc_winsor');
10:29:29  44  
10:29:29  45  	-- create normalization table
10:29:29  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:29  47  
10:29:29  48  	-- populate normalization table based on winsorized data
10:29:29  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:29  50  	  norm_table_name => 'svmc_norm',
10:29:29  51  	  data_table_name => 'svmc_winsor',
10:29:29  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:29  53  
10:29:29  54  	-- normalize the original data
10:29:29  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:29  56  	  norm_table_name => 'svmc_norm',
10:29:29  57  	  data_table_name => '&bldtable',
10:29:29  58  	  xform_view_name => 'svmc_build_prep');
10:29:29  59  END;
10:29:29  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:29:30 SQL> 
10:29:30 SQL> ---------------------
10:29:30 SQL> -- CREATE A NEW MODEL
10:29:30 SQL> --
10:29:30 SQL> -- Cleanup old model with the same name for repeat runs
10:29:30 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:30   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.79
10:29:32 SQL> 
10:29:32 SQL> -- Build a new SVM Model
10:29:32 SQL> BEGIN
10:29:32   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:32   3  	  model_name	      => '&model_name',
10:29:32   4  	  mining_function     => dbms_data_mining.classification,
10:29:32   5  	  data_table_name     => 'svmc_build_prep',
10:29:32   6  	  case_id_column_name => '&case_id',
10:29:32   7  	  target_column_name  => '&target',
10:29:32   8  	  settings_table_name => 'svmc_settings');
10:29:32   9  END;
10:29:32  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.35
10:29:34 SQL> 
10:29:34 SQL> -----------------------------------------------------------------------
10:29:34 SQL> --			       APPLY/score THE MODEL
10:29:34 SQL> -----------------------------------------------------------------------
10:29:34 SQL> 
10:29:34 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
10:29:34 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:34   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:34 SQL> -----------------------
10:29:34 SQL> -- PREPARE SCORING DATA
10:29:34 SQL> --
10:29:34 SQL> -- If the data for model creation has been prepared, then the data
10:29:34 SQL> -- to be scored using the model must be prepared in the same manner
10:29:34 SQL> -- in order to obtain meaningful results.
10:29:34 SQL> --
10:29:34 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:34 SQL> -- 2. Normalization
10:29:34 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:34 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:34 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:34 SQL> --
10:29:34 SQL> BEGIN
10:29:34   2  	-- Xform Test data to replace missing values
10:29:34   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:34   4  	  miss_table_name => 'svmc_miss_num',
10:29:34   5  	  data_table_name => '&scoretable',
10:29:34   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:34   7  
10:29:34   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:34   9  	  miss_table_name => 'svmc_miss_cat',
10:29:34  10  	  data_table_name => '&scoretable',
10:29:34  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:34  12  
10:29:34  13  	-- Normalize the data to be scored
10:29:34  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:34  15  	  norm_table_name => 'svmc_norm',
10:29:34  16  	  data_table_name => '&scoretable',
10:29:34  17  	  xform_view_name => 'svmc_apply_prep');
10:29:34  18  END;
10:29:34  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:29:34 SQL> 
10:29:34 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:34 SQL> -- DELETE it if I did:
10:29:34 SQL> DELETE ystkscores
10:29:34   2  WHERE score > 0
10:29:34   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:34   4  -- I need to supply the target attribute name:
10:29:34   5  AND targ = '&1'
10:29:34   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:34 SQL> 
10:29:34 SQL> -- We do a drumroll here:
10:29:34 SQL> 
10:29:34 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:34   2  SELECT
10:29:34   3  tkrdate
10:29:34   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:34   5  ,sysdate
10:29:34   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:34   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:34   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:34   9  ,SUBSTR(tkrdate,-10)ydate
10:29:34  10  ,'&1'
10:29:34  11  FROM svmc_apply_prep
10:29:34  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:29:34 SQL> @score1_5min.sql	      2010-05-06 TLT
10:29:34 SQL> --
10:29:34 SQL> -- score1_5min.sql
10:29:34 SQL> --
10:29:34 SQL> 
10:29:34 SQL> -- Demo:
10:29:34 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:34 SQL> 
10:29:34 SQL> CREATE OR REPLACE VIEW sme AS
10:29:34   2  SELECT
10:29:34   3  tkrdate
10:29:34   4  ,NULL gatt
10:29:34   5  ,g00
10:29:34   6  ,g01
10:29:34   7  ,g02
10:29:34   8  ,g03
10:29:34   9  ,g04
10:29:34  10  ,g05
10:29:34  11  ,g06
10:29:34  12  ,g07
10:29:34  13  ,g08
10:29:34  14  ,g09
10:29:34  15  ,g10
10:29:34  16  ,g11
10:29:34  17  ,g12
10:29:34  18  ,g13
10:29:34  19  ,g14
10:29:34  20  ,g15
10:29:34  21  ,g16
10:29:34  22  ,g17
10:29:34  23  ,g18
10:29:34  24  ,g19
10:29:34  25  ,g20
10:29:34  26  ,g21
10:29:34  27  ,g22
10:29:34  28  ,g23
10:29:34  29  ,g24
10:29:34  30  ,g25
10:29:34  31  ,g26
10:29:34  32  ,g27
10:29:34  33  ,g28
10:29:34  34  ,g29
10:29:34  35  FROM stk_ms
10:29:34  36  WHERE ydate = '&1'
10:29:34  37  AND tkr = '&2'
10:29:34  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-05-06'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:29:34 SQL> 
10:29:34 SQL> -- rpt
10:29:34 SQL> -- We should see just 1 row:
10:29:34 SQL> 
10:29:34 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:34   2  
10:29:34 SQL> -- Build the model:
10:29:35 SQL> CREATE OR REPLACE VIEW bme AS
10:29:35   2  SELECT
10:29:35   3  tkrdate
10:29:35   4  ,gatt
10:29:35   5  ,g00
10:29:35   6  ,g01
10:29:35   7  ,g02
10:29:35   8  ,g03
10:29:35   9  ,g04
10:29:35  10  ,g05
10:29:35  11  ,g06
10:29:35  12  ,g07
10:29:35  13  ,g08
10:29:35  14  ,g09
10:29:35  15  ,g10
10:29:35  16  ,g11
10:29:35  17  ,g12
10:29:35  18  ,g13
10:29:35  19  ,g14
10:29:35  20  ,g15
10:29:35  21  ,g16
10:29:35  22  ,g17
10:29:35  23  ,g18
10:29:35  24  ,g19
10:29:35  25  ,g20
10:29:35  26  ,g21
10:29:35  27  ,g22
10:29:35  28  ,g23
10:29:35  29  ,g24
10:29:35  30  ,g25
10:29:35  31  ,g26
10:29:35  32  ,g27
10:29:35  33  ,g28
10:29:35  34  ,g29
10:29:35  35  FROM stk_ms
10:29:35  36  WHERE gatt IN('nup','up')
10:29:35  37  -- Use only rows which are older than 1 day:
10:29:35  38  AND 1+ydate < '&1'
10:29:35  39  AND tkr = '&2'
10:29:35  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-05-06'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:35 SQL> 
10:29:35 SQL> -- rpt
10:29:35 SQL> 
10:29:35 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:35   2  
10:29:35 SQL> SELECT MAX(tkrdate) FROM bme
10:29:35   2  
10:29:35 SQL> -- Now build model from bme and score sme
10:29:35 SQL> @score1.sql gatt
10:29:35 SQL> -- score1.sql
10:29:35 SQL> 
10:29:35 SQL> -- I use this script to send 5 params to score.sql
10:29:35 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:35 SQL> -- Then at the very end of this script I use the model
10:29:35 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:35 SQL> 
10:29:35 SQL> -- I call this script from 2 other scripts:
10:29:35 SQL> -- score1_5min.sql
10:29:35 SQL> -- score1_5min_gattn.sql
10:29:35 SQL> 
10:29:35 SQL> -- The 1st param is the name of the target attribute.
10:29:35 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:35 SQL> 
10:29:35 SQL> -- Demo:
10:29:35 SQL> -- @score1.sql 'gatt'
10:29:35 SQL> -- @score1.sql 'gattn'
10:29:35 SQL> 
10:29:35 SQL> -- Now, I fill up svmc_apply_prep.
10:29:35 SQL> -- I use same model_name used in score.sql
10:29:35 SQL> DEFINE model_name = 'svmspy101'
10:29:35 SQL> DEFINE bldtable	= 'bme'
10:29:35 SQL> DEFINE scoretable = 'sme'
10:29:35 SQL> DEFINE case_id	= 'tkrdate'
10:29:35 SQL> -- Demo:
10:29:35 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:35 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:35 SQL> --
10:29:35 SQL> -- score.sql
10:29:35 SQL> --
10:29:35 SQL> 
10:29:35 SQL> -- usage: score.sql
10:29:35 SQL> 
10:29:35 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:35 SQL> 
10:29:35 SQL> -- DEFINE target	   = 'gatt'
10:29:35 SQL> -- DEFINE model_name = 'svmspy100'
10:29:35 SQL> -- DEFINE bldtable   = 'bme'
10:29:35 SQL> -- DEFINE scoretable = 'sme'
10:29:35 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:35 SQL> 
10:29:35 SQL> DEFINE target	= '&1'
10:29:35 SQL> DEFINE model_name = '&2'
10:29:35 SQL> DEFINE bldtable	= '&3'
10:29:35 SQL> DEFINE scoretable = '&4'
10:29:35 SQL> DEFINE case_id	= '&5'
10:29:35 SQL> 
10:29:35 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:35 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:35 SQL> 
10:29:35 SQL> -- Builds an SVM model using pl/sql.
10:29:35 SQL> 
10:29:35 SQL> -----------------------------------------------------------------------
10:29:35 SQL> --			    BUILD THE MODEL
10:29:35 SQL> -----------------------------------------------------------------------
10:29:35 SQL> 
10:29:35 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:35 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:35 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:35 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:35 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:35 SQL> 
10:29:35 SQL> 
10:29:35 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:35 SQL> --
10:29:35 SQL> -- DROP	TABLE svmc_settings ;
10:29:35 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:35 SQL> -- DELETE svmc_settings;
10:29:35 SQL> 
10:29:35 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:35 SQL> -- this choice to SVM using a settings table.
10:29:35 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:35 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:35 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:35 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:35 SQL> -- models.
10:29:35 SQL> --
10:29:35 SQL> 
10:29:35 SQL> -- Do this once and then comment it out.
10:29:35 SQL> -- That makes script go faster.
10:29:35 SQL> -- BEGIN
10:29:35 SQL> -- -- Populate settings table
10:29:35 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:35 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:35 SQL> --
10:29:35 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:35 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:35 SQL> --
10:29:35 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:35 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:35 SQL> --   COMMIT;
10:29:35 SQL> -- END;
10:29:35 SQL> -- /
10:29:35 SQL> 
10:29:35 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:35 SQL> 
10:29:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:29:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:29:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:35 SQL> 
10:29:35 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:35   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:35 SQL> 
10:29:35 SQL> --------------------------------
10:29:35 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:35 SQL> --
10:29:35 SQL> 
10:29:35 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:35 SQL> -- 2. Outlier Treatment and
10:29:35 SQL> -- 3. Normalization are performed below.
10:29:35 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:35 SQL> --    normalized here.
10:29:35 SQL> 
10:29:35 SQL> BEGIN
10:29:35   2  	-- Perform missing value treatment for all predictors
10:29:35   3  	-- create miss tables
10:29:35   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:35   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:35   6  
10:29:35   7  	-- populate miss tables
10:29:35   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:35   9  	  miss_table_name => 'svmc_miss_num',
10:29:35  10  	  data_table_name => '&bldtable',
10:29:35  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:35  12  
10:29:35  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:35  14  	  miss_table_name => 'svmc_miss_cat',
10:29:35  15  	  data_table_name => '&bldtable',
10:29:35  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:35  17  
10:29:35  18  	-- xform input data to replace missing values
10:29:35  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:35  20  	  miss_table_name => 'svmc_miss_num',
10:29:35  21  	  data_table_name => '&bldtable',
10:29:35  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:35  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:35  24  	  miss_table_name => 'svmc_miss_cat',
10:29:35  25  	  data_table_name => '&bldtable',
10:29:35  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:35  27  
10:29:35  28  	-- Perform outlier treatment.
10:29:35  29  	-- create clip table
10:29:35  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:35  31  
10:29:35  32  	-- populate clip table
10:29:35  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:35  34  	  clip_table_name => 'svmc_clip',
10:29:35  35  	  data_table_name => '&bldtable',
10:29:35  36  	  tail_frac	  => 0.025,
10:29:35  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:35  38  
10:29:35  39  	-- xform input data to winsorized data
10:29:35  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:35  41  	  clip_table_name => 'svmc_clip',
10:29:35  42  	  data_table_name => '&bldtable',
10:29:35  43  	  xform_view_name => 'svmc_winsor');
10:29:35  44  
10:29:35  45  	-- create normalization table
10:29:35  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:35  47  
10:29:35  48  	-- populate normalization table based on winsorized data
10:29:35  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:35  50  	  norm_table_name => 'svmc_norm',
10:29:35  51  	  data_table_name => 'svmc_winsor',
10:29:35  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:35  53  
10:29:35  54  	-- normalize the original data
10:29:35  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:35  56  	  norm_table_name => 'svmc_norm',
10:29:35  57  	  data_table_name => '&bldtable',
10:29:35  58  	  xform_view_name => 'svmc_build_prep');
10:29:35  59  END;
10:29:35  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.58
10:29:35 SQL> 
10:29:35 SQL> ---------------------
10:29:35 SQL> -- CREATE A NEW MODEL
10:29:35 SQL> --
10:29:35 SQL> -- Cleanup old model with the same name for repeat runs
10:29:35 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:35   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:35   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.99
10:29:36 SQL> 
10:29:36 SQL> -- Build a new SVM Model
10:29:36 SQL> BEGIN
10:29:36   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:36   3  	  model_name	      => '&model_name',
10:29:36   4  	  mining_function     => dbms_data_mining.classification,
10:29:36   5  	  data_table_name     => 'svmc_build_prep',
10:29:36   6  	  case_id_column_name => '&case_id',
10:29:36   7  	  target_column_name  => '&target',
10:29:36   8  	  settings_table_name => 'svmc_settings');
10:29:36   9  END;
10:29:36  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.30
10:29:39 SQL> 
10:29:39 SQL> -----------------------------------------------------------------------
10:29:39 SQL> --			       APPLY/score THE MODEL
10:29:39 SQL> -----------------------------------------------------------------------
10:29:39 SQL> 
10:29:39 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:29:39 SQL> -----------------------
10:29:39 SQL> -- PREPARE SCORING DATA
10:29:39 SQL> --
10:29:39 SQL> -- If the data for model creation has been prepared, then the data
10:29:39 SQL> -- to be scored using the model must be prepared in the same manner
10:29:39 SQL> -- in order to obtain meaningful results.
10:29:39 SQL> --
10:29:39 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:39 SQL> -- 2. Normalization
10:29:39 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:39 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:39 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:39 SQL> --
10:29:39 SQL> BEGIN
10:29:39   2  	-- Xform Test data to replace missing values
10:29:39   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:39   4  	  miss_table_name => 'svmc_miss_num',
10:29:39   5  	  data_table_name => '&scoretable',
10:29:39   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:39   7  
10:29:39   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:39   9  	  miss_table_name => 'svmc_miss_cat',
10:29:39  10  	  data_table_name => '&scoretable',
10:29:39  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:39  12  
10:29:39  13  	-- Normalize the data to be scored
10:29:39  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:39  15  	  norm_table_name => 'svmc_norm',
10:29:39  16  	  data_table_name => '&scoretable',
10:29:39  17  	  xform_view_name => 'svmc_apply_prep');
10:29:39  18  END;
10:29:39  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:29:39 SQL> 
10:29:39 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:39 SQL> -- DELETE it if I did:
10:29:39 SQL> DELETE ystkscores
10:29:39   2  WHERE score > 0
10:29:39   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:39   4  -- I need to supply the target attribute name:
10:29:39   5  AND targ = '&1'
10:29:39   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:39 SQL> 
10:29:39 SQL> -- We do a drumroll here:
10:29:39 SQL> 
10:29:39 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:39   2  SELECT
10:29:39   3  tkrdate
10:29:39   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:39   5  ,sysdate
10:29:39   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:39   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:39   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:39   9  ,SUBSTR(tkrdate,-10)ydate
10:29:39  10  ,'&1'
10:29:39  11  FROM svmc_apply_prep
10:29:39  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:39 SQL> @score1_5min_gattn.sql	2009-12-16 TLT
10:29:39 SQL> --
10:29:39 SQL> -- score1_5min_gattn.sql
10:29:39 SQL> --
10:29:39 SQL> 
10:29:39 SQL> -- Demo:
10:29:39 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:29:39 SQL> 
10:29:39 SQL> CREATE OR REPLACE VIEW sme AS
10:29:39   2  SELECT
10:29:39   3  tkrdate
10:29:39   4  ,NULL gattn
10:29:39   5  ,g00
10:29:39   6  ,g01
10:29:39   7  ,g02
10:29:39   8  ,g03
10:29:39   9  ,g04
10:29:39  10  ,g05
10:29:39  11  ,g06
10:29:39  12  ,g07
10:29:39  13  ,g08
10:29:39  14  ,g09
10:29:39  15  ,g10
10:29:39  16  ,g11
10:29:39  17  ,g12
10:29:39  18  ,g13
10:29:39  19  ,g14
10:29:39  20  ,g15
10:29:39  21  ,g16
10:29:39  22  ,g17
10:29:39  23  ,g18
10:29:39  24  ,g19
10:29:39  25  ,g20
10:29:39  26  ,g21
10:29:39  27  ,g22
10:29:39  28  ,g23
10:29:39  29  ,g24
10:29:39  30  ,g25
10:29:39  31  ,g26
10:29:39  32  ,g27
10:29:39  33  ,g28
10:29:39  34  ,g29
10:29:39  35  FROM stk_ms
10:29:39  36  WHERE ydate = '&1'
10:29:39  37  AND tkr = '&2'
10:29:39  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-16'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:39 SQL> 
10:29:39 SQL> -- rpt
10:29:39 SQL> -- We should see just 1 row:
10:29:39 SQL> 
10:29:39 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:39   2  
10:29:39 SQL> -- Build the model:
10:29:39 SQL> CREATE OR REPLACE VIEW bme AS
10:29:39   2  SELECT
10:29:39   3  tkrdate
10:29:39   4  ,gattn
10:29:39   5  ,g00
10:29:39   6  ,g01
10:29:39   7  ,g02
10:29:39   8  ,g03
10:29:39   9  ,g04
10:29:39  10  ,g05
10:29:39  11  ,g06
10:29:39  12  ,g07
10:29:39  13  ,g08
10:29:39  14  ,g09
10:29:39  15  ,g10
10:29:39  16  ,g11
10:29:39  17  ,g12
10:29:39  18  ,g13
10:29:39  19  ,g14
10:29:39  20  ,g15
10:29:39  21  ,g16
10:29:39  22  ,g17
10:29:39  23  ,g18
10:29:39  24  ,g19
10:29:39  25  ,g20
10:29:39  26  ,g21
10:29:39  27  ,g22
10:29:39  28  ,g23
10:29:39  29  ,g24
10:29:39  30  ,g25
10:29:39  31  ,g26
10:29:39  32  ,g27
10:29:39  33  ,g28
10:29:39  34  ,g29
10:29:39  35  FROM stk_ms
10:29:39  36  WHERE gattn IN('nup','up')
10:29:39  37  -- Use only rows which are older than 1 day:
10:29:39  38  AND 1+ydate < '&1'
10:29:39  39  AND tkr = '&2'
10:29:39  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-16'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:39 SQL> 
10:29:39 SQL> -- rpt
10:29:39 SQL> 
10:29:39 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:29:39   2  
10:29:39 SQL> SELECT MAX(tkrdate) FROM bme
10:29:39   2  
10:29:39 SQL> -- Now build model from bme and score sme
10:29:39 SQL> @score1.sql gattn
10:29:39 SQL> -- score1.sql
10:29:39 SQL> 
10:29:39 SQL> -- I use this script to send 5 params to score.sql
10:29:39 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:39 SQL> -- Then at the very end of this script I use the model
10:29:39 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:39 SQL> 
10:29:39 SQL> -- I call this script from 2 other scripts:
10:29:39 SQL> -- score1_5min.sql
10:29:39 SQL> -- score1_5min_gattn.sql
10:29:39 SQL> 
10:29:39 SQL> -- The 1st param is the name of the target attribute.
10:29:39 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:39 SQL> 
10:29:39 SQL> -- Demo:
10:29:39 SQL> -- @score1.sql 'gatt'
10:29:39 SQL> -- @score1.sql 'gattn'
10:29:39 SQL> 
10:29:39 SQL> -- Now, I fill up svmc_apply_prep.
10:29:39 SQL> -- I use same model_name used in score.sql
10:29:39 SQL> DEFINE model_name = 'svmspy101'
10:29:39 SQL> DEFINE bldtable	= 'bme'
10:29:39 SQL> DEFINE scoretable = 'sme'
10:29:39 SQL> DEFINE case_id	= 'tkrdate'
10:29:39 SQL> -- Demo:
10:29:39 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:39 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:39 SQL> --
10:29:39 SQL> -- score.sql
10:29:39 SQL> --
10:29:39 SQL> 
10:29:39 SQL> -- usage: score.sql
10:29:39 SQL> 
10:29:39 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:39 SQL> 
10:29:39 SQL> -- DEFINE target	   = 'gatt'
10:29:39 SQL> -- DEFINE model_name = 'svmspy100'
10:29:39 SQL> -- DEFINE bldtable   = 'bme'
10:29:39 SQL> -- DEFINE scoretable = 'sme'
10:29:39 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:39 SQL> 
10:29:39 SQL> DEFINE target	= '&1'
10:29:39 SQL> DEFINE model_name = '&2'
10:29:39 SQL> DEFINE bldtable	= '&3'
10:29:39 SQL> DEFINE scoretable = '&4'
10:29:39 SQL> DEFINE case_id	= '&5'
10:29:39 SQL> 
10:29:39 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:39 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:39 SQL> 
10:29:39 SQL> -- Builds an SVM model using pl/sql.
10:29:39 SQL> 
10:29:39 SQL> -----------------------------------------------------------------------
10:29:39 SQL> --			    BUILD THE MODEL
10:29:39 SQL> -----------------------------------------------------------------------
10:29:39 SQL> 
10:29:39 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:39 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:39 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:39 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:39 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:39 SQL> 
10:29:39 SQL> 
10:29:39 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:39 SQL> --
10:29:39 SQL> -- DROP	TABLE svmc_settings ;
10:29:39 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:39 SQL> -- DELETE svmc_settings;
10:29:39 SQL> 
10:29:39 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:39 SQL> -- this choice to SVM using a settings table.
10:29:39 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:39 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:39 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:39 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:39 SQL> -- models.
10:29:39 SQL> --
10:29:39 SQL> 
10:29:39 SQL> -- Do this once and then comment it out.
10:29:39 SQL> -- That makes script go faster.
10:29:39 SQL> -- BEGIN
10:29:39 SQL> -- -- Populate settings table
10:29:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:39 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:39 SQL> --
10:29:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:39 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:39 SQL> --
10:29:39 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:39 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:39 SQL> --   COMMIT;
10:29:39 SQL> -- END;
10:29:39 SQL> -- /
10:29:39 SQL> 
10:29:39 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:39 SQL> 
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:39 SQL> 
10:29:39 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:39   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:39 SQL> 
10:29:39 SQL> --------------------------------
10:29:39 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:39 SQL> --
10:29:39 SQL> 
10:29:39 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:39 SQL> -- 2. Outlier Treatment and
10:29:39 SQL> -- 3. Normalization are performed below.
10:29:39 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:39 SQL> --    normalized here.
10:29:39 SQL> 
10:29:39 SQL> BEGIN
10:29:39   2  	-- Perform missing value treatment for all predictors
10:29:39   3  	-- create miss tables
10:29:39   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:39   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:39   6  
10:29:39   7  	-- populate miss tables
10:29:39   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:39   9  	  miss_table_name => 'svmc_miss_num',
10:29:39  10  	  data_table_name => '&bldtable',
10:29:39  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:39  12  
10:29:39  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:39  14  	  miss_table_name => 'svmc_miss_cat',
10:29:39  15  	  data_table_name => '&bldtable',
10:29:39  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:39  17  
10:29:39  18  	-- xform input data to replace missing values
10:29:39  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:39  20  	  miss_table_name => 'svmc_miss_num',
10:29:39  21  	  data_table_name => '&bldtable',
10:29:39  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:39  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:39  24  	  miss_table_name => 'svmc_miss_cat',
10:29:39  25  	  data_table_name => '&bldtable',
10:29:39  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:39  27  
10:29:39  28  	-- Perform outlier treatment.
10:29:39  29  	-- create clip table
10:29:39  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:39  31  
10:29:39  32  	-- populate clip table
10:29:39  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:39  34  	  clip_table_name => 'svmc_clip',
10:29:39  35  	  data_table_name => '&bldtable',
10:29:39  36  	  tail_frac	  => 0.025,
10:29:39  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:39  38  
10:29:39  39  	-- xform input data to winsorized data
10:29:39  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:39  41  	  clip_table_name => 'svmc_clip',
10:29:39  42  	  data_table_name => '&bldtable',
10:29:39  43  	  xform_view_name => 'svmc_winsor');
10:29:39  44  
10:29:39  45  	-- create normalization table
10:29:39  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:39  47  
10:29:39  48  	-- populate normalization table based on winsorized data
10:29:39  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:39  50  	  norm_table_name => 'svmc_norm',
10:29:39  51  	  data_table_name => 'svmc_winsor',
10:29:39  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:39  53  
10:29:39  54  	-- normalize the original data
10:29:39  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:39  56  	  norm_table_name => 'svmc_norm',
10:29:39  57  	  data_table_name => '&bldtable',
10:29:39  58  	  xform_view_name => 'svmc_build_prep');
10:29:39  59  END;
10:29:39  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:29:40 SQL> 
10:29:40 SQL> ---------------------
10:29:40 SQL> -- CREATE A NEW MODEL
10:29:40 SQL> --
10:29:40 SQL> -- Cleanup old model with the same name for repeat runs
10:29:40 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:40   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:40   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.75
10:29:42 SQL> 
10:29:42 SQL> -- Build a new SVM Model
10:29:42 SQL> BEGIN
10:29:42   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:42   3  	  model_name	      => '&model_name',
10:29:42   4  	  mining_function     => dbms_data_mining.classification,
10:29:42   5  	  data_table_name     => 'svmc_build_prep',
10:29:42   6  	  case_id_column_name => '&case_id',
10:29:42   7  	  target_column_name  => '&target',
10:29:42   8  	  settings_table_name => 'svmc_settings');
10:29:42   9  END;
10:29:42  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.09
10:29:44 SQL> 
10:29:44 SQL> -----------------------------------------------------------------------
10:29:44 SQL> --			       APPLY/score THE MODEL
10:29:44 SQL> -----------------------------------------------------------------------
10:29:44 SQL> 
10:29:44 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:44 SQL> -----------------------
10:29:44 SQL> -- PREPARE SCORING DATA
10:29:44 SQL> --
10:29:44 SQL> -- If the data for model creation has been prepared, then the data
10:29:44 SQL> -- to be scored using the model must be prepared in the same manner
10:29:44 SQL> -- in order to obtain meaningful results.
10:29:44 SQL> --
10:29:44 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:44 SQL> -- 2. Normalization
10:29:44 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:44 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:44 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:44 SQL> --
10:29:44 SQL> BEGIN
10:29:44   2  	-- Xform Test data to replace missing values
10:29:44   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:44   4  	  miss_table_name => 'svmc_miss_num',
10:29:44   5  	  data_table_name => '&scoretable',
10:29:44   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:44   7  
10:29:44   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:44   9  	  miss_table_name => 'svmc_miss_cat',
10:29:44  10  	  data_table_name => '&scoretable',
10:29:44  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:44  12  
10:29:44  13  	-- Normalize the data to be scored
10:29:44  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:44  15  	  norm_table_name => 'svmc_norm',
10:29:44  16  	  data_table_name => '&scoretable',
10:29:44  17  	  xform_view_name => 'svmc_apply_prep');
10:29:44  18  END;
10:29:44  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:29:44 SQL> 
10:29:44 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:44 SQL> -- DELETE it if I did:
10:29:44 SQL> DELETE ystkscores
10:29:44   2  WHERE score > 0
10:29:44   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:44   4  -- I need to supply the target attribute name:
10:29:44   5  AND targ = '&1'
10:29:44   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:29:44 SQL> 
10:29:44 SQL> -- We do a drumroll here:
10:29:44 SQL> 
10:29:44 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:44   2  SELECT
10:29:44   3  tkrdate
10:29:44   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:44   5  ,sysdate
10:29:44   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:44   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:44   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:44   9  ,SUBSTR(tkrdate,-10)ydate
10:29:44  10  ,'&1'
10:29:44  11  FROM svmc_apply_prep
10:29:44  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:29:44 SQL> @score1_5min.sql	      2010-05-03 TLT
10:29:44 SQL> --
10:29:44 SQL> -- score1_5min.sql
10:29:44 SQL> --
10:29:44 SQL> 
10:29:44 SQL> -- Demo:
10:29:44 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:44 SQL> 
10:29:44 SQL> CREATE OR REPLACE VIEW sme AS
10:29:44   2  SELECT
10:29:44   3  tkrdate
10:29:44   4  ,NULL gatt
10:29:44   5  ,g00
10:29:44   6  ,g01
10:29:44   7  ,g02
10:29:44   8  ,g03
10:29:44   9  ,g04
10:29:44  10  ,g05
10:29:44  11  ,g06
10:29:44  12  ,g07
10:29:44  13  ,g08
10:29:44  14  ,g09
10:29:44  15  ,g10
10:29:44  16  ,g11
10:29:44  17  ,g12
10:29:44  18  ,g13
10:29:44  19  ,g14
10:29:44  20  ,g15
10:29:44  21  ,g16
10:29:44  22  ,g17
10:29:44  23  ,g18
10:29:44  24  ,g19
10:29:44  25  ,g20
10:29:44  26  ,g21
10:29:44  27  ,g22
10:29:44  28  ,g23
10:29:44  29  ,g24
10:29:44  30  ,g25
10:29:44  31  ,g26
10:29:44  32  ,g27
10:29:44  33  ,g28
10:29:44  34  ,g29
10:29:44  35  FROM stk_ms
10:29:44  36  WHERE ydate = '&1'
10:29:44  37  AND tkr = '&2'
10:29:44  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-05-03'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.10
10:29:44 SQL> 
10:29:44 SQL> -- rpt
10:29:44 SQL> -- We should see just 1 row:
10:29:44 SQL> 
10:29:44 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:44   2  
10:29:44 SQL> -- Build the model:
10:29:44 SQL> CREATE OR REPLACE VIEW bme AS
10:29:44   2  SELECT
10:29:44   3  tkrdate
10:29:44   4  ,gatt
10:29:44   5  ,g00
10:29:44   6  ,g01
10:29:44   7  ,g02
10:29:44   8  ,g03
10:29:44   9  ,g04
10:29:44  10  ,g05
10:29:44  11  ,g06
10:29:44  12  ,g07
10:29:44  13  ,g08
10:29:44  14  ,g09
10:29:44  15  ,g10
10:29:44  16  ,g11
10:29:44  17  ,g12
10:29:44  18  ,g13
10:29:44  19  ,g14
10:29:44  20  ,g15
10:29:44  21  ,g16
10:29:44  22  ,g17
10:29:44  23  ,g18
10:29:44  24  ,g19
10:29:44  25  ,g20
10:29:44  26  ,g21
10:29:44  27  ,g22
10:29:44  28  ,g23
10:29:44  29  ,g24
10:29:44  30  ,g25
10:29:44  31  ,g26
10:29:44  32  ,g27
10:29:44  33  ,g28
10:29:44  34  ,g29
10:29:44  35  FROM stk_ms
10:29:44  36  WHERE gatt IN('nup','up')
10:29:44  37  -- Use only rows which are older than 1 day:
10:29:44  38  AND 1+ydate < '&1'
10:29:44  39  AND tkr = '&2'
10:29:44  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-05-03'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.06
10:29:44 SQL> 
10:29:44 SQL> -- rpt
10:29:44 SQL> 
10:29:44 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:44   2  
10:29:44 SQL> SELECT MAX(tkrdate) FROM bme
10:29:44   2  
10:29:44 SQL> -- Now build model from bme and score sme
10:29:44 SQL> @score1.sql gatt
10:29:44 SQL> -- score1.sql
10:29:44 SQL> 
10:29:44 SQL> -- I use this script to send 5 params to score.sql
10:29:44 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:44 SQL> -- Then at the very end of this script I use the model
10:29:44 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:44 SQL> 
10:29:44 SQL> -- I call this script from 2 other scripts:
10:29:44 SQL> -- score1_5min.sql
10:29:44 SQL> -- score1_5min_gattn.sql
10:29:44 SQL> 
10:29:44 SQL> -- The 1st param is the name of the target attribute.
10:29:44 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:44 SQL> 
10:29:44 SQL> -- Demo:
10:29:44 SQL> -- @score1.sql 'gatt'
10:29:44 SQL> -- @score1.sql 'gattn'
10:29:44 SQL> 
10:29:44 SQL> -- Now, I fill up svmc_apply_prep.
10:29:44 SQL> -- I use same model_name used in score.sql
10:29:44 SQL> DEFINE model_name = 'svmspy101'
10:29:44 SQL> DEFINE bldtable	= 'bme'
10:29:44 SQL> DEFINE scoretable = 'sme'
10:29:44 SQL> DEFINE case_id	= 'tkrdate'
10:29:44 SQL> -- Demo:
10:29:44 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:44 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:44 SQL> --
10:29:44 SQL> -- score.sql
10:29:44 SQL> --
10:29:44 SQL> 
10:29:44 SQL> -- usage: score.sql
10:29:44 SQL> 
10:29:44 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:44 SQL> 
10:29:44 SQL> -- DEFINE target	   = 'gatt'
10:29:44 SQL> -- DEFINE model_name = 'svmspy100'
10:29:44 SQL> -- DEFINE bldtable   = 'bme'
10:29:44 SQL> -- DEFINE scoretable = 'sme'
10:29:44 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:44 SQL> 
10:29:44 SQL> DEFINE target	= '&1'
10:29:44 SQL> DEFINE model_name = '&2'
10:29:44 SQL> DEFINE bldtable	= '&3'
10:29:44 SQL> DEFINE scoretable = '&4'
10:29:44 SQL> DEFINE case_id	= '&5'
10:29:44 SQL> 
10:29:44 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:44 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:44 SQL> 
10:29:44 SQL> -- Builds an SVM model using pl/sql.
10:29:44 SQL> 
10:29:44 SQL> -----------------------------------------------------------------------
10:29:44 SQL> --			    BUILD THE MODEL
10:29:44 SQL> -----------------------------------------------------------------------
10:29:44 SQL> 
10:29:44 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:44 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:44 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:44 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:44 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:44 SQL> 
10:29:44 SQL> 
10:29:44 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:44 SQL> --
10:29:44 SQL> -- DROP	TABLE svmc_settings ;
10:29:44 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:44 SQL> -- DELETE svmc_settings;
10:29:44 SQL> 
10:29:44 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:44 SQL> -- this choice to SVM using a settings table.
10:29:44 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:44 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:44 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:44 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:44 SQL> -- models.
10:29:44 SQL> --
10:29:44 SQL> 
10:29:44 SQL> -- Do this once and then comment it out.
10:29:44 SQL> -- That makes script go faster.
10:29:44 SQL> -- BEGIN
10:29:44 SQL> -- -- Populate settings table
10:29:44 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:44 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:44 SQL> --
10:29:44 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:44 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:44 SQL> --
10:29:44 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:44 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:44 SQL> --   COMMIT;
10:29:44 SQL> -- END;
10:29:44 SQL> -- /
10:29:44 SQL> 
10:29:44 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:44 SQL> 
10:29:44 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:44   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.28
10:29:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:45 SQL> 
10:29:45 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:45   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:45 SQL> 
10:29:45 SQL> --------------------------------
10:29:45 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:45 SQL> --
10:29:45 SQL> 
10:29:45 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:45 SQL> -- 2. Outlier Treatment and
10:29:45 SQL> -- 3. Normalization are performed below.
10:29:45 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:45 SQL> --    normalized here.
10:29:45 SQL> 
10:29:45 SQL> BEGIN
10:29:45   2  	-- Perform missing value treatment for all predictors
10:29:45   3  	-- create miss tables
10:29:45   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:45   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:45   6  
10:29:45   7  	-- populate miss tables
10:29:45   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:45   9  	  miss_table_name => 'svmc_miss_num',
10:29:45  10  	  data_table_name => '&bldtable',
10:29:45  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:45  12  
10:29:45  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:45  14  	  miss_table_name => 'svmc_miss_cat',
10:29:45  15  	  data_table_name => '&bldtable',
10:29:45  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:45  17  
10:29:45  18  	-- xform input data to replace missing values
10:29:45  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:45  20  	  miss_table_name => 'svmc_miss_num',
10:29:45  21  	  data_table_name => '&bldtable',
10:29:45  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:45  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:45  24  	  miss_table_name => 'svmc_miss_cat',
10:29:45  25  	  data_table_name => '&bldtable',
10:29:45  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:45  27  
10:29:45  28  	-- Perform outlier treatment.
10:29:45  29  	-- create clip table
10:29:45  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:45  31  
10:29:45  32  	-- populate clip table
10:29:45  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:45  34  	  clip_table_name => 'svmc_clip',
10:29:45  35  	  data_table_name => '&bldtable',
10:29:45  36  	  tail_frac	  => 0.025,
10:29:45  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:45  38  
10:29:45  39  	-- xform input data to winsorized data
10:29:45  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:45  41  	  clip_table_name => 'svmc_clip',
10:29:45  42  	  data_table_name => '&bldtable',
10:29:45  43  	  xform_view_name => 'svmc_winsor');
10:29:45  44  
10:29:45  45  	-- create normalization table
10:29:45  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:45  47  
10:29:45  48  	-- populate normalization table based on winsorized data
10:29:45  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:45  50  	  norm_table_name => 'svmc_norm',
10:29:45  51  	  data_table_name => 'svmc_winsor',
10:29:45  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:45  53  
10:29:45  54  	-- normalize the original data
10:29:45  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:45  56  	  norm_table_name => 'svmc_norm',
10:29:45  57  	  data_table_name => '&bldtable',
10:29:45  58  	  xform_view_name => 'svmc_build_prep');
10:29:45  59  END;
10:29:45  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:29:45 SQL> 
10:29:45 SQL> ---------------------
10:29:45 SQL> -- CREATE A NEW MODEL
10:29:45 SQL> --
10:29:45 SQL> -- Cleanup old model with the same name for repeat runs
10:29:45 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:45   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:45   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.22
10:29:46 SQL> 
10:29:46 SQL> -- Build a new SVM Model
10:29:46 SQL> BEGIN
10:29:46   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:46   3  	  model_name	      => '&model_name',
10:29:46   4  	  mining_function     => dbms_data_mining.classification,
10:29:46   5  	  data_table_name     => 'svmc_build_prep',
10:29:46   6  	  case_id_column_name => '&case_id',
10:29:46   7  	  target_column_name  => '&target',
10:29:46   8  	  settings_table_name => 'svmc_settings');
10:29:46   9  END;
10:29:46  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
10:29:49 SQL> 
10:29:49 SQL> -----------------------------------------------------------------------
10:29:49 SQL> --			       APPLY/score THE MODEL
10:29:49 SQL> -----------------------------------------------------------------------
10:29:49 SQL> 
10:29:49 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:29:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:29:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:49 SQL> -----------------------
10:29:49 SQL> -- PREPARE SCORING DATA
10:29:49 SQL> --
10:29:49 SQL> -- If the data for model creation has been prepared, then the data
10:29:49 SQL> -- to be scored using the model must be prepared in the same manner
10:29:49 SQL> -- in order to obtain meaningful results.
10:29:49 SQL> --
10:29:49 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:49 SQL> -- 2. Normalization
10:29:49 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:49 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:49 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:49 SQL> --
10:29:49 SQL> BEGIN
10:29:49   2  	-- Xform Test data to replace missing values
10:29:49   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:49   4  	  miss_table_name => 'svmc_miss_num',
10:29:49   5  	  data_table_name => '&scoretable',
10:29:49   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:49   7  
10:29:49   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:49   9  	  miss_table_name => 'svmc_miss_cat',
10:29:49  10  	  data_table_name => '&scoretable',
10:29:49  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:49  12  
10:29:49  13  	-- Normalize the data to be scored
10:29:49  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:49  15  	  norm_table_name => 'svmc_norm',
10:29:49  16  	  data_table_name => '&scoretable',
10:29:49  17  	  xform_view_name => 'svmc_apply_prep');
10:29:49  18  END;
10:29:49  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:29:49 SQL> 
10:29:49 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:49 SQL> -- DELETE it if I did:
10:29:49 SQL> DELETE ystkscores
10:29:49   2  WHERE score > 0
10:29:49   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:49   4  -- I need to supply the target attribute name:
10:29:49   5  AND targ = '&1'
10:29:49   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:49 SQL> 
10:29:49 SQL> -- We do a drumroll here:
10:29:49 SQL> 
10:29:49 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:49   2  SELECT
10:29:49   3  tkrdate
10:29:49   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:49   5  ,sysdate
10:29:49   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:49   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:49   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:49   9  ,SUBSTR(tkrdate,-10)ydate
10:29:49  10  ,'&1'
10:29:49  11  FROM svmc_apply_prep
10:29:49  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:49 SQL> @score1_5min.sql	      2009-12-08 TLT
10:29:49 SQL> --
10:29:49 SQL> -- score1_5min.sql
10:29:49 SQL> --
10:29:49 SQL> 
10:29:49 SQL> -- Demo:
10:29:49 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:49 SQL> 
10:29:49 SQL> CREATE OR REPLACE VIEW sme AS
10:29:49   2  SELECT
10:29:49   3  tkrdate
10:29:49   4  ,NULL gatt
10:29:49   5  ,g00
10:29:49   6  ,g01
10:29:49   7  ,g02
10:29:49   8  ,g03
10:29:49   9  ,g04
10:29:49  10  ,g05
10:29:49  11  ,g06
10:29:49  12  ,g07
10:29:49  13  ,g08
10:29:49  14  ,g09
10:29:49  15  ,g10
10:29:49  16  ,g11
10:29:49  17  ,g12
10:29:49  18  ,g13
10:29:49  19  ,g14
10:29:49  20  ,g15
10:29:49  21  ,g16
10:29:49  22  ,g17
10:29:49  23  ,g18
10:29:49  24  ,g19
10:29:49  25  ,g20
10:29:49  26  ,g21
10:29:49  27  ,g22
10:29:49  28  ,g23
10:29:49  29  ,g24
10:29:49  30  ,g25
10:29:49  31  ,g26
10:29:49  32  ,g27
10:29:49  33  ,g28
10:29:49  34  ,g29
10:29:49  35  FROM stk_ms
10:29:49  36  WHERE ydate = '&1'
10:29:49  37  AND tkr = '&2'
10:29:49  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-08'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:29:49 SQL> 
10:29:49 SQL> -- rpt
10:29:49 SQL> -- We should see just 1 row:
10:29:49 SQL> 
10:29:49 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:49   2  
10:29:49 SQL> -- Build the model:
10:29:49 SQL> CREATE OR REPLACE VIEW bme AS
10:29:49   2  SELECT
10:29:49   3  tkrdate
10:29:49   4  ,gatt
10:29:49   5  ,g00
10:29:49   6  ,g01
10:29:49   7  ,g02
10:29:49   8  ,g03
10:29:49   9  ,g04
10:29:49  10  ,g05
10:29:49  11  ,g06
10:29:49  12  ,g07
10:29:49  13  ,g08
10:29:49  14  ,g09
10:29:49  15  ,g10
10:29:49  16  ,g11
10:29:49  17  ,g12
10:29:49  18  ,g13
10:29:49  19  ,g14
10:29:49  20  ,g15
10:29:49  21  ,g16
10:29:49  22  ,g17
10:29:49  23  ,g18
10:29:49  24  ,g19
10:29:49  25  ,g20
10:29:49  26  ,g21
10:29:49  27  ,g22
10:29:49  28  ,g23
10:29:49  29  ,g24
10:29:49  30  ,g25
10:29:49  31  ,g26
10:29:49  32  ,g27
10:29:49  33  ,g28
10:29:49  34  ,g29
10:29:49  35  FROM stk_ms
10:29:49  36  WHERE gatt IN('nup','up')
10:29:49  37  -- Use only rows which are older than 1 day:
10:29:49  38  AND 1+ydate < '&1'
10:29:49  39  AND tkr = '&2'
10:29:49  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-08'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:29:49 SQL> 
10:29:49 SQL> -- rpt
10:29:49 SQL> 
10:29:49 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:29:49   2  
10:29:49 SQL> SELECT MAX(tkrdate) FROM bme
10:29:49   2  
10:29:49 SQL> -- Now build model from bme and score sme
10:29:49 SQL> @score1.sql gatt
10:29:49 SQL> -- score1.sql
10:29:49 SQL> 
10:29:49 SQL> -- I use this script to send 5 params to score.sql
10:29:49 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:49 SQL> -- Then at the very end of this script I use the model
10:29:49 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:49 SQL> 
10:29:49 SQL> -- I call this script from 2 other scripts:
10:29:49 SQL> -- score1_5min.sql
10:29:49 SQL> -- score1_5min_gattn.sql
10:29:49 SQL> 
10:29:49 SQL> -- The 1st param is the name of the target attribute.
10:29:49 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:49 SQL> 
10:29:49 SQL> -- Demo:
10:29:49 SQL> -- @score1.sql 'gatt'
10:29:49 SQL> -- @score1.sql 'gattn'
10:29:49 SQL> 
10:29:49 SQL> -- Now, I fill up svmc_apply_prep.
10:29:49 SQL> -- I use same model_name used in score.sql
10:29:49 SQL> DEFINE model_name = 'svmspy101'
10:29:49 SQL> DEFINE bldtable	= 'bme'
10:29:49 SQL> DEFINE scoretable = 'sme'
10:29:49 SQL> DEFINE case_id	= 'tkrdate'
10:29:49 SQL> -- Demo:
10:29:49 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:49 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:49 SQL> --
10:29:49 SQL> -- score.sql
10:29:49 SQL> --
10:29:49 SQL> 
10:29:49 SQL> -- usage: score.sql
10:29:49 SQL> 
10:29:49 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:49 SQL> 
10:29:49 SQL> -- DEFINE target	   = 'gatt'
10:29:49 SQL> -- DEFINE model_name = 'svmspy100'
10:29:49 SQL> -- DEFINE bldtable   = 'bme'
10:29:49 SQL> -- DEFINE scoretable = 'sme'
10:29:49 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:49 SQL> 
10:29:49 SQL> DEFINE target	= '&1'
10:29:49 SQL> DEFINE model_name = '&2'
10:29:49 SQL> DEFINE bldtable	= '&3'
10:29:49 SQL> DEFINE scoretable = '&4'
10:29:49 SQL> DEFINE case_id	= '&5'
10:29:49 SQL> 
10:29:49 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:49 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:49 SQL> 
10:29:49 SQL> -- Builds an SVM model using pl/sql.
10:29:49 SQL> 
10:29:49 SQL> -----------------------------------------------------------------------
10:29:49 SQL> --			    BUILD THE MODEL
10:29:49 SQL> -----------------------------------------------------------------------
10:29:49 SQL> 
10:29:49 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:49 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:49 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:49 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:49 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:49 SQL> 
10:29:49 SQL> 
10:29:49 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:49 SQL> --
10:29:49 SQL> -- DROP	TABLE svmc_settings ;
10:29:49 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:49 SQL> -- DELETE svmc_settings;
10:29:49 SQL> 
10:29:49 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:49 SQL> -- this choice to SVM using a settings table.
10:29:49 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:49 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:49 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:49 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:49 SQL> -- models.
10:29:49 SQL> --
10:29:49 SQL> 
10:29:49 SQL> -- Do this once and then comment it out.
10:29:49 SQL> -- That makes script go faster.
10:29:49 SQL> -- BEGIN
10:29:49 SQL> -- -- Populate settings table
10:29:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:49 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:49 SQL> --
10:29:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:49 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:49 SQL> --
10:29:49 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:49 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:49 SQL> --   COMMIT;
10:29:49 SQL> -- END;
10:29:49 SQL> -- /
10:29:49 SQL> 
10:29:49 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:49 SQL> 
10:29:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:29:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:49 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:49   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:50 SQL> 
10:29:50 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:50   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:50 SQL> 
10:29:50 SQL> --------------------------------
10:29:50 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:50 SQL> --
10:29:50 SQL> 
10:29:50 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:50 SQL> -- 2. Outlier Treatment and
10:29:50 SQL> -- 3. Normalization are performed below.
10:29:50 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:50 SQL> --    normalized here.
10:29:50 SQL> 
10:29:50 SQL> BEGIN
10:29:50   2  	-- Perform missing value treatment for all predictors
10:29:50   3  	-- create miss tables
10:29:50   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:50   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:50   6  
10:29:50   7  	-- populate miss tables
10:29:50   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:50   9  	  miss_table_name => 'svmc_miss_num',
10:29:50  10  	  data_table_name => '&bldtable',
10:29:50  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:50  12  
10:29:50  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:50  14  	  miss_table_name => 'svmc_miss_cat',
10:29:50  15  	  data_table_name => '&bldtable',
10:29:50  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:50  17  
10:29:50  18  	-- xform input data to replace missing values
10:29:50  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:50  20  	  miss_table_name => 'svmc_miss_num',
10:29:50  21  	  data_table_name => '&bldtable',
10:29:50  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:50  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:50  24  	  miss_table_name => 'svmc_miss_cat',
10:29:50  25  	  data_table_name => '&bldtable',
10:29:50  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:50  27  
10:29:50  28  	-- Perform outlier treatment.
10:29:50  29  	-- create clip table
10:29:50  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:50  31  
10:29:50  32  	-- populate clip table
10:29:50  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:50  34  	  clip_table_name => 'svmc_clip',
10:29:50  35  	  data_table_name => '&bldtable',
10:29:50  36  	  tail_frac	  => 0.025,
10:29:50  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:50  38  
10:29:50  39  	-- xform input data to winsorized data
10:29:50  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:50  41  	  clip_table_name => 'svmc_clip',
10:29:50  42  	  data_table_name => '&bldtable',
10:29:50  43  	  xform_view_name => 'svmc_winsor');
10:29:50  44  
10:29:50  45  	-- create normalization table
10:29:50  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:50  47  
10:29:50  48  	-- populate normalization table based on winsorized data
10:29:50  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:50  50  	  norm_table_name => 'svmc_norm',
10:29:50  51  	  data_table_name => 'svmc_winsor',
10:29:50  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:50  53  
10:29:50  54  	-- normalize the original data
10:29:50  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:50  56  	  norm_table_name => 'svmc_norm',
10:29:50  57  	  data_table_name => '&bldtable',
10:29:50  58  	  xform_view_name => 'svmc_build_prep');
10:29:50  59  END;
10:29:50  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:29:50 SQL> 
10:29:50 SQL> ---------------------
10:29:50 SQL> -- CREATE A NEW MODEL
10:29:50 SQL> --
10:29:50 SQL> -- Cleanup old model with the same name for repeat runs
10:29:50 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:50   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:50   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.08
10:29:51 SQL> 
10:29:51 SQL> -- Build a new SVM Model
10:29:51 SQL> BEGIN
10:29:51   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:51   3  	  model_name	      => '&model_name',
10:29:51   4  	  mining_function     => dbms_data_mining.classification,
10:29:51   5  	  data_table_name     => 'svmc_build_prep',
10:29:51   6  	  case_id_column_name => '&case_id',
10:29:51   7  	  target_column_name  => '&target',
10:29:51   8  	  settings_table_name => 'svmc_settings');
10:29:51   9  END;
10:29:51  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.55
10:29:54 SQL> 
10:29:54 SQL> -----------------------------------------------------------------------
10:29:54 SQL> --			       APPLY/score THE MODEL
10:29:54 SQL> -----------------------------------------------------------------------
10:29:54 SQL> 
10:29:54 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:29:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:54 SQL> -----------------------
10:29:54 SQL> -- PREPARE SCORING DATA
10:29:54 SQL> --
10:29:54 SQL> -- If the data for model creation has been prepared, then the data
10:29:54 SQL> -- to be scored using the model must be prepared in the same manner
10:29:54 SQL> -- in order to obtain meaningful results.
10:29:54 SQL> --
10:29:54 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:54 SQL> -- 2. Normalization
10:29:54 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:54 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:54 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:54 SQL> --
10:29:54 SQL> BEGIN
10:29:54   2  	-- Xform Test data to replace missing values
10:29:54   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:54   4  	  miss_table_name => 'svmc_miss_num',
10:29:54   5  	  data_table_name => '&scoretable',
10:29:54   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:54   7  
10:29:54   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:54   9  	  miss_table_name => 'svmc_miss_cat',
10:29:54  10  	  data_table_name => '&scoretable',
10:29:54  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:54  12  
10:29:54  13  	-- Normalize the data to be scored
10:29:54  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:54  15  	  norm_table_name => 'svmc_norm',
10:29:54  16  	  data_table_name => '&scoretable',
10:29:54  17  	  xform_view_name => 'svmc_apply_prep');
10:29:54  18  END;
10:29:54  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:29:54 SQL> 
10:29:54 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:54 SQL> -- DELETE it if I did:
10:29:54 SQL> DELETE ystkscores
10:29:54   2  WHERE score > 0
10:29:54   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:54   4  -- I need to supply the target attribute name:
10:29:54   5  AND targ = '&1'
10:29:54   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:54 SQL> 
10:29:54 SQL> -- We do a drumroll here:
10:29:54 SQL> 
10:29:54 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:54   2  SELECT
10:29:54   3  tkrdate
10:29:54   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:54   5  ,sysdate
10:29:54   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:54   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:54   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:54   9  ,SUBSTR(tkrdate,-10)ydate
10:29:54  10  ,'&1'
10:29:54  11  FROM svmc_apply_prep
10:29:54  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:29:54 SQL> @score1_5min_gattn.sql	2010-07-23 TLT
10:29:54 SQL> --
10:29:54 SQL> -- score1_5min_gattn.sql
10:29:54 SQL> --
10:29:54 SQL> 
10:29:54 SQL> -- Demo:
10:29:54 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:29:54 SQL> 
10:29:54 SQL> CREATE OR REPLACE VIEW sme AS
10:29:54   2  SELECT
10:29:54   3  tkrdate
10:29:54   4  ,NULL gattn
10:29:54   5  ,g00
10:29:54   6  ,g01
10:29:54   7  ,g02
10:29:54   8  ,g03
10:29:54   9  ,g04
10:29:54  10  ,g05
10:29:54  11  ,g06
10:29:54  12  ,g07
10:29:54  13  ,g08
10:29:54  14  ,g09
10:29:54  15  ,g10
10:29:54  16  ,g11
10:29:54  17  ,g12
10:29:54  18  ,g13
10:29:54  19  ,g14
10:29:54  20  ,g15
10:29:54  21  ,g16
10:29:54  22  ,g17
10:29:54  23  ,g18
10:29:54  24  ,g19
10:29:54  25  ,g20
10:29:54  26  ,g21
10:29:54  27  ,g22
10:29:54  28  ,g23
10:29:54  29  ,g24
10:29:54  30  ,g25
10:29:54  31  ,g26
10:29:54  32  ,g27
10:29:54  33  ,g28
10:29:54  34  ,g29
10:29:54  35  FROM stk_ms
10:29:54  36  WHERE ydate = '&1'
10:29:54  37  AND tkr = '&2'
10:29:54  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-07-23'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:54 SQL> 
10:29:54 SQL> -- rpt
10:29:54 SQL> -- We should see just 1 row:
10:29:54 SQL> 
10:29:54 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:54   2  
10:29:54 SQL> -- Build the model:
10:29:54 SQL> CREATE OR REPLACE VIEW bme AS
10:29:54   2  SELECT
10:29:54   3  tkrdate
10:29:54   4  ,gattn
10:29:54   5  ,g00
10:29:54   6  ,g01
10:29:54   7  ,g02
10:29:54   8  ,g03
10:29:54   9  ,g04
10:29:54  10  ,g05
10:29:54  11  ,g06
10:29:54  12  ,g07
10:29:54  13  ,g08
10:29:54  14  ,g09
10:29:54  15  ,g10
10:29:54  16  ,g11
10:29:54  17  ,g12
10:29:54  18  ,g13
10:29:54  19  ,g14
10:29:54  20  ,g15
10:29:54  21  ,g16
10:29:54  22  ,g17
10:29:54  23  ,g18
10:29:54  24  ,g19
10:29:54  25  ,g20
10:29:54  26  ,g21
10:29:54  27  ,g22
10:29:54  28  ,g23
10:29:54  29  ,g24
10:29:54  30  ,g25
10:29:54  31  ,g26
10:29:54  32  ,g27
10:29:54  33  ,g28
10:29:54  34  ,g29
10:29:54  35  FROM stk_ms
10:29:54  36  WHERE gattn IN('nup','up')
10:29:54  37  -- Use only rows which are older than 1 day:
10:29:54  38  AND 1+ydate < '&1'
10:29:54  39  AND tkr = '&2'
10:29:54  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-07-23'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:54 SQL> 
10:29:54 SQL> -- rpt
10:29:54 SQL> 
10:29:54 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:29:54   2  
10:29:54 SQL> SELECT MAX(tkrdate) FROM bme
10:29:54   2  
10:29:54 SQL> -- Now build model from bme and score sme
10:29:54 SQL> @score1.sql gattn
10:29:54 SQL> -- score1.sql
10:29:54 SQL> 
10:29:54 SQL> -- I use this script to send 5 params to score.sql
10:29:54 SQL> -- which does the heavy lifting of creating an SVM model.
10:29:54 SQL> -- Then at the very end of this script I use the model
10:29:54 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:29:54 SQL> 
10:29:54 SQL> -- I call this script from 2 other scripts:
10:29:54 SQL> -- score1_5min.sql
10:29:54 SQL> -- score1_5min_gattn.sql
10:29:54 SQL> 
10:29:54 SQL> -- The 1st param is the name of the target attribute.
10:29:54 SQL> -- I like to call my target attributes either gatt or gattn.
10:29:54 SQL> 
10:29:54 SQL> -- Demo:
10:29:54 SQL> -- @score1.sql 'gatt'
10:29:54 SQL> -- @score1.sql 'gattn'
10:29:54 SQL> 
10:29:54 SQL> -- Now, I fill up svmc_apply_prep.
10:29:54 SQL> -- I use same model_name used in score.sql
10:29:54 SQL> DEFINE model_name = 'svmspy101'
10:29:54 SQL> DEFINE bldtable	= 'bme'
10:29:54 SQL> DEFINE scoretable = 'sme'
10:29:54 SQL> DEFINE case_id	= 'tkrdate'
10:29:54 SQL> -- Demo:
10:29:54 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:29:54 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:29:54 SQL> --
10:29:54 SQL> -- score.sql
10:29:54 SQL> --
10:29:54 SQL> 
10:29:54 SQL> -- usage: score.sql
10:29:54 SQL> 
10:29:54 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:29:54 SQL> 
10:29:54 SQL> -- DEFINE target	   = 'gatt'
10:29:54 SQL> -- DEFINE model_name = 'svmspy100'
10:29:54 SQL> -- DEFINE bldtable   = 'bme'
10:29:54 SQL> -- DEFINE scoretable = 'sme'
10:29:54 SQL> -- DEFINE case_id    = 'tkrdate'
10:29:54 SQL> 
10:29:54 SQL> DEFINE target	= '&1'
10:29:54 SQL> DEFINE model_name = '&2'
10:29:54 SQL> DEFINE bldtable	= '&3'
10:29:54 SQL> DEFINE scoretable = '&4'
10:29:54 SQL> DEFINE case_id	= '&5'
10:29:54 SQL> 
10:29:54 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:29:54 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:29:54 SQL> 
10:29:54 SQL> -- Builds an SVM model using pl/sql.
10:29:54 SQL> 
10:29:54 SQL> -----------------------------------------------------------------------
10:29:54 SQL> --			    BUILD THE MODEL
10:29:54 SQL> -----------------------------------------------------------------------
10:29:54 SQL> 
10:29:54 SQL> -- Cleanup old build data preparation objects for repeat runs
10:29:54 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:54 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:29:54 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:29:54 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.01
10:29:54 SQL> 
10:29:54 SQL> 
10:29:54 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:29:54 SQL> --
10:29:54 SQL> -- DROP	TABLE svmc_settings ;
10:29:54 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:29:54 SQL> -- DELETE svmc_settings;
10:29:54 SQL> 
10:29:54 SQL> -- The default classification algorithm is Naive Bayes. So override
10:29:54 SQL> -- this choice to SVM using a settings table.
10:29:54 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:29:54 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:29:54 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:29:54 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:29:54 SQL> -- models.
10:29:54 SQL> --
10:29:54 SQL> 
10:29:54 SQL> -- Do this once and then comment it out.
10:29:54 SQL> -- That makes script go faster.
10:29:54 SQL> -- BEGIN
10:29:54 SQL> -- -- Populate settings table
10:29:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:54 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:29:54 SQL> --
10:29:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:54 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:29:54 SQL> --
10:29:54 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:29:54 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:29:54 SQL> --   COMMIT;
10:29:54 SQL> -- END;
10:29:54 SQL> -- /
10:29:54 SQL> 
10:29:54 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:29:54 SQL> 
10:29:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:29:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:29:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:29:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:54 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:29:54   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:54   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.16
10:29:55 SQL> 
10:29:55 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:29:55   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:55   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.51
10:29:55 SQL> 
10:29:55 SQL> --------------------------------
10:29:55 SQL> -- PREPARE BUILD (TRAINING) DATA
10:29:55 SQL> --
10:29:55 SQL> 
10:29:55 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:55 SQL> -- 2. Outlier Treatment and
10:29:55 SQL> -- 3. Normalization are performed below.
10:29:55 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:29:55 SQL> --    normalized here.
10:29:55 SQL> 
10:29:55 SQL> BEGIN
10:29:55   2  	-- Perform missing value treatment for all predictors
10:29:55   3  	-- create miss tables
10:29:55   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:29:55   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:29:55   6  
10:29:55   7  	-- populate miss tables
10:29:55   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:29:55   9  	  miss_table_name => 'svmc_miss_num',
10:29:55  10  	  data_table_name => '&bldtable',
10:29:55  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:55  12  
10:29:55  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:29:55  14  	  miss_table_name => 'svmc_miss_cat',
10:29:55  15  	  data_table_name => '&bldtable',
10:29:55  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:55  17  
10:29:55  18  	-- xform input data to replace missing values
10:29:55  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:55  20  	  miss_table_name => 'svmc_miss_num',
10:29:55  21  	  data_table_name => '&bldtable',
10:29:55  22  	  xform_view_name => 'xformed_build_miss_num');
10:29:55  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:55  24  	  miss_table_name => 'svmc_miss_cat',
10:29:55  25  	  data_table_name => '&bldtable',
10:29:55  26  	  xform_view_name => 'xformed_build_miss_cat');
10:29:55  27  
10:29:55  28  	-- Perform outlier treatment.
10:29:55  29  	-- create clip table
10:29:55  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:29:55  31  
10:29:55  32  	-- populate clip table
10:29:55  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:29:55  34  	  clip_table_name => 'svmc_clip',
10:29:55  35  	  data_table_name => '&bldtable',
10:29:55  36  	  tail_frac	  => 0.025,
10:29:55  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:55  38  
10:29:55  39  	-- xform input data to winsorized data
10:29:55  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:29:55  41  	  clip_table_name => 'svmc_clip',
10:29:55  42  	  data_table_name => '&bldtable',
10:29:55  43  	  xform_view_name => 'svmc_winsor');
10:29:55  44  
10:29:55  45  	-- create normalization table
10:29:55  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:29:55  47  
10:29:55  48  	-- populate normalization table based on winsorized data
10:29:55  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:29:55  50  	  norm_table_name => 'svmc_norm',
10:29:55  51  	  data_table_name => 'svmc_winsor',
10:29:55  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:29:55  53  
10:29:55  54  	-- normalize the original data
10:29:55  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:55  56  	  norm_table_name => 'svmc_norm',
10:29:55  57  	  data_table_name => '&bldtable',
10:29:55  58  	  xform_view_name => 'svmc_build_prep');
10:29:55  59  END;
10:29:55  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:29:56 SQL> 
10:29:56 SQL> ---------------------
10:29:56 SQL> -- CREATE A NEW MODEL
10:29:56 SQL> --
10:29:56 SQL> -- Cleanup old model with the same name for repeat runs
10:29:56 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:29:56   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:56   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.29
10:29:57 SQL> 
10:29:57 SQL> -- Build a new SVM Model
10:29:57 SQL> BEGIN
10:29:57   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:29:57   3  	  model_name	      => '&model_name',
10:29:57   4  	  mining_function     => dbms_data_mining.classification,
10:29:57   5  	  data_table_name     => 'svmc_build_prep',
10:29:57   6  	  case_id_column_name => '&case_id',
10:29:57   7  	  target_column_name  => '&target',
10:29:57   8  	  settings_table_name => 'svmc_settings');
10:29:57   9  END;
10:29:57  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.18
10:29:59 SQL> 
10:29:59 SQL> -----------------------------------------------------------------------
10:29:59 SQL> --			       APPLY/score THE MODEL
10:29:59 SQL> -----------------------------------------------------------------------
10:29:59 SQL> 
10:29:59 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:29:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:29:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:29:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:59 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:29:59   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:29:59   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:29:59 SQL> -----------------------
10:29:59 SQL> -- PREPARE SCORING DATA
10:29:59 SQL> --
10:29:59 SQL> -- If the data for model creation has been prepared, then the data
10:29:59 SQL> -- to be scored using the model must be prepared in the same manner
10:29:59 SQL> -- in order to obtain meaningful results.
10:29:59 SQL> --
10:29:59 SQL> -- 1. Missing Value treatment for all Predictors and
10:29:59 SQL> -- 2. Normalization
10:29:59 SQL> -- No outlier treatment will be performed during test and apply. The
10:29:59 SQL> -- normalization step is sufficient, since the normalization parameters
10:29:59 SQL> -- already capture the effects of outlier treatment done with build data.
10:29:59 SQL> --
10:29:59 SQL> BEGIN
10:29:59   2  	-- Xform Test data to replace missing values
10:29:59   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:29:59   4  	  miss_table_name => 'svmc_miss_num',
10:29:59   5  	  data_table_name => '&scoretable',
10:29:59   6  	  xform_view_name => 'xformed_apply_miss_num');
10:29:59   7  
10:29:59   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:29:59   9  	  miss_table_name => 'svmc_miss_cat',
10:29:59  10  	  data_table_name => '&scoretable',
10:29:59  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:29:59  12  
10:29:59  13  	-- Normalize the data to be scored
10:29:59  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:29:59  15  	  norm_table_name => 'svmc_norm',
10:29:59  16  	  data_table_name => '&scoretable',
10:29:59  17  	  xform_view_name => 'svmc_apply_prep');
10:29:59  18  END;
10:29:59  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:29:59 SQL> 
10:29:59 SQL> -- Maybe I already collected a score for this tkrdate.
10:29:59 SQL> -- DELETE it if I did:
10:29:59 SQL> DELETE ystkscores
10:29:59   2  WHERE score > 0
10:29:59   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:29:59   4  -- I need to supply the target attribute name:
10:29:59   5  AND targ = '&1'
10:29:59   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.01
10:29:59 SQL> 
10:29:59 SQL> -- We do a drumroll here:
10:29:59 SQL> 
10:29:59 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:29:59   2  SELECT
10:29:59   3  tkrdate
10:29:59   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:29:59   5  ,sysdate
10:29:59   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:29:59   7  -- rluck/oracle_sql_demos/substr.sql :
10:29:59   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:29:59   9  ,SUBSTR(tkrdate,-10)ydate
10:29:59  10  ,'&1'
10:29:59  11  FROM svmc_apply_prep
10:29:59  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:29:59 SQL> @score1_5min.sql	      2010-03-12 TLT
10:29:59 SQL> --
10:29:59 SQL> -- score1_5min.sql
10:29:59 SQL> --
10:29:59 SQL> 
10:29:59 SQL> -- Demo:
10:29:59 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:29:59 SQL> 
10:29:59 SQL> CREATE OR REPLACE VIEW sme AS
10:29:59   2  SELECT
10:29:59   3  tkrdate
10:29:59   4  ,NULL gatt
10:29:59   5  ,g00
10:29:59   6  ,g01
10:29:59   7  ,g02
10:29:59   8  ,g03
10:29:59   9  ,g04
10:29:59  10  ,g05
10:29:59  11  ,g06
10:29:59  12  ,g07
10:29:59  13  ,g08
10:29:59  14  ,g09
10:29:59  15  ,g10
10:29:59  16  ,g11
10:29:59  17  ,g12
10:29:59  18  ,g13
10:29:59  19  ,g14
10:29:59  20  ,g15
10:29:59  21  ,g16
10:29:59  22  ,g17
10:29:59  23  ,g18
10:29:59  24  ,g19
10:29:59  25  ,g20
10:29:59  26  ,g21
10:29:59  27  ,g22
10:29:59  28  ,g23
10:29:59  29  ,g24
10:29:59  30  ,g25
10:29:59  31  ,g26
10:29:59  32  ,g27
10:29:59  33  ,g28
10:29:59  34  ,g29
10:29:59  35  FROM stk_ms
10:29:59  36  WHERE ydate = '&1'
10:29:59  37  AND tkr = '&2'
10:29:59  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-12'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:29:59 SQL> 
10:29:59 SQL> -- rpt
10:29:59 SQL> -- We should see just 1 row:
10:29:59 SQL> 
10:29:59 SQL> SELECT COUNT(tkrdate) FROM sme
10:29:59   2  
10:29:59 SQL> -- Build the model:
10:29:59 SQL> CREATE OR REPLACE VIEW bme AS
10:29:59   2  SELECT
10:29:59   3  tkrdate
10:29:59   4  ,gatt
10:29:59   5  ,g00
10:29:59   6  ,g01
10:29:59   7  ,g02
10:29:59   8  ,g03
10:29:59   9  ,g04
10:29:59  10  ,g05
10:29:59  11  ,g06
10:29:59  12  ,g07
10:29:59  13  ,g08
10:29:59  14  ,g09
10:29:59  15  ,g10
10:29:59  16  ,g11
10:29:59  17  ,g12
10:29:59  18  ,g13
10:29:59  19  ,g14
10:29:59  20  ,g15
10:29:59  21  ,g16
10:29:59  22  ,g17
10:29:59  23  ,g18
10:29:59  24  ,g19
10:29:59  25  ,g20
10:29:59  26  ,g21
10:29:59  27  ,g22
10:29:59  28  ,g23
10:29:59  29  ,g24
10:29:59  30  ,g25
10:29:59  31  ,g26
10:29:59  32  ,g27
10:29:59  33  ,g28
10:29:59  34  ,g29
10:29:59  35  FROM stk_ms
10:29:59  36  WHERE gatt IN('nup','up')
10:29:59  37  -- Use only rows which are older than 1 day:
10:29:59  38  AND 1+ydate < '&1'
10:29:59  39  AND tkr = '&2'
10:29:59  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-12'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:00 SQL> 
10:30:00 SQL> -- rpt
10:30:00 SQL> 
10:30:00 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:30:00   2  
10:30:00 SQL> SELECT MAX(tkrdate) FROM bme
10:30:00   2  
10:30:00 SQL> -- Now build model from bme and score sme
10:30:00 SQL> @score1.sql gatt
10:30:00 SQL> -- score1.sql
10:30:00 SQL> 
10:30:00 SQL> -- I use this script to send 5 params to score.sql
10:30:00 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:00 SQL> -- Then at the very end of this script I use the model
10:30:00 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:00 SQL> 
10:30:00 SQL> -- I call this script from 2 other scripts:
10:30:00 SQL> -- score1_5min.sql
10:30:00 SQL> -- score1_5min_gattn.sql
10:30:00 SQL> 
10:30:00 SQL> -- The 1st param is the name of the target attribute.
10:30:00 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:00 SQL> 
10:30:00 SQL> -- Demo:
10:30:00 SQL> -- @score1.sql 'gatt'
10:30:00 SQL> -- @score1.sql 'gattn'
10:30:00 SQL> 
10:30:00 SQL> -- Now, I fill up svmc_apply_prep.
10:30:00 SQL> -- I use same model_name used in score.sql
10:30:00 SQL> DEFINE model_name = 'svmspy101'
10:30:00 SQL> DEFINE bldtable	= 'bme'
10:30:00 SQL> DEFINE scoretable = 'sme'
10:30:00 SQL> DEFINE case_id	= 'tkrdate'
10:30:00 SQL> -- Demo:
10:30:00 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:00 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:00 SQL> --
10:30:00 SQL> -- score.sql
10:30:00 SQL> --
10:30:00 SQL> 
10:30:00 SQL> -- usage: score.sql
10:30:00 SQL> 
10:30:00 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:00 SQL> 
10:30:00 SQL> -- DEFINE target	   = 'gatt'
10:30:00 SQL> -- DEFINE model_name = 'svmspy100'
10:30:00 SQL> -- DEFINE bldtable   = 'bme'
10:30:00 SQL> -- DEFINE scoretable = 'sme'
10:30:00 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:00 SQL> 
10:30:00 SQL> DEFINE target	= '&1'
10:30:00 SQL> DEFINE model_name = '&2'
10:30:00 SQL> DEFINE bldtable	= '&3'
10:30:00 SQL> DEFINE scoretable = '&4'
10:30:00 SQL> DEFINE case_id	= '&5'
10:30:00 SQL> 
10:30:00 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:00 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:00 SQL> 
10:30:00 SQL> -- Builds an SVM model using pl/sql.
10:30:00 SQL> 
10:30:00 SQL> -----------------------------------------------------------------------
10:30:00 SQL> --			    BUILD THE MODEL
10:30:00 SQL> -----------------------------------------------------------------------
10:30:00 SQL> 
10:30:00 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:00 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:00 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:00 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:00 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:00 SQL> 
10:30:00 SQL> 
10:30:00 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:00 SQL> --
10:30:00 SQL> -- DROP	TABLE svmc_settings ;
10:30:00 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:00 SQL> -- DELETE svmc_settings;
10:30:00 SQL> 
10:30:00 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:00 SQL> -- this choice to SVM using a settings table.
10:30:00 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:00 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:00 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:00 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:00 SQL> -- models.
10:30:00 SQL> --
10:30:00 SQL> 
10:30:00 SQL> -- Do this once and then comment it out.
10:30:00 SQL> -- That makes script go faster.
10:30:00 SQL> -- BEGIN
10:30:00 SQL> -- -- Populate settings table
10:30:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:00 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:00 SQL> --
10:30:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:00 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:00 SQL> --
10:30:00 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:00 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:00 SQL> --   COMMIT;
10:30:00 SQL> -- END;
10:30:00 SQL> -- /
10:30:00 SQL> 
10:30:00 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:00 SQL> 
10:30:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:00 SQL> 
10:30:00 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:00   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:00 SQL> 
10:30:00 SQL> --------------------------------
10:30:00 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:00 SQL> --
10:30:00 SQL> 
10:30:00 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:00 SQL> -- 2. Outlier Treatment and
10:30:00 SQL> -- 3. Normalization are performed below.
10:30:00 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:00 SQL> --    normalized here.
10:30:00 SQL> 
10:30:00 SQL> BEGIN
10:30:00   2  	-- Perform missing value treatment for all predictors
10:30:00   3  	-- create miss tables
10:30:00   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:00   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:00   6  
10:30:00   7  	-- populate miss tables
10:30:00   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:00   9  	  miss_table_name => 'svmc_miss_num',
10:30:00  10  	  data_table_name => '&bldtable',
10:30:00  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:00  12  
10:30:00  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:00  14  	  miss_table_name => 'svmc_miss_cat',
10:30:00  15  	  data_table_name => '&bldtable',
10:30:00  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:00  17  
10:30:00  18  	-- xform input data to replace missing values
10:30:00  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:00  20  	  miss_table_name => 'svmc_miss_num',
10:30:00  21  	  data_table_name => '&bldtable',
10:30:00  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:00  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:00  24  	  miss_table_name => 'svmc_miss_cat',
10:30:00  25  	  data_table_name => '&bldtable',
10:30:00  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:00  27  
10:30:00  28  	-- Perform outlier treatment.
10:30:00  29  	-- create clip table
10:30:00  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:00  31  
10:30:00  32  	-- populate clip table
10:30:00  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:00  34  	  clip_table_name => 'svmc_clip',
10:30:00  35  	  data_table_name => '&bldtable',
10:30:00  36  	  tail_frac	  => 0.025,
10:30:00  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:00  38  
10:30:00  39  	-- xform input data to winsorized data
10:30:00  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:00  41  	  clip_table_name => 'svmc_clip',
10:30:00  42  	  data_table_name => '&bldtable',
10:30:00  43  	  xform_view_name => 'svmc_winsor');
10:30:00  44  
10:30:00  45  	-- create normalization table
10:30:00  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:00  47  
10:30:00  48  	-- populate normalization table based on winsorized data
10:30:00  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:00  50  	  norm_table_name => 'svmc_norm',
10:30:00  51  	  data_table_name => 'svmc_winsor',
10:30:00  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:00  53  
10:30:00  54  	-- normalize the original data
10:30:00  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:00  56  	  norm_table_name => 'svmc_norm',
10:30:00  57  	  data_table_name => '&bldtable',
10:30:00  58  	  xform_view_name => 'svmc_build_prep');
10:30:00  59  END;
10:30:00  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:30:00 SQL> 
10:30:00 SQL> ---------------------
10:30:00 SQL> -- CREATE A NEW MODEL
10:30:00 SQL> --
10:30:00 SQL> -- Cleanup old model with the same name for repeat runs
10:30:00 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:00   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:00   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.30
10:30:02 SQL> 
10:30:02 SQL> -- Build a new SVM Model
10:30:02 SQL> BEGIN
10:30:02   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:02   3  	  model_name	      => '&model_name',
10:30:02   4  	  mining_function     => dbms_data_mining.classification,
10:30:02   5  	  data_table_name     => 'svmc_build_prep',
10:30:02   6  	  case_id_column_name => '&case_id',
10:30:02   7  	  target_column_name  => '&target',
10:30:02   8  	  settings_table_name => 'svmc_settings');
10:30:02   9  END;
10:30:02  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.70
10:30:04 SQL> 
10:30:04 SQL> -----------------------------------------------------------------------
10:30:04 SQL> --			       APPLY/score THE MODEL
10:30:04 SQL> -----------------------------------------------------------------------
10:30:04 SQL> 
10:30:04 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:04 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:04   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:04   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:04 SQL> -----------------------
10:30:04 SQL> -- PREPARE SCORING DATA
10:30:04 SQL> --
10:30:04 SQL> -- If the data for model creation has been prepared, then the data
10:30:04 SQL> -- to be scored using the model must be prepared in the same manner
10:30:04 SQL> -- in order to obtain meaningful results.
10:30:04 SQL> --
10:30:04 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:04 SQL> -- 2. Normalization
10:30:04 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:04 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:04 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:04 SQL> --
10:30:04 SQL> BEGIN
10:30:04   2  	-- Xform Test data to replace missing values
10:30:04   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:04   4  	  miss_table_name => 'svmc_miss_num',
10:30:04   5  	  data_table_name => '&scoretable',
10:30:04   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:04   7  
10:30:04   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:04   9  	  miss_table_name => 'svmc_miss_cat',
10:30:04  10  	  data_table_name => '&scoretable',
10:30:04  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:04  12  
10:30:04  13  	-- Normalize the data to be scored
10:30:04  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:04  15  	  norm_table_name => 'svmc_norm',
10:30:04  16  	  data_table_name => '&scoretable',
10:30:04  17  	  xform_view_name => 'svmc_apply_prep');
10:30:04  18  END;
10:30:04  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:30:05 SQL> 
10:30:05 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:05 SQL> -- DELETE it if I did:
10:30:05 SQL> DELETE ystkscores
10:30:05   2  WHERE score > 0
10:30:05   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:05   4  -- I need to supply the target attribute name:
10:30:05   5  AND targ = '&1'
10:30:05   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:05 SQL> 
10:30:05 SQL> -- We do a drumroll here:
10:30:05 SQL> 
10:30:05 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:05   2  SELECT
10:30:05   3  tkrdate
10:30:05   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:05   5  ,sysdate
10:30:05   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:05   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:05   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:05   9  ,SUBSTR(tkrdate,-10)ydate
10:30:05  10  ,'&1'
10:30:05  11  FROM svmc_apply_prep
10:30:05  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:30:05 SQL> @score1_5min.sql	      2010-10-27 TLT
10:30:05 SQL> --
10:30:05 SQL> -- score1_5min.sql
10:30:05 SQL> --
10:30:05 SQL> 
10:30:05 SQL> -- Demo:
10:30:05 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:30:05 SQL> 
10:30:05 SQL> CREATE OR REPLACE VIEW sme AS
10:30:05   2  SELECT
10:30:05   3  tkrdate
10:30:05   4  ,NULL gatt
10:30:05   5  ,g00
10:30:05   6  ,g01
10:30:05   7  ,g02
10:30:05   8  ,g03
10:30:05   9  ,g04
10:30:05  10  ,g05
10:30:05  11  ,g06
10:30:05  12  ,g07
10:30:05  13  ,g08
10:30:05  14  ,g09
10:30:05  15  ,g10
10:30:05  16  ,g11
10:30:05  17  ,g12
10:30:05  18  ,g13
10:30:05  19  ,g14
10:30:05  20  ,g15
10:30:05  21  ,g16
10:30:05  22  ,g17
10:30:05  23  ,g18
10:30:05  24  ,g19
10:30:05  25  ,g20
10:30:05  26  ,g21
10:30:05  27  ,g22
10:30:05  28  ,g23
10:30:05  29  ,g24
10:30:05  30  ,g25
10:30:05  31  ,g26
10:30:05  32  ,g27
10:30:05  33  ,g28
10:30:05  34  ,g29
10:30:05  35  FROM stk_ms
10:30:05  36  WHERE ydate = '&1'
10:30:05  37  AND tkr = '&2'
10:30:05  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-10-27'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:05 SQL> 
10:30:05 SQL> -- rpt
10:30:05 SQL> -- We should see just 1 row:
10:30:05 SQL> 
10:30:05 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:05   2  
10:30:05 SQL> -- Build the model:
10:30:05 SQL> CREATE OR REPLACE VIEW bme AS
10:30:05   2  SELECT
10:30:05   3  tkrdate
10:30:05   4  ,gatt
10:30:05   5  ,g00
10:30:05   6  ,g01
10:30:05   7  ,g02
10:30:05   8  ,g03
10:30:05   9  ,g04
10:30:05  10  ,g05
10:30:05  11  ,g06
10:30:05  12  ,g07
10:30:05  13  ,g08
10:30:05  14  ,g09
10:30:05  15  ,g10
10:30:05  16  ,g11
10:30:05  17  ,g12
10:30:05  18  ,g13
10:30:05  19  ,g14
10:30:05  20  ,g15
10:30:05  21  ,g16
10:30:05  22  ,g17
10:30:05  23  ,g18
10:30:05  24  ,g19
10:30:05  25  ,g20
10:30:05  26  ,g21
10:30:05  27  ,g22
10:30:05  28  ,g23
10:30:05  29  ,g24
10:30:05  30  ,g25
10:30:05  31  ,g26
10:30:05  32  ,g27
10:30:05  33  ,g28
10:30:05  34  ,g29
10:30:05  35  FROM stk_ms
10:30:05  36  WHERE gatt IN('nup','up')
10:30:05  37  -- Use only rows which are older than 1 day:
10:30:05  38  AND 1+ydate < '&1'
10:30:05  39  AND tkr = '&2'
10:30:05  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-10-27'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:05 SQL> 
10:30:05 SQL> -- rpt
10:30:05 SQL> 
10:30:05 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:30:05   2  
10:30:05 SQL> SELECT MAX(tkrdate) FROM bme
10:30:05   2  
10:30:05 SQL> -- Now build model from bme and score sme
10:30:05 SQL> @score1.sql gatt
10:30:05 SQL> -- score1.sql
10:30:05 SQL> 
10:30:05 SQL> -- I use this script to send 5 params to score.sql
10:30:05 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:05 SQL> -- Then at the very end of this script I use the model
10:30:05 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:05 SQL> 
10:30:05 SQL> -- I call this script from 2 other scripts:
10:30:05 SQL> -- score1_5min.sql
10:30:05 SQL> -- score1_5min_gattn.sql
10:30:05 SQL> 
10:30:05 SQL> -- The 1st param is the name of the target attribute.
10:30:05 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:05 SQL> 
10:30:05 SQL> -- Demo:
10:30:05 SQL> -- @score1.sql 'gatt'
10:30:05 SQL> -- @score1.sql 'gattn'
10:30:05 SQL> 
10:30:05 SQL> -- Now, I fill up svmc_apply_prep.
10:30:05 SQL> -- I use same model_name used in score.sql
10:30:05 SQL> DEFINE model_name = 'svmspy101'
10:30:05 SQL> DEFINE bldtable	= 'bme'
10:30:05 SQL> DEFINE scoretable = 'sme'
10:30:05 SQL> DEFINE case_id	= 'tkrdate'
10:30:05 SQL> -- Demo:
10:30:05 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:05 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:05 SQL> --
10:30:05 SQL> -- score.sql
10:30:05 SQL> --
10:30:05 SQL> 
10:30:05 SQL> -- usage: score.sql
10:30:05 SQL> 
10:30:05 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:05 SQL> 
10:30:05 SQL> -- DEFINE target	   = 'gatt'
10:30:05 SQL> -- DEFINE model_name = 'svmspy100'
10:30:05 SQL> -- DEFINE bldtable   = 'bme'
10:30:05 SQL> -- DEFINE scoretable = 'sme'
10:30:05 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:05 SQL> 
10:30:05 SQL> DEFINE target	= '&1'
10:30:05 SQL> DEFINE model_name = '&2'
10:30:05 SQL> DEFINE bldtable	= '&3'
10:30:05 SQL> DEFINE scoretable = '&4'
10:30:05 SQL> DEFINE case_id	= '&5'
10:30:05 SQL> 
10:30:05 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:05 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:05 SQL> 
10:30:05 SQL> -- Builds an SVM model using pl/sql.
10:30:05 SQL> 
10:30:05 SQL> -----------------------------------------------------------------------
10:30:05 SQL> --			    BUILD THE MODEL
10:30:05 SQL> -----------------------------------------------------------------------
10:30:05 SQL> 
10:30:05 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:05 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:05 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:05 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:05 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:05 SQL> 
10:30:05 SQL> 
10:30:05 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:05 SQL> --
10:30:05 SQL> -- DROP	TABLE svmc_settings ;
10:30:05 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:05 SQL> -- DELETE svmc_settings;
10:30:05 SQL> 
10:30:05 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:05 SQL> -- this choice to SVM using a settings table.
10:30:05 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:05 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:05 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:05 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:05 SQL> -- models.
10:30:05 SQL> --
10:30:05 SQL> 
10:30:05 SQL> -- Do this once and then comment it out.
10:30:05 SQL> -- That makes script go faster.
10:30:05 SQL> -- BEGIN
10:30:05 SQL> -- -- Populate settings table
10:30:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:05 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:05 SQL> --
10:30:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:05 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:05 SQL> --
10:30:05 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:05 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:05 SQL> --   COMMIT;
10:30:05 SQL> -- END;
10:30:05 SQL> -- /
10:30:05 SQL> 
10:30:05 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:05 SQL> 
10:30:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:05 SQL> 
10:30:05 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:05   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:05 SQL> 
10:30:05 SQL> --------------------------------
10:30:05 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:05 SQL> --
10:30:05 SQL> 
10:30:05 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:05 SQL> -- 2. Outlier Treatment and
10:30:05 SQL> -- 3. Normalization are performed below.
10:30:05 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:05 SQL> --    normalized here.
10:30:05 SQL> 
10:30:05 SQL> BEGIN
10:30:05   2  	-- Perform missing value treatment for all predictors
10:30:05   3  	-- create miss tables
10:30:05   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:05   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:05   6  
10:30:05   7  	-- populate miss tables
10:30:05   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:05   9  	  miss_table_name => 'svmc_miss_num',
10:30:05  10  	  data_table_name => '&bldtable',
10:30:05  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:05  12  
10:30:05  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:05  14  	  miss_table_name => 'svmc_miss_cat',
10:30:05  15  	  data_table_name => '&bldtable',
10:30:05  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:05  17  
10:30:05  18  	-- xform input data to replace missing values
10:30:05  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:05  20  	  miss_table_name => 'svmc_miss_num',
10:30:05  21  	  data_table_name => '&bldtable',
10:30:05  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:05  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:05  24  	  miss_table_name => 'svmc_miss_cat',
10:30:05  25  	  data_table_name => '&bldtable',
10:30:05  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:05  27  
10:30:05  28  	-- Perform outlier treatment.
10:30:05  29  	-- create clip table
10:30:05  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:05  31  
10:30:05  32  	-- populate clip table
10:30:05  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:05  34  	  clip_table_name => 'svmc_clip',
10:30:05  35  	  data_table_name => '&bldtable',
10:30:05  36  	  tail_frac	  => 0.025,
10:30:05  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:05  38  
10:30:05  39  	-- xform input data to winsorized data
10:30:05  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:05  41  	  clip_table_name => 'svmc_clip',
10:30:05  42  	  data_table_name => '&bldtable',
10:30:05  43  	  xform_view_name => 'svmc_winsor');
10:30:05  44  
10:30:05  45  	-- create normalization table
10:30:05  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:05  47  
10:30:05  48  	-- populate normalization table based on winsorized data
10:30:05  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:05  50  	  norm_table_name => 'svmc_norm',
10:30:05  51  	  data_table_name => 'svmc_winsor',
10:30:05  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:05  53  
10:30:05  54  	-- normalize the original data
10:30:05  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:05  56  	  norm_table_name => 'svmc_norm',
10:30:05  57  	  data_table_name => '&bldtable',
10:30:05  58  	  xform_view_name => 'svmc_build_prep');
10:30:05  59  END;
10:30:05  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:30:05 SQL> 
10:30:05 SQL> ---------------------
10:30:05 SQL> -- CREATE A NEW MODEL
10:30:05 SQL> --
10:30:05 SQL> -- Cleanup old model with the same name for repeat runs
10:30:05 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:05   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:05   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.33
10:30:07 SQL> 
10:30:07 SQL> -- Build a new SVM Model
10:30:07 SQL> BEGIN
10:30:07   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:07   3  	  model_name	      => '&model_name',
10:30:07   4  	  mining_function     => dbms_data_mining.classification,
10:30:07   5  	  data_table_name     => 'svmc_build_prep',
10:30:07   6  	  case_id_column_name => '&case_id',
10:30:07   7  	  target_column_name  => '&target',
10:30:07   8  	  settings_table_name => 'svmc_settings');
10:30:07   9  END;
10:30:07  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.38
10:30:09 SQL> 
10:30:09 SQL> -----------------------------------------------------------------------
10:30:09 SQL> --			       APPLY/score THE MODEL
10:30:09 SQL> -----------------------------------------------------------------------
10:30:09 SQL> 
10:30:09 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:09 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:09   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:09   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:09 SQL> -----------------------
10:30:09 SQL> -- PREPARE SCORING DATA
10:30:09 SQL> --
10:30:09 SQL> -- If the data for model creation has been prepared, then the data
10:30:09 SQL> -- to be scored using the model must be prepared in the same manner
10:30:09 SQL> -- in order to obtain meaningful results.
10:30:09 SQL> --
10:30:09 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:09 SQL> -- 2. Normalization
10:30:09 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:09 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:09 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:09 SQL> --
10:30:09 SQL> BEGIN
10:30:09   2  	-- Xform Test data to replace missing values
10:30:09   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:09   4  	  miss_table_name => 'svmc_miss_num',
10:30:09   5  	  data_table_name => '&scoretable',
10:30:09   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:09   7  
10:30:09   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:09   9  	  miss_table_name => 'svmc_miss_cat',
10:30:09  10  	  data_table_name => '&scoretable',
10:30:09  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:09  12  
10:30:09  13  	-- Normalize the data to be scored
10:30:09  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:09  15  	  norm_table_name => 'svmc_norm',
10:30:09  16  	  data_table_name => '&scoretable',
10:30:09  17  	  xform_view_name => 'svmc_apply_prep');
10:30:09  18  END;
10:30:09  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.22
10:30:10 SQL> 
10:30:10 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:10 SQL> -- DELETE it if I did:
10:30:10 SQL> DELETE ystkscores
10:30:10   2  WHERE score > 0
10:30:10   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:10   4  -- I need to supply the target attribute name:
10:30:10   5  AND targ = '&1'
10:30:10   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:10 SQL> 
10:30:10 SQL> -- We do a drumroll here:
10:30:10 SQL> 
10:30:10 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:10   2  SELECT
10:30:10   3  tkrdate
10:30:10   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:10   5  ,sysdate
10:30:10   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:10   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:10   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:10   9  ,SUBSTR(tkrdate,-10)ydate
10:30:10  10  ,'&1'
10:30:10  11  FROM svmc_apply_prep
10:30:10  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.03
10:30:10 SQL> @score1_5min.sql	      2009-12-30 TLT
10:30:10 SQL> --
10:30:10 SQL> -- score1_5min.sql
10:30:10 SQL> --
10:30:10 SQL> 
10:30:10 SQL> -- Demo:
10:30:10 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:30:10 SQL> 
10:30:10 SQL> CREATE OR REPLACE VIEW sme AS
10:30:10   2  SELECT
10:30:10   3  tkrdate
10:30:10   4  ,NULL gatt
10:30:10   5  ,g00
10:30:10   6  ,g01
10:30:10   7  ,g02
10:30:10   8  ,g03
10:30:10   9  ,g04
10:30:10  10  ,g05
10:30:10  11  ,g06
10:30:10  12  ,g07
10:30:10  13  ,g08
10:30:10  14  ,g09
10:30:10  15  ,g10
10:30:10  16  ,g11
10:30:10  17  ,g12
10:30:10  18  ,g13
10:30:10  19  ,g14
10:30:10  20  ,g15
10:30:10  21  ,g16
10:30:10  22  ,g17
10:30:10  23  ,g18
10:30:10  24  ,g19
10:30:10  25  ,g20
10:30:10  26  ,g21
10:30:10  27  ,g22
10:30:10  28  ,g23
10:30:10  29  ,g24
10:30:10  30  ,g25
10:30:10  31  ,g26
10:30:10  32  ,g27
10:30:10  33  ,g28
10:30:10  34  ,g29
10:30:10  35  FROM stk_ms
10:30:10  36  WHERE ydate = '&1'
10:30:10  37  AND tkr = '&2'
10:30:10  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2009-12-30'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:30:10 SQL> 
10:30:10 SQL> -- rpt
10:30:10 SQL> -- We should see just 1 row:
10:30:10 SQL> 
10:30:10 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:10   2  
10:30:10 SQL> -- Build the model:
10:30:10 SQL> CREATE OR REPLACE VIEW bme AS
10:30:10   2  SELECT
10:30:10   3  tkrdate
10:30:10   4  ,gatt
10:30:10   5  ,g00
10:30:10   6  ,g01
10:30:10   7  ,g02
10:30:10   8  ,g03
10:30:10   9  ,g04
10:30:10  10  ,g05
10:30:10  11  ,g06
10:30:10  12  ,g07
10:30:10  13  ,g08
10:30:10  14  ,g09
10:30:10  15  ,g10
10:30:10  16  ,g11
10:30:10  17  ,g12
10:30:10  18  ,g13
10:30:10  19  ,g14
10:30:10  20  ,g15
10:30:10  21  ,g16
10:30:10  22  ,g17
10:30:10  23  ,g18
10:30:10  24  ,g19
10:30:10  25  ,g20
10:30:10  26  ,g21
10:30:10  27  ,g22
10:30:10  28  ,g23
10:30:10  29  ,g24
10:30:10  30  ,g25
10:30:10  31  ,g26
10:30:10  32  ,g27
10:30:10  33  ,g28
10:30:10  34  ,g29
10:30:10  35  FROM stk_ms
10:30:10  36  WHERE gatt IN('nup','up')
10:30:10  37  -- Use only rows which are older than 1 day:
10:30:10  38  AND 1+ydate < '&1'
10:30:10  39  AND tkr = '&2'
10:30:10  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2009-12-30'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:10 SQL> 
10:30:10 SQL> -- rpt
10:30:10 SQL> 
10:30:10 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:30:10   2  
10:30:10 SQL> SELECT MAX(tkrdate) FROM bme
10:30:10   2  
10:30:10 SQL> -- Now build model from bme and score sme
10:30:10 SQL> @score1.sql gatt
10:30:10 SQL> -- score1.sql
10:30:10 SQL> 
10:30:10 SQL> -- I use this script to send 5 params to score.sql
10:30:10 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:10 SQL> -- Then at the very end of this script I use the model
10:30:10 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:10 SQL> 
10:30:10 SQL> -- I call this script from 2 other scripts:
10:30:10 SQL> -- score1_5min.sql
10:30:10 SQL> -- score1_5min_gattn.sql
10:30:10 SQL> 
10:30:10 SQL> -- The 1st param is the name of the target attribute.
10:30:10 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:10 SQL> 
10:30:10 SQL> -- Demo:
10:30:10 SQL> -- @score1.sql 'gatt'
10:30:10 SQL> -- @score1.sql 'gattn'
10:30:10 SQL> 
10:30:10 SQL> -- Now, I fill up svmc_apply_prep.
10:30:10 SQL> -- I use same model_name used in score.sql
10:30:10 SQL> DEFINE model_name = 'svmspy101'
10:30:10 SQL> DEFINE bldtable	= 'bme'
10:30:10 SQL> DEFINE scoretable = 'sme'
10:30:10 SQL> DEFINE case_id	= 'tkrdate'
10:30:10 SQL> -- Demo:
10:30:10 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:10 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:10 SQL> --
10:30:10 SQL> -- score.sql
10:30:10 SQL> --
10:30:10 SQL> 
10:30:10 SQL> -- usage: score.sql
10:30:10 SQL> 
10:30:10 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:10 SQL> 
10:30:10 SQL> -- DEFINE target	   = 'gatt'
10:30:10 SQL> -- DEFINE model_name = 'svmspy100'
10:30:10 SQL> -- DEFINE bldtable   = 'bme'
10:30:10 SQL> -- DEFINE scoretable = 'sme'
10:30:10 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:10 SQL> 
10:30:10 SQL> DEFINE target	= '&1'
10:30:10 SQL> DEFINE model_name = '&2'
10:30:10 SQL> DEFINE bldtable	= '&3'
10:30:10 SQL> DEFINE scoretable = '&4'
10:30:10 SQL> DEFINE case_id	= '&5'
10:30:10 SQL> 
10:30:10 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:10 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:10 SQL> 
10:30:10 SQL> -- Builds an SVM model using pl/sql.
10:30:10 SQL> 
10:30:10 SQL> -----------------------------------------------------------------------
10:30:10 SQL> --			    BUILD THE MODEL
10:30:10 SQL> -----------------------------------------------------------------------
10:30:10 SQL> 
10:30:10 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:10 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:10 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:10 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:10 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:10 SQL> 
10:30:10 SQL> 
10:30:10 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:10 SQL> --
10:30:10 SQL> -- DROP	TABLE svmc_settings ;
10:30:10 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:10 SQL> -- DELETE svmc_settings;
10:30:10 SQL> 
10:30:10 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:10 SQL> -- this choice to SVM using a settings table.
10:30:10 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:10 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:10 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:10 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:10 SQL> -- models.
10:30:10 SQL> --
10:30:10 SQL> 
10:30:10 SQL> -- Do this once and then comment it out.
10:30:10 SQL> -- That makes script go faster.
10:30:10 SQL> -- BEGIN
10:30:10 SQL> -- -- Populate settings table
10:30:10 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:10 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:10 SQL> --
10:30:10 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:10 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:10 SQL> --
10:30:10 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:10 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:10 SQL> --   COMMIT;
10:30:10 SQL> -- END;
10:30:10 SQL> -- /
10:30:10 SQL> 
10:30:10 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:10 SQL> 
10:30:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:10 SQL> 
10:30:10 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:10   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:10 SQL> 
10:30:10 SQL> --------------------------------
10:30:10 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:10 SQL> --
10:30:10 SQL> 
10:30:10 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:10 SQL> -- 2. Outlier Treatment and
10:30:10 SQL> -- 3. Normalization are performed below.
10:30:10 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:10 SQL> --    normalized here.
10:30:10 SQL> 
10:30:10 SQL> BEGIN
10:30:10   2  	-- Perform missing value treatment for all predictors
10:30:10   3  	-- create miss tables
10:30:10   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:10   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:10   6  
10:30:10   7  	-- populate miss tables
10:30:10   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:10   9  	  miss_table_name => 'svmc_miss_num',
10:30:10  10  	  data_table_name => '&bldtable',
10:30:10  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:10  12  
10:30:10  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:10  14  	  miss_table_name => 'svmc_miss_cat',
10:30:10  15  	  data_table_name => '&bldtable',
10:30:10  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:10  17  
10:30:10  18  	-- xform input data to replace missing values
10:30:10  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:10  20  	  miss_table_name => 'svmc_miss_num',
10:30:10  21  	  data_table_name => '&bldtable',
10:30:10  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:10  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:10  24  	  miss_table_name => 'svmc_miss_cat',
10:30:10  25  	  data_table_name => '&bldtable',
10:30:10  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:10  27  
10:30:10  28  	-- Perform outlier treatment.
10:30:10  29  	-- create clip table
10:30:10  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:10  31  
10:30:10  32  	-- populate clip table
10:30:10  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:10  34  	  clip_table_name => 'svmc_clip',
10:30:10  35  	  data_table_name => '&bldtable',
10:30:10  36  	  tail_frac	  => 0.025,
10:30:10  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:10  38  
10:30:10  39  	-- xform input data to winsorized data
10:30:10  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:10  41  	  clip_table_name => 'svmc_clip',
10:30:10  42  	  data_table_name => '&bldtable',
10:30:10  43  	  xform_view_name => 'svmc_winsor');
10:30:10  44  
10:30:10  45  	-- create normalization table
10:30:10  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:10  47  
10:30:10  48  	-- populate normalization table based on winsorized data
10:30:10  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:10  50  	  norm_table_name => 'svmc_norm',
10:30:10  51  	  data_table_name => 'svmc_winsor',
10:30:10  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:10  53  
10:30:10  54  	-- normalize the original data
10:30:10  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:10  56  	  norm_table_name => 'svmc_norm',
10:30:10  57  	  data_table_name => '&bldtable',
10:30:10  58  	  xform_view_name => 'svmc_build_prep');
10:30:10  59  END;
10:30:10  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:30:10 SQL> 
10:30:10 SQL> ---------------------
10:30:10 SQL> -- CREATE A NEW MODEL
10:30:10 SQL> --
10:30:10 SQL> -- Cleanup old model with the same name for repeat runs
10:30:10 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:10   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:10   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.96
10:30:11 SQL> 
10:30:11 SQL> -- Build a new SVM Model
10:30:11 SQL> BEGIN
10:30:11   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:11   3  	  model_name	      => '&model_name',
10:30:11   4  	  mining_function     => dbms_data_mining.classification,
10:30:11   5  	  data_table_name     => 'svmc_build_prep',
10:30:11   6  	  case_id_column_name => '&case_id',
10:30:11   7  	  target_column_name  => '&target',
10:30:11   8  	  settings_table_name => 'svmc_settings');
10:30:11   9  END;
10:30:11  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.30
10:30:14 SQL> 
10:30:14 SQL> -----------------------------------------------------------------------
10:30:14 SQL> --			       APPLY/score THE MODEL
10:30:14 SQL> -----------------------------------------------------------------------
10:30:14 SQL> 
10:30:14 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:14 SQL> -----------------------
10:30:14 SQL> -- PREPARE SCORING DATA
10:30:14 SQL> --
10:30:14 SQL> -- If the data for model creation has been prepared, then the data
10:30:14 SQL> -- to be scored using the model must be prepared in the same manner
10:30:14 SQL> -- in order to obtain meaningful results.
10:30:14 SQL> --
10:30:14 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:14 SQL> -- 2. Normalization
10:30:14 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:14 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:14 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:14 SQL> --
10:30:14 SQL> BEGIN
10:30:14   2  	-- Xform Test data to replace missing values
10:30:14   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:14   4  	  miss_table_name => 'svmc_miss_num',
10:30:14   5  	  data_table_name => '&scoretable',
10:30:14   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:14   7  
10:30:14   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:14   9  	  miss_table_name => 'svmc_miss_cat',
10:30:14  10  	  data_table_name => '&scoretable',
10:30:14  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:14  12  
10:30:14  13  	-- Normalize the data to be scored
10:30:14  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:14  15  	  norm_table_name => 'svmc_norm',
10:30:14  16  	  data_table_name => '&scoretable',
10:30:14  17  	  xform_view_name => 'svmc_apply_prep');
10:30:14  18  END;
10:30:14  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
10:30:14 SQL> 
10:30:14 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:14 SQL> -- DELETE it if I did:
10:30:14 SQL> DELETE ystkscores
10:30:14   2  WHERE score > 0
10:30:14   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:14   4  -- I need to supply the target attribute name:
10:30:14   5  AND targ = '&1'
10:30:14   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.01
10:30:14 SQL> 
10:30:14 SQL> -- We do a drumroll here:
10:30:14 SQL> 
10:30:14 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:14   2  SELECT
10:30:14   3  tkrdate
10:30:14   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:14   5  ,sysdate
10:30:14   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:14   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:14   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:14   9  ,SUBSTR(tkrdate,-10)ydate
10:30:14  10  ,'&1'
10:30:14  11  FROM svmc_apply_prep
10:30:14  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:30:14 SQL> @score1_5min_gattn.sql	2010-03-09 TLT
10:30:14 SQL> --
10:30:14 SQL> -- score1_5min_gattn.sql
10:30:14 SQL> --
10:30:14 SQL> 
10:30:14 SQL> -- Demo:
10:30:14 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:14 SQL> 
10:30:14 SQL> CREATE OR REPLACE VIEW sme AS
10:30:14   2  SELECT
10:30:14   3  tkrdate
10:30:14   4  ,NULL gattn
10:30:14   5  ,g00
10:30:14   6  ,g01
10:30:14   7  ,g02
10:30:14   8  ,g03
10:30:14   9  ,g04
10:30:14  10  ,g05
10:30:14  11  ,g06
10:30:14  12  ,g07
10:30:14  13  ,g08
10:30:14  14  ,g09
10:30:14  15  ,g10
10:30:14  16  ,g11
10:30:14  17  ,g12
10:30:14  18  ,g13
10:30:14  19  ,g14
10:30:14  20  ,g15
10:30:14  21  ,g16
10:30:14  22  ,g17
10:30:14  23  ,g18
10:30:14  24  ,g19
10:30:14  25  ,g20
10:30:14  26  ,g21
10:30:14  27  ,g22
10:30:14  28  ,g23
10:30:14  29  ,g24
10:30:14  30  ,g25
10:30:14  31  ,g26
10:30:14  32  ,g27
10:30:14  33  ,g28
10:30:14  34  ,g29
10:30:14  35  FROM stk_ms
10:30:14  36  WHERE ydate = '&1'
10:30:14  37  AND tkr = '&2'
10:30:14  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-09'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:14 SQL> 
10:30:14 SQL> -- rpt
10:30:14 SQL> -- We should see just 1 row:
10:30:14 SQL> 
10:30:14 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:14   2  
10:30:14 SQL> -- Build the model:
10:30:14 SQL> CREATE OR REPLACE VIEW bme AS
10:30:14   2  SELECT
10:30:14   3  tkrdate
10:30:14   4  ,gattn
10:30:14   5  ,g00
10:30:14   6  ,g01
10:30:14   7  ,g02
10:30:14   8  ,g03
10:30:14   9  ,g04
10:30:14  10  ,g05
10:30:14  11  ,g06
10:30:14  12  ,g07
10:30:14  13  ,g08
10:30:14  14  ,g09
10:30:14  15  ,g10
10:30:14  16  ,g11
10:30:14  17  ,g12
10:30:14  18  ,g13
10:30:14  19  ,g14
10:30:14  20  ,g15
10:30:14  21  ,g16
10:30:14  22  ,g17
10:30:14  23  ,g18
10:30:14  24  ,g19
10:30:14  25  ,g20
10:30:14  26  ,g21
10:30:14  27  ,g22
10:30:14  28  ,g23
10:30:14  29  ,g24
10:30:14  30  ,g25
10:30:14  31  ,g26
10:30:14  32  ,g27
10:30:14  33  ,g28
10:30:14  34  ,g29
10:30:14  35  FROM stk_ms
10:30:14  36  WHERE gattn IN('nup','up')
10:30:14  37  -- Use only rows which are older than 1 day:
10:30:14  38  AND 1+ydate < '&1'
10:30:14  39  AND tkr = '&2'
10:30:14  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-09'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:14 SQL> 
10:30:14 SQL> -- rpt
10:30:14 SQL> 
10:30:14 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:14   2  
10:30:14 SQL> SELECT MAX(tkrdate) FROM bme
10:30:14   2  
10:30:14 SQL> -- Now build model from bme and score sme
10:30:14 SQL> @score1.sql gattn
10:30:14 SQL> -- score1.sql
10:30:14 SQL> 
10:30:14 SQL> -- I use this script to send 5 params to score.sql
10:30:14 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:14 SQL> -- Then at the very end of this script I use the model
10:30:14 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:14 SQL> 
10:30:14 SQL> -- I call this script from 2 other scripts:
10:30:14 SQL> -- score1_5min.sql
10:30:14 SQL> -- score1_5min_gattn.sql
10:30:14 SQL> 
10:30:14 SQL> -- The 1st param is the name of the target attribute.
10:30:14 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:14 SQL> 
10:30:14 SQL> -- Demo:
10:30:14 SQL> -- @score1.sql 'gatt'
10:30:14 SQL> -- @score1.sql 'gattn'
10:30:14 SQL> 
10:30:14 SQL> -- Now, I fill up svmc_apply_prep.
10:30:14 SQL> -- I use same model_name used in score.sql
10:30:14 SQL> DEFINE model_name = 'svmspy101'
10:30:14 SQL> DEFINE bldtable	= 'bme'
10:30:14 SQL> DEFINE scoretable = 'sme'
10:30:14 SQL> DEFINE case_id	= 'tkrdate'
10:30:14 SQL> -- Demo:
10:30:14 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:14 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:14 SQL> --
10:30:14 SQL> -- score.sql
10:30:14 SQL> --
10:30:14 SQL> 
10:30:14 SQL> -- usage: score.sql
10:30:14 SQL> 
10:30:14 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:14 SQL> 
10:30:14 SQL> -- DEFINE target	   = 'gatt'
10:30:14 SQL> -- DEFINE model_name = 'svmspy100'
10:30:14 SQL> -- DEFINE bldtable   = 'bme'
10:30:14 SQL> -- DEFINE scoretable = 'sme'
10:30:14 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:14 SQL> 
10:30:14 SQL> DEFINE target	= '&1'
10:30:14 SQL> DEFINE model_name = '&2'
10:30:14 SQL> DEFINE bldtable	= '&3'
10:30:14 SQL> DEFINE scoretable = '&4'
10:30:14 SQL> DEFINE case_id	= '&5'
10:30:14 SQL> 
10:30:14 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:14 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:14 SQL> 
10:30:14 SQL> -- Builds an SVM model using pl/sql.
10:30:14 SQL> 
10:30:14 SQL> -----------------------------------------------------------------------
10:30:14 SQL> --			    BUILD THE MODEL
10:30:14 SQL> -----------------------------------------------------------------------
10:30:14 SQL> 
10:30:14 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:14 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.01
10:30:14 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:14 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:14 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:14 SQL> 
10:30:14 SQL> 
10:30:14 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:14 SQL> --
10:30:14 SQL> -- DROP	TABLE svmc_settings ;
10:30:14 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:14 SQL> -- DELETE svmc_settings;
10:30:14 SQL> 
10:30:14 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:14 SQL> -- this choice to SVM using a settings table.
10:30:14 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:14 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:14 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:14 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:14 SQL> -- models.
10:30:14 SQL> --
10:30:14 SQL> 
10:30:14 SQL> -- Do this once and then comment it out.
10:30:14 SQL> -- That makes script go faster.
10:30:14 SQL> -- BEGIN
10:30:14 SQL> -- -- Populate settings table
10:30:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:14 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:14 SQL> --
10:30:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:14 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:14 SQL> --
10:30:14 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:14 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:14 SQL> --   COMMIT;
10:30:14 SQL> -- END;
10:30:14 SQL> -- /
10:30:14 SQL> 
10:30:14 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:14 SQL> 
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:14 SQL> 
10:30:14 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:14   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:14   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:14 SQL> 
10:30:14 SQL> --------------------------------
10:30:14 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:14 SQL> --
10:30:14 SQL> 
10:30:14 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:14 SQL> -- 2. Outlier Treatment and
10:30:14 SQL> -- 3. Normalization are performed below.
10:30:14 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:14 SQL> --    normalized here.
10:30:14 SQL> 
10:30:14 SQL> BEGIN
10:30:14   2  	-- Perform missing value treatment for all predictors
10:30:14   3  	-- create miss tables
10:30:14   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:14   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:14   6  
10:30:14   7  	-- populate miss tables
10:30:14   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:14   9  	  miss_table_name => 'svmc_miss_num',
10:30:14  10  	  data_table_name => '&bldtable',
10:30:14  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:14  12  
10:30:14  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:14  14  	  miss_table_name => 'svmc_miss_cat',
10:30:14  15  	  data_table_name => '&bldtable',
10:30:14  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:14  17  
10:30:14  18  	-- xform input data to replace missing values
10:30:14  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:14  20  	  miss_table_name => 'svmc_miss_num',
10:30:14  21  	  data_table_name => '&bldtable',
10:30:14  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:14  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:14  24  	  miss_table_name => 'svmc_miss_cat',
10:30:14  25  	  data_table_name => '&bldtable',
10:30:14  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:14  27  
10:30:14  28  	-- Perform outlier treatment.
10:30:14  29  	-- create clip table
10:30:14  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:14  31  
10:30:14  32  	-- populate clip table
10:30:14  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:14  34  	  clip_table_name => 'svmc_clip',
10:30:14  35  	  data_table_name => '&bldtable',
10:30:14  36  	  tail_frac	  => 0.025,
10:30:14  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:14  38  
10:30:14  39  	-- xform input data to winsorized data
10:30:14  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:14  41  	  clip_table_name => 'svmc_clip',
10:30:14  42  	  data_table_name => '&bldtable',
10:30:14  43  	  xform_view_name => 'svmc_winsor');
10:30:14  44  
10:30:14  45  	-- create normalization table
10:30:14  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:14  47  
10:30:14  48  	-- populate normalization table based on winsorized data
10:30:14  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:14  50  	  norm_table_name => 'svmc_norm',
10:30:14  51  	  data_table_name => 'svmc_winsor',
10:30:14  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:14  53  
10:30:14  54  	-- normalize the original data
10:30:14  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:14  56  	  norm_table_name => 'svmc_norm',
10:30:14  57  	  data_table_name => '&bldtable',
10:30:14  58  	  xform_view_name => 'svmc_build_prep');
10:30:14  59  END;
10:30:14  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:30:15 SQL> 
10:30:15 SQL> ---------------------
10:30:15 SQL> -- CREATE A NEW MODEL
10:30:15 SQL> --
10:30:15 SQL> -- Cleanup old model with the same name for repeat runs
10:30:15 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:15   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:15   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.33
10:30:16 SQL> 
10:30:16 SQL> -- Build a new SVM Model
10:30:16 SQL> BEGIN
10:30:16   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:16   3  	  model_name	      => '&model_name',
10:30:16   4  	  mining_function     => dbms_data_mining.classification,
10:30:16   5  	  data_table_name     => 'svmc_build_prep',
10:30:16   6  	  case_id_column_name => '&case_id',
10:30:16   7  	  target_column_name  => '&target',
10:30:16   8  	  settings_table_name => 'svmc_settings');
10:30:16   9  END;
10:30:16  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.96
10:30:18 SQL> 
10:30:18 SQL> -----------------------------------------------------------------------
10:30:18 SQL> --			       APPLY/score THE MODEL
10:30:18 SQL> -----------------------------------------------------------------------
10:30:18 SQL> 
10:30:18 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:18 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:18   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:18   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:18 SQL> -----------------------
10:30:18 SQL> -- PREPARE SCORING DATA
10:30:18 SQL> --
10:30:18 SQL> -- If the data for model creation has been prepared, then the data
10:30:18 SQL> -- to be scored using the model must be prepared in the same manner
10:30:18 SQL> -- in order to obtain meaningful results.
10:30:18 SQL> --
10:30:18 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:18 SQL> -- 2. Normalization
10:30:18 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:18 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:18 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:18 SQL> --
10:30:18 SQL> BEGIN
10:30:18   2  	-- Xform Test data to replace missing values
10:30:18   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:18   4  	  miss_table_name => 'svmc_miss_num',
10:30:18   5  	  data_table_name => '&scoretable',
10:30:18   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:18   7  
10:30:18   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:18   9  	  miss_table_name => 'svmc_miss_cat',
10:30:18  10  	  data_table_name => '&scoretable',
10:30:18  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:18  12  
10:30:18  13  	-- Normalize the data to be scored
10:30:18  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:18  15  	  norm_table_name => 'svmc_norm',
10:30:18  16  	  data_table_name => '&scoretable',
10:30:18  17  	  xform_view_name => 'svmc_apply_prep');
10:30:18  18  END;
10:30:18  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:30:18 SQL> 
10:30:18 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:18 SQL> -- DELETE it if I did:
10:30:18 SQL> DELETE ystkscores
10:30:18   2  WHERE score > 0
10:30:18   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:18   4  -- I need to supply the target attribute name:
10:30:18   5  AND targ = '&1'
10:30:18   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:18 SQL> 
10:30:18 SQL> -- We do a drumroll here:
10:30:18 SQL> 
10:30:18 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:18   2  SELECT
10:30:18   3  tkrdate
10:30:18   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:18   5  ,sysdate
10:30:18   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:18   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:18   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:18   9  ,SUBSTR(tkrdate,-10)ydate
10:30:18  10  ,'&1'
10:30:18  11  FROM svmc_apply_prep
10:30:18  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:30:18 SQL> @score1_5min_gattn.sql	2010-06-10 TLT
10:30:18 SQL> --
10:30:18 SQL> -- score1_5min_gattn.sql
10:30:18 SQL> --
10:30:18 SQL> 
10:30:18 SQL> -- Demo:
10:30:18 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:18 SQL> 
10:30:18 SQL> CREATE OR REPLACE VIEW sme AS
10:30:18   2  SELECT
10:30:18   3  tkrdate
10:30:18   4  ,NULL gattn
10:30:18   5  ,g00
10:30:18   6  ,g01
10:30:18   7  ,g02
10:30:18   8  ,g03
10:30:18   9  ,g04
10:30:18  10  ,g05
10:30:18  11  ,g06
10:30:18  12  ,g07
10:30:18  13  ,g08
10:30:18  14  ,g09
10:30:18  15  ,g10
10:30:18  16  ,g11
10:30:18  17  ,g12
10:30:18  18  ,g13
10:30:18  19  ,g14
10:30:18  20  ,g15
10:30:18  21  ,g16
10:30:18  22  ,g17
10:30:18  23  ,g18
10:30:18  24  ,g19
10:30:18  25  ,g20
10:30:18  26  ,g21
10:30:18  27  ,g22
10:30:18  28  ,g23
10:30:18  29  ,g24
10:30:18  30  ,g25
10:30:18  31  ,g26
10:30:18  32  ,g27
10:30:18  33  ,g28
10:30:18  34  ,g29
10:30:18  35  FROM stk_ms
10:30:18  36  WHERE ydate = '&1'
10:30:18  37  AND tkr = '&2'
10:30:18  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-06-10'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:19 SQL> 
10:30:19 SQL> -- rpt
10:30:19 SQL> -- We should see just 1 row:
10:30:19 SQL> 
10:30:19 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:19   2  
10:30:19 SQL> -- Build the model:
10:30:19 SQL> CREATE OR REPLACE VIEW bme AS
10:30:19   2  SELECT
10:30:19   3  tkrdate
10:30:19   4  ,gattn
10:30:19   5  ,g00
10:30:19   6  ,g01
10:30:19   7  ,g02
10:30:19   8  ,g03
10:30:19   9  ,g04
10:30:19  10  ,g05
10:30:19  11  ,g06
10:30:19  12  ,g07
10:30:19  13  ,g08
10:30:19  14  ,g09
10:30:19  15  ,g10
10:30:19  16  ,g11
10:30:19  17  ,g12
10:30:19  18  ,g13
10:30:19  19  ,g14
10:30:19  20  ,g15
10:30:19  21  ,g16
10:30:19  22  ,g17
10:30:19  23  ,g18
10:30:19  24  ,g19
10:30:19  25  ,g20
10:30:19  26  ,g21
10:30:19  27  ,g22
10:30:19  28  ,g23
10:30:19  29  ,g24
10:30:19  30  ,g25
10:30:19  31  ,g26
10:30:19  32  ,g27
10:30:19  33  ,g28
10:30:19  34  ,g29
10:30:19  35  FROM stk_ms
10:30:19  36  WHERE gattn IN('nup','up')
10:30:19  37  -- Use only rows which are older than 1 day:
10:30:19  38  AND 1+ydate < '&1'
10:30:19  39  AND tkr = '&2'
10:30:19  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-06-10'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:19 SQL> 
10:30:19 SQL> -- rpt
10:30:19 SQL> 
10:30:19 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:19   2  
10:30:19 SQL> SELECT MAX(tkrdate) FROM bme
10:30:19   2  
10:30:19 SQL> -- Now build model from bme and score sme
10:30:19 SQL> @score1.sql gattn
10:30:19 SQL> -- score1.sql
10:30:19 SQL> 
10:30:19 SQL> -- I use this script to send 5 params to score.sql
10:30:19 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:19 SQL> -- Then at the very end of this script I use the model
10:30:19 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:19 SQL> 
10:30:19 SQL> -- I call this script from 2 other scripts:
10:30:19 SQL> -- score1_5min.sql
10:30:19 SQL> -- score1_5min_gattn.sql
10:30:19 SQL> 
10:30:19 SQL> -- The 1st param is the name of the target attribute.
10:30:19 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:19 SQL> 
10:30:19 SQL> -- Demo:
10:30:19 SQL> -- @score1.sql 'gatt'
10:30:19 SQL> -- @score1.sql 'gattn'
10:30:19 SQL> 
10:30:19 SQL> -- Now, I fill up svmc_apply_prep.
10:30:19 SQL> -- I use same model_name used in score.sql
10:30:19 SQL> DEFINE model_name = 'svmspy101'
10:30:19 SQL> DEFINE bldtable	= 'bme'
10:30:19 SQL> DEFINE scoretable = 'sme'
10:30:19 SQL> DEFINE case_id	= 'tkrdate'
10:30:19 SQL> -- Demo:
10:30:19 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:19 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:19 SQL> --
10:30:19 SQL> -- score.sql
10:30:19 SQL> --
10:30:19 SQL> 
10:30:19 SQL> -- usage: score.sql
10:30:19 SQL> 
10:30:19 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:19 SQL> 
10:30:19 SQL> -- DEFINE target	   = 'gatt'
10:30:19 SQL> -- DEFINE model_name = 'svmspy100'
10:30:19 SQL> -- DEFINE bldtable   = 'bme'
10:30:19 SQL> -- DEFINE scoretable = 'sme'
10:30:19 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:19 SQL> 
10:30:19 SQL> DEFINE target	= '&1'
10:30:19 SQL> DEFINE model_name = '&2'
10:30:19 SQL> DEFINE bldtable	= '&3'
10:30:19 SQL> DEFINE scoretable = '&4'
10:30:19 SQL> DEFINE case_id	= '&5'
10:30:19 SQL> 
10:30:19 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:19 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:19 SQL> 
10:30:19 SQL> -- Builds an SVM model using pl/sql.
10:30:19 SQL> 
10:30:19 SQL> -----------------------------------------------------------------------
10:30:19 SQL> --			    BUILD THE MODEL
10:30:19 SQL> -----------------------------------------------------------------------
10:30:19 SQL> 
10:30:19 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:19 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:19 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:19 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:30:19 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:19 SQL> 
10:30:19 SQL> 
10:30:19 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:19 SQL> --
10:30:19 SQL> -- DROP	TABLE svmc_settings ;
10:30:19 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:19 SQL> -- DELETE svmc_settings;
10:30:19 SQL> 
10:30:19 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:19 SQL> -- this choice to SVM using a settings table.
10:30:19 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:19 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:19 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:19 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:19 SQL> -- models.
10:30:19 SQL> --
10:30:19 SQL> 
10:30:19 SQL> -- Do this once and then comment it out.
10:30:19 SQL> -- That makes script go faster.
10:30:19 SQL> -- BEGIN
10:30:19 SQL> -- -- Populate settings table
10:30:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:19 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:19 SQL> --
10:30:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:19 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:19 SQL> --
10:30:19 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:19 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:19 SQL> --   COMMIT;
10:30:19 SQL> -- END;
10:30:19 SQL> -- /
10:30:19 SQL> 
10:30:19 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:19 SQL> 
10:30:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:19 SQL> 
10:30:19 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:19   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:19 SQL> 
10:30:19 SQL> --------------------------------
10:30:19 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:19 SQL> --
10:30:19 SQL> 
10:30:19 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:19 SQL> -- 2. Outlier Treatment and
10:30:19 SQL> -- 3. Normalization are performed below.
10:30:19 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:19 SQL> --    normalized here.
10:30:19 SQL> 
10:30:19 SQL> BEGIN
10:30:19   2  	-- Perform missing value treatment for all predictors
10:30:19   3  	-- create miss tables
10:30:19   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:19   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:19   6  
10:30:19   7  	-- populate miss tables
10:30:19   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:19   9  	  miss_table_name => 'svmc_miss_num',
10:30:19  10  	  data_table_name => '&bldtable',
10:30:19  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:19  12  
10:30:19  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:19  14  	  miss_table_name => 'svmc_miss_cat',
10:30:19  15  	  data_table_name => '&bldtable',
10:30:19  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:19  17  
10:30:19  18  	-- xform input data to replace missing values
10:30:19  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:19  20  	  miss_table_name => 'svmc_miss_num',
10:30:19  21  	  data_table_name => '&bldtable',
10:30:19  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:19  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:19  24  	  miss_table_name => 'svmc_miss_cat',
10:30:19  25  	  data_table_name => '&bldtable',
10:30:19  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:19  27  
10:30:19  28  	-- Perform outlier treatment.
10:30:19  29  	-- create clip table
10:30:19  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:19  31  
10:30:19  32  	-- populate clip table
10:30:19  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:19  34  	  clip_table_name => 'svmc_clip',
10:30:19  35  	  data_table_name => '&bldtable',
10:30:19  36  	  tail_frac	  => 0.025,
10:30:19  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:19  38  
10:30:19  39  	-- xform input data to winsorized data
10:30:19  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:19  41  	  clip_table_name => 'svmc_clip',
10:30:19  42  	  data_table_name => '&bldtable',
10:30:19  43  	  xform_view_name => 'svmc_winsor');
10:30:19  44  
10:30:19  45  	-- create normalization table
10:30:19  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:19  47  
10:30:19  48  	-- populate normalization table based on winsorized data
10:30:19  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:19  50  	  norm_table_name => 'svmc_norm',
10:30:19  51  	  data_table_name => 'svmc_winsor',
10:30:19  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:19  53  
10:30:19  54  	-- normalize the original data
10:30:19  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:19  56  	  norm_table_name => 'svmc_norm',
10:30:19  57  	  data_table_name => '&bldtable',
10:30:19  58  	  xform_view_name => 'svmc_build_prep');
10:30:19  59  END;
10:30:19  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:30:19 SQL> 
10:30:19 SQL> ---------------------
10:30:19 SQL> -- CREATE A NEW MODEL
10:30:19 SQL> --
10:30:19 SQL> -- Cleanup old model with the same name for repeat runs
10:30:19 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:19   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:19   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.26
10:30:21 SQL> 
10:30:21 SQL> -- Build a new SVM Model
10:30:21 SQL> BEGIN
10:30:21   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:21   3  	  model_name	      => '&model_name',
10:30:21   4  	  mining_function     => dbms_data_mining.classification,
10:30:21   5  	  data_table_name     => 'svmc_build_prep',
10:30:21   6  	  case_id_column_name => '&case_id',
10:30:21   7  	  target_column_name  => '&target',
10:30:21   8  	  settings_table_name => 'svmc_settings');
10:30:21   9  END;
10:30:21  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.58
10:30:23 SQL> 
10:30:23 SQL> -----------------------------------------------------------------------
10:30:23 SQL> --			       APPLY/score THE MODEL
10:30:23 SQL> -----------------------------------------------------------------------
10:30:23 SQL> 
10:30:23 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:30:23 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:23   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:23   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.35
10:30:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.36
10:30:24 SQL> -----------------------
10:30:24 SQL> -- PREPARE SCORING DATA
10:30:24 SQL> --
10:30:24 SQL> -- If the data for model creation has been prepared, then the data
10:30:24 SQL> -- to be scored using the model must be prepared in the same manner
10:30:24 SQL> -- in order to obtain meaningful results.
10:30:24 SQL> --
10:30:24 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:24 SQL> -- 2. Normalization
10:30:24 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:24 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:24 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:24 SQL> --
10:30:24 SQL> BEGIN
10:30:24   2  	-- Xform Test data to replace missing values
10:30:24   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:24   4  	  miss_table_name => 'svmc_miss_num',
10:30:24   5  	  data_table_name => '&scoretable',
10:30:24   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:24   7  
10:30:24   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:24   9  	  miss_table_name => 'svmc_miss_cat',
10:30:24  10  	  data_table_name => '&scoretable',
10:30:24  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:24  12  
10:30:24  13  	-- Normalize the data to be scored
10:30:24  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:24  15  	  norm_table_name => 'svmc_norm',
10:30:24  16  	  data_table_name => '&scoretable',
10:30:24  17  	  xform_view_name => 'svmc_apply_prep');
10:30:24  18  END;
10:30:24  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.20
10:30:24 SQL> 
10:30:24 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:24 SQL> -- DELETE it if I did:
10:30:24 SQL> DELETE ystkscores
10:30:24   2  WHERE score > 0
10:30:24   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:24   4  -- I need to supply the target attribute name:
10:30:24   5  AND targ = '&1'
10:30:24   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:24 SQL> 
10:30:24 SQL> -- We do a drumroll here:
10:30:24 SQL> 
10:30:24 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:24   2  SELECT
10:30:24   3  tkrdate
10:30:24   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:24   5  ,sysdate
10:30:24   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:24   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:24   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:24   9  ,SUBSTR(tkrdate,-10)ydate
10:30:24  10  ,'&1'
10:30:24  11  FROM svmc_apply_prep
10:30:24  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:30:24 SQL> @score1_5min_gattn.sql	2010-08-27 TLT
10:30:24 SQL> --
10:30:24 SQL> -- score1_5min_gattn.sql
10:30:24 SQL> --
10:30:24 SQL> 
10:30:24 SQL> -- Demo:
10:30:24 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:24 SQL> 
10:30:24 SQL> CREATE OR REPLACE VIEW sme AS
10:30:24   2  SELECT
10:30:24   3  tkrdate
10:30:24   4  ,NULL gattn
10:30:24   5  ,g00
10:30:24   6  ,g01
10:30:24   7  ,g02
10:30:24   8  ,g03
10:30:24   9  ,g04
10:30:24  10  ,g05
10:30:24  11  ,g06
10:30:24  12  ,g07
10:30:24  13  ,g08
10:30:24  14  ,g09
10:30:24  15  ,g10
10:30:24  16  ,g11
10:30:24  17  ,g12
10:30:24  18  ,g13
10:30:24  19  ,g14
10:30:24  20  ,g15
10:30:24  21  ,g16
10:30:24  22  ,g17
10:30:24  23  ,g18
10:30:24  24  ,g19
10:30:24  25  ,g20
10:30:24  26  ,g21
10:30:24  27  ,g22
10:30:24  28  ,g23
10:30:24  29  ,g24
10:30:24  30  ,g25
10:30:24  31  ,g26
10:30:24  32  ,g27
10:30:24  33  ,g28
10:30:24  34  ,g29
10:30:24  35  FROM stk_ms
10:30:24  36  WHERE ydate = '&1'
10:30:24  37  AND tkr = '&2'
10:30:24  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-08-27'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:24 SQL> 
10:30:24 SQL> -- rpt
10:30:24 SQL> -- We should see just 1 row:
10:30:24 SQL> 
10:30:24 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:24   2  
10:30:24 SQL> -- Build the model:
10:30:24 SQL> CREATE OR REPLACE VIEW bme AS
10:30:24   2  SELECT
10:30:24   3  tkrdate
10:30:24   4  ,gattn
10:30:24   5  ,g00
10:30:24   6  ,g01
10:30:24   7  ,g02
10:30:24   8  ,g03
10:30:24   9  ,g04
10:30:24  10  ,g05
10:30:24  11  ,g06
10:30:24  12  ,g07
10:30:24  13  ,g08
10:30:24  14  ,g09
10:30:24  15  ,g10
10:30:24  16  ,g11
10:30:24  17  ,g12
10:30:24  18  ,g13
10:30:24  19  ,g14
10:30:24  20  ,g15
10:30:24  21  ,g16
10:30:24  22  ,g17
10:30:24  23  ,g18
10:30:24  24  ,g19
10:30:24  25  ,g20
10:30:24  26  ,g21
10:30:24  27  ,g22
10:30:24  28  ,g23
10:30:24  29  ,g24
10:30:24  30  ,g25
10:30:24  31  ,g26
10:30:24  32  ,g27
10:30:24  33  ,g28
10:30:24  34  ,g29
10:30:24  35  FROM stk_ms
10:30:24  36  WHERE gattn IN('nup','up')
10:30:24  37  -- Use only rows which are older than 1 day:
10:30:24  38  AND 1+ydate < '&1'
10:30:24  39  AND tkr = '&2'
10:30:24  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-08-27'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:24 SQL> 
10:30:24 SQL> -- rpt
10:30:24 SQL> 
10:30:24 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:24   2  
10:30:24 SQL> SELECT MAX(tkrdate) FROM bme
10:30:24   2  
10:30:24 SQL> -- Now build model from bme and score sme
10:30:24 SQL> @score1.sql gattn
10:30:24 SQL> -- score1.sql
10:30:24 SQL> 
10:30:24 SQL> -- I use this script to send 5 params to score.sql
10:30:24 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:24 SQL> -- Then at the very end of this script I use the model
10:30:24 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:24 SQL> 
10:30:24 SQL> -- I call this script from 2 other scripts:
10:30:24 SQL> -- score1_5min.sql
10:30:24 SQL> -- score1_5min_gattn.sql
10:30:24 SQL> 
10:30:24 SQL> -- The 1st param is the name of the target attribute.
10:30:24 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:24 SQL> 
10:30:24 SQL> -- Demo:
10:30:24 SQL> -- @score1.sql 'gatt'
10:30:24 SQL> -- @score1.sql 'gattn'
10:30:24 SQL> 
10:30:24 SQL> -- Now, I fill up svmc_apply_prep.
10:30:24 SQL> -- I use same model_name used in score.sql
10:30:24 SQL> DEFINE model_name = 'svmspy101'
10:30:24 SQL> DEFINE bldtable	= 'bme'
10:30:24 SQL> DEFINE scoretable = 'sme'
10:30:24 SQL> DEFINE case_id	= 'tkrdate'
10:30:24 SQL> -- Demo:
10:30:24 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:24 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:24 SQL> --
10:30:24 SQL> -- score.sql
10:30:24 SQL> --
10:30:24 SQL> 
10:30:24 SQL> -- usage: score.sql
10:30:24 SQL> 
10:30:24 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:24 SQL> 
10:30:24 SQL> -- DEFINE target	   = 'gatt'
10:30:24 SQL> -- DEFINE model_name = 'svmspy100'
10:30:24 SQL> -- DEFINE bldtable   = 'bme'
10:30:24 SQL> -- DEFINE scoretable = 'sme'
10:30:24 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:24 SQL> 
10:30:24 SQL> DEFINE target	= '&1'
10:30:24 SQL> DEFINE model_name = '&2'
10:30:24 SQL> DEFINE bldtable	= '&3'
10:30:24 SQL> DEFINE scoretable = '&4'
10:30:24 SQL> DEFINE case_id	= '&5'
10:30:24 SQL> 
10:30:24 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:24 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:24 SQL> 
10:30:24 SQL> -- Builds an SVM model using pl/sql.
10:30:24 SQL> 
10:30:24 SQL> -----------------------------------------------------------------------
10:30:24 SQL> --			    BUILD THE MODEL
10:30:24 SQL> -----------------------------------------------------------------------
10:30:24 SQL> 
10:30:24 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:24 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:24 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:24 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:24 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:24 SQL> 
10:30:24 SQL> 
10:30:24 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:24 SQL> --
10:30:24 SQL> -- DROP	TABLE svmc_settings ;
10:30:24 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:24 SQL> -- DELETE svmc_settings;
10:30:24 SQL> 
10:30:24 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:24 SQL> -- this choice to SVM using a settings table.
10:30:24 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:24 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:24 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:24 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:24 SQL> -- models.
10:30:24 SQL> --
10:30:24 SQL> 
10:30:24 SQL> -- Do this once and then comment it out.
10:30:24 SQL> -- That makes script go faster.
10:30:24 SQL> -- BEGIN
10:30:24 SQL> -- -- Populate settings table
10:30:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:24 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:24 SQL> --
10:30:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:24 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:24 SQL> --
10:30:24 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:24 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:24 SQL> --   COMMIT;
10:30:24 SQL> -- END;
10:30:24 SQL> -- /
10:30:24 SQL> 
10:30:24 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:24 SQL> 
10:30:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:24 SQL> 
10:30:24 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:24   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:24   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:24 SQL> 
10:30:24 SQL> --------------------------------
10:30:24 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:24 SQL> --
10:30:24 SQL> 
10:30:24 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:24 SQL> -- 2. Outlier Treatment and
10:30:24 SQL> -- 3. Normalization are performed below.
10:30:24 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:24 SQL> --    normalized here.
10:30:24 SQL> 
10:30:24 SQL> BEGIN
10:30:24   2  	-- Perform missing value treatment for all predictors
10:30:24   3  	-- create miss tables
10:30:24   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:24   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:24   6  
10:30:24   7  	-- populate miss tables
10:30:24   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:24   9  	  miss_table_name => 'svmc_miss_num',
10:30:24  10  	  data_table_name => '&bldtable',
10:30:24  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:24  12  
10:30:24  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:24  14  	  miss_table_name => 'svmc_miss_cat',
10:30:24  15  	  data_table_name => '&bldtable',
10:30:24  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:24  17  
10:30:24  18  	-- xform input data to replace missing values
10:30:24  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:24  20  	  miss_table_name => 'svmc_miss_num',
10:30:24  21  	  data_table_name => '&bldtable',
10:30:24  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:24  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:24  24  	  miss_table_name => 'svmc_miss_cat',
10:30:24  25  	  data_table_name => '&bldtable',
10:30:24  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:24  27  
10:30:24  28  	-- Perform outlier treatment.
10:30:24  29  	-- create clip table
10:30:24  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:24  31  
10:30:24  32  	-- populate clip table
10:30:24  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:24  34  	  clip_table_name => 'svmc_clip',
10:30:24  35  	  data_table_name => '&bldtable',
10:30:24  36  	  tail_frac	  => 0.025,
10:30:24  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:24  38  
10:30:24  39  	-- xform input data to winsorized data
10:30:24  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:24  41  	  clip_table_name => 'svmc_clip',
10:30:24  42  	  data_table_name => '&bldtable',
10:30:24  43  	  xform_view_name => 'svmc_winsor');
10:30:24  44  
10:30:24  45  	-- create normalization table
10:30:24  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:24  47  
10:30:24  48  	-- populate normalization table based on winsorized data
10:30:24  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:24  50  	  norm_table_name => 'svmc_norm',
10:30:24  51  	  data_table_name => 'svmc_winsor',
10:30:24  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:24  53  
10:30:24  54  	-- normalize the original data
10:30:24  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:24  56  	  norm_table_name => 'svmc_norm',
10:30:24  57  	  data_table_name => '&bldtable',
10:30:24  58  	  xform_view_name => 'svmc_build_prep');
10:30:24  59  END;
10:30:24  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:30:25 SQL> 
10:30:25 SQL> ---------------------
10:30:25 SQL> -- CREATE A NEW MODEL
10:30:25 SQL> --
10:30:25 SQL> -- Cleanup old model with the same name for repeat runs
10:30:25 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:25   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:25   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.17
10:30:26 SQL> 
10:30:26 SQL> -- Build a new SVM Model
10:30:26 SQL> BEGIN
10:30:26   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:26   3  	  model_name	      => '&model_name',
10:30:26   4  	  mining_function     => dbms_data_mining.classification,
10:30:26   5  	  data_table_name     => 'svmc_build_prep',
10:30:26   6  	  case_id_column_name => '&case_id',
10:30:26   7  	  target_column_name  => '&target',
10:30:26   8  	  settings_table_name => 'svmc_settings');
10:30:26   9  END;
10:30:26  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.14
10:30:28 SQL> 
10:30:28 SQL> -----------------------------------------------------------------------
10:30:28 SQL> --			       APPLY/score THE MODEL
10:30:28 SQL> -----------------------------------------------------------------------
10:30:28 SQL> 
10:30:28 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:28 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:28   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:28   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:28 SQL> -----------------------
10:30:28 SQL> -- PREPARE SCORING DATA
10:30:28 SQL> --
10:30:28 SQL> -- If the data for model creation has been prepared, then the data
10:30:28 SQL> -- to be scored using the model must be prepared in the same manner
10:30:28 SQL> -- in order to obtain meaningful results.
10:30:28 SQL> --
10:30:28 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:28 SQL> -- 2. Normalization
10:30:28 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:28 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:28 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:28 SQL> --
10:30:28 SQL> BEGIN
10:30:28   2  	-- Xform Test data to replace missing values
10:30:28   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:28   4  	  miss_table_name => 'svmc_miss_num',
10:30:28   5  	  data_table_name => '&scoretable',
10:30:28   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:28   7  
10:30:28   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:28   9  	  miss_table_name => 'svmc_miss_cat',
10:30:28  10  	  data_table_name => '&scoretable',
10:30:28  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:28  12  
10:30:28  13  	-- Normalize the data to be scored
10:30:28  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:28  15  	  norm_table_name => 'svmc_norm',
10:30:28  16  	  data_table_name => '&scoretable',
10:30:28  17  	  xform_view_name => 'svmc_apply_prep');
10:30:28  18  END;
10:30:28  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.27
10:30:29 SQL> 
10:30:29 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:29 SQL> -- DELETE it if I did:
10:30:29 SQL> DELETE ystkscores
10:30:29   2  WHERE score > 0
10:30:29   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:29   4  -- I need to supply the target attribute name:
10:30:29   5  AND targ = '&1'
10:30:29   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:29 SQL> 
10:30:29 SQL> -- We do a drumroll here:
10:30:29 SQL> 
10:30:29 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:29   2  SELECT
10:30:29   3  tkrdate
10:30:29   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:29   5  ,sysdate
10:30:29   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:29   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:29   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:29   9  ,SUBSTR(tkrdate,-10)ydate
10:30:29  10  ,'&1'
10:30:29  11  FROM svmc_apply_prep
10:30:29  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.04
10:30:29 SQL> @score1_5min.sql	      2010-07-29 TLT
10:30:29 SQL> --
10:30:29 SQL> -- score1_5min.sql
10:30:29 SQL> --
10:30:29 SQL> 
10:30:29 SQL> -- Demo:
10:30:29 SQL> -- @score1_5min.sql 2010-12-31 SPY
10:30:29 SQL> 
10:30:29 SQL> CREATE OR REPLACE VIEW sme AS
10:30:29   2  SELECT
10:30:29   3  tkrdate
10:30:29   4  ,NULL gatt
10:30:29   5  ,g00
10:30:29   6  ,g01
10:30:29   7  ,g02
10:30:29   8  ,g03
10:30:29   9  ,g04
10:30:29  10  ,g05
10:30:29  11  ,g06
10:30:29  12  ,g07
10:30:29  13  ,g08
10:30:29  14  ,g09
10:30:29  15  ,g10
10:30:29  16  ,g11
10:30:29  17  ,g12
10:30:29  18  ,g13
10:30:29  19  ,g14
10:30:29  20  ,g15
10:30:29  21  ,g16
10:30:29  22  ,g17
10:30:29  23  ,g18
10:30:29  24  ,g19
10:30:29  25  ,g20
10:30:29  26  ,g21
10:30:29  27  ,g22
10:30:29  28  ,g23
10:30:29  29  ,g24
10:30:29  30  ,g25
10:30:29  31  ,g26
10:30:29  32  ,g27
10:30:29  33  ,g28
10:30:29  34  ,g29
10:30:29  35  FROM stk_ms
10:30:29  36  WHERE ydate = '&1'
10:30:29  37  AND tkr = '&2'
10:30:29  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-07-29'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.09
10:30:29 SQL> 
10:30:29 SQL> -- rpt
10:30:29 SQL> -- We should see just 1 row:
10:30:29 SQL> 
10:30:29 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:29   2  
10:30:29 SQL> -- Build the model:
10:30:29 SQL> CREATE OR REPLACE VIEW bme AS
10:30:29   2  SELECT
10:30:29   3  tkrdate
10:30:29   4  ,gatt
10:30:29   5  ,g00
10:30:29   6  ,g01
10:30:29   7  ,g02
10:30:29   8  ,g03
10:30:29   9  ,g04
10:30:29  10  ,g05
10:30:29  11  ,g06
10:30:29  12  ,g07
10:30:29  13  ,g08
10:30:29  14  ,g09
10:30:29  15  ,g10
10:30:29  16  ,g11
10:30:29  17  ,g12
10:30:29  18  ,g13
10:30:29  19  ,g14
10:30:29  20  ,g15
10:30:29  21  ,g16
10:30:29  22  ,g17
10:30:29  23  ,g18
10:30:29  24  ,g19
10:30:29  25  ,g20
10:30:29  26  ,g21
10:30:29  27  ,g22
10:30:29  28  ,g23
10:30:29  29  ,g24
10:30:29  30  ,g25
10:30:29  31  ,g26
10:30:29  32  ,g27
10:30:29  33  ,g28
10:30:29  34  ,g29
10:30:29  35  FROM stk_ms
10:30:29  36  WHERE gatt IN('nup','up')
10:30:29  37  -- Use only rows which are older than 1 day:
10:30:29  38  AND 1+ydate < '&1'
10:30:29  39  AND tkr = '&2'
10:30:29  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-07-29'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:29 SQL> 
10:30:29 SQL> -- rpt
10:30:29 SQL> 
10:30:29 SQL> SELECT gatt, COUNT(tkrdate) FROM bme GROUP BY gatt
10:30:29   2  
10:30:29 SQL> SELECT MAX(tkrdate) FROM bme
10:30:29   2  
10:30:29 SQL> -- Now build model from bme and score sme
10:30:29 SQL> @score1.sql gatt
10:30:29 SQL> -- score1.sql
10:30:29 SQL> 
10:30:29 SQL> -- I use this script to send 5 params to score.sql
10:30:29 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:29 SQL> -- Then at the very end of this script I use the model
10:30:29 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:29 SQL> 
10:30:29 SQL> -- I call this script from 2 other scripts:
10:30:29 SQL> -- score1_5min.sql
10:30:29 SQL> -- score1_5min_gattn.sql
10:30:29 SQL> 
10:30:29 SQL> -- The 1st param is the name of the target attribute.
10:30:29 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:29 SQL> 
10:30:29 SQL> -- Demo:
10:30:29 SQL> -- @score1.sql 'gatt'
10:30:29 SQL> -- @score1.sql 'gattn'
10:30:29 SQL> 
10:30:29 SQL> -- Now, I fill up svmc_apply_prep.
10:30:29 SQL> -- I use same model_name used in score.sql
10:30:29 SQL> DEFINE model_name = 'svmspy101'
10:30:29 SQL> DEFINE bldtable	= 'bme'
10:30:29 SQL> DEFINE scoretable = 'sme'
10:30:29 SQL> DEFINE case_id	= 'tkrdate'
10:30:29 SQL> -- Demo:
10:30:29 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:29 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:29 SQL> --
10:30:29 SQL> -- score.sql
10:30:29 SQL> --
10:30:29 SQL> 
10:30:29 SQL> -- usage: score.sql
10:30:29 SQL> 
10:30:29 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:29 SQL> 
10:30:29 SQL> -- DEFINE target	   = 'gatt'
10:30:29 SQL> -- DEFINE model_name = 'svmspy100'
10:30:29 SQL> -- DEFINE bldtable   = 'bme'
10:30:29 SQL> -- DEFINE scoretable = 'sme'
10:30:29 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:29 SQL> 
10:30:29 SQL> DEFINE target	= '&1'
10:30:29 SQL> DEFINE model_name = '&2'
10:30:29 SQL> DEFINE bldtable	= '&3'
10:30:29 SQL> DEFINE scoretable = '&4'
10:30:29 SQL> DEFINE case_id	= '&5'
10:30:29 SQL> 
10:30:29 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:29 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:29 SQL> 
10:30:29 SQL> -- Builds an SVM model using pl/sql.
10:30:29 SQL> 
10:30:29 SQL> -----------------------------------------------------------------------
10:30:29 SQL> --			    BUILD THE MODEL
10:30:29 SQL> -----------------------------------------------------------------------
10:30:29 SQL> 
10:30:29 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:29 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:29 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:29 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:29 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:29 SQL> 
10:30:29 SQL> 
10:30:29 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:29 SQL> --
10:30:29 SQL> -- DROP	TABLE svmc_settings ;
10:30:29 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:29 SQL> -- DELETE svmc_settings;
10:30:29 SQL> 
10:30:29 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:29 SQL> -- this choice to SVM using a settings table.
10:30:29 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:29 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:29 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:29 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:29 SQL> -- models.
10:30:29 SQL> --
10:30:29 SQL> 
10:30:29 SQL> -- Do this once and then comment it out.
10:30:29 SQL> -- That makes script go faster.
10:30:29 SQL> -- BEGIN
10:30:29 SQL> -- -- Populate settings table
10:30:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:29 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:29 SQL> --
10:30:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:29 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:29 SQL> --
10:30:29 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:29 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:29 SQL> --   COMMIT;
10:30:29 SQL> -- END;
10:30:29 SQL> -- /
10:30:29 SQL> 
10:30:29 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:30:29 SQL> 
10:30:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:29 SQL> 
10:30:29 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:29   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:29   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:29 SQL> 
10:30:29 SQL> --------------------------------
10:30:29 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:29 SQL> --
10:30:29 SQL> 
10:30:29 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:29 SQL> -- 2. Outlier Treatment and
10:30:29 SQL> -- 3. Normalization are performed below.
10:30:29 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:29 SQL> --    normalized here.
10:30:29 SQL> 
10:30:29 SQL> BEGIN
10:30:29   2  	-- Perform missing value treatment for all predictors
10:30:29   3  	-- create miss tables
10:30:29   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:29   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:29   6  
10:30:29   7  	-- populate miss tables
10:30:29   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:29   9  	  miss_table_name => 'svmc_miss_num',
10:30:29  10  	  data_table_name => '&bldtable',
10:30:29  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:29  12  
10:30:29  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:29  14  	  miss_table_name => 'svmc_miss_cat',
10:30:29  15  	  data_table_name => '&bldtable',
10:30:29  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:29  17  
10:30:29  18  	-- xform input data to replace missing values
10:30:29  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:29  20  	  miss_table_name => 'svmc_miss_num',
10:30:29  21  	  data_table_name => '&bldtable',
10:30:29  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:29  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:29  24  	  miss_table_name => 'svmc_miss_cat',
10:30:29  25  	  data_table_name => '&bldtable',
10:30:29  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:29  27  
10:30:29  28  	-- Perform outlier treatment.
10:30:29  29  	-- create clip table
10:30:29  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:29  31  
10:30:29  32  	-- populate clip table
10:30:29  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:29  34  	  clip_table_name => 'svmc_clip',
10:30:29  35  	  data_table_name => '&bldtable',
10:30:29  36  	  tail_frac	  => 0.025,
10:30:29  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:29  38  
10:30:29  39  	-- xform input data to winsorized data
10:30:29  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:29  41  	  clip_table_name => 'svmc_clip',
10:30:29  42  	  data_table_name => '&bldtable',
10:30:29  43  	  xform_view_name => 'svmc_winsor');
10:30:29  44  
10:30:29  45  	-- create normalization table
10:30:29  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:29  47  
10:30:29  48  	-- populate normalization table based on winsorized data
10:30:29  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:29  50  	  norm_table_name => 'svmc_norm',
10:30:29  51  	  data_table_name => 'svmc_winsor',
10:30:29  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:29  53  
10:30:29  54  	-- normalize the original data
10:30:29  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:29  56  	  norm_table_name => 'svmc_norm',
10:30:29  57  	  data_table_name => '&bldtable',
10:30:29  58  	  xform_view_name => 'svmc_build_prep');
10:30:29  59  END;
10:30:29  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gatt','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.60
10:30:30 SQL> 
10:30:30 SQL> ---------------------
10:30:30 SQL> -- CREATE A NEW MODEL
10:30:30 SQL> --
10:30:30 SQL> -- Cleanup old model with the same name for repeat runs
10:30:30 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:30   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:30   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.11
10:30:31 SQL> 
10:30:31 SQL> -- Build a new SVM Model
10:30:31 SQL> BEGIN
10:30:31   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:31   3  	  model_name	      => '&model_name',
10:30:31   4  	  mining_function     => dbms_data_mining.classification,
10:30:31   5  	  data_table_name     => 'svmc_build_prep',
10:30:31   6  	  case_id_column_name => '&case_id',
10:30:31   7  	  target_column_name  => '&target',
10:30:31   8  	  settings_table_name => 'svmc_settings');
10:30:31   9  END;
10:30:31  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gatt',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.02
10:30:33 SQL> 
10:30:33 SQL> -----------------------------------------------------------------------
10:30:33 SQL> --			       APPLY/score THE MODEL
10:30:33 SQL> -----------------------------------------------------------------------
10:30:33 SQL> 
10:30:33 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:33 SQL> -----------------------
10:30:33 SQL> -- PREPARE SCORING DATA
10:30:33 SQL> --
10:30:33 SQL> -- If the data for model creation has been prepared, then the data
10:30:33 SQL> -- to be scored using the model must be prepared in the same manner
10:30:33 SQL> -- in order to obtain meaningful results.
10:30:33 SQL> --
10:30:33 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:33 SQL> -- 2. Normalization
10:30:33 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:33 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:33 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:33 SQL> --
10:30:33 SQL> BEGIN
10:30:33   2  	-- Xform Test data to replace missing values
10:30:33   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:33   4  	  miss_table_name => 'svmc_miss_num',
10:30:33   5  	  data_table_name => '&scoretable',
10:30:33   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:33   7  
10:30:33   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:33   9  	  miss_table_name => 'svmc_miss_cat',
10:30:33  10  	  data_table_name => '&scoretable',
10:30:33  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:33  12  
10:30:33  13  	-- Normalize the data to be scored
10:30:33  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:33  15  	  norm_table_name => 'svmc_norm',
10:30:33  16  	  data_table_name => '&scoretable',
10:30:33  17  	  xform_view_name => 'svmc_apply_prep');
10:30:33  18  END;
10:30:33  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:30:33 SQL> 
10:30:33 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:33 SQL> -- DELETE it if I did:
10:30:33 SQL> DELETE ystkscores
10:30:33   2  WHERE score > 0
10:30:33   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:33   4  -- I need to supply the target attribute name:
10:30:33   5  AND targ = '&1'
10:30:33   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gatt'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:33 SQL> 
10:30:33 SQL> -- We do a drumroll here:
10:30:33 SQL> 
10:30:33 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:33   2  SELECT
10:30:33   3  tkrdate
10:30:33   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:33   5  ,sysdate
10:30:33   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:33   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:33   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:33   9  ,SUBSTR(tkrdate,-10)ydate
10:30:33  10  ,'&1'
10:30:33  11  FROM svmc_apply_prep
10:30:33  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gatt'

1 row created.

Elapsed: 00:00:00.04
10:30:33 SQL> @score1_5min_gattn.sql	2010-03-26 TLT
10:30:33 SQL> --
10:30:33 SQL> -- score1_5min_gattn.sql
10:30:33 SQL> --
10:30:33 SQL> 
10:30:33 SQL> -- Demo:
10:30:33 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:33 SQL> 
10:30:33 SQL> CREATE OR REPLACE VIEW sme AS
10:30:33   2  SELECT
10:30:33   3  tkrdate
10:30:33   4  ,NULL gattn
10:30:33   5  ,g00
10:30:33   6  ,g01
10:30:33   7  ,g02
10:30:33   8  ,g03
10:30:33   9  ,g04
10:30:33  10  ,g05
10:30:33  11  ,g06
10:30:33  12  ,g07
10:30:33  13  ,g08
10:30:33  14  ,g09
10:30:33  15  ,g10
10:30:33  16  ,g11
10:30:33  17  ,g12
10:30:33  18  ,g13
10:30:33  19  ,g14
10:30:33  20  ,g15
10:30:33  21  ,g16
10:30:33  22  ,g17
10:30:33  23  ,g18
10:30:33  24  ,g19
10:30:33  25  ,g20
10:30:33  26  ,g21
10:30:33  27  ,g22
10:30:33  28  ,g23
10:30:33  29  ,g24
10:30:33  30  ,g25
10:30:33  31  ,g26
10:30:33  32  ,g27
10:30:33  33  ,g28
10:30:33  34  ,g29
10:30:33  35  FROM stk_ms
10:30:33  36  WHERE ydate = '&1'
10:30:33  37  AND tkr = '&2'
10:30:33  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-03-26'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:33 SQL> 
10:30:33 SQL> -- rpt
10:30:33 SQL> -- We should see just 1 row:
10:30:33 SQL> 
10:30:33 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:33   2  
10:30:33 SQL> -- Build the model:
10:30:33 SQL> CREATE OR REPLACE VIEW bme AS
10:30:33   2  SELECT
10:30:33   3  tkrdate
10:30:33   4  ,gattn
10:30:33   5  ,g00
10:30:33   6  ,g01
10:30:33   7  ,g02
10:30:33   8  ,g03
10:30:33   9  ,g04
10:30:33  10  ,g05
10:30:33  11  ,g06
10:30:33  12  ,g07
10:30:33  13  ,g08
10:30:33  14  ,g09
10:30:33  15  ,g10
10:30:33  16  ,g11
10:30:33  17  ,g12
10:30:33  18  ,g13
10:30:33  19  ,g14
10:30:33  20  ,g15
10:30:33  21  ,g16
10:30:33  22  ,g17
10:30:33  23  ,g18
10:30:33  24  ,g19
10:30:33  25  ,g20
10:30:33  26  ,g21
10:30:33  27  ,g22
10:30:33  28  ,g23
10:30:33  29  ,g24
10:30:33  30  ,g25
10:30:33  31  ,g26
10:30:33  32  ,g27
10:30:33  33  ,g28
10:30:33  34  ,g29
10:30:33  35  FROM stk_ms
10:30:33  36  WHERE gattn IN('nup','up')
10:30:33  37  -- Use only rows which are older than 1 day:
10:30:33  38  AND 1+ydate < '&1'
10:30:33  39  AND tkr = '&2'
10:30:33  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-03-26'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:33 SQL> 
10:30:33 SQL> -- rpt
10:30:33 SQL> 
10:30:33 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:33   2  
10:30:33 SQL> SELECT MAX(tkrdate) FROM bme
10:30:33   2  
10:30:33 SQL> -- Now build model from bme and score sme
10:30:33 SQL> @score1.sql gattn
10:30:33 SQL> -- score1.sql
10:30:33 SQL> 
10:30:33 SQL> -- I use this script to send 5 params to score.sql
10:30:33 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:33 SQL> -- Then at the very end of this script I use the model
10:30:33 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:33 SQL> 
10:30:33 SQL> -- I call this script from 2 other scripts:
10:30:33 SQL> -- score1_5min.sql
10:30:33 SQL> -- score1_5min_gattn.sql
10:30:33 SQL> 
10:30:33 SQL> -- The 1st param is the name of the target attribute.
10:30:33 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:33 SQL> 
10:30:33 SQL> -- Demo:
10:30:33 SQL> -- @score1.sql 'gatt'
10:30:33 SQL> -- @score1.sql 'gattn'
10:30:33 SQL> 
10:30:33 SQL> -- Now, I fill up svmc_apply_prep.
10:30:33 SQL> -- I use same model_name used in score.sql
10:30:33 SQL> DEFINE model_name = 'svmspy101'
10:30:33 SQL> DEFINE bldtable	= 'bme'
10:30:33 SQL> DEFINE scoretable = 'sme'
10:30:33 SQL> DEFINE case_id	= 'tkrdate'
10:30:33 SQL> -- Demo:
10:30:33 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:33 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:33 SQL> --
10:30:33 SQL> -- score.sql
10:30:33 SQL> --
10:30:33 SQL> 
10:30:33 SQL> -- usage: score.sql
10:30:33 SQL> 
10:30:33 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:33 SQL> 
10:30:33 SQL> -- DEFINE target	   = 'gatt'
10:30:33 SQL> -- DEFINE model_name = 'svmspy100'
10:30:33 SQL> -- DEFINE bldtable   = 'bme'
10:30:33 SQL> -- DEFINE scoretable = 'sme'
10:30:33 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:33 SQL> 
10:30:33 SQL> DEFINE target	= '&1'
10:30:33 SQL> DEFINE model_name = '&2'
10:30:33 SQL> DEFINE bldtable	= '&3'
10:30:33 SQL> DEFINE scoretable = '&4'
10:30:33 SQL> DEFINE case_id	= '&5'
10:30:33 SQL> 
10:30:33 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:33 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:33 SQL> 
10:30:33 SQL> -- Builds an SVM model using pl/sql.
10:30:33 SQL> 
10:30:33 SQL> -----------------------------------------------------------------------
10:30:33 SQL> --			    BUILD THE MODEL
10:30:33 SQL> -----------------------------------------------------------------------
10:30:33 SQL> 
10:30:33 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:33 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:33 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.01
10:30:33 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:33 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:33 SQL> 
10:30:33 SQL> 
10:30:33 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:33 SQL> --
10:30:33 SQL> -- DROP	TABLE svmc_settings ;
10:30:33 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:33 SQL> -- DELETE svmc_settings;
10:30:33 SQL> 
10:30:33 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:33 SQL> -- this choice to SVM using a settings table.
10:30:33 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:33 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:33 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:33 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:33 SQL> -- models.
10:30:33 SQL> --
10:30:33 SQL> 
10:30:33 SQL> -- Do this once and then comment it out.
10:30:33 SQL> -- That makes script go faster.
10:30:33 SQL> -- BEGIN
10:30:33 SQL> -- -- Populate settings table
10:30:33 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:33 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:33 SQL> --
10:30:33 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:33 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:33 SQL> --
10:30:33 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:33 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:33 SQL> --   COMMIT;
10:30:33 SQL> -- END;
10:30:33 SQL> -- /
10:30:33 SQL> 
10:30:33 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:33 SQL> 
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:33 SQL> 
10:30:33 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:33   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:33   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:33 SQL> 
10:30:33 SQL> --------------------------------
10:30:33 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:33 SQL> --
10:30:33 SQL> 
10:30:33 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:33 SQL> -- 2. Outlier Treatment and
10:30:33 SQL> -- 3. Normalization are performed below.
10:30:33 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:33 SQL> --    normalized here.
10:30:33 SQL> 
10:30:33 SQL> BEGIN
10:30:33   2  	-- Perform missing value treatment for all predictors
10:30:33   3  	-- create miss tables
10:30:33   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:33   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:33   6  
10:30:33   7  	-- populate miss tables
10:30:33   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:33   9  	  miss_table_name => 'svmc_miss_num',
10:30:33  10  	  data_table_name => '&bldtable',
10:30:33  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:33  12  
10:30:33  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:33  14  	  miss_table_name => 'svmc_miss_cat',
10:30:33  15  	  data_table_name => '&bldtable',
10:30:33  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:33  17  
10:30:33  18  	-- xform input data to replace missing values
10:30:33  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:33  20  	  miss_table_name => 'svmc_miss_num',
10:30:33  21  	  data_table_name => '&bldtable',
10:30:33  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:33  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:33  24  	  miss_table_name => 'svmc_miss_cat',
10:30:33  25  	  data_table_name => '&bldtable',
10:30:33  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:33  27  
10:30:33  28  	-- Perform outlier treatment.
10:30:33  29  	-- create clip table
10:30:33  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:33  31  
10:30:33  32  	-- populate clip table
10:30:33  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:33  34  	  clip_table_name => 'svmc_clip',
10:30:33  35  	  data_table_name => '&bldtable',
10:30:33  36  	  tail_frac	  => 0.025,
10:30:33  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:33  38  
10:30:33  39  	-- xform input data to winsorized data
10:30:33  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:33  41  	  clip_table_name => 'svmc_clip',
10:30:33  42  	  data_table_name => '&bldtable',
10:30:33  43  	  xform_view_name => 'svmc_winsor');
10:30:33  44  
10:30:33  45  	-- create normalization table
10:30:33  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:33  47  
10:30:33  48  	-- populate normalization table based on winsorized data
10:30:33  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:33  50  	  norm_table_name => 'svmc_norm',
10:30:33  51  	  data_table_name => 'svmc_winsor',
10:30:33  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:33  53  
10:30:33  54  	-- normalize the original data
10:30:33  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:33  56  	  norm_table_name => 'svmc_norm',
10:30:33  57  	  data_table_name => '&bldtable',
10:30:33  58  	  xform_view_name => 'svmc_build_prep');
10:30:33  59  END;
10:30:33  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:30:34 SQL> 
10:30:34 SQL> ---------------------
10:30:34 SQL> -- CREATE A NEW MODEL
10:30:34 SQL> --
10:30:34 SQL> -- Cleanup old model with the same name for repeat runs
10:30:34 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:34   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:34   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.19
10:30:35 SQL> 
10:30:35 SQL> -- Build a new SVM Model
10:30:35 SQL> BEGIN
10:30:35   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:35   3  	  model_name	      => '&model_name',
10:30:35   4  	  mining_function     => dbms_data_mining.classification,
10:30:35   5  	  data_table_name     => 'svmc_build_prep',
10:30:35   6  	  case_id_column_name => '&case_id',
10:30:35   7  	  target_column_name  => '&target',
10:30:35   8  	  settings_table_name => 'svmc_settings');
10:30:35   9  END;
10:30:35  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.53
10:30:38 SQL> 
10:30:38 SQL> -----------------------------------------------------------------------
10:30:38 SQL> --			       APPLY/score THE MODEL
10:30:38 SQL> -----------------------------------------------------------------------
10:30:38 SQL> 
10:30:38 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:38 SQL> -----------------------
10:30:38 SQL> -- PREPARE SCORING DATA
10:30:38 SQL> --
10:30:38 SQL> -- If the data for model creation has been prepared, then the data
10:30:38 SQL> -- to be scored using the model must be prepared in the same manner
10:30:38 SQL> -- in order to obtain meaningful results.
10:30:38 SQL> --
10:30:38 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:38 SQL> -- 2. Normalization
10:30:38 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:38 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:38 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:38 SQL> --
10:30:38 SQL> BEGIN
10:30:38   2  	-- Xform Test data to replace missing values
10:30:38   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:38   4  	  miss_table_name => 'svmc_miss_num',
10:30:38   5  	  data_table_name => '&scoretable',
10:30:38   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:38   7  
10:30:38   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:38   9  	  miss_table_name => 'svmc_miss_cat',
10:30:38  10  	  data_table_name => '&scoretable',
10:30:38  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:38  12  
10:30:38  13  	-- Normalize the data to be scored
10:30:38  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:38  15  	  norm_table_name => 'svmc_norm',
10:30:38  16  	  data_table_name => '&scoretable',
10:30:38  17  	  xform_view_name => 'svmc_apply_prep');
10:30:38  18  END;
10:30:38  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.19
10:30:38 SQL> 
10:30:38 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:38 SQL> -- DELETE it if I did:
10:30:38 SQL> DELETE ystkscores
10:30:38   2  WHERE score > 0
10:30:38   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:38   4  -- I need to supply the target attribute name:
10:30:38   5  AND targ = '&1'
10:30:38   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:38 SQL> 
10:30:38 SQL> -- We do a drumroll here:
10:30:38 SQL> 
10:30:38 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:38   2  SELECT
10:30:38   3  tkrdate
10:30:38   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:38   5  ,sysdate
10:30:38   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:38   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:38   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:38   9  ,SUBSTR(tkrdate,-10)ydate
10:30:38  10  ,'&1'
10:30:38  11  FROM svmc_apply_prep
10:30:38  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:30:38 SQL> @score1_5min_gattn.sql	2010-11-29 TLT
10:30:38 SQL> --
10:30:38 SQL> -- score1_5min_gattn.sql
10:30:38 SQL> --
10:30:38 SQL> 
10:30:38 SQL> -- Demo:
10:30:38 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:38 SQL> 
10:30:38 SQL> CREATE OR REPLACE VIEW sme AS
10:30:38   2  SELECT
10:30:38   3  tkrdate
10:30:38   4  ,NULL gattn
10:30:38   5  ,g00
10:30:38   6  ,g01
10:30:38   7  ,g02
10:30:38   8  ,g03
10:30:38   9  ,g04
10:30:38  10  ,g05
10:30:38  11  ,g06
10:30:38  12  ,g07
10:30:38  13  ,g08
10:30:38  14  ,g09
10:30:38  15  ,g10
10:30:38  16  ,g11
10:30:38  17  ,g12
10:30:38  18  ,g13
10:30:38  19  ,g14
10:30:38  20  ,g15
10:30:38  21  ,g16
10:30:38  22  ,g17
10:30:38  23  ,g18
10:30:38  24  ,g19
10:30:38  25  ,g20
10:30:38  26  ,g21
10:30:38  27  ,g22
10:30:38  28  ,g23
10:30:38  29  ,g24
10:30:38  30  ,g25
10:30:38  31  ,g26
10:30:38  32  ,g27
10:30:38  33  ,g28
10:30:38  34  ,g29
10:30:38  35  FROM stk_ms
10:30:38  36  WHERE ydate = '&1'
10:30:38  37  AND tkr = '&2'
10:30:38  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-11-29'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:30:38 SQL> 
10:30:38 SQL> -- rpt
10:30:38 SQL> -- We should see just 1 row:
10:30:38 SQL> 
10:30:38 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:38   2  
10:30:38 SQL> -- Build the model:
10:30:38 SQL> CREATE OR REPLACE VIEW bme AS
10:30:38   2  SELECT
10:30:38   3  tkrdate
10:30:38   4  ,gattn
10:30:38   5  ,g00
10:30:38   6  ,g01
10:30:38   7  ,g02
10:30:38   8  ,g03
10:30:38   9  ,g04
10:30:38  10  ,g05
10:30:38  11  ,g06
10:30:38  12  ,g07
10:30:38  13  ,g08
10:30:38  14  ,g09
10:30:38  15  ,g10
10:30:38  16  ,g11
10:30:38  17  ,g12
10:30:38  18  ,g13
10:30:38  19  ,g14
10:30:38  20  ,g15
10:30:38  21  ,g16
10:30:38  22  ,g17
10:30:38  23  ,g18
10:30:38  24  ,g19
10:30:38  25  ,g20
10:30:38  26  ,g21
10:30:38  27  ,g22
10:30:38  28  ,g23
10:30:38  29  ,g24
10:30:38  30  ,g25
10:30:38  31  ,g26
10:30:38  32  ,g27
10:30:38  33  ,g28
10:30:38  34  ,g29
10:30:38  35  FROM stk_ms
10:30:38  36  WHERE gattn IN('nup','up')
10:30:38  37  -- Use only rows which are older than 1 day:
10:30:38  38  AND 1+ydate < '&1'
10:30:38  39  AND tkr = '&2'
10:30:38  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-11-29'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:38 SQL> 
10:30:38 SQL> -- rpt
10:30:38 SQL> 
10:30:38 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:38   2  
10:30:38 SQL> SELECT MAX(tkrdate) FROM bme
10:30:38   2  
10:30:38 SQL> -- Now build model from bme and score sme
10:30:38 SQL> @score1.sql gattn
10:30:38 SQL> -- score1.sql
10:30:38 SQL> 
10:30:38 SQL> -- I use this script to send 5 params to score.sql
10:30:38 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:38 SQL> -- Then at the very end of this script I use the model
10:30:38 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:38 SQL> 
10:30:38 SQL> -- I call this script from 2 other scripts:
10:30:38 SQL> -- score1_5min.sql
10:30:38 SQL> -- score1_5min_gattn.sql
10:30:38 SQL> 
10:30:38 SQL> -- The 1st param is the name of the target attribute.
10:30:38 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:38 SQL> 
10:30:38 SQL> -- Demo:
10:30:38 SQL> -- @score1.sql 'gatt'
10:30:38 SQL> -- @score1.sql 'gattn'
10:30:38 SQL> 
10:30:38 SQL> -- Now, I fill up svmc_apply_prep.
10:30:38 SQL> -- I use same model_name used in score.sql
10:30:38 SQL> DEFINE model_name = 'svmspy101'
10:30:38 SQL> DEFINE bldtable	= 'bme'
10:30:38 SQL> DEFINE scoretable = 'sme'
10:30:38 SQL> DEFINE case_id	= 'tkrdate'
10:30:38 SQL> -- Demo:
10:30:38 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:38 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:38 SQL> --
10:30:38 SQL> -- score.sql
10:30:38 SQL> --
10:30:38 SQL> 
10:30:38 SQL> -- usage: score.sql
10:30:38 SQL> 
10:30:38 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:38 SQL> 
10:30:38 SQL> -- DEFINE target	   = 'gatt'
10:30:38 SQL> -- DEFINE model_name = 'svmspy100'
10:30:38 SQL> -- DEFINE bldtable   = 'bme'
10:30:38 SQL> -- DEFINE scoretable = 'sme'
10:30:38 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:38 SQL> 
10:30:38 SQL> DEFINE target	= '&1'
10:30:38 SQL> DEFINE model_name = '&2'
10:30:38 SQL> DEFINE bldtable	= '&3'
10:30:38 SQL> DEFINE scoretable = '&4'
10:30:38 SQL> DEFINE case_id	= '&5'
10:30:38 SQL> 
10:30:38 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:38 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:38 SQL> 
10:30:38 SQL> -- Builds an SVM model using pl/sql.
10:30:38 SQL> 
10:30:38 SQL> -----------------------------------------------------------------------
10:30:38 SQL> --			    BUILD THE MODEL
10:30:38 SQL> -----------------------------------------------------------------------
10:30:38 SQL> 
10:30:38 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:38 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:38 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:38 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.01
10:30:38 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:38 SQL> 
10:30:38 SQL> 
10:30:38 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:38 SQL> --
10:30:38 SQL> -- DROP	TABLE svmc_settings ;
10:30:38 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:38 SQL> -- DELETE svmc_settings;
10:30:38 SQL> 
10:30:38 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:38 SQL> -- this choice to SVM using a settings table.
10:30:38 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:38 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:38 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:38 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:38 SQL> -- models.
10:30:38 SQL> --
10:30:38 SQL> 
10:30:38 SQL> -- Do this once and then comment it out.
10:30:38 SQL> -- That makes script go faster.
10:30:38 SQL> -- BEGIN
10:30:38 SQL> -- -- Populate settings table
10:30:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:38 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:38 SQL> --
10:30:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:38 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:38 SQL> --
10:30:38 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:38 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:38 SQL> --   COMMIT;
10:30:38 SQL> -- END;
10:30:38 SQL> -- /
10:30:38 SQL> 
10:30:38 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.00
10:30:38 SQL> 
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:38 SQL> 
10:30:38 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:38   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:38   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:38 SQL> 
10:30:38 SQL> --------------------------------
10:30:38 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:38 SQL> --
10:30:38 SQL> 
10:30:38 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:38 SQL> -- 2. Outlier Treatment and
10:30:38 SQL> -- 3. Normalization are performed below.
10:30:38 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:38 SQL> --    normalized here.
10:30:38 SQL> 
10:30:38 SQL> BEGIN
10:30:38   2  	-- Perform missing value treatment for all predictors
10:30:38   3  	-- create miss tables
10:30:38   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:38   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:38   6  
10:30:38   7  	-- populate miss tables
10:30:38   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:38   9  	  miss_table_name => 'svmc_miss_num',
10:30:38  10  	  data_table_name => '&bldtable',
10:30:38  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:38  12  
10:30:38  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:38  14  	  miss_table_name => 'svmc_miss_cat',
10:30:38  15  	  data_table_name => '&bldtable',
10:30:38  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:38  17  
10:30:38  18  	-- xform input data to replace missing values
10:30:38  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:38  20  	  miss_table_name => 'svmc_miss_num',
10:30:38  21  	  data_table_name => '&bldtable',
10:30:38  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:38  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:38  24  	  miss_table_name => 'svmc_miss_cat',
10:30:38  25  	  data_table_name => '&bldtable',
10:30:38  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:38  27  
10:30:38  28  	-- Perform outlier treatment.
10:30:38  29  	-- create clip table
10:30:38  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:38  31  
10:30:38  32  	-- populate clip table
10:30:38  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:38  34  	  clip_table_name => 'svmc_clip',
10:30:38  35  	  data_table_name => '&bldtable',
10:30:38  36  	  tail_frac	  => 0.025,
10:30:38  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:38  38  
10:30:38  39  	-- xform input data to winsorized data
10:30:38  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:38  41  	  clip_table_name => 'svmc_clip',
10:30:38  42  	  data_table_name => '&bldtable',
10:30:38  43  	  xform_view_name => 'svmc_winsor');
10:30:38  44  
10:30:38  45  	-- create normalization table
10:30:38  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:38  47  
10:30:38  48  	-- populate normalization table based on winsorized data
10:30:38  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:38  50  	  norm_table_name => 'svmc_norm',
10:30:38  51  	  data_table_name => 'svmc_winsor',
10:30:38  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:38  53  
10:30:38  54  	-- normalize the original data
10:30:38  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:38  56  	  norm_table_name => 'svmc_norm',
10:30:38  57  	  data_table_name => '&bldtable',
10:30:38  58  	  xform_view_name => 'svmc_build_prep');
10:30:38  59  END;
10:30:38  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.61
10:30:39 SQL> 
10:30:39 SQL> ---------------------
10:30:39 SQL> -- CREATE A NEW MODEL
10:30:39 SQL> --
10:30:39 SQL> -- Cleanup old model with the same name for repeat runs
10:30:39 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:39   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:39   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.04
10:30:40 SQL> 
10:30:40 SQL> -- Build a new SVM Model
10:30:40 SQL> BEGIN
10:30:40   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:40   3  	  model_name	      => '&model_name',
10:30:40   4  	  mining_function     => dbms_data_mining.classification,
10:30:40   5  	  data_table_name     => 'svmc_build_prep',
10:30:40   6  	  case_id_column_name => '&case_id',
10:30:40   7  	  target_column_name  => '&target',
10:30:40   8  	  settings_table_name => 'svmc_settings');
10:30:40   9  END;
10:30:40  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.99
10:30:42 SQL> 
10:30:42 SQL> -----------------------------------------------------------------------
10:30:42 SQL> --			       APPLY/score THE MODEL
10:30:42 SQL> -----------------------------------------------------------------------
10:30:42 SQL> 
10:30:42 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
10:30:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:42 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:42   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:42   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.11
10:30:42 SQL> -----------------------
10:30:42 SQL> -- PREPARE SCORING DATA
10:30:42 SQL> --
10:30:42 SQL> -- If the data for model creation has been prepared, then the data
10:30:42 SQL> -- to be scored using the model must be prepared in the same manner
10:30:42 SQL> -- in order to obtain meaningful results.
10:30:42 SQL> --
10:30:42 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:42 SQL> -- 2. Normalization
10:30:42 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:42 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:42 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:42 SQL> --
10:30:42 SQL> BEGIN
10:30:42   2  	-- Xform Test data to replace missing values
10:30:42   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:42   4  	  miss_table_name => 'svmc_miss_num',
10:30:42   5  	  data_table_name => '&scoretable',
10:30:42   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:42   7  
10:30:42   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:42   9  	  miss_table_name => 'svmc_miss_cat',
10:30:42  10  	  data_table_name => '&scoretable',
10:30:42  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:42  12  
10:30:42  13  	-- Normalize the data to be scored
10:30:42  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:42  15  	  norm_table_name => 'svmc_norm',
10:30:42  16  	  data_table_name => '&scoretable',
10:30:42  17  	  xform_view_name => 'svmc_apply_prep');
10:30:42  18  END;
10:30:42  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.26
10:30:43 SQL> 
10:30:43 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:43 SQL> -- DELETE it if I did:
10:30:43 SQL> DELETE ystkscores
10:30:43   2  WHERE score > 0
10:30:43   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:43   4  -- I need to supply the target attribute name:
10:30:43   5  AND targ = '&1'
10:30:43   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:43 SQL> 
10:30:43 SQL> -- We do a drumroll here:
10:30:43 SQL> 
10:30:43 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:43   2  SELECT
10:30:43   3  tkrdate
10:30:43   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:43   5  ,sysdate
10:30:43   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:43   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:43   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:43   9  ,SUBSTR(tkrdate,-10)ydate
10:30:43  10  ,'&1'
10:30:43  11  FROM svmc_apply_prep
10:30:43  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:30:43 SQL> @score1_5min_gattn.sql	2010-10-28 TLT
10:30:43 SQL> --
10:30:43 SQL> -- score1_5min_gattn.sql
10:30:43 SQL> --
10:30:43 SQL> 
10:30:43 SQL> -- Demo:
10:30:43 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:43 SQL> 
10:30:43 SQL> CREATE OR REPLACE VIEW sme AS
10:30:43   2  SELECT
10:30:43   3  tkrdate
10:30:43   4  ,NULL gattn
10:30:43   5  ,g00
10:30:43   6  ,g01
10:30:43   7  ,g02
10:30:43   8  ,g03
10:30:43   9  ,g04
10:30:43  10  ,g05
10:30:43  11  ,g06
10:30:43  12  ,g07
10:30:43  13  ,g08
10:30:43  14  ,g09
10:30:43  15  ,g10
10:30:43  16  ,g11
10:30:43  17  ,g12
10:30:43  18  ,g13
10:30:43  19  ,g14
10:30:43  20  ,g15
10:30:43  21  ,g16
10:30:43  22  ,g17
10:30:43  23  ,g18
10:30:43  24  ,g19
10:30:43  25  ,g20
10:30:43  26  ,g21
10:30:43  27  ,g22
10:30:43  28  ,g23
10:30:43  29  ,g24
10:30:43  30  ,g25
10:30:43  31  ,g26
10:30:43  32  ,g27
10:30:43  33  ,g28
10:30:43  34  ,g29
10:30:43  35  FROM stk_ms
10:30:43  36  WHERE ydate = '&1'
10:30:43  37  AND tkr = '&2'
10:30:43  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-10-28'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.04
10:30:43 SQL> 
10:30:43 SQL> -- rpt
10:30:43 SQL> -- We should see just 1 row:
10:30:43 SQL> 
10:30:43 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:43   2  
10:30:43 SQL> -- Build the model:
10:30:43 SQL> CREATE OR REPLACE VIEW bme AS
10:30:43   2  SELECT
10:30:43   3  tkrdate
10:30:43   4  ,gattn
10:30:43   5  ,g00
10:30:43   6  ,g01
10:30:43   7  ,g02
10:30:43   8  ,g03
10:30:43   9  ,g04
10:30:43  10  ,g05
10:30:43  11  ,g06
10:30:43  12  ,g07
10:30:43  13  ,g08
10:30:43  14  ,g09
10:30:43  15  ,g10
10:30:43  16  ,g11
10:30:43  17  ,g12
10:30:43  18  ,g13
10:30:43  19  ,g14
10:30:43  20  ,g15
10:30:43  21  ,g16
10:30:43  22  ,g17
10:30:43  23  ,g18
10:30:43  24  ,g19
10:30:43  25  ,g20
10:30:43  26  ,g21
10:30:43  27  ,g22
10:30:43  28  ,g23
10:30:43  29  ,g24
10:30:43  30  ,g25
10:30:43  31  ,g26
10:30:43  32  ,g27
10:30:43  33  ,g28
10:30:43  34  ,g29
10:30:43  35  FROM stk_ms
10:30:43  36  WHERE gattn IN('nup','up')
10:30:43  37  -- Use only rows which are older than 1 day:
10:30:43  38  AND 1+ydate < '&1'
10:30:43  39  AND tkr = '&2'
10:30:43  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-10-28'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:43 SQL> 
10:30:43 SQL> -- rpt
10:30:43 SQL> 
10:30:43 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:43   2  
10:30:43 SQL> SELECT MAX(tkrdate) FROM bme
10:30:43   2  
10:30:43 SQL> -- Now build model from bme and score sme
10:30:43 SQL> @score1.sql gattn
10:30:43 SQL> -- score1.sql
10:30:43 SQL> 
10:30:43 SQL> -- I use this script to send 5 params to score.sql
10:30:43 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:43 SQL> -- Then at the very end of this script I use the model
10:30:43 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:43 SQL> 
10:30:43 SQL> -- I call this script from 2 other scripts:
10:30:43 SQL> -- score1_5min.sql
10:30:43 SQL> -- score1_5min_gattn.sql
10:30:43 SQL> 
10:30:43 SQL> -- The 1st param is the name of the target attribute.
10:30:43 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:43 SQL> 
10:30:43 SQL> -- Demo:
10:30:43 SQL> -- @score1.sql 'gatt'
10:30:43 SQL> -- @score1.sql 'gattn'
10:30:43 SQL> 
10:30:43 SQL> -- Now, I fill up svmc_apply_prep.
10:30:43 SQL> -- I use same model_name used in score.sql
10:30:43 SQL> DEFINE model_name = 'svmspy101'
10:30:43 SQL> DEFINE bldtable	= 'bme'
10:30:43 SQL> DEFINE scoretable = 'sme'
10:30:43 SQL> DEFINE case_id	= 'tkrdate'
10:30:43 SQL> -- Demo:
10:30:43 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:43 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:43 SQL> --
10:30:43 SQL> -- score.sql
10:30:43 SQL> --
10:30:43 SQL> 
10:30:43 SQL> -- usage: score.sql
10:30:43 SQL> 
10:30:43 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:43 SQL> 
10:30:43 SQL> -- DEFINE target	   = 'gatt'
10:30:43 SQL> -- DEFINE model_name = 'svmspy100'
10:30:43 SQL> -- DEFINE bldtable   = 'bme'
10:30:43 SQL> -- DEFINE scoretable = 'sme'
10:30:43 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:43 SQL> 
10:30:43 SQL> DEFINE target	= '&1'
10:30:43 SQL> DEFINE model_name = '&2'
10:30:43 SQL> DEFINE bldtable	= '&3'
10:30:43 SQL> DEFINE scoretable = '&4'
10:30:43 SQL> DEFINE case_id	= '&5'
10:30:43 SQL> 
10:30:43 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:43 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:43 SQL> 
10:30:43 SQL> -- Builds an SVM model using pl/sql.
10:30:43 SQL> 
10:30:43 SQL> -----------------------------------------------------------------------
10:30:43 SQL> --			    BUILD THE MODEL
10:30:43 SQL> -----------------------------------------------------------------------
10:30:43 SQL> 
10:30:43 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:43 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:43 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:43 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:43 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:43 SQL> 
10:30:43 SQL> 
10:30:43 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:43 SQL> --
10:30:43 SQL> -- DROP	TABLE svmc_settings ;
10:30:43 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:43 SQL> -- DELETE svmc_settings;
10:30:43 SQL> 
10:30:43 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:43 SQL> -- this choice to SVM using a settings table.
10:30:43 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:43 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:43 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:43 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:43 SQL> -- models.
10:30:43 SQL> --
10:30:43 SQL> 
10:30:43 SQL> -- Do this once and then comment it out.
10:30:43 SQL> -- That makes script go faster.
10:30:43 SQL> -- BEGIN
10:30:43 SQL> -- -- Populate settings table
10:30:43 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:43 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:43 SQL> --
10:30:43 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:43 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:43 SQL> --
10:30:43 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:43 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:43 SQL> --   COMMIT;
10:30:43 SQL> -- END;
10:30:43 SQL> -- /
10:30:43 SQL> 
10:30:43 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:30:43 SQL> 
10:30:43 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:43   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:43   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
10:30:43 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:43   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:43   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:43 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:43   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:43   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:43 SQL> 
10:30:43 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:43   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:43   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:43 SQL> 
10:30:43 SQL> --------------------------------
10:30:43 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:43 SQL> --
10:30:43 SQL> 
10:30:43 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:43 SQL> -- 2. Outlier Treatment and
10:30:43 SQL> -- 3. Normalization are performed below.
10:30:43 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:43 SQL> --    normalized here.
10:30:43 SQL> 
10:30:43 SQL> BEGIN
10:30:43   2  	-- Perform missing value treatment for all predictors
10:30:43   3  	-- create miss tables
10:30:43   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:43   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:43   6  
10:30:43   7  	-- populate miss tables
10:30:43   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:43   9  	  miss_table_name => 'svmc_miss_num',
10:30:43  10  	  data_table_name => '&bldtable',
10:30:43  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:43  12  
10:30:43  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:43  14  	  miss_table_name => 'svmc_miss_cat',
10:30:43  15  	  data_table_name => '&bldtable',
10:30:43  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:43  17  
10:30:43  18  	-- xform input data to replace missing values
10:30:43  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:43  20  	  miss_table_name => 'svmc_miss_num',
10:30:43  21  	  data_table_name => '&bldtable',
10:30:43  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:43  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:43  24  	  miss_table_name => 'svmc_miss_cat',
10:30:43  25  	  data_table_name => '&bldtable',
10:30:43  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:43  27  
10:30:43  28  	-- Perform outlier treatment.
10:30:43  29  	-- create clip table
10:30:43  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:43  31  
10:30:43  32  	-- populate clip table
10:30:43  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:43  34  	  clip_table_name => 'svmc_clip',
10:30:43  35  	  data_table_name => '&bldtable',
10:30:43  36  	  tail_frac	  => 0.025,
10:30:43  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:43  38  
10:30:43  39  	-- xform input data to winsorized data
10:30:43  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:43  41  	  clip_table_name => 'svmc_clip',
10:30:43  42  	  data_table_name => '&bldtable',
10:30:43  43  	  xform_view_name => 'svmc_winsor');
10:30:43  44  
10:30:43  45  	-- create normalization table
10:30:43  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:43  47  
10:30:43  48  	-- populate normalization table based on winsorized data
10:30:43  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:43  50  	  norm_table_name => 'svmc_norm',
10:30:43  51  	  data_table_name => 'svmc_winsor',
10:30:43  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:43  53  
10:30:43  54  	-- normalize the original data
10:30:43  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:43  56  	  norm_table_name => 'svmc_norm',
10:30:43  57  	  data_table_name => '&bldtable',
10:30:43  58  	  xform_view_name => 'svmc_build_prep');
10:30:43  59  END;
10:30:43  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.59
10:30:44 SQL> 
10:30:44 SQL> ---------------------
10:30:44 SQL> -- CREATE A NEW MODEL
10:30:44 SQL> --
10:30:44 SQL> -- Cleanup old model with the same name for repeat runs
10:30:44 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:44   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:44   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.00
10:30:46 SQL> 
10:30:46 SQL> -- Build a new SVM Model
10:30:46 SQL> BEGIN
10:30:46   2  	DBMS_DATA_MINING.CREATE_MODEL(
10:30:46   3  	  model_name	      => '&model_name',
10:30:46   4  	  mining_function     => dbms_data_mining.classification,
10:30:46   5  	  data_table_name     => 'svmc_build_prep',
10:30:46   6  	  case_id_column_name => '&case_id',
10:30:46   7  	  target_column_name  => '&target',
10:30:46   8  	  settings_table_name => 'svmc_settings');
10:30:46   9  END;
10:30:46  10  /
old   3:     model_name 	 => '&model_name',
new   3:     model_name 	 => 'svmspy101',
old   6:     case_id_column_name => '&case_id',
new   6:     case_id_column_name => 'tkrdate',
old   7:     target_column_name  => '&target',
new   7:     target_column_name  => 'gattn',

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.11
10:30:48 SQL> 
10:30:48 SQL> -----------------------------------------------------------------------
10:30:48 SQL> --			       APPLY/score THE MODEL
10:30:48 SQL> -----------------------------------------------------------------------
10:30:48 SQL> 
10:30:48 SQL> -- Cleanup old scoring data preparation objects for repeat runs
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_num';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_apply_miss_cat';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_apply_prep';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:48 SQL> -----------------------
10:30:48 SQL> -- PREPARE SCORING DATA
10:30:48 SQL> --
10:30:48 SQL> -- If the data for model creation has been prepared, then the data
10:30:48 SQL> -- to be scored using the model must be prepared in the same manner
10:30:48 SQL> -- in order to obtain meaningful results.
10:30:48 SQL> --
10:30:48 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:48 SQL> -- 2. Normalization
10:30:48 SQL> -- No outlier treatment will be performed during test and apply. The
10:30:48 SQL> -- normalization step is sufficient, since the normalization parameters
10:30:48 SQL> -- already capture the effects of outlier treatment done with build data.
10:30:48 SQL> --
10:30:48 SQL> BEGIN
10:30:48   2  	-- Xform Test data to replace missing values
10:30:48   3  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:48   4  	  miss_table_name => 'svmc_miss_num',
10:30:48   5  	  data_table_name => '&scoretable',
10:30:48   6  	  xform_view_name => 'xformed_apply_miss_num');
10:30:48   7  
10:30:48   8  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:48   9  	  miss_table_name => 'svmc_miss_cat',
10:30:48  10  	  data_table_name => '&scoretable',
10:30:48  11  	  xform_view_name => 'xformed_apply_miss_cat');
10:30:48  12  
10:30:48  13  	-- Normalize the data to be scored
10:30:48  14  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:48  15  	  norm_table_name => 'svmc_norm',
10:30:48  16  	  data_table_name => '&scoretable',
10:30:48  17  	  xform_view_name => 'svmc_apply_prep');
10:30:48  18  END;
10:30:48  19  /
old   5:     data_table_name => '&scoretable',
new   5:     data_table_name => 'sme',
old  10:     data_table_name => '&scoretable',
new  10:     data_table_name => 'sme',
old  16:     data_table_name => '&scoretable',
new  16:     data_table_name => 'sme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
10:30:48 SQL> 
10:30:48 SQL> -- Maybe I already collected a score for this tkrdate.
10:30:48 SQL> -- DELETE it if I did:
10:30:48 SQL> DELETE ystkscores
10:30:48   2  WHERE score > 0
10:30:48   3  AND tkrdate IN(SELECT tkrdate FROM svmc_apply_prep)
10:30:48   4  -- I need to supply the target attribute name:
10:30:48   5  AND targ = '&1'
10:30:48   6  /
old   5: AND targ = '&1'
new   5: AND targ = 'gattn'

0 rows deleted.

Elapsed: 00:00:00.02
10:30:48 SQL> 
10:30:48 SQL> -- We do a drumroll here:
10:30:48 SQL> 
10:30:48 SQL> INSERT INTO ystkscores (tkrdate,score,rundate,tkr,ydate,targ)
10:30:48   2  SELECT
10:30:48   3  tkrdate
10:30:48   4  ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
10:30:48   5  ,sysdate
10:30:48   6  -- ,SUBSTR(tkrdate,1,3)tkr
10:30:48   7  -- rluck/oracle_sql_demos/substr.sql :
10:30:48   8  ,SUBSTR(tkrdate,-LENGTH(tkrdate),LENGTH(tkrdate)-10)tkr
10:30:48   9  ,SUBSTR(tkrdate,-10)ydate
10:30:48  10  ,'&1'
10:30:48  11  FROM svmc_apply_prep
10:30:48  12  /
old   4: ,PREDICTION_PROBABILITY(&model_name,'up' USING *)score
new   4: ,PREDICTION_PROBABILITY(svmspy101,'up' USING *)score
old  10: ,'&1'
new  10: ,'gattn'

1 row created.

Elapsed: 00:00:00.03
10:30:48 SQL> @score1_5min_gattn.sql	2010-10-19 TLT
10:30:48 SQL> --
10:30:48 SQL> -- score1_5min_gattn.sql
10:30:48 SQL> --
10:30:48 SQL> 
10:30:48 SQL> -- Demo:
10:30:48 SQL> -- @score1_5min_gattn.sql 2010-12-31 SPY
10:30:48 SQL> 
10:30:48 SQL> CREATE OR REPLACE VIEW sme AS
10:30:48   2  SELECT
10:30:48   3  tkrdate
10:30:48   4  ,NULL gattn
10:30:48   5  ,g00
10:30:48   6  ,g01
10:30:48   7  ,g02
10:30:48   8  ,g03
10:30:48   9  ,g04
10:30:48  10  ,g05
10:30:48  11  ,g06
10:30:48  12  ,g07
10:30:48  13  ,g08
10:30:48  14  ,g09
10:30:48  15  ,g10
10:30:48  16  ,g11
10:30:48  17  ,g12
10:30:48  18  ,g13
10:30:48  19  ,g14
10:30:48  20  ,g15
10:30:48  21  ,g16
10:30:48  22  ,g17
10:30:48  23  ,g18
10:30:48  24  ,g19
10:30:48  25  ,g20
10:30:48  26  ,g21
10:30:48  27  ,g22
10:30:48  28  ,g23
10:30:48  29  ,g24
10:30:48  30  ,g25
10:30:48  31  ,g26
10:30:48  32  ,g27
10:30:48  33  ,g28
10:30:48  34  ,g29
10:30:48  35  FROM stk_ms
10:30:48  36  WHERE ydate = '&1'
10:30:48  37  AND tkr = '&2'
10:30:48  38  /
old  36: WHERE ydate = '&1'
new  36: WHERE ydate = '2010-10-19'
old  37: AND tkr = '&2'
new  37: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.03
10:30:48 SQL> 
10:30:48 SQL> -- rpt
10:30:48 SQL> -- We should see just 1 row:
10:30:48 SQL> 
10:30:48 SQL> SELECT COUNT(tkrdate) FROM sme
10:30:48   2  
10:30:48 SQL> -- Build the model:
10:30:48 SQL> CREATE OR REPLACE VIEW bme AS
10:30:48   2  SELECT
10:30:48   3  tkrdate
10:30:48   4  ,gattn
10:30:48   5  ,g00
10:30:48   6  ,g01
10:30:48   7  ,g02
10:30:48   8  ,g03
10:30:48   9  ,g04
10:30:48  10  ,g05
10:30:48  11  ,g06
10:30:48  12  ,g07
10:30:48  13  ,g08
10:30:48  14  ,g09
10:30:48  15  ,g10
10:30:48  16  ,g11
10:30:48  17  ,g12
10:30:48  18  ,g13
10:30:48  19  ,g14
10:30:48  20  ,g15
10:30:48  21  ,g16
10:30:48  22  ,g17
10:30:48  23  ,g18
10:30:48  24  ,g19
10:30:48  25  ,g20
10:30:48  26  ,g21
10:30:48  27  ,g22
10:30:48  28  ,g23
10:30:48  29  ,g24
10:30:48  30  ,g25
10:30:48  31  ,g26
10:30:48  32  ,g27
10:30:48  33  ,g28
10:30:48  34  ,g29
10:30:48  35  FROM stk_ms
10:30:48  36  WHERE gattn IN('nup','up')
10:30:48  37  -- Use only rows which are older than 1 day:
10:30:48  38  AND 1+ydate < '&1'
10:30:48  39  AND tkr = '&2'
10:30:48  40  /
old  38: AND 1+ydate < '&1'
new  38: AND 1+ydate < '2010-10-19'
old  39: AND tkr = '&2'
new  39: AND tkr = 'TLT'

View created.

Elapsed: 00:00:00.05
10:30:48 SQL> 
10:30:48 SQL> -- rpt
10:30:48 SQL> 
10:30:48 SQL> SELECT gattn, COUNT(tkrdate) FROM bme GROUP BY gattn
10:30:48   2  
10:30:48 SQL> SELECT MAX(tkrdate) FROM bme
10:30:48   2  
10:30:48 SQL> -- Now build model from bme and score sme
10:30:48 SQL> @score1.sql gattn
10:30:48 SQL> -- score1.sql
10:30:48 SQL> 
10:30:48 SQL> -- I use this script to send 5 params to score.sql
10:30:48 SQL> -- which does the heavy lifting of creating an SVM model.
10:30:48 SQL> -- Then at the very end of this script I use the model
10:30:48 SQL> -- inside an INSERT via a call to: PREDICTION_PROBABILITY()
10:30:48 SQL> 
10:30:48 SQL> -- I call this script from 2 other scripts:
10:30:48 SQL> -- score1_5min.sql
10:30:48 SQL> -- score1_5min_gattn.sql
10:30:48 SQL> 
10:30:48 SQL> -- The 1st param is the name of the target attribute.
10:30:48 SQL> -- I like to call my target attributes either gatt or gattn.
10:30:48 SQL> 
10:30:48 SQL> -- Demo:
10:30:48 SQL> -- @score1.sql 'gatt'
10:30:48 SQL> -- @score1.sql 'gattn'
10:30:48 SQL> 
10:30:48 SQL> -- Now, I fill up svmc_apply_prep.
10:30:48 SQL> -- I use same model_name used in score.sql
10:30:48 SQL> DEFINE model_name = 'svmspy101'
10:30:48 SQL> DEFINE bldtable	= 'bme'
10:30:48 SQL> DEFINE scoretable = 'sme'
10:30:48 SQL> DEFINE case_id	= 'tkrdate'
10:30:48 SQL> -- Demo:
10:30:48 SQL> -- @score.sql gatt svmspy100   bme	 sme	       tkrdate
10:30:48 SQL> @score.sql '&1' '&model_name' '&bldtable' '&scoretable' '&case_id'
10:30:48 SQL> --
10:30:48 SQL> -- score.sql
10:30:48 SQL> --
10:30:48 SQL> 
10:30:48 SQL> -- usage: score.sql
10:30:48 SQL> 
10:30:48 SQL> -- A script which feeds data to SVM and captures the results in table svmc_apply_prep
10:30:48 SQL> 
10:30:48 SQL> -- DEFINE target	   = 'gatt'
10:30:48 SQL> -- DEFINE model_name = 'svmspy100'
10:30:48 SQL> -- DEFINE bldtable   = 'bme'
10:30:48 SQL> -- DEFINE scoretable = 'sme'
10:30:48 SQL> -- DEFINE case_id    = 'tkrdate'
10:30:48 SQL> 
10:30:48 SQL> DEFINE target	= '&1'
10:30:48 SQL> DEFINE model_name = '&2'
10:30:48 SQL> DEFINE bldtable	= '&3'
10:30:48 SQL> DEFINE scoretable = '&4'
10:30:48 SQL> DEFINE case_id	= '&5'
10:30:48 SQL> 
10:30:48 SQL> -- Define a variable to help me exclude some columns from some data mining calls
10:30:48 SQL> DEFINE exclude1 = "'&target','&case_id'"
10:30:48 SQL> 
10:30:48 SQL> -- Builds an SVM model using pl/sql.
10:30:48 SQL> 
10:30:48 SQL> -----------------------------------------------------------------------
10:30:48 SQL> --			    BUILD THE MODEL
10:30:48 SQL> -----------------------------------------------------------------------
10:30:48 SQL> 
10:30:48 SQL> -- Cleanup old build data preparation objects for repeat runs
10:30:48 SQL> DELETE svmc_miss_num;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:48 SQL> DELETE svmc_miss_cat;

0 rows deleted.

Elapsed: 00:00:00.00
10:30:48 SQL> DELETE svmc_clip;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:48 SQL> DELETE svmc_norm;

30 rows deleted.

Elapsed: 00:00:00.00
10:30:48 SQL> 
10:30:48 SQL> 
10:30:48 SQL> -- CREATE AND POPULATE A SETTINGS TABLE
10:30:48 SQL> --
10:30:48 SQL> -- DROP	TABLE svmc_settings ;
10:30:48 SQL> -- CREATE TABLE svmc_settings ( setting_name  VARCHAR2(30), setting_value VARCHAR2(30));
10:30:48 SQL> -- DELETE svmc_settings;
10:30:48 SQL> 
10:30:48 SQL> -- The default classification algorithm is Naive Bayes. So override
10:30:48 SQL> -- this choice to SVM using a settings table.
10:30:48 SQL> -- SVM chooses a kernel type automatically. This choice can be overriden
10:30:48 SQL> -- by the user. Linear kernel is preferred high dimensional data, and
10:30:48 SQL> -- Gaussian kernel for low dimensional data. Here we use linear kernel
10:30:48 SQL> -- to demonstrate the get_model_details_svm() API, which applies only for
10:30:48 SQL> -- models.
10:30:48 SQL> --
10:30:48 SQL> 
10:30:48 SQL> -- Do this once and then comment it out.
10:30:48 SQL> -- That makes script go faster.
10:30:48 SQL> -- BEGIN
10:30:48 SQL> -- -- Populate settings table
10:30:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:48 SQL> --   (dbms_data_mining.algo_name, dbms_data_mining.algo_support_vector_machines);
10:30:48 SQL> --
10:30:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:48 SQL> --   (dbms_data_mining.svms_kernel_function, dbms_data_mining.svms_gaussian);
10:30:48 SQL> --
10:30:48 SQL> --   INSERT INTO svmc_settings (setting_name, setting_value) VALUES
10:30:48 SQL> --   (dbms_data_mining.svms_kernel_cache_size,190123123);
10:30:48 SQL> --   COMMIT;
10:30:48 SQL> -- END;
10:30:48 SQL> -- /
10:30:48 SQL> 
10:30:48 SQL> SELECT * FROM svmc_settings;

SETTING_NAME		       SETTING_VALUE
------------------------------ ------------------------------
ALGO_NAME		       ALGO_SUPPORT_VECTOR_MACHINES
SVMS_KERNEL_FUNCTION	       SVMS_GAUSSIAN
SVMS_KERNEL_CACHE_SIZE	       320123123

Elapsed: 00:00:00.01
10:30:48 SQL> 
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_winsor';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW svmc_build_prep';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_num';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
10:30:48 SQL> 
10:30:48 SQL> BEGIN EXECUTE IMMEDIATE 'DROP VIEW xformed_build_miss_cat';
10:30:48   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:48   3  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
10:30:48 SQL> 
10:30:48 SQL> --------------------------------
10:30:48 SQL> -- PREPARE BUILD (TRAINING) DATA
10:30:48 SQL> --
10:30:48 SQL> 
10:30:48 SQL> -- 1. Missing Value treatment for all Predictors and
10:30:48 SQL> -- 2. Outlier Treatment and
10:30:48 SQL> -- 3. Normalization are performed below.
10:30:48 SQL> --    NOTE: that unlike SVM regression, the classification target is NOT
10:30:48 SQL> --    normalized here.
10:30:48 SQL> 
10:30:48 SQL> BEGIN
10:30:48   2  	-- Perform missing value treatment for all predictors
10:30:48   3  	-- create miss tables
10:30:48   4  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (miss_table_name => 'svmc_miss_num');
10:30:48   5  	--  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (miss_table_name => 'svmc_miss_cat');
10:30:48   6  
10:30:48   7  	-- populate miss tables
10:30:48   8  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
10:30:48   9  	  miss_table_name => 'svmc_miss_num',
10:30:48  10  	  data_table_name => '&bldtable',
10:30:48  11  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:48  12  
10:30:48  13  	DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
10:30:48  14  	  miss_table_name => 'svmc_miss_cat',
10:30:48  15  	  data_table_name => '&bldtable',
10:30:48  16  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:48  17  
10:30:48  18  	-- xform input data to replace missing values
10:30:48  19  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(
10:30:48  20  	  miss_table_name => 'svmc_miss_num',
10:30:48  21  	  data_table_name => '&bldtable',
10:30:48  22  	  xform_view_name => 'xformed_build_miss_num');
10:30:48  23  	DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(
10:30:48  24  	  miss_table_name => 'svmc_miss_cat',
10:30:48  25  	  data_table_name => '&bldtable',
10:30:48  26  	  xform_view_name => 'xformed_build_miss_cat');
10:30:48  27  
10:30:48  28  	-- Perform outlier treatment.
10:30:48  29  	-- create clip table
10:30:48  30  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (clip_table_name => 'svmc_clip');
10:30:48  31  
10:30:48  32  	-- populate clip table
10:30:48  33  	DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
10:30:48  34  	  clip_table_name => 'svmc_clip',
10:30:48  35  	  data_table_name => '&bldtable',
10:30:48  36  	  tail_frac	  => 0.025,
10:30:48  37  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:48  38  
10:30:48  39  	-- xform input data to winsorized data
10:30:48  40  	DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(
10:30:48  41  	  clip_table_name => 'svmc_clip',
10:30:48  42  	  data_table_name => '&bldtable',
10:30:48  43  	  xform_view_name => 'svmc_winsor');
10:30:48  44  
10:30:48  45  	-- create normalization table
10:30:48  46  	-- DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (norm_table_name => 'svmc_norm');
10:30:48  47  
10:30:48  48  	-- populate normalization table based on winsorized data
10:30:48  49  	DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
10:30:48  50  	  norm_table_name => 'svmc_norm',
10:30:48  51  	  data_table_name => 'svmc_winsor',
10:30:48  52  	  exclude_list	  => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
10:30:48  53  
10:30:48  54  	-- normalize the original data
10:30:48  55  	DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
10:30:48  56  	  norm_table_name => 'svmc_norm',
10:30:48  57  	  data_table_name => '&bldtable',
10:30:48  58  	  xform_view_name => 'svmc_build_prep');
10:30:48  59  END;
10:30:48  60  /
old  10:     data_table_name => '&bldtable',
new  10:     data_table_name => 'bme',
old  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  11:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  15:     data_table_name => '&bldtable',
new  15:     data_table_name => 'bme',
old  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  16:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  21:     data_table_name => '&bldtable',
new  21:     data_table_name => 'bme',
old  25:     data_table_name => '&bldtable',
new  25:     data_table_name => 'bme',
old  35:     data_table_name => '&bldtable',
new  35:     data_table_name => 'bme',
old  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  37:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  42:     data_table_name => '&bldtable',
new  42:     data_table_name => 'bme',
old  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (&exclude1));
new  52:     exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST ('gattn','tkrdate'));
old  57:     data_table_name => '&bldtable',
new  57:     data_table_name => 'bme',

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.64
10:30:49 SQL> 
10:30:49 SQL> ---------------------
10:30:49 SQL> -- CREATE A NEW MODEL
10:30:49 SQL> --
10:30:49 SQL> -- Cleanup old model with the same name for repeat runs
10:30:49 SQL> BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
10:30:49   2  EXCEPTION WHEN OTHERS THEN NULL; END;
10:30:49   3  /
old   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('&model_name');
new   1: BEGIN DBMS_DATA_MINING.DROP_MODEL('svmspy101');
